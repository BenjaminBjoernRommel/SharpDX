// <auto-generated/>

namespace SharpDX.XAudio2
{
    internal partial interface EngineCallback : SharpDX.ICallbackable
    {
    }

    public partial class MasteringVoice : SharpDX.XAudio2.Voice
    {
        public MasteringVoice(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator MasteringVoice(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new MasteringVoice(nativePtr);
        /// <summary>
        /// <p>Returns the channel mask for this voice.</p>
        /// </summary>
        /// <param name = "channelmaskRef"><dd> <p> Returns the channel mask for this voice. This corresponds to the <strong>dwChannelMask</strong> member of the  <strong><see cref = "SharpDX.Multimedia.WaveFormatExtensible"/></strong> structure. </p> </dd></param>
        /// <returns><p>This method does not return a value.</p></returns>
        /// <remarks>
        /// <p>The <em>pChannelMask</em> argument is a bit-mask of the various channels in the speaker geometry reported by the audio system. This information is needed for the <strong>X3DAudioInitialize</strong> <em>SpeakerChannelMask</em> parameter. </p><p>The X3DAUDIO.H header declares a number of <strong>SPEAKER_</strong> positional defines to decode these channels masks. </p><p>Examples include: </p><pre>SPEAKER_STEREO // SPEAKER_FRONT_LEFT (0x1) | SPEAKER_FRONT_RIGHT (0x2)  SPEAKER_5POINT1 // SPEAKER_FRONT_LEFT (0x1) | SPEAKER_FRONT_RIGHT (0x2) // | SPEAKER_FRONT_CENTER (0x4) // | SPEAKER_LOW_FREQUENCY (0x8) // | SPEAKER_BACK_LEFT (0x10) | SPEAKER_BACK_RIGHT (0x20)</pre><strong>Note</strong>??For the DirectX SDK versions of XAUDIO, the channel mask for the output device was obtained via the <strong>IXAudio2::GetDeviceDetails</strong> method, which doesn't exist in Windows?8 and later.?
        /// </remarks>
        /// <doc-id>microsoft.directx_sdk.ixaudio2masteringvoice.ixaudio2masteringvoice.getchannelmask</doc-id>
        /// <unmanaged>HRESULT IXAudio2MasteringVoice::GetChannelMask([Out] DWORD* pChannelmask)</unmanaged>
        /// <unmanaged-short>IXAudio2MasteringVoice::GetChannelMask</unmanaged-short>
        public unsafe void GetChannelMask(out System.Int32 channelmaskRef)
        {
            SharpDX.Result __result__;
            fixed (void *channelmaskRef_ = &channelmaskRef)
                __result__ = SharpDX.XAudio2.LocalInterop.CalliStdCallint(this._nativePointer, channelmaskRef_, (*(void ***)this._nativePointer)[19]);
            __result__.CheckError();
        }
    }

    public partial class SourceVoice : SharpDX.XAudio2.Voice
    {
        public SourceVoice(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator SourceVoice(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new SourceVoice(nativePtr);
        /// <summary>
        /// <p>Reconfigures the voice to consume source data at a different sample rate than the rate specified when the voice was created.</p>
        /// </summary>
        /// <remarks>
        /// <p>The <strong>SetSourceSampleRate</strong> method supports reuse of XAudio2 voices by allowing a voice to play sounds with a variety of sample rates. To use <strong>SetSourceSampleRate</strong> the voice must have been created without the XAUDIO2_VOICE_NOPITCH or XAUDIO2_VOICE_NOSRC flags and must not have any buffers currently queued. </p><p>The typical use of <strong>SetSourceSampleRate</strong> is to support voice pooling. For example to support voice pooling an application would precreate all the voices it expects to use. Whenever a new sound will be played the application chooses an inactive voice or ,if all voices are busy, picks the least important voice and calls <strong>SetSourceSampleRate</strong> on the voice with the new sound's sample rate. After <strong>SetSourceSampleRate</strong> has been called on the voice, the application can immediately start submitting and playing buffers with the new sample rate. This allows the application to avoid the overhead of creating and destroying voices frequently during gameplay.
        /// </p>
        /// </remarks>
        /// <doc-id>microsoft.directx_sdk.ixaudio2sourcevoice.ixaudio2sourcevoice.setsourcesamplerate</doc-id>
        /// <unmanaged>SetSourceSampleRate</unmanaged>
        /// <unmanaged-short>SetSourceSampleRate</unmanaged-short>
        public System.Int32 SourceSampleRate
        {
            set => SetSourceSampleRate(value);
        }

        /// <summary>
        /// <p>Starts consumption and processing of audio by the voice. Delivers the result to any connected submix or mastering voices, or to the output device.</p>
        /// </summary>
        /// <param name = "flags"><dd> <p>Flags that control how the voice is started. Must be 0.</p> </dd></param>
        /// <param name = "operationSet"><dd> <p> Identifies this call as part of a deferred batch. See the XAudio2 Operation Sets overview for more information.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful, an error code otherwise. See <strong>XAudio2 Error Codes</strong> for descriptions of XAudio2 specific error codes.</p></returns>
        /// <remarks>
        /// <p>If the XAudio2 engine is stopped, the voice stops running. However, it remains in the started state, so that it starts running again as soon as the engine starts. </p><p>When first created, source voices are in the stopped state. Submix and mastering voices are in the started state. </p><p>After <strong>Start</strong> is called it has no further effect if called again before <strong>IXAudio2SourceVoice::Stop</strong> is called. In addition multiple calls to <strong>Start</strong> without matching calls to <strong>IXAudio2SourceVoice::Stop</strong> will result in warning messages in debug builds.</p>
        /// </remarks>
        /// <doc-id>microsoft.directx_sdk.ixaudio2sourcevoice.ixaudio2sourcevoice.start</doc-id>
        /// <unmanaged>HRESULT IXAudio2SourceVoice::Start([In] unsigned int Flags,[In] unsigned int OperationSet)</unmanaged>
        /// <unmanaged-short>IXAudio2SourceVoice::Start</unmanaged-short>
        internal unsafe void Start(System.Int32 flags, System.Int32 operationSet = 0)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.XAudio2.LocalInterop.CalliStdCallint(this._nativePointer, flags, operationSet, (*(void ***)this._nativePointer)[19]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Stops consumption of audio by the current voice.</p>
        /// </summary>
        /// <param name = "flags"><dd> <p> Flags that control how the voice is stopped. Can be 0 or the following: </p> <table> <tr><th>Value</th><th>Description</th></tr> <tr><td>XAUDIO2_PLAY_TAILS</td><td>Continue emitting effect output after the voice is stopped.?</td></tr> </table> <p>?</p> </dd></param>
        /// <param name = "operationSet"><dd> <p>Identifies this call as part of a deferred batch. See the XAudio2 Operation Sets overview for more information.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful, an error code otherwise. See <strong>XAudio2 Error Codes</strong> for descriptions of XAudio2 specific error codes.</p></returns>
        /// <remarks>
        /// <p>All source buffers that are queued on the voice and the current cursor position are preserved. This allows the voice to continue from where it left off, when it is restarted. The <strong>IXAudio2SourceVoice::FlushSourceBuffers</strong> method can be used to flush queued source buffers. </p><p>By default, any pending output from voice effects?for example, reverb tails?is not played. Instead, the voice is immediately rendered silent. The XAUDIO2_PLAY_TAILS flag can be used to continue emitting effect output after the voice stops running. </p><p>A voice stopped with the XAUDIO2_PLAY_TAILS flag stops consuming source buffers, but continues to process its effects and send audio to its destination voices. A voice in this state can later be stopped completely by calling <strong>Stop</strong> again with the Flags argument set to 0. This enables stopping a voice with XAUDIO2_PLAY_TAILS, waiting sufficient time for any audio being produced by its effects to finish, and then fully stopping the voice by calling <strong>Stop</strong> again without XAUDIO2_PLAY_TAILS. This technique allows voices with effects to be stopped gracefully while ensuring idle voices will not continue to be processed after they have finished producing audio. </p><p><strong>Stop</strong> is always asynchronous, even if called within a callback. </p><strong>Note</strong>??XAudio2 never calls any voice callbacks for a voice if the voice is stopped (even if it was stopped with XAUDIO2_PLAY_TAILS).?
        /// </remarks>
        /// <doc-id>microsoft.directx_sdk.ixaudio2sourcevoice.ixaudio2sourcevoice.stop</doc-id>
        /// <unmanaged>HRESULT IXAudio2SourceVoice::Stop([In] unsigned int Flags,[In] unsigned int OperationSet)</unmanaged>
        /// <unmanaged-short>IXAudio2SourceVoice::Stop</unmanaged-short>
        public unsafe void Stop(SharpDX.XAudio2.PlayFlags flags, System.Int32 operationSet = 0)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.XAudio2.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)flags), operationSet, (*(void ***)this._nativePointer)[20]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Adds a new audio buffer to the voice queue.</p>
        /// </summary>
        /// <param name = "bufferRef"><dd> <p> Pointer to an <strong><see cref = "SharpDX.XAudio2.AudioBuffer"/></strong> structure to queue. </p> </dd></param>
        /// <param name = "bufferWMARef"><dd> <p>Pointer to an additional <strong><see cref = "SharpDX.XAudio2.BufferWma"/></strong> structure used when submitting WMA data. </p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful, an error code otherwise. See <strong>XAudio2 Error Codes</strong> for descriptions of XAudio2 specific error codes.</p></returns>
        /// <remarks>
        /// <p>The voice processes and plays back the buffers in its queue in the order that they were submitted. </p><p>The <strong><see cref = "SharpDX.XAudio2.AudioBuffer"/></strong> structure includes details about the audio buffer's location and size, the part of the buffer that should actually be played, the loop region (if any) and loop count, the context reference to be used in any callbacks relating to this buffer, and an optional XAUDIO2_END_OF_STREAM flag that indicates that it is the last buffer of a contiguous sound. </p><p>If the voice is started and has no buffers queued, the new buffer will start playing immediately. If the voice is stopped, the buffer is added to the voice's queue and will be played when the voice starts. </p><p>If only part of the given buffer should be played, the <strong>PlayBegin</strong> and <strong>PlayLength</strong> fields in the <strong><see cref = "SharpDX.XAudio2.AudioBuffer"/></strong> can be used to specify the region to be played. A <strong>PlayLength</strong> value of 0 means to play the entire buffer (and in this case <strong>PlayBegin</strong> must be 0 as well). </p><p>If all or part of the buffer should be played in a continuous loop, the <strong>LoopBegin</strong>, <strong>LoopLength</strong> and <strong>LoopCount</strong> fields in <strong><see cref = "SharpDX.XAudio2.AudioBuffer"/></strong> can be used to specify the characteristics of the loop region. A <strong>LoopBegin</strong> value of <see cref = "NoLoopRegion"/> means that no looping should be performed, and in this case <strong>LoopLength</strong> and <strong>LoopCount</strong> must be given as 0. If a loop region is specified, it must be non-empty (<strong>LoopLength</strong> &gt; 0), and the loop count must be between 1 and <see cref = "MaximumLoopCount"/> inclusive (or <see cref = "LoopInfinite"/> to specify an endless loop which will only end when <strong>IXAudio2SourceVoice::ExitLoop</strong> is called). A loop count of <em>N</em> means to skip backwards N times, i.e. to play the loop region <em>N</em>+1 times. </p><p>If an explicit play region is specified, it must begin and end within the given audio buffer (or, in the compressed case, within the set of samples that the buffer will decode to). In addition, the loop region cannot end past the end of the play region. </p><table> <tr><th>Xbox 360</th></tr> <tr><td>For certain audio formats, there may be additional restrictions on the valid endpoints of any play or loop regions; e.g. for XMA buffers, the regions can only begin or end at 128-sample boundaries in the decoded audio.
        /// </td></tr> </table><p>?</p><p>The <em>pBuffer</em> reference can be reused or freed immediately after calling this method, but the actual audio data referenced by <em>pBuffer</em> must remain valid until the buffer has been fully consumed by XAudio2 (which is indicated by the <strong>IXAudio2VoiceCallback::OnBufferEnd</strong> callback). </p><p>Up to <see cref = "MaximumQueuedBuffers"/> buffers can be queued on a voice at any one time. </p><p><strong>SubmitSourceBuffer</strong> takes effect immediately when called from an XAudio2 callback with an OperationSet of <see cref = "CommitNow"/>.
        /// </p><table> <tr><th>Xbox 360</th></tr> <tr><td>This method can be called from an Xbox system thread (most other XAudio2 methods cannot). However, a maximum of two source buffers can be submitted from a system thread at a time.</td></tr> </table><p>?</p>
        /// </remarks>
        /// <doc-id>microsoft.directx_sdk.ixaudio2sourcevoice.ixaudio2sourcevoice.submitsourcebuffer</doc-id>
        /// <unmanaged>HRESULT IXAudio2SourceVoice::SubmitSourceBuffer([In] const XAUDIO2_BUFFER* pBuffer,[In, Optional] const XAUDIO2_BUFFER_WMA* pBufferWMA)</unmanaged>
        /// <unmanaged-short>IXAudio2SourceVoice::SubmitSourceBuffer</unmanaged-short>
        internal unsafe void SubmitSourceBuffer(SharpDX.XAudio2.AudioBuffer bufferRef, SharpDX.XAudio2.BufferWma? bufferWMARef)
        {
            SharpDX.XAudio2.AudioBuffer.__Native bufferRef_ = default (SharpDX.XAudio2.AudioBuffer.__Native);
            SharpDX.XAudio2.BufferWma bufferWMARef_;
            SharpDX.Result __result__;
            bufferRef.__MarshalTo(ref bufferRef_);
            if (bufferWMARef != null)
                bufferWMARef_ = bufferWMARef.Value;
            __result__ = SharpDX.XAudio2.LocalInterop.CalliStdCallint(this._nativePointer, &bufferRef_, bufferWMARef == null ? (void *)0 : &bufferWMARef_, (*(void ***)this._nativePointer)[21]);
            bufferRef.__MarshalFree(ref bufferRef_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Removes all pending audio buffers from the voice queue.</p>
        /// </summary>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful, an error code otherwise.</p></returns>
        /// <remarks>
        /// <p>If the voice is started, the buffer that is currently playing is not removed from the queue. </p><p><strong>FlushSourceBuffers</strong> can be called regardless of whether the voice is currently started or stopped. </p><p>For every buffer removed, an <strong>OnBufferEnd</strong> callback will be made, but none of the other per-buffer callbacks (<strong>OnBufferStart</strong>, <strong>OnStreamEnd</strong> or <strong>OnLoopEnd</strong>) will be made. </p><p><strong>FlushSourceBuffers</strong> does not change a the voice's running state, so if the voice was playing a buffer prior to the call, it will continue to do so, and will deliver all the callbacks for the buffer normally. This means that the <strong>OnBufferEnd</strong> callback for this buffer will take place after the <strong>OnBufferEnd</strong> callbacks for the buffers that were removed. Thus, an XAudio2 client that calls <strong>FlushSourceBuffers</strong> cannot expect to receive <strong>OnBufferEnd</strong> callbacks in the order in which the buffers were submitted. </p><p>No warnings for starvation of the buffer queue will be emitted when the currently playing buffer completes; it is assumed that the client has intentionally removed the buffers that followed it. However, there may be an audio pop if this buffer does not end at a zero crossing. If the application must ensure that the flush operation takes place while a specific buffer is playing?perhaps because the buffer ends with a zero crossing?it must call <strong>FlushSourceBuffers</strong> from a callback, so that it executes synchronously. </p><p>Calling <strong>FlushSourceBuffers</strong> after a voice is stopped and then submitting new data to the voice resets all of the voice's internal counters. </p><p>A voice's state is not considered reset after calling <strong>FlushSourceBuffers</strong> until the <strong>OnBufferEnd</strong> callback occurs (if a buffer was previously submitted) or <strong>IXAudio2SourceVoice::GetState</strong> returns with <strong><see cref = "SharpDX.XAudio2.VoiceState"/></strong>. <strong>BuffersQueued</strong> == 0. For example, if you stop a voice and call <strong>FlushSourceBuffers</strong>, it's still not legal to immediately call <strong>IXAudio2SourceVoice::SetSourceSampleRate</strong> (which requires the voice to not have any buffers currently queued), until either of the previously mentioned conditions are met.  </p>
        /// </remarks>
        /// <doc-id>microsoft.directx_sdk.ixaudio2sourcevoice.ixaudio2sourcevoice.flushsourcebuffers</doc-id>
        /// <unmanaged>HRESULT IXAudio2SourceVoice::FlushSourceBuffers()</unmanaged>
        /// <unmanaged-short>IXAudio2SourceVoice::FlushSourceBuffers</unmanaged-short>
        public unsafe void FlushSourceBuffers()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.XAudio2.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[22]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Notifies an XAudio2 voice that no more buffers are coming after the last one that is currently in its queue.</p>
        /// </summary>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful, an error code otherwise.</p></returns>
        /// <remarks>
        /// <p><strong>Discontinuity</strong> suppresses the warnings that normally occur in the debug build of XAudio2 when a voice runs out of audio buffers to play. It is preferable to mark the final buffer of a stream by tagging it with the XAUDIO2_END_OF_STREAM flag, but in some cases the client may not know that a buffer is the end of a stream until after the buffer has been submitted. </p><p>Because calling <strong>Discontinuity</strong> is equivalent to applying the XAUDIO2_END_OF_STREAM flag retroactively to the last buffer submitted, an <strong>OnStreamEnd</strong> callback will be made when this buffer completes.
        /// </p><strong>Note</strong>??XAudio2 may consume its entire buffer queue and emit a warning before the <strong>Discontinuity</strong> call takes effect, so <strong>Discontinuity</strong> is not guaranteed to suppress the warnings.?
        /// </remarks>
        /// <doc-id>microsoft.directx_sdk.ixaudio2sourcevoice.ixaudio2sourcevoice.discontinuity</doc-id>
        /// <unmanaged>HRESULT IXAudio2SourceVoice::Discontinuity()</unmanaged>
        /// <unmanaged-short>IXAudio2SourceVoice::Discontinuity</unmanaged-short>
        public unsafe void Discontinuity()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.XAudio2.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[23]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Stops looping the voice when it reaches the end of the current loop region. </p>
        /// </summary>
        /// <param name = "operationSet"><dd> <p> Identifies this call as part of a deferred batch. See the XAudio2 Operation Sets overview for more information.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful, an error code otherwise. See <strong>XAudio2 Error Codes</strong> for descriptions of XAudio2 specific error codes.</p></returns>
        /// <remarks>
        /// <p>If the cursor for the voice is not in a loop region, <strong>ExitLoop</strong> does nothing. </p>
        /// </remarks>
        /// <doc-id>microsoft.directx_sdk.ixaudio2sourcevoice.ixaudio2sourcevoice.exitloop</doc-id>
        /// <unmanaged>HRESULT IXAudio2SourceVoice::ExitLoop([In] unsigned int OperationSet)</unmanaged>
        /// <unmanaged-short>IXAudio2SourceVoice::ExitLoop</unmanaged-short>
        public unsafe void ExitLoop(System.Int32 operationSet = 0)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.XAudio2.LocalInterop.CalliStdCallint(this._nativePointer, operationSet, (*(void ***)this._nativePointer)[24]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Returns the voice's current state and cursor position data.</p>
        /// </summary>
        /// <param name = "flags"><dd> <p>Number of audio buffers currently queued on the voice, including the one that is processed currently.</p> </dd></param>
        /// <remarks>
        /// <p>For all encoded formats, including constant bit rate (CBR) formats such as adaptive differential pulse code modulation (ADPCM), <strong>SamplesPlayed</strong> is expressed in terms of decoded samples. For pulse code modulation (PCM) formats, <strong>SamplesPlayed</strong> is expressed in terms of either input or output samples. There is a one-to-one mapping from input to output for PCM formats. </p><p>If a client needs to get the correlated positions of several voices?that is, to know exactly which sample of a particular voice is playing when a specified sample of another voice is playing?it must make the <strong>IXAudio2SourceVoice::GetState</strong> calls in an XAudio2 engine callback. Doing this ensures that none of the voices advance while the calls are made.</p>
        /// </remarks>
        /// <doc-id>microsoft.directx_sdk.xaudio2.xaudio2_voice_state</doc-id>
        /// <unmanaged>void IXAudio2SourceVoice::GetState([Out] XAUDIO2_VOICE_STATE* pVoiceState,[In] unsigned int Flags)</unmanaged>
        /// <unmanaged-short>IXAudio2SourceVoice::GetState</unmanaged-short>
        internal unsafe SharpDX.XAudio2.VoiceState GetState(System.Int32 flags)
        {
            SharpDX.XAudio2.VoiceState voiceStateRef;
            SharpDX.XAudio2.LocalInterop.CalliStdCallvoid(this._nativePointer, &voiceStateRef, flags, (*(void ***)this._nativePointer)[25]);
            return voiceStateRef;
        }

        /// <summary>
        /// <p>Sets the frequency adjustment ratio of the voice.</p>
        /// </summary>
        /// <param name = "ratio"><dd> <p>Frequency adjustment ratio. This value must be between <see cref = "MinimumFrequencyRatio"/> and the <em>MaxFrequencyRatio</em> parameter specified when the voice was created (see <strong>IXAudio2::CreateSourceVoice</strong>). <see cref = "MinimumFrequencyRatio"/> currently is 0.0005, which allows pitch to be lowered by up to 11 octaves.</p> </dd></param>
        /// <param name = "operationSet"><dd> <p>Identifies this call as part of a deferred batch. See the XAudio2 Operation Sets overview for more information. </p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful, an error code otherwise. See <strong>XAudio2 Error Codes</strong> for descriptions of error codes. </p></returns>
        /// <remarks>
        /// <p>Frequency adjustment is expressed as <em>source frequency</em> / <em>target frequency</em>. Changing the frequency ratio changes the rate audio is played on the voice. A ratio greater than 1.0 will cause the audio to play faster and a ratio less than 1.0 will cause the audio to play slower. Additionally, the frequency ratio affects the pitch of audio on the voice. As an example, a value of 1.0 has no effect on the audio, whereas a value of 2.0 raises pitch by one octave and 0.5 lowers it by one octave. </p><p>If <strong>SetFrequencyRatio</strong> is called specifying a Ratio value outside the valid range, the method will set the frequency ratio to the nearest valid value. A warning also will be generated for debug builds. </p><strong>Note</strong>??<strong>IXAudio2SourceVoice::GetFrequencyRatio</strong> always returns the voice's actual current frequency ratio. However, this may not match the ratio set by the most recent <strong>IXAudio2SourceVoice::SetFrequencyRatio</strong> call: the actual ratio is only changed the next time the audio engine runs after the <strong>IXAudio2SourceVoice::SetFrequencyRatio</strong> call (or after the corresponding <strong>IXAudio2::CommitChanges</strong> call, if <strong>IXAudio2SourceVoice::SetFrequencyRatio</strong> was called with a deferred operation ID).?
        /// </remarks>
        /// <doc-id>microsoft.directx_sdk.ixaudio2sourcevoice.ixaudio2sourcevoice.setfrequencyratio</doc-id>
        /// <unmanaged>HRESULT IXAudio2SourceVoice::SetFrequencyRatio([In] float Ratio,[In] unsigned int OperationSet)</unmanaged>
        /// <unmanaged-short>IXAudio2SourceVoice::SetFrequencyRatio</unmanaged-short>
        public unsafe void SetFrequencyRatio(System.Single ratio, System.Int32 operationSet = 0)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.XAudio2.LocalInterop.CalliStdCallint(this._nativePointer, ratio, operationSet, (*(void ***)this._nativePointer)[26]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Returns the frequency adjustment ratio of the voice.</p>
        /// </summary>
        /// <param name = "ratioRef"><dd> <p>Returns the current frequency adjustment ratio if successful.</p> </dd></param>
        /// <remarks>
        /// <p><strong>GetFrequencyRatio</strong> always returns the voice's actual current frequency ratio. However, this may not match the ratio set by the most recent <strong>IXAudio2SourceVoice::SetFrequencyRatio</strong> call: the actual ratio is only changed the next time the audio engine runs after the <strong>IXAudio2SourceVoice::SetFrequencyRatio</strong> call (or after the corresponding <strong>IXAudio2::CommitChanges</strong> call, if <strong>IXAudio2SourceVoice::SetFrequencyRatio</strong> was called with a deferred operation ID). </p><p>For information on frequency ratios, see <strong>IXAudio2SourceVoice::SetFrequencyRatio</strong>.
        /// </p>
        /// </remarks>
        /// <doc-id>microsoft.directx_sdk.ixaudio2sourcevoice.ixaudio2sourcevoice.getfrequencyratio</doc-id>
        /// <unmanaged>void IXAudio2SourceVoice::GetFrequencyRatio([Out] float* pRatio)</unmanaged>
        /// <unmanaged-short>IXAudio2SourceVoice::GetFrequencyRatio</unmanaged-short>
        public unsafe void GetFrequencyRatio(out System.Single ratioRef)
        {
            fixed (void *ratioRef_ = &ratioRef)
                SharpDX.XAudio2.LocalInterop.CalliStdCallvoid(this._nativePointer, ratioRef_, (*(void ***)this._nativePointer)[27]);
        }

        /// <summary>
        /// <p>Reconfigures the voice to consume source data at a different sample rate than the rate specified when the voice was created.</p>
        /// </summary>
        /// <param name = "newSourceSampleRate"><dd> <p>The new sample rate the voice should process submitted data at. Valid sample rates are 1kHz to 200kHz. </p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful, an error code otherwise. See <strong>XAudio2 Error Codes</strong> for descriptions of error codes. </p></returns>
        /// <remarks>
        /// <p>The <strong>SetSourceSampleRate</strong> method supports reuse of XAudio2 voices by allowing a voice to play sounds with a variety of sample rates. To use <strong>SetSourceSampleRate</strong> the voice must have been created without the XAUDIO2_VOICE_NOPITCH or XAUDIO2_VOICE_NOSRC flags and must not have any buffers currently queued. </p><p>The typical use of <strong>SetSourceSampleRate</strong> is to support voice pooling. For example to support voice pooling an application would precreate all the voices it expects to use. Whenever a new sound will be played the application chooses an inactive voice or ,if all voices are busy, picks the least important voice and calls <strong>SetSourceSampleRate</strong> on the voice with the new sound's sample rate. After <strong>SetSourceSampleRate</strong> has been called on the voice, the application can immediately start submitting and playing buffers with the new sample rate. This allows the application to avoid the overhead of creating and destroying voices frequently during gameplay.
        /// </p>
        /// </remarks>
        /// <doc-id>microsoft.directx_sdk.ixaudio2sourcevoice.ixaudio2sourcevoice.setsourcesamplerate</doc-id>
        /// <unmanaged>HRESULT IXAudio2SourceVoice::SetSourceSampleRate([In] unsigned int NewSourceSampleRate)</unmanaged>
        /// <unmanaged-short>IXAudio2SourceVoice::SetSourceSampleRate</unmanaged-short>
        internal unsafe void SetSourceSampleRate(System.Int32 newSourceSampleRate)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.XAudio2.LocalInterop.CalliStdCallint(this._nativePointer, newSourceSampleRate, (*(void ***)this._nativePointer)[28]);
            __result__.CheckError();
        }
    }

    public partial class SubmixVoice : SharpDX.XAudio2.Voice
    {
        public SubmixVoice(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator SubmixVoice(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new SubmixVoice(nativePtr);
    }

    public partial class Voice : SharpDX.CppObject
    {
        public Voice(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Voice(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Voice(nativePtr);
        /// <summary>
        /// <p>Designates a new set of submix or mastering voices to receive the output of the voice.</p>
        /// </summary>
        /// <remarks>
        /// <p>This method is only valid for source and submix voices. Mastering voices can not send audio to another voice. </p><p>After calling <strong>SetOutputVoices</strong> a voice's current send levels will be replaced by a default send matrix. The <strong>IXAudio2Voice::SetOutputMatrix</strong> method must be called to set a custom matrix for the new sendlist. </p><p>It is invalid to call <strong>SetOutputVoices</strong> from within a callback (that is, <strong><see cref = "SharpDX.XAudio2.EngineCallback"/></strong> or <strong><see cref = "SharpDX.XAudio2.VoiceCallback"/></strong>). If <strong>SetOutputVoices</strong> is called within a callback, it returns <see cref = "InvalidCall"/>.</p><strong>Note</strong>??Calling <strong>SetOutputVoices</strong> invalidates any send matrices previously set with <strong>IXAudio2Voice::SetOutputMatrix</strong>.?
        /// </remarks>
        /// <doc-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.setoutputvoices</doc-id>
        /// <unmanaged>SetOutputVoices</unmanaged>
        /// <unmanaged-short>SetOutputVoices</unmanaged-short>
        internal SharpDX.XAudio2.VoiceSendDescriptors OutputVoices
        {
            set => SetOutputVoices(value);
        }

        /// <summary>
        /// <p>Returns information about the creation flags, input channels, and sample rate of a voice.</p>
        /// </summary>
        /// <param name = "voiceDetailsRef"><dd> <p> <strong><see cref = "SharpDX.XAudio2.VoiceDetails"/></strong> structure containing information about the voice.</p> </dd></param>
        /// <doc-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.getvoicedetails</doc-id>
        /// <unmanaged>void IXAudio2Voice::GetVoiceDetails([Out] XAUDIO2_VOICE_DETAILS* pVoiceDetails)</unmanaged>
        /// <unmanaged-short>IXAudio2Voice::GetVoiceDetails</unmanaged-short>
        public unsafe void GetVoiceDetails(out SharpDX.XAudio2.VoiceDetails voiceDetailsRef)
        {
            voiceDetailsRef = default (SharpDX.XAudio2.VoiceDetails);
            fixed (void *voiceDetailsRef_ = &voiceDetailsRef)
                SharpDX.XAudio2.LocalInterop.CalliStdCallvoid(this._nativePointer, voiceDetailsRef_, (*(void ***)this._nativePointer)[0]);
        }

        /// <summary>
        /// <p>Designates a new set of submix or mastering voices to receive the output of the voice.</p>
        /// </summary>
        /// <param name = "sendListRef"><dd> <p>Array of <strong><see cref = "SharpDX.XAudio2.VoiceSendDescriptors"/></strong> structure references to destination voices. If <em>pSendList</em> is <c>null</c>, the voice will send its output to the current mastering voice. To set the voice to not send its output anywhere set the <strong>OutputCount</strong> member of <strong><see cref = "SharpDX.XAudio2.VoiceSendDescriptors"/></strong> to 0. All of the voices in a send list must have the same input sample rate, see XAudio2 Sample Rate Conversions for additional information.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful, an error code otherwise. See <strong>XAudio2 Error Codes</strong> for descriptions of XAudio2 specific error codes. </p></returns>
        /// <remarks>
        /// <p>This method is only valid for source and submix voices. Mastering voices can not send audio to another voice. </p><p>After calling <strong>SetOutputVoices</strong> a voice's current send levels will be replaced by a default send matrix. The <strong>IXAudio2Voice::SetOutputMatrix</strong> method must be called to set a custom matrix for the new sendlist. </p><p>It is invalid to call <strong>SetOutputVoices</strong> from within a callback (that is, <strong><see cref = "SharpDX.XAudio2.EngineCallback"/></strong> or <strong><see cref = "SharpDX.XAudio2.VoiceCallback"/></strong>). If <strong>SetOutputVoices</strong> is called within a callback, it returns <see cref = "InvalidCall"/>.</p><strong>Note</strong>??Calling <strong>SetOutputVoices</strong> invalidates any send matrices previously set with <strong>IXAudio2Voice::SetOutputMatrix</strong>.?
        /// </remarks>
        /// <doc-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.setoutputvoices</doc-id>
        /// <unmanaged>HRESULT IXAudio2Voice::SetOutputVoices([In, Optional] const XAUDIO2_VOICE_SENDS* pSendList)</unmanaged>
        /// <unmanaged-short>IXAudio2Voice::SetOutputVoices</unmanaged-short>
        internal unsafe void SetOutputVoices(SharpDX.XAudio2.VoiceSendDescriptors? sendListRef)
        {
            SharpDX.XAudio2.VoiceSendDescriptors sendListRef_;
            SharpDX.Result __result__;
            if (sendListRef != null)
                sendListRef_ = sendListRef.Value;
            __result__ = SharpDX.XAudio2.LocalInterop.CalliStdCallint(this._nativePointer, sendListRef == null ? (void *)0 : &sendListRef_, (*(void ***)this._nativePointer)[1]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Replaces the effect chain of the voice.</p>
        /// </summary>
        /// <param name = "effectChainRef"><dd> <p>Pointer to an <strong><see cref = "SharpDX.XAudio2.EffectChain"/></strong> structure that describes the new effect chain to use. If <c>null</c> is passed, the current effect chain is removed.</p> <strong>Note</strong>??If <em>pEffectChain</em> is non-<c>null</c>, the <strong><see cref = "SharpDX.XAudio2.EffectChain"/></strong> structure that it points to must specify at least one effect. ? </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise, an error code.  </p><p>See <strong>XAudio2 Error Codes</strong> for descriptions of XAudio2 specific error codes.</p></returns>
        /// <remarks>
        /// <p>The number of output channels allowed for a voice's effect chain is locked at creation of the voice. If you create the voice with an effect chain, any new effect chain passed to <strong>SetEffectChain</strong> must have the same number of input and output channels as the original effect chain. If you create the voice without an effect chain, the number of output channels allowed for the effect chain will default to the number of input channels for the voice. If any part of effect chain creation fails, none of it is applied. </p><p>After you attach an effect to an XAudio2 voice, XAudio2 takes control of the effect, and the client should not make any further calls to it. The simplest way to ensure this is to release all references to the effect. </p><p>It is invalid to call <strong>SetEffectChain</strong> from within a callback (that is, <strong><see cref = "SharpDX.XAudio2.EngineCallback"/></strong> or <strong><see cref = "SharpDX.XAudio2.VoiceCallback"/></strong>). If you call <strong>SetEffectChain</strong> within a callback, it returns <see cref = "InvalidCall"/>. </p><p>The <strong><see cref = "SharpDX.XAudio2.EffectChain"/></strong> that is passed in as the pEffectChain argument and any <strong><see cref = "SharpDX.XAudio2.EffectDescriptor"/></strong> information contained within it are no longer needed after <strong>SetEffectChain</strong> successfully completes, and may be deleted immediately after <strong>SetEffectChain</strong> is called.</p>
        /// </remarks>
        /// <doc-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.seteffectchain</doc-id>
        /// <unmanaged>HRESULT IXAudio2Voice::SetEffectChain([In, Optional] const XAUDIO2_EFFECT_CHAIN* pEffectChain)</unmanaged>
        /// <unmanaged-short>IXAudio2Voice::SetEffectChain</unmanaged-short>
        internal unsafe void SetEffectChain(SharpDX.XAudio2.EffectChain? effectChainRef)
        {
            SharpDX.XAudio2.EffectChain effectChainRef_;
            SharpDX.Result __result__;
            if (effectChainRef != null)
                effectChainRef_ = effectChainRef.Value;
            __result__ = SharpDX.XAudio2.LocalInterop.CalliStdCallint(this._nativePointer, effectChainRef == null ? (void *)0 : &effectChainRef_, (*(void ***)this._nativePointer)[2]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Enables the effect at a given position in the effect chain of the voice.</p>
        /// </summary>
        /// <param name = "effectIndex"><dd> <p>Zero-based index of an effect in the effect chain of the voice.</p> </dd></param>
        /// <param name = "operationSet"><dd> <p>Identifies this call as part of a deferred batch. See the XAudio2 Operation Sets overview for more information. </p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise, an error code. See <strong>XAudio2 Error Codes</strong> for descriptions of error codes. </p></returns>
        /// <remarks>
        /// <p>Be careful when you enable an effect while the voice that hosts it is running. Such an action can result in a problem if the effect significantly changes the audio's pitch or volume. </p><p>The effects in a given XAudio2 voice's effect chain must consume and produce audio at that voice's processing sample rate. The only aspect of the audio format they can change is the channel count. For example a reverb effect can convert mono data to 5.1. The client can use the <strong><see cref = "SharpDX.XAudio2.EffectDescriptor"/></strong> structure's <strong>OutputChannels</strong> field to specify the number of channels it wants each effect to produce. Each effect in an effect chain must produce a number of channels that the next effect can consume. Any calls to <strong>IXAudio2Voice::EnableEffect</strong> or <strong>IXAudio2Voice::DisableEffect</strong> that would make the effect chain stop fulfilling these requirements will fail. </p><p><strong>EnableEffect</strong> takes effect immediately when you call it from an XAudio2 callback with an <em>OperationSet</em> of <strong><see cref = "CommitNow"/></strong>.</p>
        /// </remarks>
        /// <doc-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.enableeffect</doc-id>
        /// <unmanaged>HRESULT IXAudio2Voice::EnableEffect([In] unsigned int EffectIndex,[In] unsigned int OperationSet)</unmanaged>
        /// <unmanaged-short>IXAudio2Voice::EnableEffect</unmanaged-short>
        public unsafe void EnableEffect(System.Int32 effectIndex, System.Int32 operationSet = 0)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.XAudio2.LocalInterop.CalliStdCallint(this._nativePointer, effectIndex, operationSet, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Disables the effect at a given position in the effect chain of the voice.</p>
        /// </summary>
        /// <param name = "effectIndex"><dd> <p>Zero-based index of an effect in the effect chain of the voice.</p> </dd></param>
        /// <param name = "operationSet"><dd> <p>Identifies this call as part of a deferred batch. See the XAudio2 Operation Sets overview for more information. </p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise, an error code. See <strong>XAudio2 Error Codes</strong> for descriptions of valid error codes.</p></returns>
        /// <remarks>
        /// <p>The effects in a given XAudio2 voice's effect chain must consume and produce audio at that voice's processing sample rate. The only aspect of the audio format they can change is the channel count. For example a reverb effect can convert mono data to 5.1. The client can use the <strong><see cref = "SharpDX.XAudio2.EffectDescriptor"/></strong> structure's <strong>OutputChannels</strong> field to specify the number of channels it wants each effect to produce. Each effect in an effect chain must produce a number of channels that the next effect can consume. Any calls to <strong>IXAudio2Voice::EnableEffect</strong> or <strong>IXAudio2Voice::DisableEffect</strong> that would make the effect chain stop fulfilling these requirements will fail. </p><p>Disabling an effect immediately removes it from the processing graph. Any pending audio in the effect?such as a reverb tail?is not played. Be careful disabling an effect while the voice that hosts it is running. This can result in an audible artifact if the effect significantly changes the audio's pitch or volume. </p><p><strong>DisableEffect</strong> takes effect immediately when called from an XAudio2 callback with an <em>OperationSet</em> of <strong><see cref = "CommitNow"/></strong>. </p>
        /// </remarks>
        /// <doc-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.disableeffect</doc-id>
        /// <unmanaged>HRESULT IXAudio2Voice::DisableEffect([In] unsigned int EffectIndex,[In] unsigned int OperationSet)</unmanaged>
        /// <unmanaged-short>IXAudio2Voice::DisableEffect</unmanaged-short>
        public unsafe void DisableEffect(System.Int32 effectIndex, System.Int32 operationSet = 0)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.XAudio2.LocalInterop.CalliStdCallint(this._nativePointer, effectIndex, operationSet, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Returns the running state of the effect at a specified position in the effect chain of the voice.</p>
        /// </summary>
        /// <param name = "effectIndex"><dd> <p>Zero-based index of an effect in the effect chain of the voice.</p> </dd></param>
        /// <param name = "enabledRef"><dd> <p>Returns TRUE If the effect is enabled. If the effect is disabled, returns <see cref = "SharpDX.Result.False"/>.</p> </dd></param>
        /// <remarks>
        /// <p><strong>GetEffectState</strong> always returns the effect's actual current state. However, this may not be the state set by the most recent <strong>IXAudio2Voice::EnableEffect</strong> or <strong>IXAudio2Voice::DisableEffect</strong> call: the actual state is only changed the next time the audio engine runs after the <strong>IXAudio2Voice::EnableEffect</strong> or <strong>IXAudio2Voice::DisableEffect</strong> call (or after the corresponding <strong>IXAudio2::CommitChanges</strong> call, if EnableEffect/DisableEffect was called with a deferred operation ID).</p>
        /// </remarks>
        /// <doc-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.geteffectstate</doc-id>
        /// <unmanaged>void IXAudio2Voice::GetEffectState([In] unsigned int EffectIndex,[Out] BOOL* pEnabled)</unmanaged>
        /// <unmanaged-short>IXAudio2Voice::GetEffectState</unmanaged-short>
        public unsafe void IsEffectEnabled(System.Int32 effectIndex, out SharpDX.Mathematics.Interop.RawBool enabledRef)
        {
            enabledRef = default (SharpDX.Mathematics.Interop.RawBool);
            fixed (void *enabledRef_ = &enabledRef)
                SharpDX.XAudio2.LocalInterop.CalliStdCallvoid(this._nativePointer, effectIndex, enabledRef_, (*(void ***)this._nativePointer)[5]);
        }

        /// <summary>
        /// <p>Sets parameters for a given effect in the voice's effect chain.</p>
        /// </summary>
        /// <param name = "effectIndex"><dd> <p>Zero-based index of an effect within the voice's effect chain.</p> </dd></param>
        /// <param name = "parametersRef"><dd> <p> Returns the current values of the effect-specific parameters.</p> </dd></param>
        /// <param name = "parametersByteSize"><dd> <p> Size of the <strong>pParameters</strong> array in bytes.</p> </dd></param>
        /// <param name = "operationSet"><dd> <p>Identifies this call as part of a deferred batch. See the XAudio2 Operation Sets overview for more information.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise, an error code. See <strong>XAudio2 Error Codes</strong> for descriptions of error codes. </p><p>Fails with E_NOTIMPL if the effect does not support a generic parameter control interface.</p></returns>
        /// <remarks>
        /// <p>The specific effect being used determines the valid size and format of the <em>pParameters</em> buffer. The call will fail if <em>pParameters</em> is invalid or if <em>ParametersByteSize</em> is not exactly the size that the effect expects. The client must take care to direct the <strong>SetEffectParameters</strong> call to the right effect. If this call is directed to a different effect that happens to accept the same parameter block size, the parameters will be interpreted differently. This may lead to unexpected results. </p><p>The memory pointed to by <em>pParameters</em> must <em>not</em> be freed immediately, because XAudio2 will need to refer to it later when the parameters actually are applied to the effect. This happens during the next audio processing pass if the <em>OperationSet</em> argument is <strong><see cref = "CommitNow"/></strong>. Otherwise, the parameters are applied to the effect later, during the first processing pass after the <strong>IXAudio2::CommitChanges</strong> function is called with the same <em>OperationSet</em> argument. </p><p><strong>SetEffectParameters</strong> takes effect immediately when called from an XAudio2 callback with an <em>OperationSet</em> of <strong><see cref = "CommitNow"/></strong>.
        /// </p><strong>Note</strong>??<strong>IXAudio2Voice::GetEffectParameters</strong> always returns the effect's actual current parameters. However, these may not match the parameters set by the most recent call to <strong>IXAudio2Voice::SetEffectParameters</strong>. The actual parameters are only changed the next time the audio engine runs after the <strong>IXAudio2Voice::SetEffectParameters</strong> call (or after the corresponding <strong>IXAudio2::CommitChanges</strong> call, if <strong>IXAudio2Voice::SetEffectParameters</strong> was called with a deferred operation ID).?
        /// </remarks>
        /// <doc-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.seteffectparameters</doc-id>
        /// <unmanaged>HRESULT IXAudio2Voice::SetEffectParameters([In] unsigned int EffectIndex,[In, Buffer] const void* pParameters,[In] unsigned int ParametersByteSize,[In] unsigned int OperationSet)</unmanaged>
        /// <unmanaged-short>IXAudio2Voice::SetEffectParameters</unmanaged-short>
        internal unsafe void SetEffectParameters(System.Int32 effectIndex, System.IntPtr parametersRef, System.Int32 parametersByteSize, System.Int32 operationSet = 0)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.XAudio2.LocalInterop.CalliStdCallint(this._nativePointer, effectIndex, (void *)parametersRef, parametersByteSize, operationSet, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Returns the current effect-specific parameters of a given effect in the voice's effect chain.</p>
        /// </summary>
        /// <param name = "effectIndex"><dd> <p>Zero-based index of an effect within the voice's effect chain.</p> </dd></param>
        /// <param name = "parametersRef"><dd> <p>Returns the current values of the effect-specific parameters.</p> </dd></param>
        /// <param name = "parametersByteSize"><dd> <p>Size, in bytes, of the pParameters array.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful, an error code otherwise. See <strong>XAudio2 Error Codes</strong> for descriptions of error codes. </p><p>Fails with E_NOTIMPL if the effect does not support a generic parameter control interface.</p></returns>
        /// <remarks>
        /// <p><strong>GetEffectParameters</strong> always returns the effect's actual current parameters. However, these may not match the parameters set by the most recent call to <strong>IXAudio2Voice::SetEffectParameters</strong>: the actual parameters are only changed the next time the audio engine runs after the <strong>IXAudio2Voice::SetEffectParameters</strong> call (or after the corresponding <strong>IXAudio2::CommitChanges</strong> call, if <strong>IXAudio2Voice::SetEffectParameters</strong> was called with a deferred operation ID). </p>
        /// </remarks>
        /// <doc-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.geteffectparameters</doc-id>
        /// <unmanaged>HRESULT IXAudio2Voice::GetEffectParameters([In] unsigned int EffectIndex,[Out, Buffer] void* pParameters,[In] unsigned int ParametersByteSize)</unmanaged>
        /// <unmanaged-short>IXAudio2Voice::GetEffectParameters</unmanaged-short>
        internal unsafe void GetEffectParameters(System.Int32 effectIndex, System.IntPtr parametersRef, System.Int32 parametersByteSize)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.XAudio2.LocalInterop.CalliStdCallint(this._nativePointer, effectIndex, (void *)parametersRef, parametersByteSize, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the voice's filter parameters.</p>
        /// </summary>
        /// <param name = "parametersRef"><dd> <p>Pointer to an <strong><see cref = "SharpDX.XAudio2.FilterParameters"/></strong> structure containing the filter information. </p> </dd></param>
        /// <param name = "operationSet"><dd> <p>Identifies this call as part of a deferred batch. See the XAudio2 Operation Sets overview for more information.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful, an error code otherwise. See <strong>XAudio2 Error Codes</strong> for descriptions of error codes. </p></returns>
        /// <remarks>
        /// <p><strong>SetFilterParameters</strong> will fail if the voice was not created with the XAUDIO2_VOICE_USEFILTER flag. </p><p>This method is usable only on source and submix voices and has no effect on mastering voices.</p><strong>Note</strong>??<strong>IXAudio2Voice::GetFilterParameters</strong> always returns this voice's actual current filter parameters. However, these may not match the parameters set by the most recent <strong>IXAudio2Voice::SetFilterParameters</strong> call: the actual parameters are only changed the next time the audio engine runs after the <strong>IXAudio2Voice::SetFilterParameters</strong> call (or after the corresponding <strong>IXAudio2::CommitChanges</strong> call, if <strong>IXAudio2Voice::SetFilterParameters</strong> was called with a deferred operation ID).?
        /// </remarks>
        /// <doc-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.setfilterparameters</doc-id>
        /// <unmanaged>HRESULT IXAudio2Voice::SetFilterParameters([In] const XAUDIO2_FILTER_PARAMETERS* pParameters,[In] unsigned int OperationSet)</unmanaged>
        /// <unmanaged-short>IXAudio2Voice::SetFilterParameters</unmanaged-short>
        public unsafe void SetFilterParameters(SharpDX.XAudio2.FilterParameters parametersRef, System.Int32 operationSet = 0)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.XAudio2.LocalInterop.CalliStdCallint(this._nativePointer, &parametersRef, operationSet, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the voice's filter parameters.</p>
        /// </summary>
        /// <param name = "parametersRef"><dd> <p>Pointer to an <strong><see cref = "SharpDX.XAudio2.FilterParameters"/></strong> structure containing the filter information. </p> </dd></param>
        /// <remarks>
        /// <p><strong>GetFilterParameters</strong> will fail if the voice was not created with the XAUDIO2_VOICE_USEFILTER flag. </p><p><strong>GetFilterParameters</strong> always returns this voice's actual current filter parameters. However, these may not match the parameters set by the most recent <strong>IXAudio2Voice::SetFilterParameters</strong> call: the actual parameters are only changed the next time the audio engine runs after the <strong>IXAudio2Voice::SetFilterParameters</strong> call (or after the corresponding <strong>IXAudio2::CommitChanges</strong> call, if <strong>IXAudio2Voice::SetFilterParameters</strong> was called with a deferred operation ID). </p><strong>Note</strong>??<strong>GetFilterParameters</strong> is usable only on source and submix voices and has no effect on mastering voices.?
        /// </remarks>
        /// <doc-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.getfilterparameters</doc-id>
        /// <unmanaged>void IXAudio2Voice::GetFilterParameters([Out] XAUDIO2_FILTER_PARAMETERS* pParameters)</unmanaged>
        /// <unmanaged-short>IXAudio2Voice::GetFilterParameters</unmanaged-short>
        public unsafe void GetFilterParameters(out SharpDX.XAudio2.FilterParameters parametersRef)
        {
            parametersRef = default (SharpDX.XAudio2.FilterParameters);
            fixed (void *parametersRef_ = &parametersRef)
                SharpDX.XAudio2.LocalInterop.CalliStdCallvoid(this._nativePointer, parametersRef_, (*(void ***)this._nativePointer)[9]);
        }

        /// <summary>
        /// <p>Sets the filter parameters on one of this voice's sends.</p>
        /// </summary>
        /// <param name = "destinationVoiceRef"><dd> <p> <strong><see cref = "SharpDX.XAudio2.Voice"/></strong> reference to the destination voice of the send whose filter parameters will be set.</p> </dd></param>
        /// <param name = "parametersRef"><dd> <p> Pointer to an <strong><see cref = "SharpDX.XAudio2.FilterParameters"/></strong> structure containing the filter information.</p> </dd></param>
        /// <param name = "operationSet"><dd> <p>Identifies this call as part of a deferred batch. See the XAudio2 Operation Sets overview for more information.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful, an error code otherwise. See <strong>XAudio2 Error Codes</strong> for descriptions of error codes. </p></returns>
        /// <remarks>
        /// <p><strong>SetOutputFilterParameters</strong> will fail if the send was not created with the XAUDIO2_SEND_USEFILTER flag. This method is usable only on sends belonging to source and submix voices and has no effect on a mastering voice's sends.
        /// </p><strong>Note</strong>??<strong>IXAudio2Voice::GetOutputFilterParameters</strong> always returns this send?s actual current filter parameters. However, these may not match the parameters set by the most recent <strong>IXAudio2Voice::SetOutputFilterParameters</strong> call: the actual parameters are only changed the next time the audio engine runs after the <strong>IXAudio2Voice::SetOutputFilterParameters</strong> call (or after the corresponding <strong>IXAudio2::CommitChanges</strong> call, if <strong>IXAudio2Voice::SetOutputFilterParameters</strong> was called with a deferred operation ID).?
        /// </remarks>
        /// <doc-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.setoutputfilterparameters</doc-id>
        /// <unmanaged>HRESULT IXAudio2Voice::SetOutputFilterParameters([In, Optional] IXAudio2Voice* pDestinationVoice,[In] const XAUDIO2_FILTER_PARAMETERS* pParameters,[In] unsigned int OperationSet)</unmanaged>
        /// <unmanaged-short>IXAudio2Voice::SetOutputFilterParameters</unmanaged-short>
        public unsafe void SetOutputFilterParameters(SharpDX.XAudio2.Voice destinationVoiceRef, SharpDX.XAudio2.FilterParameters parametersRef, System.Int32 operationSet = 0)
        {
            System.IntPtr destinationVoiceRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            destinationVoiceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.XAudio2.Voice>(destinationVoiceRef);
            __result__ = SharpDX.XAudio2.LocalInterop.CalliStdCallint(this._nativePointer, (void *)destinationVoiceRef_, &parametersRef, operationSet, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Returns the filter parameters from one of this voice's sends.</p>
        /// </summary>
        /// <param name = "destinationVoiceRef"><dd> <p> <strong><see cref = "SharpDX.XAudio2.Voice"/></strong> reference to the destination voice of the send whose filter parameters will be read.</p> </dd></param>
        /// <param name = "parametersRef"><dd> <p>Pointer to an <strong><see cref = "SharpDX.XAudio2.FilterParameters"/></strong> structure containing the filter information.</p> </dd></param>
        /// <remarks>
        /// <p><strong>GetOutputFilterParameters</strong> will fail if the send was not created with the XAUDIO2_SEND_USEFILTER flag. This method is usable only on sends belonging to source and submix voices and has no effect on mastering voices? sends. </p><strong>Note</strong>??<strong>IXAudio2Voice::GetOutputFilterParameters</strong> always returns this send?s actual current filter parameters. However, these may not match the parameters set by the most recent <strong>IXAudio2Voice::SetOutputFilterParameters</strong> call: the actual parameters are only changed the next time the audio engine runs after the <strong>IXAudio2Voice::SetOutputFilterParameters</strong> call (or after the corresponding <strong>IXAudio2::CommitChanges</strong> call, if <strong>IXAudio2Voice::SetOutputFilterParameters</strong> was called with a deferred operation ID).?
        /// </remarks>
        /// <doc-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.getoutputfilterparameters</doc-id>
        /// <unmanaged>void IXAudio2Voice::GetOutputFilterParameters([In, Optional] IXAudio2Voice* pDestinationVoice,[Out] XAUDIO2_FILTER_PARAMETERS* pParameters)</unmanaged>
        /// <unmanaged-short>IXAudio2Voice::GetOutputFilterParameters</unmanaged-short>
        public unsafe void GetOutputFilterParameters(SharpDX.XAudio2.Voice destinationVoiceRef, out SharpDX.XAudio2.FilterParameters parametersRef)
        {
            System.IntPtr destinationVoiceRef_ = System.IntPtr.Zero;
            parametersRef = default (SharpDX.XAudio2.FilterParameters);
            destinationVoiceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.XAudio2.Voice>(destinationVoiceRef);
            fixed (void *parametersRef_ = &parametersRef)
                SharpDX.XAudio2.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)destinationVoiceRef_, parametersRef_, (*(void ***)this._nativePointer)[11]);
        }

        /// <summary>
        /// <p>Sets the overall volume level for the voice.</p>
        /// </summary>
        /// <param name = "volume"><dd> <p>Overall volume level to use. See Remarks for more information on volume levels. </p> </dd></param>
        /// <param name = "operationSet"><dd> <p> Identifies this call as part of a deferred batch. See the XAudio2 Operation Sets overview for more information. </p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful, an error code otherwise. See <strong>XAudio2 Error Codes</strong> for descriptions of error codes.</p></returns>
        /// <remarks>
        /// <p><strong>SetVolume</strong> controls a voice's master input volume level. The master volume level is applied at different times depending on the type of voice. For submix and mastering voices the volume level is applied just before the voice's built in filter and effect chain is applied. For source voices the master volume level is applied after the voice's filter and effect chain is applied. </p><p>Volume levels are expressed as floating-point amplitude multipliers between -<see cref = "MaximumVolumeLevel"/> and <see cref = "MaximumVolumeLevel"/> (-2?? to 2??), with a maximum gain of 144.5 dB. A volume level of 1.0 means there is no attenuation or gain and 0 means silence. Negative levels can be used to invert the audio's phase. See XAudio2 Volume and Pitch Control for additional information on volume control. </p><strong>Note</strong>??<strong>IXAudio2Voice::GetVolume</strong> always returns the volume most recently set by <strong>IXAudio2Voice::SetVolume</strong>. However, it may not actually be in effect yet: it only takes effect the next time the audio engine runs after the <strong>IXAudio2Voice::SetVolume</strong> call (or after the corresponding <strong>IXAudio2::CommitChanges</strong> call, if <strong>IXAudio2Voice::SetVolume</strong> was called with a deferred operation ID).?
        /// </remarks>
        /// <doc-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.setvolume</doc-id>
        /// <unmanaged>HRESULT IXAudio2Voice::SetVolume([In] float Volume,[In] unsigned int OperationSet)</unmanaged>
        /// <unmanaged-short>IXAudio2Voice::SetVolume</unmanaged-short>
        public unsafe void SetVolume(System.Single volume, System.Int32 operationSet = 0)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.XAudio2.LocalInterop.CalliStdCallint(this._nativePointer, volume, operationSet, (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the overall volume level for the voice.</p>
        /// </summary>
        /// <param name = "volumeRef"><dd> <p>Overall volume level to use. See Remarks for more information on volume levels. </p> </dd></param>
        /// <remarks>
        /// <p><strong>SetVolume</strong> controls a voice's master input volume level. The master volume level is applied at different times depending on the type of voice. For submix and mastering voices the volume level is applied just before the voice's built in filter and effect chain is applied. For source voices the master volume level is applied after the voice's filter and effect chain is applied. </p><p>Volume levels are expressed as floating-point amplitude multipliers between -<see cref = "MaximumVolumeLevel"/> and <see cref = "MaximumVolumeLevel"/> (-2?? to 2??), with a maximum gain of 144.5 dB. A volume level of 1.0 means there is no attenuation or gain and 0 means silence. Negative levels can be used to invert the audio's phase. See XAudio2 Volume and Pitch Control for additional information on volume control. </p><strong>Note</strong>??<strong>IXAudio2Voice::GetVolume</strong> always returns the volume most recently set by <strong>IXAudio2Voice::SetVolume</strong>. However, it may not actually be in effect yet: it only takes effect the next time the audio engine runs after the <strong>IXAudio2Voice::SetVolume</strong> call (or after the corresponding <strong>IXAudio2::CommitChanges</strong> call, if <strong>IXAudio2Voice::SetVolume</strong> was called with a deferred operation ID).?
        /// </remarks>
        /// <doc-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.setvolume</doc-id>
        /// <unmanaged>void IXAudio2Voice::GetVolume([Out] float* pVolume)</unmanaged>
        /// <unmanaged-short>IXAudio2Voice::GetVolume</unmanaged-short>
        public unsafe void GetVolume(out System.Single volumeRef)
        {
            fixed (void *volumeRef_ = &volumeRef)
                SharpDX.XAudio2.LocalInterop.CalliStdCallvoid(this._nativePointer, volumeRef_, (*(void ***)this._nativePointer)[13]);
        }

        /// <summary>
        /// <p>Sets the volume levels for the voice, per channel.</p>
        /// </summary>
        /// <param name = "channels"><dd> <p>Number of channels in the voice.</p> </dd></param>
        /// <param name = "volumesRef"><dd> <p>Array containing the new volumes of each channel in the voice. The array must have <em>Channels</em> elements. See Remarks for more information on volume levels.</p> </dd></param>
        /// <param name = "operationSet"><dd> <p>Identifies this call as part of a deferred batch. See the XAudio2 Operation Sets overview for more information.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful, an error code otherwise. See <strong>XAudio2 Error Codes</strong> for descriptions of XAudio2 specific error codes.</p></returns>
        /// <remarks>
        /// <p><strong>SetChannelVolumes</strong> controls a voice's per-channel output levels and is applied just after the voice's final SRC and before its sends. </p><p>This method is valid only for source and submix voices, because mastering voices do not specify volume per channel. </p><p>Volume levels are expressed as floating-point amplitude multipliers between -<see cref = "MaximumVolumeLevel"/> and <see cref = "MaximumVolumeLevel"/> (-2?? to 2??), with a maximum gain of 144.5 dB. A volume of 1 means there is no attenuation or gain and 0 means silence. Negative levels can be used to invert the audio's phase. See XAudio2 Volume and Pitch Control for additional information on volume control. </p><strong>Note</strong>??<strong>IXAudio2Voice::GetChannelVolumes</strong> always returns the volume levels most recently set by <strong>IXAudio2Voice::SetChannelVolumes</strong>. However, those values may not actually be in effect yet: they only take effect the next time the audio engine runs after the <strong>IXAudio2Voice::SetChannelVolumes</strong> call (or after the corresponding <strong>IXAudio2::CommitChanges</strong> call, if <strong>IXAudio2Voice::SetChannelVolumes</strong> was called with a deferred operation ID).?
        /// </remarks>
        /// <doc-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.setchannelvolumes</doc-id>
        /// <unmanaged>HRESULT IXAudio2Voice::SetChannelVolumes([In] unsigned int Channels,[In, Buffer] const float* pVolumes,[In] unsigned int OperationSet)</unmanaged>
        /// <unmanaged-short>IXAudio2Voice::SetChannelVolumes</unmanaged-short>
        public unsafe void SetChannelVolumes(System.Int32 channels, System.Single[] volumesRef, System.Int32 operationSet = 0)
        {
            SharpDX.Result __result__;
            fixed (void *volumesRef_ = volumesRef)
                __result__ = SharpDX.XAudio2.LocalInterop.CalliStdCallint(this._nativePointer, channels, volumesRef_, operationSet, (*(void ***)this._nativePointer)[14]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Returns the volume levels for the voice, per channel.</p>
        /// </summary>
        /// <param name = "channels"><dd> <p>Confirms the channel count of the voice.</p> </dd></param>
        /// <param name = "volumesRef"><dd> <p>Returns the current volume level of each channel in the voice. The array must have at least <em>Channels</em> elements. See Remarks for more information on volume levels.</p> </dd></param>
        /// <remarks>
        /// <p>These settings are applied after the effect chain is applied. This method is valid only for source and submix voices, because mastering voices do not specify volume per channel. </p><p>Volume levels are expressed as floating-point amplitude multipliers between -2?? to 2??, with a maximum gain of 144.5 dB. A volume of 1 means there is no attenuation or gain, 0 means silence, and negative levels can be used to invert the audio's phase. See XAudio2 Volume and Pitch Control for additional information on volume control. </p><strong>Note</strong>??<strong>GetChannelVolumes</strong> always returns the volume levels most recently set by <strong>IXAudio2Voice::SetChannelVolumes</strong>. However, those values may not actually be in effect yet: they only take effect the next time the audio engine runs after the <strong>IXAudio2Voice::SetChannelVolumes</strong> call (or after the corresponding <strong>IXAudio2::CommitChanges</strong> call, if <strong>IXAudio2Voice::SetChannelVolumes</strong> was called with a deferred operation ID).?
        /// </remarks>
        /// <doc-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.getchannelvolumes</doc-id>
        /// <unmanaged>void IXAudio2Voice::GetChannelVolumes([In] unsigned int Channels,[Out, Buffer] float* pVolumes)</unmanaged>
        /// <unmanaged-short>IXAudio2Voice::GetChannelVolumes</unmanaged-short>
        public unsafe void GetChannelVolumes(System.Int32 channels, System.Single[] volumesRef)
        {
            fixed (void *volumesRef_ = volumesRef)
                SharpDX.XAudio2.LocalInterop.CalliStdCallvoid(this._nativePointer, channels, volumesRef_, (*(void ***)this._nativePointer)[15]);
        }

        /// <summary>
        /// <p>Sets the volume level of each channel of the final output for the voice. These channels are mapped to the input channels of a specified destination voice.</p>
        /// </summary>
        /// <param name = "destinationVoiceRef"><dd> <p>Pointer to a destination <strong><see cref = "SharpDX.XAudio2.Voice"/></strong> for which to set volume levels.</p> <strong>Note</strong>??If the voice sends to a single target voice then specifying <c>null</c> will cause <strong>SetOutputMatrix</strong> to operate on that target voice. ? </dd></param>
        /// <param name = "sourceChannels"><dd> <p>Confirms the output channel count of the voice. This is the number of channels that are produced by the last effect in the chain.</p> </dd></param>
        /// <param name = "destinationChannels"><dd> <p>Confirms the input channel count of the destination voice.</p> </dd></param>
        /// <param name = "levelMatrixRef"><dd> <p>Array of [<em>SourceChannels</em> ? <em>DestinationChannels</em>] volume levels sent to the destination voice. The level sent from source channel <em>S</em> to destination channel <em>D</em> is specified in the form <em>pLevelMatrix</em>[<em>SourceChannels</em> ? <em>D</em> + <em>S</em>]. </p> <p>For example, when rendering two-channel stereo input into 5.1 output that is weighted toward the front channels?but is absent from the center and low-frequency channels?the matrix might have the values shown in the following table. </p> <table> <tr><th>Output</th><th>Left Input [Array Index]</th><th>Right Input [Array Index]</th></tr> <tr><td>Left</td><td>1.0 [0]</td><td>0.0 [1]</td></tr> <tr><td>Right</td><td>0.0 [2]</td><td>1.0 [3]</td></tr> <tr><td>Front Center</td><td>0.0 [4]</td><td>0.0 [5]</td></tr> <tr><td>LFE</td><td>0.0 [6]</td><td>0.0 [7]</td></tr> <tr><td>Rear Left</td><td>0.8 [8]</td><td>0.0 [9]</td></tr> <tr><td>Rear Right</td><td>0.0 [10]</td><td>0.8 [11]</td></tr> </table> <p>?</p> <strong>Note</strong>??The left and right input are fully mapped to the output left and right channels; 80 percent of the left and right input is mapped to the rear left and right channels. ? <p>See Remarks for more information on volume levels.</p> </dd></param>
        /// <param name = "operationSet"><dd> <p>Identifies this call as part of a deferred batch. See the XAudio2 Operation Sets overview for more information.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful, an error code otherwise. See <strong>XAudio2 Error Codes</strong> for descriptions of error codes.</p></returns>
        /// <remarks>
        /// <p>This method is valid only for source and submix voices, because mastering voices write directly to the device with no matrix mixing. </p><p>Volume levels are expressed as floating-point amplitude multipliers between -<see cref = "MaximumVolumeLevel"/> and <see cref = "MaximumVolumeLevel"/> (-2?? to 2??), with a maximum gain of 144.5 dB. A volume level of 1.0 means there is no attenuation or gain and 0 means silence. Negative levels can be used to invert the audio's phase. See XAudio2 Volume and Pitch Control for additional information on volume control. </p><p>The X3DAudio function <strong>X3DAudioCalculate</strong> can produce an output matrix for use with <strong>SetOutputMatrix</strong> based on a sound's position and a listener's position.</p><strong>Note</strong>??<strong>IXAudio2Voice::GetOutputMatrix</strong> always returns the levels most recently set by <strong>IXAudio2Voice::SetOutputMatrix</strong>. However, they may not actually be in effect yet: they only take effect the next time the audio engine runs after the <strong>IXAudio2Voice::SetOutputMatrix</strong> call (or after the corresponding <strong>IXAudio2::CommitChanges</strong> call, if <strong>IXAudio2Voice::SetOutputMatrix</strong> was called with a deferred operation ID).?
        /// </remarks>
        /// <doc-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.setoutputmatrix</doc-id>
        /// <unmanaged>HRESULT IXAudio2Voice::SetOutputMatrix([In, Optional] IXAudio2Voice* pDestinationVoice,[In] unsigned int SourceChannels,[In] unsigned int DestinationChannels,[In, Buffer] const float* pLevelMatrix,[In] unsigned int OperationSet)</unmanaged>
        /// <unmanaged-short>IXAudio2Voice::SetOutputMatrix</unmanaged-short>
        public unsafe void SetOutputMatrix(SharpDX.XAudio2.Voice destinationVoiceRef, System.Int32 sourceChannels, System.Int32 destinationChannels, System.Single[] levelMatrixRef, System.Int32 operationSet = 0)
        {
            System.IntPtr destinationVoiceRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            destinationVoiceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.XAudio2.Voice>(destinationVoiceRef);
            fixed (void *levelMatrixRef_ = levelMatrixRef)
                __result__ = SharpDX.XAudio2.LocalInterop.CalliStdCallint(this._nativePointer, (void *)destinationVoiceRef_, sourceChannels, destinationChannels, levelMatrixRef_, operationSet, (*(void ***)this._nativePointer)[16]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the volume level of each channel of the final output for the voice. These channels are mapped to the input channels of a specified destination voice.</p>
        /// </summary>
        /// <param name = "destinationVoiceRef"><dd> <p>Pointer specifying the destination <strong><see cref = "SharpDX.XAudio2.Voice"/></strong> to retrieve the output matrix for.</p> <strong>Note</strong>??If the voice sends to a single target voice then specifying <c>null</c> will cause <strong>GetOutputMatrix</strong> to operate on that target voice. ? </dd></param>
        /// <param name = "sourceChannels"><dd> <p>Confirms the output channel count of the voice. This is the number of channels that are produced by the last effect in the chain.</p> </dd></param>
        /// <param name = "destinationChannels"><dd> <p>Confirms the input channel count of the destination voice.</p> </dd></param>
        /// <param name = "levelMatrixRef"><dd> <p>Array of [<em>SourceChannels</em> * <em>DestinationChannels</em>] volume levels sent to the destination voice. The level sent from source channel S to destination channel D is returned in the form <em>pLevelMatrix</em>[<em>DestinationChannels</em> ? S + D]. See Remarks for more information on volume levels.</p> </dd></param>
        /// <remarks>
        /// <p>This method applies only to source and submix voices, because mastering voices write directly to the device with no matrix mixing. Volume levels are expressed as floating-point amplitude multipliers between -2?? to 2??, with a maximum gain of 144.5 dB. A volume level of 1 means there is no attenuation or gain and 0 means silence. Negative levels can be used to invert the audio's phase. See XAudio2 Volume and Pitch Control for additional information on volume control. </p><p>See <strong><see cref = "SharpDX.Multimedia.WaveFormatExtensible"/></strong> for information on standard channel ordering. </p><strong>Note</strong>??<strong>GetOutputMatrix</strong> always returns the levels most recently set by <strong>IXAudio2Voice::SetOutputMatrix</strong>. However, they may not actually be in effect yet: they only take effect the next time the audio engine runs after the <strong>IXAudio2Voice::SetOutputMatrix</strong> call (or after the corresponding <strong>IXAudio2::CommitChanges</strong> call, if <strong>IXAudio2Voice::SetOutputMatrix</strong> was called with a deferred operation ID).?
        /// </remarks>
        /// <doc-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.getoutputmatrix</doc-id>
        /// <unmanaged>void IXAudio2Voice::GetOutputMatrix([In, Optional] IXAudio2Voice* pDestinationVoice,[In] unsigned int SourceChannels,[In] unsigned int DestinationChannels,[Out, Buffer] float* pLevelMatrix)</unmanaged>
        /// <unmanaged-short>IXAudio2Voice::GetOutputMatrix</unmanaged-short>
        public unsafe void GetOutputMatrix(SharpDX.XAudio2.Voice destinationVoiceRef, System.Int32 sourceChannels, System.Int32 destinationChannels, System.Single[] levelMatrixRef)
        {
            System.IntPtr destinationVoiceRef_ = System.IntPtr.Zero;
            destinationVoiceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.XAudio2.Voice>(destinationVoiceRef);
            fixed (void *levelMatrixRef_ = levelMatrixRef)
                SharpDX.XAudio2.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)destinationVoiceRef_, sourceChannels, destinationChannels, levelMatrixRef_, (*(void ***)this._nativePointer)[17]);
        }

        /// <summary>
        /// <p>Destroys the voice. If necessary, stops the voice and removes it from the XAudio2 graph.</p>
        /// </summary>
        /// <remarks>
        /// <p>If any other voice is currently sending audio to this voice, the method fails. </p><p><strong>DestroyVoice</strong> waits for the audio processing thread to be idle, so it can take a little while (typically no more than a couple of milliseconds). This is necessary to guarantee that the voice will no longer make any callbacks or read any audio data, so the application can safely free up these resources as soon as the call returns. </p><p>To avoid title thread interruptions from a blocking <strong>DestroyVoice</strong> call, the application can destroy voices on a separate non-critical thread, or the application can use voice pooling strategies to reuse voices rather than destroying them. Note that voices can only be reused with audio that has the same data format and the same number of channels the voice was created with. A voice can play audio data with different sample rates than that of the voice by calling <strong>IXAudio2SourceVoice::SetFrequencyRatio</strong> with an appropriate ratio parameter. </p><p>It is invalid to call <strong>DestroyVoice</strong> from within a callback (that is, <strong><see cref = "SharpDX.XAudio2.EngineCallback"/></strong> or <strong><see cref = "SharpDX.XAudio2.VoiceCallback"/></strong>).</p>
        /// </remarks>
        /// <doc-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.destroyvoice</doc-id>
        /// <unmanaged>void IXAudio2Voice::DestroyVoice()</unmanaged>
        /// <unmanaged-short>IXAudio2Voice::DestroyVoice</unmanaged-short>
        public unsafe void DestroyVoice()
        {
            SharpDX.XAudio2.LocalInterop.CalliStdCallvoid(this._nativePointer, (*(void ***)this._nativePointer)[18]);
        }
    }

    public partial interface VoiceCallback : SharpDX.ICallbackable
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("2B02E3CF-2E0B-4ec3-BE45-1B2A3FE7210D")]
    public partial class XAudio2 : SharpDX.ComObject
    {
        public XAudio2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator XAudio2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new XAudio2(nativePtr);
                ///<summary>Constant MaximumBufferBytes</summary>
        ///<unmanaged>XAUDIO2_MAX_BUFFER_BYTES</unmanaged>
        public const int MaximumBufferBytes = unchecked ((int)2147483648U);
                ///<summary>Constant MaximumQueuedBuffers</summary>
        ///<unmanaged>XAUDIO2_MAX_QUEUED_BUFFERS</unmanaged>
        public const int MaximumQueuedBuffers = 64;
                ///<summary>Constant MaximumAudioChannels</summary>
        ///<unmanaged>XAUDIO2_MAX_AUDIO_CHANNELS</unmanaged>
        public const int MaximumAudioChannels = 64;
                ///<summary>Constant MinimumSampleRate</summary>
        ///<unmanaged>XAUDIO2_MIN_SAMPLE_RATE</unmanaged>
        public const int MinimumSampleRate = 1000;
                ///<summary>Constant MaximumSampleRate</summary>
        ///<unmanaged>XAUDIO2_MAX_SAMPLE_RATE</unmanaged>
        public const int MaximumSampleRate = 200000;
                ///<summary>Constant MaximumVolumeLevel</summary>
        ///<unmanaged>XAUDIO2_MAX_VOLUME_LEVEL</unmanaged>
        public const float MaximumVolumeLevel = 16777216.0F;
                ///<summary>Constant MinimumFrequencyRatio</summary>
        ///<unmanaged>XAUDIO2_MIN_FREQ_RATIO</unmanaged>
        public const float MinimumFrequencyRatio = unchecked ((float)1 / 1024.0F);
                ///<summary>Constant MaximumFrequencyRatio</summary>
        ///<unmanaged>XAUDIO2_MAX_FREQ_RATIO</unmanaged>
        public const float MaximumFrequencyRatio = 1024.0F;
                ///<summary>Constant DefaultFrequencyRatio</summary>
        ///<unmanaged>XAUDIO2_DEFAULT_FREQ_RATIO</unmanaged>
        public const float DefaultFrequencyRatio = 2.0F;
                ///<summary>Constant MaximumFilterOneOverQ</summary>
        ///<unmanaged>XAUDIO2_MAX_FILTER_ONEOVERQ</unmanaged>
        public const float MaximumFilterOneOverQ = 1.5F;
                ///<summary>Constant MaximumFilterFrequency</summary>
        ///<unmanaged>XAUDIO2_MAX_FILTER_FREQUENCY</unmanaged>
        public const float MaximumFilterFrequency = 1.0F;
                ///<summary>Constant MaximumLoopCount</summary>
        ///<unmanaged>XAUDIO2_MAX_LOOP_COUNT</unmanaged>
        public const int MaximumLoopCount = 254;
                ///<summary>Constant CommitNow</summary>
        ///<unmanaged>XAUDIO2_COMMIT_NOW</unmanaged>
        public const int CommitNow = 0;
                ///<summary>Constant CommitAll</summary>
        ///<unmanaged>XAUDIO2_COMMIT_ALL</unmanaged>
        public const int CommitAll = 0;
                ///<summary>Constant NoLoopRegion</summary>
        ///<unmanaged>XAUDIO2_NO_LOOP_REGION</unmanaged>
        public const int NoLoopRegion = 0;
                ///<summary>Constant DefaultChannels</summary>
        ///<unmanaged>XAUDIO2_DEFAULT_CHANNELS</unmanaged>
        public const int DefaultChannels = 0;
                ///<summary>Constant DefaultSampleRate</summary>
        ///<unmanaged>XAUDIO2_DEFAULT_SAMPLERATE</unmanaged>
        public const int DefaultSampleRate = 0;
        /// <summary>
        /// <p>Returns current resource usage details, such as available memory or CPU usage.</p>
        /// </summary>
        /// <remarks>
        /// <p>For specific information on the statistics returned by <strong>GetPerformanceData</strong>, see the <strong><see cref = "SharpDX.XAudio2.PerformanceData"/></strong> structure reference. </p>
        /// </remarks>
        /// <doc-id>microsoft.directx_sdk.ixaudio2.ixaudio2.getperformancedata</doc-id>
        /// <unmanaged>GetPerformanceData</unmanaged>
        /// <unmanaged-short>GetPerformanceData</unmanaged-short>
        public SharpDX.XAudio2.PerformanceData PerformanceData
        {
            get
            {
                GetPerformanceData(out var __output__);
                return __output__;
            }
        }

        private int RegisterForCallbacks__vtbl_index = 3;
        /// <summary>
        /// <p>Adds an <strong><see cref = "SharpDX.XAudio2.EngineCallback"/></strong> reference to the <strong>XAudio2</strong> engine callback list.</p>
        /// </summary>
        /// <param name = "callbackRef">No documentation.</param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful, an error code otherwise. See <strong>XAudio2 Error Codes</strong> for descriptions of XAudio2 specific error codes.</p></returns>
        /// <remarks>
        /// <p>This method can be called multiple times, allowing different components or layers of the same application to manage their own engine callback implementations separately. </p><p>It is invalid to call <strong>RegisterForCallbacks</strong> from within a callback (that is, <strong><see cref = "SharpDX.XAudio2.EngineCallback"/></strong> or <strong><see cref = "SharpDX.XAudio2.VoiceCallback"/></strong>). If <strong>RegisterForCallbacks</strong> is called within a callback, it returns <see cref = "InvalidCall"/>. </p>
        /// </remarks>
        /// <doc-id>microsoft.directx_sdk.ixaudio2.ixaudio2.registerforcallbacks</doc-id>
        /// <unmanaged>HRESULT IXAudio2::RegisterForCallbacks([In] IXAudio2EngineCallback* pCallback)</unmanaged>
        /// <unmanaged-short>IXAudio2::RegisterForCallbacks</unmanaged-short>
        internal unsafe void RegisterForCallbacks(SharpDX.XAudio2.EngineCallback callbackRef)
        {
            System.IntPtr callbackRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            callbackRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.XAudio2.EngineCallback>(callbackRef);
            __result__ = SharpDX.XAudio2.LocalInterop.CalliStdCallint(this._nativePointer, (void *)callbackRef_, (*(void ***)this._nativePointer)[this.RegisterForCallbacks__vtbl_index]);
            __result__.CheckError();
        }

        private int UnregisterForCallbacks__vtbl_index = 4;
        /// <summary>
        /// <p>Removes an <strong><see cref = "SharpDX.XAudio2.EngineCallback"/></strong> reference from the <strong>XAudio2</strong> engine callback list.</p>
        /// </summary>
        /// <param name = "callbackRef">No documentation.</param>
        /// <remarks>
        /// <p>It is invalid to call <strong>UnregisterForCallbacks</strong> from within a callback (that is, <strong><see cref = "SharpDX.XAudio2.EngineCallback"/></strong> or <strong><see cref = "SharpDX.XAudio2.VoiceCallback"/></strong>). </p>
        /// </remarks>
        /// <doc-id>microsoft.directx_sdk.ixaudio2.ixaudio2.unregisterforcallbacks</doc-id>
        /// <unmanaged>void IXAudio2::UnregisterForCallbacks([In] IXAudio2EngineCallback* pCallback)</unmanaged>
        /// <unmanaged-short>IXAudio2::UnregisterForCallbacks</unmanaged-short>
        internal unsafe void UnregisterForCallbacks(SharpDX.XAudio2.EngineCallback callbackRef)
        {
            System.IntPtr callbackRef_ = System.IntPtr.Zero;
            callbackRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.XAudio2.EngineCallback>(callbackRef);
            SharpDX.XAudio2.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)callbackRef_, (*(void ***)this._nativePointer)[this.UnregisterForCallbacks__vtbl_index]);
        }

        private int CreateSourceVoice__vtbl_index = 5;
        /// <summary>
        /// <p>Creates and configures a source voice.</p>
        /// </summary>
        /// <param name = "sourceVoiceOut"><dd> <p>If successful, returns a reference to the new <strong><see cref = "SharpDX.XAudio2.SourceVoice"/></strong> object.</p> </dd></param>
        /// <param name = "sourceFormatRef"><dd> <p>Pointer to a one of the structures in the table below. This structure contains the expected format for all audio buffers submitted to the source voice. XAudio2 supports PCM and ADPCM voice types. </p> <table> <tr><th>Format tag</th><th>Wave format structure</th><th>Size (in bytes)</th></tr> <tr><td>WAVE_FORMAT_PCM (0x0001) </td><td> <strong>PCMWAVEFORMAT</strong> </td><td>16</td></tr> <tr><td>-or-</td><td> <strong><see cref = "SharpDX.Multimedia.WaveFormat"/></strong> </td><td>18</td></tr> <tr><td>WAVE_FORMAT_IEEE_FLOAT (0x0003) [32-bit]</td><td> <strong>PCMWAVEFORMAT</strong> </td><td>18</td></tr> <tr><td>WAVE_FORMAT_ADPCM (0x0002) [MS-ADPCM]</td><td> <strong>ADPCMWAVEFORMAT</strong> </td><td>50</td></tr> <tr><td>WAVE_FORMAT_EXTENSIBLE (0xFFFE)</td><td> <strong><see cref = "SharpDX.Multimedia.WaveFormatExtensible"/></strong> </td><td>40</td></tr> </table> <p>?</p> <p>XAudio2 supports the following PCM formats.</p> <ul> <li>8-bit (unsigned) integer PCM </li> <li>16-bit integer PCM (optimal format for XAudio2) </li> <li>20-bit integer PCM (either in 24 or 32 bit containers) </li> <li>24-bit integer PCM (either in 24 or 32 bit containers) </li> <li>32-bit integer PCM </li> <li>32-bit float PCM (preferred format after 16-bit integer)</li> </ul> <p>The number of channels in a source voice must be less than or equal to <see cref = "MaximumAudioChannels"/>. The sample rate of a source voice must be between <see cref = "MinimumSampleRate"/> and <see cref = "MaximumSampleRate"/>.</p> <strong>Note</strong>??PCM data formats such as <strong>PCMWAVEFORMAT</strong> and  <strong>ADPCMWAVEFORMAT</strong> that require more information than provided by <strong><see cref = "SharpDX.Multimedia.WaveFormat"/></strong> have a <strong><see cref = "SharpDX.Multimedia.WaveFormat"/></strong> structure as the first member in their format structures. When you create a source voice with one of those formats, cast the format's structure as a <strong><see cref = "SharpDX.Multimedia.WaveFormat"/></strong> structure and use it as the value for <em>pSourceFormat</em>. ? </dd></param>
        /// <param name = "flags"><dd> <p>Flags that specify the behavior of the source voice. A flag can be 0 or a combination of one or more of the following:</p> <table> <tr><th>Value</th><th>Description</th></tr> <tr><td>XAUDIO2_VOICE_NOPITCH</td><td>No pitch control is available on the voice.?</td></tr> <tr><td>XAUDIO2_VOICE_NOSRC</td><td>No sample rate conversion is available on the voice.  The voice's outputs must have the same sample rate.<strong>Note</strong>??The XAUDIO2_VOICE_NOSRC flag causes the voice to behave as though the XAUDIO2_VOICE_NOPITCH flag also is specified. ? </td></tr> <tr><td>XAUDIO2_VOICE_USEFILTER</td><td>The filter effect should be available on this voice.?</td></tr> </table> <p>?</p> <strong>Note</strong>??The XAUDIO2_VOICE_MUSIC flag is not supported on Windows. ? </dd></param>
        /// <param name = "maxFrequencyRatio"><dd> <p>Highest allowable frequency ratio that can be set on this voice. The value for this argument must be between <see cref = "MinimumFrequencyRatio"/> and <see cref = "MaximumFrequencyRatio"/>. Subsequent calls to <strong>IXAudio2SourceVoice::SetFrequencyRatio</strong> are clamped between <see cref = "MinimumFrequencyRatio"/> and <strong>MaxFrequencyRatio</strong>. The maximum value for this argument is defined as <see cref = "MaximumFrequencyRatio"/>, which allows pitch to be raised by up to 10 octaves. </p> <p>If <em>MaxFrequencyRatio</em> is less than 1.0, the voice will use that ratio immediately after being created (rather than the default of 1.0). </p> <p> </p><table> <tr><th>Xbox 360</th></tr> <tr><td>For XMA voices, there is one more restriction on the <em>MaxFrequencyRatio</em> argument and the voice's sample rate. The product of these two numbers cannot exceed XAUDIO2_MAX_RATIO_TIMES_RATE_XMA_MONO for one-channel voices or XAUDIO2_MAX_RATIO_TIMES_RATE_XMA_MULTICHANNEL for voices with any other number of channels. If the value specified for <em>MaxFrequencyRatio</em> is too high for the specified format, the call to <strong>CreateSourceVoice</strong> fails and produces a debug message.</td></tr> </table> <p>?</p> <strong>Note</strong>??You can use the lowest possible <em>MaxFrequencyRatio</em> value to reduce XAudio2's memory usage. ? </dd></param>
        /// <param name = "callbackRef"><dd> <p>Pointer to a client-provided callback interface, <strong><see cref = "SharpDX.XAudio2.VoiceCallback"/></strong>.</p> </dd></param>
        /// <param name = "sendListRef"><dd> <p>Pointer to a list of <strong><see cref = "SharpDX.XAudio2.VoiceSendDescriptors"/></strong> structures that describe the set of destination voices for the source voice. If pSendList is <c>null</c>, the send list defaults to a single output to the first mastering voice created.</p> </dd></param>
        /// <param name = "effectChainRef"><dd> <p>Pointer to a list of <strong><see cref = "SharpDX.XAudio2.EffectChain"/></strong> structures that describe an effect chain to use in the source voice.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise, an error code.  </p><p>See <strong>XAudio2 Error Codes</strong> for descriptions of XAudio2-specific error codes.</p></returns>
        /// <remarks>
        /// <p>Source voices read audio data from the client. They process the data and send it to the XAudio2 processing graph. </p><p>A source voice includes a variable-rate sample rate conversion, to convert data from the source format sample rate to the output rate required for the voice send list. If you use a <c>null</c> send list, the target sample rate will be the mastering voice's input sample rate. If you provide a single voice in pSendList, that voice's input sample rate is the target rate. If you provide multiple voices in the pSendList, all the source voice's output voices must be running at the same input sample rate. </p><p>You cannot create any source or submix voices until a mastering voice exists, and you cannot destory a mastering voice if any source or submix voices still exist. </p><p>Source voices are always processed before any submix or mastering voices. This means that you do not need a ProcessingStage parameter to control the processing order. </p><p>When first created, source voices are in the stopped state. </p><p>XAudio2 uses an internal memory pooler for voices with the same format. This means memory allocation for voices will occur less frequently as more voices are created and then destroyed. To minimize just-in-time allocations, a title can create the anticipated maximum number of voices needed up front, and then delete them as necessary. Voices will then be reused from the XAudio2 pool. The memory pool is tied to an XAudio2 engine instance. You can reclaim all the memory used by an instance of the XAudio2 engine by destroying the XAudio2 object and recreating it as necessary (forcing the memory pool to grow via preallocation would have to be reapplied as needed). </p><p>It is invalid to call <strong>CreateSourceVoice</strong> from within a callback (that is, <strong><see cref = "SharpDX.XAudio2.EngineCallback"/></strong> or <strong><see cref = "SharpDX.XAudio2.VoiceCallback"/></strong>). If you call <strong>CreateSourceVoice</strong> within a callback, it returns <see cref = "InvalidCall"/>. </p><p>The <strong><see cref = "SharpDX.XAudio2.EffectChain"/></strong> that is passed in as the pEffectChain argument and any <strong><see cref = "SharpDX.XAudio2.EffectDescriptor"/></strong> information contained within it are no longer needed after <strong>CreateSourceVoice</strong> successfully completes, and may be deleted immediately after <strong>CreateSourceVoice</strong> is called.
        /// </p>
        /// </remarks>
        /// <doc-id>microsoft.directx_sdk.ixaudio2.ixaudio2.createsourcevoice</doc-id>
        /// <unmanaged>HRESULT IXAudio2::CreateSourceVoice([Out, Fast] IXAudio2SourceVoice** ppSourceVoice,[In] const WAVEFORMATEX* pSourceFormat,[In] unsigned int Flags,[In] float MaxFrequencyRatio,[In, Optional] IXAudio2VoiceCallback* pCallback,[In, Optional] const XAUDIO2_VOICE_SENDS* pSendList,[In, Optional] const XAUDIO2_EFFECT_CHAIN* pEffectChain)</unmanaged>
        /// <unmanaged-short>IXAudio2::CreateSourceVoice</unmanaged-short>
        internal unsafe void CreateSourceVoice(SharpDX.XAudio2.SourceVoice sourceVoiceOut, System.IntPtr sourceFormatRef, SharpDX.XAudio2.VoiceFlags flags, System.Single maxFrequencyRatio, SharpDX.XAudio2.VoiceCallback callbackRef, SharpDX.XAudio2.VoiceSendDescriptors? sendListRef, SharpDX.XAudio2.EffectChain? effectChainRef)
        {
            System.IntPtr sourceVoiceOut_ = System.IntPtr.Zero;
            System.IntPtr callbackRef_ = System.IntPtr.Zero;
            SharpDX.XAudio2.VoiceSendDescriptors sendListRef_;
            SharpDX.XAudio2.EffectChain effectChainRef_;
            SharpDX.Result __result__;
            callbackRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.XAudio2.VoiceCallback>(callbackRef);
            if (sendListRef != null)
                sendListRef_ = sendListRef.Value;
            if (effectChainRef != null)
                effectChainRef_ = effectChainRef.Value;
            __result__ = SharpDX.XAudio2.LocalInterop.CalliStdCallint(this._nativePointer, &sourceVoiceOut_, (void *)sourceFormatRef, unchecked ((System.Int32)flags), maxFrequencyRatio, (void *)callbackRef_, sendListRef == null ? (void *)0 : &sendListRef_, effectChainRef == null ? (void *)0 : &effectChainRef_, (*(void ***)this._nativePointer)[this.CreateSourceVoice__vtbl_index]);
            (sourceVoiceOut).NativePointer = sourceVoiceOut_;
            __result__.CheckError();
        }

        private int CreateSubmixVoice__vtbl_index = 6;
        /// <summary>
        /// <p>Creates and configures a submix voice.</p>
        /// </summary>
        /// <param name = "submixVoiceOut"><dd> <p>On success, returns a reference to the new <strong><see cref = "SharpDX.XAudio2.SubmixVoice"/></strong> object.</p> </dd></param>
        /// <param name = "inputChannels"><dd> <p>Number of channels in the input audio data of the submix voice. <em>InputChannels</em> must be less than or equal to <see cref = "MaximumAudioChannels"/>.</p> </dd></param>
        /// <param name = "inputSampleRate"><dd> <p>Sample rate of the input audio data of submix voice. This rate must be a multiple of XAUDIO2_QUANTUM_DENOMINATOR. <em>InputSampleRate</em> must be between <see cref = "MinimumSampleRate"/> and <see cref = "MaximumSampleRate"/>. </p> </dd></param>
        /// <param name = "flags"><dd> <p>Flags that specify the behavior of the submix voice. It can be 0 or the following:</p> <table> <tr><th>Value</th><th>Description</th></tr> <tr><td>XAUDIO2_VOICE_USEFILTER</td><td>The filter effect should be available on this voice.</td></tr> </table> <p>?</p> </dd></param>
        /// <param name = "processingStage"><dd> <p>An arbitrary number that specifies when this voice is processed with respect to other submix voices, if the XAudio2 engine is running other submix voices. The voice is processed after all other voices that include a smaller <em>ProcessingStage</em> value and before all other voices that include a larger <em>ProcessingStage</em> value. Voices that include the same <em>ProcessingStage</em> value are processed in any order. A submix voice cannot send to another submix voice with a lower or equal <em>ProcessingStage</em> value. This prevents audio being lost due to a submix cycle. </p> </dd></param>
        /// <param name = "sendListRef"><dd> <p>Pointer to a list of <strong><see cref = "SharpDX.XAudio2.VoiceSendDescriptors"/></strong> structures that describe the set of destination voices for the submix voice. If <em>pSendList</em> is <c>null</c>, the send list will default to a single output to the first mastering voice created.</p> </dd></param>
        /// <param name = "effectChainRef"><dd> <p>Pointer to a list of <strong><see cref = "SharpDX.XAudio2.EffectChain"/></strong> structures that describe an effect chain to use in the submix voice. </p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise, an error code.  </p><p>See <strong>XAudio2 Error Codes</strong> for descriptions of XAudio2 specific error codes. </p></returns>
        /// <remarks>
        /// <p>Submix voices receive the output of one or more source or submix voices. They process the output, and then send it to another submix voice or to a mastering voice. </p><p>A submix voice performs a sample rate conversion from the input sample rate to the input rate of its output voices in <em>pSendList</em>. If you specify multiple voice sends, they must all have the input same sample rate. </p><p>You cannot create any source or submix voices until a mastering voice exists, and you cannot destroy a mastering voice if any source or submix voices still exist. </p><p>When first created, submix voices are in the started state. </p><p>XAudio2 uses an internal memory pooler for voices with the same format. This means that memory allocation for voices will occur less frequently as more voices are created and then destroyed. To minimize just-in-time allocations, a title can create the anticipated maximum number of voices needed up front, and then delete them as necessary. Voices will then be reused from the XAudio2 pool. The memory pool is tied to an XAudio2 engine instance. You can reclaim all the memory used by an instance of the XAudio2 engine by destroying the XAudio2 object and recreating it as necessary (forcing the memory pool to grow via preallocation would have to be reapplied as needed). </p><p>It is invalid to call <strong>CreateSubmixVoice</strong> from within a callback (that is, <strong><see cref = "SharpDX.XAudio2.EngineCallback"/></strong> or <strong><see cref = "SharpDX.XAudio2.VoiceCallback"/></strong>). If you call <strong>CreateSubmixVoice</strong> within a callback, it returns <see cref = "InvalidCall"/>. </p><p>The <strong><see cref = "SharpDX.XAudio2.EffectChain"/></strong> that is passed in as the <em>pEffectChain</em> argument and any <strong><see cref = "SharpDX.XAudio2.EffectDescriptor"/></strong> information contained within it are no longer needed after <strong>CreateSubmixVoice</strong> successfully completes, and may be deleted immediately after <strong>CreateSubmixVoice</strong> is called.</p>
        /// </remarks>
        /// <doc-id>microsoft.directx_sdk.ixaudio2.ixaudio2.createsubmixvoice</doc-id>
        /// <unmanaged>HRESULT IXAudio2::CreateSubmixVoice([Out, Fast] IXAudio2SubmixVoice** ppSubmixVoice,[In] unsigned int InputChannels,[In] unsigned int InputSampleRate,[In] unsigned int Flags,[In] unsigned int ProcessingStage,[In, Optional] const XAUDIO2_VOICE_SENDS* pSendList,[In, Optional] const XAUDIO2_EFFECT_CHAIN* pEffectChain)</unmanaged>
        /// <unmanaged-short>IXAudio2::CreateSubmixVoice</unmanaged-short>
        internal unsafe void CreateSubmixVoice(SharpDX.XAudio2.SubmixVoice submixVoiceOut, System.Int32 inputChannels, System.Int32 inputSampleRate, System.Int32 flags, System.Int32 processingStage, SharpDX.XAudio2.VoiceSendDescriptors? sendListRef, SharpDX.XAudio2.EffectChain? effectChainRef)
        {
            System.IntPtr submixVoiceOut_ = System.IntPtr.Zero;
            SharpDX.XAudio2.VoiceSendDescriptors sendListRef_;
            SharpDX.XAudio2.EffectChain effectChainRef_;
            SharpDX.Result __result__;
            if (sendListRef != null)
                sendListRef_ = sendListRef.Value;
            if (effectChainRef != null)
                effectChainRef_ = effectChainRef.Value;
            __result__ = SharpDX.XAudio2.LocalInterop.CalliStdCallint(this._nativePointer, &submixVoiceOut_, inputChannels, inputSampleRate, flags, processingStage, sendListRef == null ? (void *)0 : &sendListRef_, effectChainRef == null ? (void *)0 : &effectChainRef_, (*(void ***)this._nativePointer)[this.CreateSubmixVoice__vtbl_index]);
            (submixVoiceOut).NativePointer = submixVoiceOut_;
            __result__.CheckError();
        }

        private int CreateMasteringVoice__vtbl_index = 7;
        /// <summary>
        /// <p>Creates and configures a mastering voice.</p>
        /// </summary>
        /// <param name = "masteringVoiceOut"><dd> <p> If successful, returns a reference to the new <strong><see cref = "SharpDX.XAudio2.MasteringVoice"/></strong> object.</p> </dd></param>
        /// <param name = "inputChannels"><dd> <p>Number of channels the mastering voice expects in its input audio. <em>InputChannels</em> must be less than or equal to <see cref = "MaximumAudioChannels"/>. </p> <p>You can set <em>InputChannels</em> to <see cref = "DefaultChannels"/>, which causes XAudio2 to try to detect the system speaker configuration setup. </p> </dd></param>
        /// <param name = "inputSampleRate"><dd> <p>Sample rate of the input audio data of the mastering voice. This rate must be a multiple of XAUDIO2_QUANTUM_DENOMINATOR. <em>InputSampleRate</em> must be between <see cref = "MinimumSampleRate"/> and <see cref = "MaximumSampleRate"/>. </p> <p>You can set <em>InputSampleRate</em> to <see cref = "DefaultSampleRate"/>, with the default being determined by the current platform. </p> <p>Windows XP defaults to 44100. </p> <p>Windows Vista and Windows 7 default to the setting specified in the Sound Control Panel. The default for this setting is 44100 (or 48000 if required by the driver). Flags</p> </dd></param>
        /// <param name = "flags"><dd> <p> Flags that specify the behavior of the mastering voice. Must be 0.</p> </dd></param>
        /// <param name = "szDeviceId"><dd> <p>Identifier of the device to receive the output audio. Specifying the default value of <c>null</c> causes XAudio2 to select the global default audio device.</p> </dd></param>
        /// <param name = "effectChainRef"><dd> <p>Pointer to an <strong><see cref = "SharpDX.XAudio2.EffectChain"/></strong> structure that describes an effect chain to use in the mastering voice, or <c>null</c> to use no effects.</p> </dd></param>
        /// <param name = "streamCategory"><dd> <p>The audio stream category to use for this mastering voice.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise, an error code. Returns ERROR_NOT_FOUND if no default audio device exists and <c>null</c> is passed in as the szDeviceId parameter.  </p><p>See <strong>XAudio2 Error Codes</strong> for descriptions of XAudio2 specific error codes. </p></returns>
        /// <remarks>
        /// <p>Mastering voices receive the output of one or more source or submix voices. They process the data, and send it to the audio output device. </p><p>Typically, you should create a mastering voice with an input sample rate that will be used by the majority of the title's audio content. The mastering voice performs a sample rate conversion from this input sample rate to the actual device output rate. </p><p>You cannot create a source or submix voices until a mastering voice exists. You cannot destroy a mastering voice if any source or submix voices still exist. </p><p>Mastering voices are always processed after all source and submix voices. This means that you need not specify a <em>ProcessingStage</em> parameter to control the processing order. </p><p>XAudio2 only allows one mastering voice to exist at once. If you attempt to create more than one voice, <see cref = "InvalidCall"/> is returned. If an additional mastering voice is needed, for example for an output device with a different audio category set, you will need to create an additional XAudio2 instance. </p><p>When first created, mastering voices are in the started state. </p><p>It is invalid to call <strong>CreateMasteringVoice</strong> from within a callback (that is, <strong><see cref = "SharpDX.XAudio2.EngineCallback"/></strong> or <strong><see cref = "SharpDX.XAudio2.VoiceCallback"/></strong>). If you call <strong>CreateMasteringVoice</strong> within a callback, it returns <see cref = "InvalidCall"/>. </p><p>The <strong><see cref = "SharpDX.XAudio2.EffectChain"/></strong> that is passed in as the pEffectChain argument and any <strong><see cref = "SharpDX.XAudio2.EffectDescriptor"/></strong> information contained within it are no longer needed after <strong>CreateMasteringVoice</strong> successfully completes, and may be deleted immediately after <strong>CreateMasteringVoice</strong> is called. </p><p>Note that the DirectX SDK XAUDIO2 version of <strong>CreateMasteringVoice</strong> took a DeviceIndex argument instead of a szDeviceId and a StreamCategory argument. This reflects the changes needed for the standard Windows device enumeration model.</p>
        /// </remarks>
        /// <doc-id>hh405048</doc-id>
        /// <unmanaged>HRESULT IXAudio2::CreateMasteringVoice([Out, Fast] IXAudio2MasteringVoice** ppMasteringVoice,[In] unsigned int InputChannels,[In] unsigned int InputSampleRate,[In] unsigned int Flags,[In, Optional] const wchar_t* szDeviceId,[In, Optional] const XAUDIO2_EFFECT_CHAIN* pEffectChain,[In] AUDIO_STREAM_CATEGORY StreamCategory)</unmanaged>
        /// <unmanaged-short>IXAudio2::CreateMasteringVoice</unmanaged-short>
        internal unsafe void CreateMasteringVoice(SharpDX.XAudio2.MasteringVoice masteringVoiceOut, System.Int32 inputChannels, System.Int32 inputSampleRate, System.Int32 flags, System.String szDeviceId, SharpDX.XAudio2.EffectChain? effectChainRef, SharpDX.Multimedia.AudioStreamCategory streamCategory)
        {
            System.IntPtr masteringVoiceOut_ = System.IntPtr.Zero;
            SharpDX.XAudio2.EffectChain effectChainRef_;
            SharpDX.Result __result__;
            if (effectChainRef != null)
                effectChainRef_ = effectChainRef.Value;
            fixed (char *szDeviceId_ = szDeviceId)
                __result__ = SharpDX.XAudio2.LocalInterop.CalliStdCallint(this._nativePointer, &masteringVoiceOut_, inputChannels, inputSampleRate, flags, (void *)szDeviceId_, effectChainRef == null ? (void *)0 : &effectChainRef_, unchecked ((System.Int32)streamCategory), (*(void ***)this._nativePointer)[this.CreateMasteringVoice__vtbl_index]);
            (masteringVoiceOut).NativePointer = masteringVoiceOut_;
            __result__.CheckError();
        }

        private int StartEngine__vtbl_index = 8;
        /// <summary>
        /// <p>Starts the audio processing thread.</p>
        /// </summary>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful, an error code otherwise. See <strong>XAudio2 Error Codes</strong> for descriptions of XAudio2 specific error codes. </p></returns>
        /// <remarks>
        /// <p>After <strong>StartEngine</strong> is called, all started voices begin to consume audio. All enabled effects start running, and the resulting audio is sent to any connected output devices. When XAudio2 is first initialized, the engine is already in the started state. </p><p>It is invalid to call <strong>StartEngine</strong> from within a callback (that is, <strong><see cref = "SharpDX.XAudio2.EngineCallback"/></strong> or <strong><see cref = "SharpDX.XAudio2.VoiceCallback"/></strong>). If <strong>StartEngine</strong> is called within a callback, it returns <see cref = "InvalidCall"/>. </p>
        /// </remarks>
        /// <doc-id>microsoft.directx_sdk.ixaudio2.ixaudio2.startengine</doc-id>
        /// <unmanaged>HRESULT IXAudio2::StartEngine()</unmanaged>
        /// <unmanaged-short>IXAudio2::StartEngine</unmanaged-short>
        public unsafe void StartEngine()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.XAudio2.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[this.StartEngine__vtbl_index]);
            __result__.CheckError();
        }

        private int StopEngine__vtbl_index = 9;
        /// <summary>
        /// <p>Stops the audio processing thread.</p>
        /// </summary>
        /// <remarks>
        /// <p>When <strong>StopEngine</strong> is called, all output is stopped immediately. However, the audio graph is left untouched, preserving effect parameters, effect histories (for example, the data stored by a reverb effect in order to emit echoes of a previous sound), voice states, pending source buffers, cursor positions, and so forth. When the engine is restarted, the resulting audio output will be identical?apart from a period of silence?to the output that would have been produced if the engine had never been stopped. </p><p>It is invalid to call <strong>StopEngine</strong> from within a callback (that is, <strong><see cref = "SharpDX.XAudio2.EngineCallback"/></strong> or <strong><see cref = "SharpDX.XAudio2.VoiceCallback"/></strong>).</p>
        /// </remarks>
        /// <doc-id>microsoft.directx_sdk.ixaudio2.ixaudio2.stopengine</doc-id>
        /// <unmanaged>void IXAudio2::StopEngine()</unmanaged>
        /// <unmanaged-short>IXAudio2::StopEngine</unmanaged-short>
        public unsafe void StopEngine()
        {
            SharpDX.XAudio2.LocalInterop.CalliStdCallvoid(this._nativePointer, (*(void ***)this._nativePointer)[this.StopEngine__vtbl_index]);
        }

        private int CommitChanges__vtbl_index = 10;
        /// <summary>
        /// <p>Atomically applies a set of operations that are tagged with a given identifier.</p>
        /// </summary>
        /// <param name = "operationSet"><dd> <p>Identifier of the set of operations to be applied. To commit all pending operations, pass <strong><see cref = "CommitAll"/></strong>. </p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; returns an error code otherwise. See <strong>XAudio2 Error Codes</strong> for descriptions of XAudio2 specific error codes.</p></returns>
        /// <remarks>
        /// <p><strong>CommitChanges</strong> does nothing if no operations are tagged with the given identifier. </p><p>See the XAudio2 Operation Sets overview about working with <strong>CommitChanges</strong> and XAudio2 interface methods that may be deferred.
        /// </p>
        /// </remarks>
        /// <doc-id>microsoft.directx_sdk.ixaudio2.ixaudio2.commitchanges</doc-id>
        /// <unmanaged>HRESULT IXAudio2::CommitChanges([In] unsigned int OperationSet)</unmanaged>
        /// <unmanaged-short>IXAudio2::CommitChanges</unmanaged-short>
        public unsafe void CommitChanges(System.Int32 operationSet = 0)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.XAudio2.LocalInterop.CalliStdCallint(this._nativePointer, operationSet, (*(void ***)this._nativePointer)[this.CommitChanges__vtbl_index]);
            __result__.CheckError();
        }

        private int GetPerformanceData__vtbl_index = 11;
        /// <summary>
        /// <p>Returns current resource usage details, such as available memory or CPU usage.</p>
        /// </summary>
        /// <param name = "perfDataRef"><dd> <p>On success, reference to an <strong><see cref = "SharpDX.XAudio2.PerformanceData"/></strong> structure that is returned. </p> </dd></param>
        /// <remarks>
        /// <p>For specific information on the statistics returned by <strong>GetPerformanceData</strong>, see the <strong><see cref = "SharpDX.XAudio2.PerformanceData"/></strong> structure reference. </p>
        /// </remarks>
        /// <doc-id>microsoft.directx_sdk.ixaudio2.ixaudio2.getperformancedata</doc-id>
        /// <unmanaged>void IXAudio2::GetPerformanceData([Out] XAUDIO2_PERFORMANCE_DATA* pPerfData)</unmanaged>
        /// <unmanaged-short>IXAudio2::GetPerformanceData</unmanaged-short>
        internal unsafe void GetPerformanceData(out SharpDX.XAudio2.PerformanceData perfDataRef)
        {
            perfDataRef = default (SharpDX.XAudio2.PerformanceData);
            fixed (void *perfDataRef_ = &perfDataRef)
                SharpDX.XAudio2.LocalInterop.CalliStdCallvoid(this._nativePointer, perfDataRef_, (*(void ***)this._nativePointer)[this.GetPerformanceData__vtbl_index]);
        }

        private int SetDebugConfiguration__vtbl_index = 12;
        /// <summary>
        /// <p>Changes global debug logging options for XAudio2.</p>
        /// </summary>
        /// <param name = "debugConfigurationRef"><dd> <p>Pointer to a <strong><see cref = "SharpDX.XAudio2.DebugConfiguration"/></strong> structure that contains the new debug configuration.</p> </dd></param>
        /// <param name = "reservedRef"><dd> <p>This parameter is reserved and must be <c>null</c>.</p> </dd></param>
        /// <remarks>
        /// <p>SetDebugConfiguration sets the debug configuration for the given instance of XAudio2 engine. See <strong><see cref = "SharpDX.XAudio2.DebugConfiguration"/></strong> Structure for supported debug options. By default, XAudio2 does not log debug output or break on errors. </p>
        /// </remarks>
        /// <doc-id>microsoft.directx_sdk.ixaudio2.ixaudio2.setdebugconfiguration</doc-id>
        /// <unmanaged>void IXAudio2::SetDebugConfiguration([In, Value] const XAUDIO2_DEBUG_CONFIGURATION* pDebugConfiguration,[In] void* pReserved)</unmanaged>
        /// <unmanaged-short>IXAudio2::SetDebugConfiguration</unmanaged-short>
        public unsafe void SetDebugConfiguration(SharpDX.XAudio2.DebugConfiguration debugConfigurationRef, System.IntPtr reservedRef)
        {
            SharpDX.XAudio2.LocalInterop.CalliStdCallvoid(this._nativePointer, &debugConfigurationRef, (void *)reservedRef, (*(void ***)this._nativePointer)[this.SetDebugConfiguration__vtbl_index]);
        }
    }
}
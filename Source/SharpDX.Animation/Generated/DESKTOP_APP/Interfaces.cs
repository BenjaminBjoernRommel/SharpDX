// <auto-generated/>

namespace SharpDX.Animation
{
    [System.Runtime.InteropServices.GuidAttribute("7815CBBA-DDF7-478c-A46C-7B6C738B7978")]
    public partial class Interpolator : SharpDX.ComObject
    {
        public Interpolator(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Interpolator(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Interpolator(nativePtr);
        /// <summary>
        /// <p>Gets or sets the duration of a transition.</p>
        /// </summary>
        /// <remarks>
        /// <p>Windows Animation always calls the <strong>SetInitialValueAndVelocity</strong> method to set the initial value and velocity before calling <strong>GetDuration</strong>, so a custom interpolator need not check whether the initial value and velocity have been set.</p><p>Windows Animation can call <strong>SetInitialValueAndVelocity</strong> multiple times with different parameters. Interpolators can cache internal state to improve performance, but they must update this cached state each time <strong>SetInitialValueAndVelocity</strong> is called and ensure that the results of subsequent calls to <strong>GetDuration</strong> reflect the updated state.</p>
        /// </remarks>
        /// <doc-id>dd371674</doc-id>
        /// <unmanaged>GetDuration / SetDuration</unmanaged>
        /// <unmanaged-short>GetDuration</unmanaged-short>
        public System.Double Duration
        {
            get
            {
                GetDuration(out var __output__);
                return __output__;
            }

            set => SetDuration(value);
        }

        /// <summary>
        /// <p>Gets the final value at the end of the transition.</p>
        /// </summary>
        /// <remarks>
        /// <p>Windows Animation always calls the <strong>SetInitialValueAndVelocity</strong> method to set the initial value and velocity before calling <strong>GetFinalValue</strong>, so a custom interpolator need not check whether the initial value and velocity have been set.</p><p>Windows Animation can call <strong>SetInitialValueAndVelocity</strong> multiple times with different parameters. Interpolators can cache internal state to improve performance, but they must update this cached state each time <strong>SetInitialValueAndVelocity</strong> is called and ensure that the results of subsequent calls to <strong>GetFinalValue</strong> reflect the updated state.</p>
        /// </remarks>
        /// <doc-id>dd371676</doc-id>
        /// <unmanaged>GetFinalValue</unmanaged>
        /// <unmanaged-short>GetFinalValue</unmanaged-short>
        public System.Double FinalValue
        {
            get
            {
                GetFinalValue(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Sets the initial value and velocity at the start of the transition.</p>
        /// </summary>
        /// <param name = "initialValue"><dd> <p>The initial value.</p> </dd></param>
        /// <param name = "initialVelocity"><dd> <p>The initial velocity.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.  See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Windows Animation always calls <strong>SetInitialValueAndVelocity</strong> before calling the other methods of  <strong><see cref = "SharpDX.Animation.Interpolator"/></strong> at different offsets. However, it can be called multiple times with different parameters. Interpolators can cache internal state to improve performance, but they must update this cached state each time <strong>SetInitialValueAndVelocity</strong> is called and ensure that the results of subsequent calls to these methods reflect the updated state.</p>
        /// </remarks>
        /// <doc-id>dd371682</doc-id>
        /// <unmanaged>HRESULT IUIAnimationInterpolator::SetInitialValueAndVelocity([In] double initialValue,[In] double initialVelocity)</unmanaged>
        /// <unmanaged-short>IUIAnimationInterpolator::SetInitialValueAndVelocity</unmanaged-short>
        public unsafe void SetInitialValueAndVelocity(System.Double initialValue, System.Double initialVelocity)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, initialValue, initialVelocity, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Sets the duration of the transition.</p>
        /// </summary>
        /// <param name = "duration"><dd> <p>The duration of the transition.</p> </dd></param>
        /// <returns><p> If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Windows Animation calls this method only after calling the <strong>GetDependencies</strong> method, and only if that call returns <strong>UI_ANIMATION_DEPENDENCY_DURATION</strong> as one of its <em>durationDependencies</em> flags.</p><p>Typically, an interpolator with a duration dependency will have a duration parameter in its associated creation method of <strong><see cref = "SharpDX.Animation.TransitionFactory"/></strong>.  The interpolator should store its duration when first initialized and overwrite it when <strong>SetDuration</strong> is called.</p><p>Windows Animation always calls the <strong>SetInitialValueAndVelocity</strong> method to set the initial value and velocity before calling <strong>SetDuration</strong>, so a custom interpolator need not check whether the initial value and velocity have been set.</p><p>Windows Animation can call <strong>SetInitialValueAndVelocity</strong> and <strong>SetDuration</strong> multiple times with different parameters. Interpolators can cache internal state to improve performance, but they must update this cached state each time <strong>SetInitialValueAndVelocity</strong> is called and ensure that the results of subsequent calls to <strong>SetDuration</strong> reflect the updated state.</p>
        /// </remarks>
        /// <doc-id>dd371679</doc-id>
        /// <unmanaged>HRESULT IUIAnimationInterpolator::SetDuration([In] double duration)</unmanaged>
        /// <unmanaged-short>IUIAnimationInterpolator::SetDuration</unmanaged-short>
        internal unsafe void SetDuration(System.Double duration)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, duration, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the duration of a transition.</p>
        /// </summary>
        /// <param name = "duration"><dd> <p>The duration of the transition.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Windows Animation always calls the <strong>SetInitialValueAndVelocity</strong> method to set the initial value and velocity before calling <strong>GetDuration</strong>, so a custom interpolator need not check whether the initial value and velocity have been set.</p><p>Windows Animation can call <strong>SetInitialValueAndVelocity</strong> multiple times with different parameters. Interpolators can cache internal state to improve performance, but they must update this cached state each time <strong>SetInitialValueAndVelocity</strong> is called and ensure that the results of subsequent calls to <strong>GetDuration</strong> reflect the updated state.</p>
        /// </remarks>
        /// <doc-id>dd371674</doc-id>
        /// <unmanaged>HRESULT IUIAnimationInterpolator::GetDuration([Out] double* duration)</unmanaged>
        /// <unmanaged-short>IUIAnimationInterpolator::GetDuration</unmanaged-short>
        internal unsafe void GetDuration(out System.Double duration)
        {
            SharpDX.Result __result__;
            fixed (void *duration_ = &duration)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, duration_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the final value at the end of the transition.</p>
        /// </summary>
        /// <param name = "value"><dd> <p>The final value.</p> </dd></param>
        /// <returns><p> If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.  See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Windows Animation always calls the <strong>SetInitialValueAndVelocity</strong> method to set the initial value and velocity before calling <strong>GetFinalValue</strong>, so a custom interpolator need not check whether the initial value and velocity have been set.</p><p>Windows Animation can call <strong>SetInitialValueAndVelocity</strong> multiple times with different parameters. Interpolators can cache internal state to improve performance, but they must update this cached state each time <strong>SetInitialValueAndVelocity</strong> is called and ensure that the results of subsequent calls to <strong>GetFinalValue</strong> reflect the updated state.</p>
        /// </remarks>
        /// <doc-id>dd371676</doc-id>
        /// <unmanaged>HRESULT IUIAnimationInterpolator::GetFinalValue([Out] double* value)</unmanaged>
        /// <unmanaged-short>IUIAnimationInterpolator::GetFinalValue</unmanaged-short>
        internal unsafe void GetFinalValue(out System.Double value)
        {
            SharpDX.Result __result__;
            fixed (void *value_ = &value)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, value_, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Interpolates the value of an animation variable at the specified offset.</p>
        /// </summary>
        /// <param name = "offset"><dd> <p> The offset from the start of the transition.</p> <p>This parameter is always greater than or equal to zero and less than the duration of the transition. This method is not called if the duration of the transition is zero.</p> </dd></param>
        /// <returns><dd> <p>The interpolated value.</p> </dd></returns>
        /// <remarks>
        /// <p>Windows Animation always calls the <strong>SetInitialValueAndVelocity</strong> method to set the initial value and velocity before calling <strong>InterpolateValue</strong>, so a custom interpolator need not check whether the initial value and velocity have been set.</p><p>Windows Animation can call <strong>SetInitialValueAndVelocity</strong> multiple times with different parameters. Interpolators can cache internal state to improve performance, but they must update this cached state each time <strong>SetInitialValueAndVelocity</strong> is called and ensure that the results of subsequent calls to <strong>InterpolateValue</strong> reflect the updated state.</p>
        /// </remarks>
        /// <doc-id>dd756725</doc-id>
        /// <unmanaged>HRESULT IUIAnimationInterpolator::InterpolateValue([In] double offset,[Out] double* value)</unmanaged>
        /// <unmanaged-short>IUIAnimationInterpolator::InterpolateValue</unmanaged-short>
        public unsafe System.Double InterpolateValue(System.Double offset)
        {
            System.Double value;
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, offset, &value, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
            return value;
        }

        /// <summary>
        /// <p> Interpolates the velocity, or rate of change, at the specified offset.</p>
        /// </summary>
        /// <param name = "offset"><dd> <p>The offset from the start of the transition.</p> <p>The offset is always greater than or equal to zero and less than or equal to the duration of the transition. This method is not called if the duration of the transition is zero.</p> </dd></param>
        /// <returns><dd> <p> The interpolated velocity.</p> </dd></returns>
        /// <remarks>
        /// <p>Windows Animation always calls the <strong>SetInitialValueAndVelocity</strong> method to set the initial value and velocity before calling <strong>InterpolateVelocity</strong>, so a custom interpolator need not check whether the initial value and velocity have been set.</p><p>Windows Animation can call <strong>SetInitialValueAndVelocity</strong> multiple times with different parameters. Interpolators can cache internal state to improve performance, but they must update this cached state each time <strong>SetInitialValueAndVelocity</strong> is called and ensure that the results of subsequent calls to <strong>InterpolateVelocity</strong> reflect the updated state.</p>
        /// </remarks>
        /// <doc-id>dd756726</doc-id>
        /// <unmanaged>HRESULT IUIAnimationInterpolator::InterpolateVelocity([In] double offset,[Out] double* velocity)</unmanaged>
        /// <unmanaged-short>IUIAnimationInterpolator::InterpolateVelocity</unmanaged-short>
        public unsafe System.Double InterpolateVelocity(System.Double offset)
        {
            System.Double velocity;
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, offset, &velocity, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
            return velocity;
        }

        /// <summary>
        /// <p> Gets the aspects of the interpolator that depend on the initial value or velocity passed to <strong>SetInitialValueAndVelocity</strong>, or that depend on the duration passed to <strong>SetDuration</strong>.</p>
        /// </summary>
        /// <param name = "initialValueDependencies">No documentation.</param>
        /// <param name = "initialVelocityDependencies">No documentation.</param>
        /// <param name = "durationDependencies">No documentation.</param>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method is called to identify which aspects of the custom interpolator are affected by certain inputs: value, velocity, and duration. For each of these inputs, the interpolator returns either of the following:</p><ul> <li>The bitwise-OR of any members of <strong><see cref = "SharpDX.Animation.Dependencies"/></strong> that apply.</li> <li><strong>UI_ANIMATION_DEPENDENCY_NONE</strong> if nothing depends on the input.</li> </ul><p>For example, consider an interpolator (1) that accepts a final value as a parameter, (2) that always comes to a gradual stop at that final value, and (3) whose duration is determined by the difference between the final and initial values.  The interpolator should return <strong>UI_ANIMATION_DEPENDENCY_INTERMEDIATE_VALUES</strong>|<strong>UI_ANIMATION_DURATION</strong> for <em>initialValueDependencies</em>.  It should not return <strong>UI_ANIMATION_DEPENDENCY_FINAL_VALUE</strong> because this is set when the interpolator is created and is not affected by the initial value. Likewise it should not return <strong>UI_ANIMATION_DEPENDENCY_FINAL_VELOCITY</strong> because the slope of the curve is defined to always be zero when it reaches the final value.</p><p>It is important that an interpolator return correct set of flags. If a flag is not present for an output, Windows Animation assumes that the corresponding parameter does not affect that aspect of the interpolator's results.  For example, if the custom interpolator does not include <strong>UI_ANIMATION_DEPENDENCY_FINAL_VALUE</strong> for <em>initialVelocityDependencies</em>, Windows Animation may call <strong>SetInitialValueAndVelocity</strong> with an arbitrary velocity parameter, then call <strong>GetFinalValue</strong> to determine the final value.  The interpolator's implementation of <strong>GetFinalValue</strong> must return the same result no matter what velocity parameter has been passed to <strong>SetInitialValueAndVelocity</strong> because the interpolator has claimed that the transition's final value does not depend on the initial velocity.</p><strong>Note</strong>??If the flags returned for <em>durationDependencies</em> do not include <strong>UI_ANIMATION_DEPENDENCY_DURATION</strong>, <strong>SetDuration</strong> will never be called on the interpolator.?
        /// </remarks>
        /// <doc-id>dd371672</doc-id>
        /// <unmanaged>HRESULT IUIAnimationInterpolator::GetDependencies([Out] UI_ANIMATION_DEPENDENCIES* initialValueDependencies,[Out] UI_ANIMATION_DEPENDENCIES* initialVelocityDependencies,[Out] UI_ANIMATION_DEPENDENCIES* durationDependencies)</unmanaged>
        /// <unmanaged-short>IUIAnimationInterpolator::GetDependencies</unmanaged-short>
        public unsafe void GetDependencies(out SharpDX.Animation.Dependencies initialValueDependencies, out SharpDX.Animation.Dependencies initialVelocityDependencies, out SharpDX.Animation.Dependencies durationDependencies)
        {
            SharpDX.Result __result__;
            fixed (void *durationDependencies_ = &durationDependencies)
                fixed (void *initialVelocityDependencies_ = &initialVelocityDependencies)
                    fixed (void *initialValueDependencies_ = &initialValueDependencies)
                        __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, initialValueDependencies_, initialVelocityDependencies_, durationDependencies_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("EA76AFF8-EA22-4a23-A0EF-A6A966703518")]
    public partial class Interpolator2 : SharpDX.ComObject
    {
        public Interpolator2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Interpolator2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Interpolator2(nativePtr);
        /// <summary>
        /// <p>Gets the number of dimensions that require interpolation.</p>
        /// </summary>
        /// <doc-id>hh437125</doc-id>
        /// <unmanaged>GetDimension</unmanaged>
        /// <unmanaged-short>GetDimension</unmanaged-short>
        public System.Int32 Dimension
        {
            get
            {
                GetDimension(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets or sets the duration of a transition for the given dimension.</p>
        /// </summary>
        /// <remarks>
        /// <p>Windows Animation always calls the <strong>IUIAnimationInterpolator2::SetInitialValueAndVelocity</strong> method to set the initial value and velocity before calling <strong>GetDuration</strong>, so a custom interpolator need not check whether the initial value and velocity have been set.</p><p>Windows Animation can call <strong>SetInitialValueAndVelocity</strong> multiple times with different parameters. Interpolators can cache internal state to improve performance, but they must update this cached state each time <strong>SetInitialValueAndVelocity</strong> is called and ensure that the results of subsequent calls to <strong>GetDuration</strong> reflect the updated state.</p>
        /// </remarks>
        /// <doc-id>hh437126</doc-id>
        /// <unmanaged>GetDuration / SetDuration</unmanaged>
        /// <unmanaged-short>GetDuration</unmanaged-short>
        public System.Double Duration
        {
            get
            {
                GetDuration(out var __output__);
                return __output__;
            }

            set => SetDuration(value);
        }

        /// <summary>
        /// <p>Gets the number of dimensions that require interpolation.</p>
        /// </summary>
        /// <param name = "dimension"><dd> <p>The number of dimensions.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <doc-id>hh437125</doc-id>
        /// <unmanaged>HRESULT IUIAnimationInterpolator2::GetDimension([Out] unsigned int* dimension)</unmanaged>
        /// <unmanaged-short>IUIAnimationInterpolator2::GetDimension</unmanaged-short>
        internal unsafe void GetDimension(out System.Int32 dimension)
        {
            SharpDX.Result __result__;
            fixed (void *dimension_ = &dimension)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, dimension_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the initial value and velocity of the transition for the given dimension.</p>
        /// </summary>
        /// <param name = "initialValue"><dd> <p>The initial value.</p> </dd></param>
        /// <param name = "initialVelocity"><dd> <p>The initial velocity.</p> </dd></param>
        /// <param name = "cDimension"><dd> <p>The dimension in which to set the initial value or velocity of the transition.</p> </dd></param>
        /// <returns><p>Returns <strong><see cref = "SharpDX.Result.Ok"/></strong> if successful; otherwise an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Windows Animation always calls <strong>SetInitialValueAndVelocity</strong> before calling the other methods of  <strong><see cref = "SharpDX.Animation.Interpolator2"/></strong> at different offsets. However, <strong>SetInitialValueAndVelocity</strong> can be called multiple times with different parameters. Interpolators can cache internal state to improve performance, but they must update this cached state each time <strong>SetInitialValueAndVelocity</strong> is called and ensure that the results of subsequent calls to these methods reflect the updated state.</p>
        /// </remarks>
        /// <doc-id>hh437132</doc-id>
        /// <unmanaged>HRESULT IUIAnimationInterpolator2::SetInitialValueAndVelocity([In, Buffer] double* initialValue,[In, Buffer] double* initialVelocity,[In] unsigned int cDimension)</unmanaged>
        /// <unmanaged-short>IUIAnimationInterpolator2::SetInitialValueAndVelocity</unmanaged-short>
        public unsafe void SetInitialValueAndVelocity(System.Double[] initialValue, System.Double[] initialVelocity, System.Int32 cDimension)
        {
            SharpDX.Result __result__;
            fixed (void *initialVelocity_ = initialVelocity)
                fixed (void *initialValue_ = initialValue)
                    __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, initialValue_, initialVelocity_, cDimension, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the duration of the transition in the given dimension.</p>
        /// </summary>
        /// <param name = "duration"><dd> <p>The duration of the transition.</p> </dd></param>
        /// <returns><p>Returns <strong><see cref = "SharpDX.Result.Ok"/></strong> if successful; otherwise an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Windows Animation calls this method only after calling the <strong>IUIAnimationInterpolator2::GetDependencies</strong> method, and only if that call returns <strong>UI_ANIMATION_DEPENDENCY_DURATION</strong> as one of its <em>durationDependencies</em> flags.</p><p>Typically, an interpolator with a duration dependency has a duration parameter in the <strong><see cref = "SharpDX.Animation.TransitionFactory"/></strong> or <strong><see cref = "SharpDX.Animation.TransitionFactory2"/></strong> creation method  that is associated with that interpolator.  The interpolator should store its duration when first initialized and overwrite the duration when <strong>SetDuration</strong> is called.</p><p>Windows Animation always calls the <strong>IUIAnimationInterpolator2::SetInitialValueAndVelocity</strong> method to set the initial value and velocity before calling <strong>SetDuration</strong>, so a custom interpolator doesn't need to check whether the initial value and velocity have been set.</p><p>Windows Animation can call <strong>SetInitialValueAndVelocity</strong> and <strong>SetDuration</strong> multiple times with different parameters. Interpolators can cache internal state to improve performance, but they must update this cached state each time <strong>SetInitialValueAndVelocity</strong> is called and ensure that the results of subsequent calls to <strong>SetDuration</strong> reflect the updated state.</p>
        /// </remarks>
        /// <doc-id>hh437131</doc-id>
        /// <unmanaged>HRESULT IUIAnimationInterpolator2::SetDuration([In] double duration)</unmanaged>
        /// <unmanaged-short>IUIAnimationInterpolator2::SetDuration</unmanaged-short>
        internal unsafe void SetDuration(System.Double duration)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, duration, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the duration of a transition for the given dimension.</p>
        /// </summary>
        /// <param name = "duration"><dd> <p>The duration of the transition.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Windows Animation always calls the <strong>IUIAnimationInterpolator2::SetInitialValueAndVelocity</strong> method to set the initial value and velocity before calling <strong>GetDuration</strong>, so a custom interpolator need not check whether the initial value and velocity have been set.</p><p>Windows Animation can call <strong>SetInitialValueAndVelocity</strong> multiple times with different parameters. Interpolators can cache internal state to improve performance, but they must update this cached state each time <strong>SetInitialValueAndVelocity</strong> is called and ensure that the results of subsequent calls to <strong>GetDuration</strong> reflect the updated state.</p>
        /// </remarks>
        /// <doc-id>hh437126</doc-id>
        /// <unmanaged>HRESULT IUIAnimationInterpolator2::GetDuration([Out] double* duration)</unmanaged>
        /// <unmanaged-short>IUIAnimationInterpolator2::GetDuration</unmanaged-short>
        internal unsafe void GetDuration(out System.Double duration)
        {
            SharpDX.Result __result__;
            fixed (void *duration_ = &duration)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, duration_, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the final value at the end of the transition for the given dimension.</p>
        /// </summary>
        /// <param name = "value"><dd> <p>The final value.</p> </dd></param>
        /// <param name = "cDimension"><dd> <p>The dimension from which to retrieve the final value.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Windows Animation always calls the <strong>IUIAnimationInterpolator2::SetInitialValueAndVelocity</strong> method to set the initial value and velocity before calling <strong>GetFinalValue</strong>, so a custom interpolator need not check whether the initial value and velocity have been set.</p><p>Windows Animation can call <strong>SetInitialValueAndVelocity</strong> multiple times with different parameters. Interpolators can cache internal state to improve performance, but they must update this cached state each time <strong>SetInitialValueAndVelocity</strong> is called and ensure that the results of subsequent calls to <strong>GetFinalValue</strong> reflect the updated state.</p>
        /// </remarks>
        /// <doc-id>hh437127</doc-id>
        /// <unmanaged>HRESULT IUIAnimationInterpolator2::GetFinalValue([Out, Buffer] double* value,[In] unsigned int cDimension)</unmanaged>
        /// <unmanaged-short>IUIAnimationInterpolator2::GetFinalValue</unmanaged-short>
        public unsafe void GetFinalValue(System.Double[] value, System.Int32 cDimension)
        {
            SharpDX.Result __result__;
            fixed (void *value_ = value)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, value_, cDimension, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Interpolates the value of an animation variable at the specified offset and for the given dimension.</p>
        /// </summary>
        /// <param name = "offset"><dd> <p>The offset from the start of the transition.</p> <p>This parameter is always greater than or equal to zero and less than the duration of the transition. This method is not called if the duration of the transition is zero.</p> </dd></param>
        /// <param name = "value"><dd> <p>The interpolated value.</p> </dd></param>
        /// <param name = "cDimension"><dd> <p>The dimension in which to interpolate the value.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Windows Animation always calls the <strong>IUIAnimationInterpolator2::SetInitialValueAndVelocity</strong> method to set the initial value and velocity before calling <strong>InterpolateValue</strong>, so a custom interpolator need not check whether the initial value and velocity have been set.</p><p>Windows Animation can call <strong>SetInitialValueAndVelocity</strong> multiple times with different parameters. Interpolators can cache internal state to improve performance, but they must update this cached state each time <strong>SetInitialValueAndVelocity</strong> is called and ensure that the results of subsequent calls to <strong>InterpolateValue</strong> reflect the updated state.</p>
        /// </remarks>
        /// <doc-id>hh437129</doc-id>
        /// <unmanaged>HRESULT IUIAnimationInterpolator2::InterpolateValue([In] double offset,[Out, Buffer] double* value,[In] unsigned int cDimension)</unmanaged>
        /// <unmanaged-short>IUIAnimationInterpolator2::InterpolateValue</unmanaged-short>
        public unsafe void InterpolateValue(System.Double offset, System.Double[] value, System.Int32 cDimension)
        {
            SharpDX.Result __result__;
            fixed (void *value_ = value)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, offset, value_, cDimension, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Interpolates the velocity, or rate of change, at the specified offset for the given dimension.</p>
        /// </summary>
        /// <param name = "offset"><dd> <p>The offset from the start of the transition. </p> <p>The offset is always greater than or equal to zero and less than or equal to the duration of the transition. This method is not called if the duration of the transition is zero.</p> </dd></param>
        /// <param name = "velocity"><dd> <p>The interpolated velocity.</p> </dd></param>
        /// <param name = "cDimension"><dd> <p>The dimension in which to interpolate the velocity.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Windows Animation always calls the <strong>IUIAnimationInterpolator2::SetInitialValueAndVelocity</strong> method to set the initial value and velocity before calling <strong>InterpolateVelocity</strong>, so a custom interpolator need not check whether the initial value and velocity have been set.</p><p>Windows Animation can call <strong>SetInitialValueAndVelocity</strong> multiple times with different parameters. Interpolators can cache internal state to improve performance, but they must update this cached state each time <strong>SetInitialValueAndVelocity</strong> is called and ensure that the results of subsequent calls to <strong>InterpolateVelocity</strong> reflect the updated state.</p>
        /// </remarks>
        /// <doc-id>hh437130</doc-id>
        /// <unmanaged>HRESULT IUIAnimationInterpolator2::InterpolateVelocity([In] double offset,[Out, Buffer] double* velocity,[In] unsigned int cDimension)</unmanaged>
        /// <unmanaged-short>IUIAnimationInterpolator2::InterpolateVelocity</unmanaged-short>
        public unsafe void InterpolateVelocity(System.Double offset, System.Double[] velocity, System.Int32 cDimension)
        {
            SharpDX.Result __result__;
            fixed (void *velocity_ = velocity)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, offset, velocity_, cDimension, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Generates a primitive interpolation of the specified animation curve.</p>
        /// </summary>
        /// <param name = "interpolation"><dd> <p>The object that defines the custom animation curve information.</p> </dd></param>
        /// <param name = "cDimension"><dd> <p>The dimension in which to apply the new segment.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <doc-id>hh437128</doc-id>
        /// <unmanaged>HRESULT IUIAnimationInterpolator2::GetPrimitiveInterpolation([In] IUIAnimationPrimitiveInterpolation* interpolation,[In] unsigned int cDimension)</unmanaged>
        /// <unmanaged-short>IUIAnimationInterpolator2::GetPrimitiveInterpolation</unmanaged-short>
        public unsafe void GetPrimitiveInterpolation(SharpDX.Animation.PrimitiveInterpolation interpolation, System.Int32 cDimension)
        {
            System.IntPtr interpolation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            interpolation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.PrimitiveInterpolation>(interpolation);
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)interpolation_, cDimension, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>For the given dimension, <strong>GetDependencies</strong> retrieves the aspects of the interpolator that depend on the initial value or velocity that is passed to the <strong>IUIAnimationInterpolator2::SetInitialValueAndVelocity</strong> method or the duration that is passed to the <strong>IUIAnimationInterpolator2::SetDuration</strong> method.</p>
        /// </summary>
        /// <param name = "initialValueDependencies">No documentation.</param>
        /// <param name = "initialVelocityDependencies">No documentation.</param>
        /// <param name = "durationDependencies">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method is called to identify which aspects of the custom interpolator are affected by certain inputs: value, velocity, and duration. For each of these inputs, the interpolator returns either of the following:</p><ul> <li>The bitwise-OR of any members of <strong><see cref = "SharpDX.Animation.Dependencies"/></strong> that apply.</li> <li><strong>UI_ANIMATION_DEPENDENCY_NONE</strong> if nothing depends on the input.</li> </ul><p>For example, consider an interpolator that:</p><ul> <li>Accepts a final value as a parameter.</li> <li>Always comes to a gradual stop at that final value.</li> <li>Has a duration determined by the difference between the final value and the initial value.</li> </ul><p>In this case the interpolator should return <strong>UI_ANIMATION_DEPENDENCY_INTERMEDIATE_VALUES</strong>|<strong>UI_ANIMATION_DURATION</strong> for the <em>initialValueDependencies</em> parameter.  It should not return <strong>UI_ANIMATION_DEPENDENCY_FINAL_VALUE</strong>, because this value is set when the interpolator is created and is not affected by the initial value. Likewise, the interpolator should not return <strong>UI_ANIMATION_DEPENDENCY_FINAL_VELOCITY</strong>, because the slope of the curve is defined to always be zero when it reaches the final value.</p><p>It is important that an interpolator return a correct set of flags. If a flag is not present for an output, Windows Animation assumes that the corresponding parameter does not affect that aspect of the interpolator's results.  For example, if the custom interpolator does not include <strong>UI_ANIMATION_DEPENDENCY_FINAL_VALUE</strong> for <em>initialVelocityDependencies</em>, Windows Animation may call <strong>SetInitialValueAndVelocity</strong> with an arbitrary velocity parameter, and then call <strong>GetFinalValue</strong> to determine the final value.  The interpolator's implementation of <strong>GetFinalValue</strong> must return the same result no matter which velocity parameter has been passed to <strong>SetInitialValueAndVelocity</strong>, because the interpolator has claimed that the transition's final value does not depend on the initial velocity.</p><strong>Note</strong>??If the flags returned for <em>durationDependencies</em> do not include <strong>UI_ANIMATION_DEPENDENCY_DURATION</strong>, <strong>SetDuration</strong> will never be called on the interpolator.?
        /// </remarks>
        /// <doc-id>hh437123</doc-id>
        /// <unmanaged>HRESULT IUIAnimationInterpolator2::GetDependencies([Out] UI_ANIMATION_DEPENDENCIES* initialValueDependencies,[Out] UI_ANIMATION_DEPENDENCIES* initialVelocityDependencies,[Out] UI_ANIMATION_DEPENDENCIES* durationDependencies)</unmanaged>
        /// <unmanaged-short>IUIAnimationInterpolator2::GetDependencies</unmanaged-short>
        public unsafe void GetDependencies(out SharpDX.Animation.Dependencies initialValueDependencies, out SharpDX.Animation.Dependencies initialVelocityDependencies, out SharpDX.Animation.Dependencies durationDependencies)
        {
            SharpDX.Result __result__;
            fixed (void *durationDependencies_ = &durationDependencies)
                fixed (void *initialVelocityDependencies_ = &initialVelocityDependencies)
                    fixed (void *initialValueDependencies_ = &initialValueDependencies)
                        __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, initialValueDependencies_, initialVelocityDependencies_, durationDependencies_, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("2D3B15A4-4762-47AB-A030-B23221DF3AE0")]
    internal partial interface LoopIterationChangeHandler2 : SharpDX.IUnknown
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("9169896C-AC8D-4e7d-94E5-67FA4DC2F2E8")]
    public partial class Manager : SharpDX.ComObject
    {
        public Manager(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Manager(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Manager(nativePtr);
        /// <summary>
        /// <p> Gets the status of the animation manager.</p>
        /// </summary>
        /// <doc-id>dd371712</doc-id>
        /// <unmanaged>GetStatus</unmanaged>
        /// <unmanaged-short>GetStatus</unmanaged-short>
        public SharpDX.Animation.ManagerStatus Status
        {
            get
            {
                GetStatus(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p> Sets the animation mode.</p>
        /// </summary>
        /// <remarks>
        /// <p>This method is used to enable or disable animation globally. While animation is disabled, all storyboards finish immediately when they are scheduled. The default mode is <strong>UI_ANIMATION_MODE_SYSTEM_DEFAULT</strong>, which lets Windows decide when to enable or disable animation in the application.</p>
        /// </remarks>
        /// <doc-id>dd371732</doc-id>
        /// <unmanaged>SetAnimationMode</unmanaged>
        /// <unmanaged-short>SetAnimationMode</unmanaged-short>
        public SharpDX.Animation.Mode AnimationMode
        {
            set => SetAnimationMode(value);
        }

        /// <summary>
        /// <p> Sets the default acceptable animation delay. This is the length of time that may pass before storyboards begin.</p>
        /// </summary>
        /// <remarks>
        /// <p>For a storyboard to be successfully scheduled, it must begin before the longest acceptable delay has elapsed. This delay is determined in the following order: the delay value set by calling <strong>IUIAnimationStoryboard::SetLongestAcceptableDelay</strong> for this specific storyboard, the delay value set by calling this method, or 0.0 if neither method has been called.</p>
        /// </remarks>
        /// <doc-id>dd371746</doc-id>
        /// <unmanaged>SetDefaultLongestAcceptableDelay</unmanaged>
        /// <unmanaged-short>SetDefaultLongestAcceptableDelay</unmanaged-short>
        public System.Double DefaultLongestAcceptableDelay
        {
            set => SetDefaultLongestAcceptableDelay(value);
        }

        /// <summary>
        /// <p> Creates a new animation variable.</p>
        /// </summary>
        /// <param name = "initialValue"><dd> <p> The initial value for the new animation variable.</p> </dd></param>
        /// <param name = "variable"><dd> <p> The new animation variable.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>The initial value of an animation variable is specified when the variable is created. After an animation variable is created, its value cannot be changed directly; it must be updated through the animation manager.</p><p>An animation variable is typically created to represent each visual characteristic that is to be animated. For example, an application might create two animation variables for the X and Y coordinates of an object that can move freely within a window.</p>
        /// </remarks>
        /// <doc-id>dd371699</doc-id>
        /// <unmanaged>HRESULT IUIAnimationManager::CreateAnimationVariable([In] double initialValue,[Out, Fast] IUIAnimationVariable** variable)</unmanaged>
        /// <unmanaged-short>IUIAnimationManager::CreateAnimationVariable</unmanaged-short>
        internal unsafe void CreateAnimationVariable(System.Double initialValue, SharpDX.Animation.Variable variable)
        {
            System.IntPtr variable_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, initialValue, &variable_, (*(void ***)this._nativePointer)[3]);
            (variable).NativePointer = variable_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates and schedules a single-transition storyboard.</p>
        /// </summary>
        /// <param name = "variable"><dd> <p> The animation variable.</p> </dd></param>
        /// <param name = "transition"><dd> <p> A transition to be applied to the animation variable.</p> </dd></param>
        /// <param name = "timeNow"><dd> <p> The current system time.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method schedules a new storyboard by creating the storyboard, applying the specified transition to the specified variable, and then scheduling the storyboard.</p>
        /// </remarks>
        /// <doc-id>dd371728</doc-id>
        /// <unmanaged>HRESULT IUIAnimationManager::ScheduleTransition([In] IUIAnimationVariable* variable,[In] IUIAnimationTransition* transition,[In] double timeNow)</unmanaged>
        /// <unmanaged-short>IUIAnimationManager::ScheduleTransition</unmanaged-short>
        public unsafe void ScheduleTransition(SharpDX.Animation.Variable variable, SharpDX.Animation.Transition transition, System.Double timeNow)
        {
            System.IntPtr variable_ = System.IntPtr.Zero;
            System.IntPtr transition_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            variable_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.Variable>(variable);
            transition_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.Transition>(transition);
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)variable_, (void *)transition_, timeNow, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates a new storyboard.</p>
        /// </summary>
        /// <param name = "storyboard"><dd> <p> The new storyboard.</p> </dd></param>
        /// <returns><p> If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Storyboards can specify complex coordinated updates to many animation variables. These updates happen in sequence or in parallel, and they are guaranteed to remain synchronized within the storyboard. A storyboard is created, populated with transitions on animation variables, and then scheduled. </p>
        /// </remarks>
        /// <doc-id>dd371703</doc-id>
        /// <unmanaged>HRESULT IUIAnimationManager::CreateStoryboard([Out, Fast] IUIAnimationStoryboard** storyboard)</unmanaged>
        /// <unmanaged-short>IUIAnimationManager::CreateStoryboard</unmanaged-short>
        internal unsafe void CreateStoryboard(SharpDX.Animation.Storyboard storyboard)
        {
            System.IntPtr storyboard_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, &storyboard_, (*(void ***)this._nativePointer)[5]);
            (storyboard).NativePointer = storyboard_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Finishes all active storyboards within the specified time interval.</p>
        /// </summary>
        /// <param name = "completionDeadline"><dd> <p> The maximum time interval during which all storyboards must be finished.</p> </dd></param>
        /// <returns><p> If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p> Calling <strong>FinishAllStoryboards</strong> ensures that all active storyboards finish within the specified completion deadline. If a storyboard is scheduled to play past the deadline, it is compressed. A storyboard is considered active if its status is <strong>UI_ANIMATION_STORYBOARD_PLAYING</strong> or <strong>UI_ANIMATION_STORYBOARD_SCHEDULED</strong>.</p>
        /// </remarks>
        /// <doc-id>dd371707</doc-id>
        /// <unmanaged>HRESULT IUIAnimationManager::FinishAllStoryboards([In] double completionDeadline)</unmanaged>
        /// <unmanaged-short>IUIAnimationManager::FinishAllStoryboards</unmanaged-short>
        public unsafe void FinishAllStoryboards(System.Double completionDeadline)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, completionDeadline, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Abandons all active storyboards.</p>
        /// </summary>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Calling this method is equivalent to calling the <strong>IUIAnimationStoryboard::Abandon</strong> method for each active storyboard. A storyboard is considered active if its status is <strong>UI_ANIMATION_STORYBOARD_PLAYING</strong> or <strong>UI_ANIMATION_STORYBOARD_SCHEDULED</strong>.</p>
        /// </remarks>
        /// <doc-id>dd371697</doc-id>
        /// <unmanaged>HRESULT IUIAnimationManager::AbandonAllStoryboards()</unmanaged>
        /// <unmanaged-short>IUIAnimationManager::AbandonAllStoryboards</unmanaged-short>
        public unsafe void AbandonAllStoryboards()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Updates the values of all animation variables.</p>
        /// </summary>
        /// <param name = "timeNow"><dd> <p> The current system time. This parameter must be greater than or equal to 0.0.</p> </dd></param>
        /// <returns><dd> <p>The result of the update. This parameter can be omitted from calls to this method.</p> </dd></returns>
        /// <remarks>
        /// <p>Calling this method advances the animation manager to <em>timeNow</em>, changing statuses of storyboards as necessary and updating any animation variables to appropriate interpolated values. If the animation manager is paused, no storyboards or variables are updated. If the animation  mode is <strong>UI_ANIMATION_MODE_DISABLED</strong>, all scheduled storyboards finish playing immediately. If the values of any variables change during this call, the value of <em>updateResult</em> is <strong>UI_ANIMATION_UPDATE_VARIABLES_CHANGED</strong>; otherwise, it is <strong>UI_ANIMATION_UPDATE_NO_CHANGE</strong>. </p>
        /// </remarks>
        /// <doc-id>dd371755</doc-id>
        /// <unmanaged>HRESULT IUIAnimationManager::Update([In] double timeNow,[Out, Optional] UI_ANIMATION_UPDATE_RESULT* updateResult)</unmanaged>
        /// <unmanaged-short>IUIAnimationManager::Update</unmanaged-short>
        public unsafe SharpDX.Animation.UpdateResult Update(System.Double timeNow)
        {
            SharpDX.Animation.UpdateResult updateResult;
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, timeNow, &updateResult, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
            return updateResult;
        }

        /// <summary>
        /// <p> Gets the animation variable with the specified tag.</p>
        /// </summary>
        /// <param name = "@object"><dd> <p> The object portion of the tag. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>
        /// <param name = "id"><dd> <p> The identifier portion of the tag.</p> </dd></param>
        /// <returns><dd> <p> The animation variable that matches the specified tag, or <strong><c>null</c></strong> if no match is found.</p> </dd></returns>
        /// <remarks>
        /// <p> A tag is a pairing of an integer identifier (<em>id</em>) with a COM object (<em>object</em>). An application can use tags to identify animation variables and storyboards. <strong><c>null</c></strong> is a valid object component of a tag; therefore, the <em>object</em> parameter can be <strong><c>null</c></strong>.</p><p>Tags are not necessarily unique; this method returns <strong>UI_E_AMBIGUOUS_MATCH</strong> if more than one animation variable exists with the specified tag.</p>
        /// </remarks>
        /// <doc-id>dd371717</doc-id>
        /// <unmanaged>HRESULT IUIAnimationManager::GetVariableFromTag([In, Optional] IUnknown* object,[In] unsigned int id,[Out] IUIAnimationVariable** variable)</unmanaged>
        /// <unmanaged-short>IUIAnimationManager::GetVariableFromTag</unmanaged-short>
        internal unsafe SharpDX.Animation.Variable GetVariableFromTag(System.IntPtr @object, System.Int32 id)
        {
            SharpDX.Animation.Variable variable;
            System.IntPtr variable_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)@object, id, &variable_, (*(void ***)this._nativePointer)[9]);
            if (variable_ != System.IntPtr.Zero)
                variable = new SharpDX.Animation.Variable(variable_);
            else
                variable = null;
            __result__.CheckError();
            return variable;
        }

        /// <summary>
        /// <p> Gets the storyboard with the specified tag.</p>
        /// </summary>
        /// <param name = "@object"><dd> <p> The object portion of the tag. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>
        /// <param name = "id"><dd> <p> The identifier portion of the tag.</p> </dd></param>
        /// <returns><dd> <p> The storyboard that matches the specified tag, or <strong><c>null</c></strong> if no match is found.</p> </dd></returns>
        /// <remarks>
        /// <p>A tag is a pairing of an integer identifier (<em>id</em>) with a COM object (<em>object</em>). An application can use tags to identify animation variables and storyboards. <strong><c>null</c></strong> is a valid object component of a tag; therefore, the <em>object</em> parameter can be <strong><c>null</c></strong>.</p><p>Tags are not necessarily unique; this method returns UI_E_AMBIGUOUS_MATCH if more than one storyboard exists with the specified tag.</p>
        /// </remarks>
        /// <doc-id>dd371714</doc-id>
        /// <unmanaged>HRESULT IUIAnimationManager::GetStoryboardFromTag([In, Optional] IUnknown* object,[In] unsigned int id,[Out] IUIAnimationStoryboard** storyboard)</unmanaged>
        /// <unmanaged-short>IUIAnimationManager::GetStoryboardFromTag</unmanaged-short>
        internal unsafe SharpDX.Animation.Storyboard GetStoryboardFromTag(System.IntPtr @object, System.Int32 id)
        {
            SharpDX.Animation.Storyboard storyboard;
            System.IntPtr storyboard_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)@object, id, &storyboard_, (*(void ***)this._nativePointer)[10]);
            if (storyboard_ != System.IntPtr.Zero)
                storyboard = new SharpDX.Animation.Storyboard(storyboard_);
            else
                storyboard = null;
            __result__.CheckError();
            return storyboard;
        }

        /// <summary>
        /// <p> Gets the status of the animation manager.</p>
        /// </summary>
        /// <param name = "status"><dd> <p> The status.</p> </dd></param>
        /// <returns><p> If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <doc-id>dd371712</doc-id>
        /// <unmanaged>HRESULT IUIAnimationManager::GetStatus([Out] UI_ANIMATION_MANAGER_STATUS* status)</unmanaged>
        /// <unmanaged-short>IUIAnimationManager::GetStatus</unmanaged-short>
        internal unsafe void GetStatus(out SharpDX.Animation.ManagerStatus status)
        {
            SharpDX.Result __result__;
            fixed (void *status_ = &status)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, status_, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Sets the animation mode.</p>
        /// </summary>
        /// <param name = "mode"><dd> <p> The animation mode.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method is used to enable or disable animation globally. While animation is disabled, all storyboards finish immediately when they are scheduled. The default mode is <strong>UI_ANIMATION_MODE_SYSTEM_DEFAULT</strong>, which lets Windows decide when to enable or disable animation in the application.</p>
        /// </remarks>
        /// <doc-id>dd371732</doc-id>
        /// <unmanaged>HRESULT IUIAnimationManager::SetAnimationMode([In] UI_ANIMATION_MODE mode)</unmanaged>
        /// <unmanaged-short>IUIAnimationManager::SetAnimationMode</unmanaged-short>
        internal unsafe void SetAnimationMode(SharpDX.Animation.Mode mode)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)mode), (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Pauses all animations.</p>
        /// </summary>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p> When an animation manager is paused, its status is set to <strong>UI_ANIMATION_MANAGER_IDLE</strong>.</p>
        /// </remarks>
        /// <doc-id>dd371722</doc-id>
        /// <unmanaged>HRESULT IUIAnimationManager::Pause()</unmanaged>
        /// <unmanaged-short>IUIAnimationManager::Pause</unmanaged-short>
        public unsafe void Pause()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[13]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Resumes all animations.</p>
        /// </summary>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p> When an animation manager is resumed, and at least one animation is currently scheduled or playing, its status is set to <strong>UI_ANIMATION_MANAGER_BUSY</strong>.</p>
        /// </remarks>
        /// <doc-id>dd371726</doc-id>
        /// <unmanaged>HRESULT IUIAnimationManager::Resume()</unmanaged>
        /// <unmanaged-short>IUIAnimationManager::Resume</unmanaged-short>
        public unsafe void Resume()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[14]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Specifies a handler for animation manager status updates.</p>
        /// </summary>
        /// <param name = "handler"><dd> <p>The event handler to be called when the status of the animation manager changes.   The specified object must implement the <strong><see cref = "SharpDX.Animation.ManagerEventHandler"/></strong> interface or be <strong><c>null</c></strong>. See Remarks section for more information.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Passing <strong><c>null</c></strong> for the <em>handler</em> parameter causes Windows Animation to release its reference to any handler object that you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong>IUIAnimationManager::Shutdown</strong> method.</p>
        /// </remarks>
        /// <doc-id>dd371749</doc-id>
        /// <unmanaged>HRESULT IUIAnimationManager::SetManagerEventHandler([In, Optional] IUIAnimationManagerEventHandler* handler)</unmanaged>
        /// <unmanaged-short>IUIAnimationManager::SetManagerEventHandler</unmanaged-short>
        internal unsafe void SetManagerEventHandler(SharpDX.Animation.ManagerEventHandler handler)
        {
            System.IntPtr handler_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            handler_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.ManagerEventHandler>(handler);
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)handler_, (*(void ***)this._nativePointer)[15]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Sets the priority comparison handler to be called to determine whether a scheduled storyboard can be canceled.</p>
        /// </summary>
        /// <param name = "comparison"><dd> <p> The priority comparison handler for cancelation.   The specified object must implement the <strong><see cref = "SharpDX.Animation.PriorityComparison"/></strong> interface or be <strong><c>null</c></strong>. See Remarks.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Setting a priority comparison handler with this method enables the application to indicate when scheduling conflicts can be resolved by canceling storyboards.</p><p>A scheduled storyboard can be canceled only if it has not started playing and the priority comparison object registered with this method returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Canceled storyboards are completely removed from the schedule.</p><p>Passing <strong><c>null</c></strong> for the <em>comparison</em> parameter causes Windows Animation to release its reference to any priority comparison handler object you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong>IUIAnimationManager::Shutdown</strong> method.</p>
        /// </remarks>
        /// <doc-id>dd371734</doc-id>
        /// <unmanaged>HRESULT IUIAnimationManager::SetCancelPriorityComparison([In, Optional] IUIAnimationPriorityComparison* comparison)</unmanaged>
        /// <unmanaged-short>IUIAnimationManager::SetCancelPriorityComparison</unmanaged-short>
        internal unsafe void SetCancelPriorityComparison(SharpDX.Animation.PriorityComparison comparison)
        {
            System.IntPtr comparison_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            comparison_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.PriorityComparison>(comparison);
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)comparison_, (*(void ***)this._nativePointer)[16]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the priority comparison handler to be called to determine whether a scheduled storyboard can be trimmed.</p>
        /// </summary>
        /// <param name = "comparison"><dd> <p>The priority comparison handler for trimming.   The specified object must implement the <strong><see cref = "SharpDX.Animation.PriorityComparison"/></strong> interface or be <strong><c>null</c></strong>. See Remarks.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes. </p></returns>
        /// <remarks>
        /// <p> Setting a priority comparison handler with this method enables the application to indicate when  scheduling conflicts can be resolved by trimming the scheduled storyboard.</p><p>A scheduled storyboard can be trimmed only if the priority comparison object registered with this method returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If the new storyboard trims the scheduled storyboard,  the scheduled storyboard can no longer affect a variable once the new storyboard begins to animate that variable.</p><p>Passing <strong><c>null</c></strong> for the <em>comparison</em> parameter causes Windows Animation to release its reference to any handler object you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong>IUIAnimationManager::Shutdown</strong> method.</p>
        /// </remarks>
        /// <doc-id>dd371750</doc-id>
        /// <unmanaged>HRESULT IUIAnimationManager::SetTrimPriorityComparison([In, Optional] IUIAnimationPriorityComparison* comparison)</unmanaged>
        /// <unmanaged-short>IUIAnimationManager::SetTrimPriorityComparison</unmanaged-short>
        internal unsafe void SetTrimPriorityComparison(SharpDX.Animation.PriorityComparison comparison)
        {
            System.IntPtr comparison_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            comparison_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.PriorityComparison>(comparison);
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)comparison_, (*(void ***)this._nativePointer)[17]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Sets the priority comparison handler to be called to determine whether a scheduled storyboard can be compressed.</p>
        /// </summary>
        /// <param name = "comparison"><dd> <p> The priority comparison handler for compression.   The specified object must implement the <strong><see cref = "SharpDX.Animation.PriorityComparison"/></strong> interface or be <strong><c>null</c></strong>. See Remarks. </p> </dd></param>
        /// <returns><p> If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Setting a priority comparison handler with this method enables the application to indicate when the scheduling conflicts can be resolved by compressing  the scheduled storyboard and any other storyboards animating the same variables.</p><p>A storyboard can be compressed only if the priority comparison object registered with this method returns <strong><see cref = "SharpDX.Result.Ok"/></strong> for all the other scheduled storyboards that will be affected by compression. When the storyboards are compressed, time is temporarily accelerated for affected storyboards, so they play faster.</p><p>Passing <strong><c>null</c></strong> for the <em>comparison</em> parameter causes Windows Animation to release its reference to any handler object you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong>IUIAnimationManager::Shutdown</strong> method.</p>
        /// </remarks>
        /// <doc-id>dd371737</doc-id>
        /// <unmanaged>HRESULT IUIAnimationManager::SetCompressPriorityComparison([In, Optional] IUIAnimationPriorityComparison* comparison)</unmanaged>
        /// <unmanaged-short>IUIAnimationManager::SetCompressPriorityComparison</unmanaged-short>
        internal unsafe void SetCompressPriorityComparison(SharpDX.Animation.PriorityComparison comparison)
        {
            System.IntPtr comparison_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            comparison_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.PriorityComparison>(comparison);
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)comparison_, (*(void ***)this._nativePointer)[18]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Sets the priority comparison handler to be called to determine whether a scheduled storyboard can be concluded.</p>
        /// </summary>
        /// <param name = "comparison"><dd> <p> The priority comparison handler for conclusion. The specified object must implement the <strong><see cref = "SharpDX.Animation.PriorityComparison"/></strong> interface or be <strong><c>null</c></strong>. See Remarks.</p> </dd></param>
        /// <returns><p> If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Setting a priority comparison handler with this method enables the application to indicate when scheduling conflicts can be resolved by concluding the scheduled storyboard.</p><p>A scheduled storyboard can be concluded only if it contains a loop with a repetition count of <strong><strong>UI_ANIMATION_REPEAT_INDEFINITELY</strong></strong> and the priority comparison object registered with this method returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If the storyboard is concluded, the current repetition of the loop completes, and the reminder of the storyboard then plays. </p><p>Passing <strong><c>null</c></strong> for the <em>comparison</em> parameter causes Windows Animation to release its reference to any handler object you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong>IUIAnimationManager::Shutdown</strong> method.</p>
        /// </remarks>
        /// <doc-id>dd371742</doc-id>
        /// <unmanaged>HRESULT IUIAnimationManager::SetConcludePriorityComparison([In, Optional] IUIAnimationPriorityComparison* comparison)</unmanaged>
        /// <unmanaged-short>IUIAnimationManager::SetConcludePriorityComparison</unmanaged-short>
        internal unsafe void SetConcludePriorityComparison(SharpDX.Animation.PriorityComparison comparison)
        {
            System.IntPtr comparison_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            comparison_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.PriorityComparison>(comparison);
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)comparison_, (*(void ***)this._nativePointer)[19]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Sets the default acceptable animation delay. This is the length of time that may pass before storyboards begin.</p>
        /// </summary>
        /// <param name = "delay"><dd> <p> The default delay. This parameter can be a positive value, or <strong>UI_ANIMATION_SECONDS_EVENTUALLY</strong> (-1) to indicate that any finite delay is acceptable.</p> </dd></param>
        /// <returns><p> If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.             See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>For a storyboard to be successfully scheduled, it must begin before the longest acceptable delay has elapsed. This delay is determined in the following order: the delay value set by calling <strong>IUIAnimationStoryboard::SetLongestAcceptableDelay</strong> for this specific storyboard, the delay value set by calling this method, or 0.0 if neither method has been called.</p>
        /// </remarks>
        /// <doc-id>dd371746</doc-id>
        /// <unmanaged>HRESULT IUIAnimationManager::SetDefaultLongestAcceptableDelay([In] double delay)</unmanaged>
        /// <unmanaged-short>IUIAnimationManager::SetDefaultLongestAcceptableDelay</unmanaged-short>
        internal unsafe void SetDefaultLongestAcceptableDelay(System.Double delay)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, delay, (*(void ***)this._nativePointer)[20]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Shuts down the animation manager and all its associated objects.</p>
        /// </summary>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Calling this method directs the animation manager, and all the objects it created, to  release all their references to other objects. After <strong>IUIAnimationManager::Shutdown</strong> has been called, no other methods may be called on the animation manager or any objects that it created. An application can call this method to clean up if there is any possibility that the application has introduced a reference cycle that includes some animation objects.</p>
        /// </remarks>
        /// <doc-id>dd371753</doc-id>
        /// <unmanaged>HRESULT IUIAnimationManager::Shutdown()</unmanaged>
        /// <unmanaged-short>IUIAnimationManager::Shutdown</unmanaged-short>
        public unsafe void Shutdown()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[21]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("D8B6F7D4-4109-4d3f-ACEE-879926968CB1")]
    public partial class Manager2 : SharpDX.ComObject
    {
        public Manager2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Manager2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Manager2(nativePtr);
        /// <summary>
        /// <p> Gets the status of the animation manager.</p>
        /// </summary>
        /// <doc-id>hh437147</doc-id>
        /// <unmanaged>GetStatus</unmanaged>
        /// <unmanaged-short>GetStatus</unmanaged-short>
        public SharpDX.Animation.ManagerStatus Status
        {
            get
            {
                GetStatus(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p> Sets the animation mode.</p>
        /// </summary>
        /// <remarks>
        /// <p>Use this method to enable or disable animation globally. While animation is disabled, all storyboards finish immediately when they are scheduled. The default mode is <strong>UI_ANIMATION_MODE_SYSTEM_DEFAULT</strong>, which lets Windows decide when to enable or disable animation in the application.</p>
        /// </remarks>
        /// <doc-id>hh437159</doc-id>
        /// <unmanaged>SetAnimationMode</unmanaged>
        /// <unmanaged-short>SetAnimationMode</unmanaged-short>
        public SharpDX.Animation.Mode AnimationMode
        {
            set => SetAnimationMode(value);
        }

        /// <summary>
        /// <p> Sets the priority comparison handler that determines whether  a scheduled storyboard can be canceled.</p>
        /// </summary>
        /// <remarks>
        /// <p>Setting a priority comparison handler with this method enables the application to indicate when scheduling conflicts can be resolved by canceling storyboards.</p><p>A scheduled storyboard can be canceled only if it hasn't started playing and the priority comparison object registered with this method returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Canceled storyboards are completely removed from the schedule.</p><p>Passing <strong><c>null</c></strong> for the <em>comparison</em> parameter causes Windows Animation to release its reference to any priority comparison handler object that you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong>IUIAnimationManager2::Shutdown</strong> method.</p>
        /// </remarks>
        /// <doc-id>hh437161</doc-id>
        /// <unmanaged>SetCancelPriorityComparison</unmanaged>
        /// <unmanaged-short>SetCancelPriorityComparison</unmanaged-short>
        public SharpDX.Animation.PriorityComparison2 CancelPriorityComparison
        {
            set => SetCancelPriorityComparison(value);
        }

        /// <summary>
        /// <p> Sets the priority comparison handler that determines whether  a scheduled storyboard can be trimmed.</p>
        /// </summary>
        /// <remarks>
        /// <p> Setting a priority comparison handler with this method enables the application to indicate when  scheduling conflicts can be resolved by trimming the scheduled storyboard.</p><p>A scheduled storyboard can be trimmed only if the priority comparison object registered with this method returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If the new storyboard trims the scheduled storyboard,  the scheduled storyboard can no longer affect a variable after the new storyboard begins to animate that variable.</p><p>Passing <strong><c>null</c></strong> for the <em>comparison</em> parameter causes Windows Animation to release its reference to any handler object that you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong>IUIAnimationManager2::Shutdown</strong> method.</p>
        /// </remarks>
        /// <doc-id>hh437169</doc-id>
        /// <unmanaged>SetTrimPriorityComparison</unmanaged>
        /// <unmanaged-short>SetTrimPriorityComparison</unmanaged-short>
        public SharpDX.Animation.PriorityComparison2 TrimPriorityComparison
        {
            set => SetTrimPriorityComparison(value);
        }

        /// <summary>
        /// <p> Sets the priority comparison handler that determines whether  a scheduled storyboard can be compressed.</p>
        /// </summary>
        /// <remarks>
        /// <p>Setting a priority comparison handler with this method enables the application to indicate when scheduling conflicts can be resolved by compressing  the scheduled storyboard and any other storyboards animating the same variables.</p><p>A storyboard can be compressed only if the priority comparison object registered with this method returns <strong><see cref = "SharpDX.Result.Ok"/></strong> for all the other scheduled storyboards that will be affected by compression. When the storyboards are compressed, time is temporarily accelerated for affected storyboards, so they play faster.</p><p>Passing <strong><c>null</c></strong> for the <em>comparison</em> parameter causes Windows Animation to release its reference to any handler object that you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong>IUIAnimationManager2::Shutdown</strong> method.</p>
        /// </remarks>
        /// <doc-id>hh437163</doc-id>
        /// <unmanaged>SetCompressPriorityComparison</unmanaged>
        /// <unmanaged-short>SetCompressPriorityComparison</unmanaged-short>
        public SharpDX.Animation.PriorityComparison2 CompressPriorityComparison
        {
            set => SetCompressPriorityComparison(value);
        }

        /// <summary>
        /// <p> Sets the priority comparison handler that determines whether  a scheduled storyboard can be concluded.</p>
        /// </summary>
        /// <remarks>
        /// <p>Setting a priority comparison handler with this method enables the application to indicate when scheduling conflicts can be resolved by concluding the scheduled storyboard.</p><p>A scheduled storyboard can be concluded only if it contains a loop with a repetition count of <strong>UI_ANIMATION_REPEAT_INDEFINITELY</strong> and the priority comparison object registered with this method returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If the storyboard is concluded, the current repetition of the loop completes, and the rest of the storyboard then plays. </p><p>Passing <strong><c>null</c></strong> for the <em>comparison</em> parameter causes Windows Animation to release its reference to any handler object that you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong>IUIAnimationManager2::Shutdown</strong> method.</p>
        /// </remarks>
        /// <doc-id>hh437165</doc-id>
        /// <unmanaged>SetConcludePriorityComparison</unmanaged>
        /// <unmanaged-short>SetConcludePriorityComparison</unmanaged-short>
        public SharpDX.Animation.PriorityComparison2 ConcludePriorityComparison
        {
            set => SetConcludePriorityComparison(value);
        }

        /// <summary>
        /// <p> Sets the default acceptable animation delay. This is the length of time that may pass before storyboards begin.</p>
        /// </summary>
        /// <remarks>
        /// <p>For Windows Animation to schedule a storyboard successfully, the storyboard must begin before the longest acceptable delay has elapsed. Windows Animation determines this delay in the following order: the delay value set by calling <strong>IUIAnimationStoryboard::SetLongestAcceptableDelay</strong> for this specific storyboard, the delay value set by calling this method, or 0.0 if neither method has been called.</p>
        /// </remarks>
        /// <doc-id>hh437167</doc-id>
        /// <unmanaged>SetDefaultLongestAcceptableDelay</unmanaged>
        /// <unmanaged-short>SetDefaultLongestAcceptableDelay</unmanaged-short>
        public System.Double DefaultLongestAcceptableDelay
        {
            set => SetDefaultLongestAcceptableDelay(value);
        }

        /// <summary>
        /// <p>Creates a new animation variable for each specified dimension.</p>
        /// </summary>
        /// <param name = "initialValue"><dd> <p>A vector (of size <em>cDimension</em>) of  initial values for the animation variable.</p> </dd></param>
        /// <param name = "cDimension"><dd> <p>The number of dimensions that require animated values. This parameter specifies the number of values listed in <em>initialValue</em>.</p> </dd></param>
        /// <param name = "variable"><dd> <p> The new animation variable.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>The initial value of an animation variable is specified when the variable is created. After an animation variable is created, its value cannot be changed directly; it must be updated through the animation manager.</p><p>An animation variable is typically created to represent each visual characteristic that is to be animated. For example, an application might create three animation variables for the X, Y, and Z coordinates of an object  that can move freely within a a three-dimensional space.</p>
        /// </remarks>
        /// <doc-id>hh437139</doc-id>
        /// <unmanaged>HRESULT IUIAnimationManager2::CreateAnimationVectorVariable([In, Buffer] const double* initialValue,[In] unsigned int cDimension,[Out] IUIAnimationVariable2** variable)</unmanaged>
        /// <unmanaged-short>IUIAnimationManager2::CreateAnimationVectorVariable</unmanaged-short>
        public unsafe void CreateAnimationVectorVariable(System.Double[] initialValue, System.Int32 cDimension, out SharpDX.Animation.Variable2 variable)
        {
            System.IntPtr variable_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *initialValue_ = initialValue)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, initialValue_, cDimension, &variable_, (*(void ***)this._nativePointer)[3]);
            if (variable_ != System.IntPtr.Zero)
                variable = new SharpDX.Animation.Variable2(variable_);
            else
                variable = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a new animation variable.</p>
        /// </summary>
        /// <param name = "initialValue"><dd> <p> The initial value for the animation variable.</p> </dd></param>
        /// <param name = "variable"><dd> <p> The new animation variable.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>The initial value of an animation variable is specified when the variable is created. After an animation variable is created, its value cannot be changed directly; it must be updated through the animation manager.</p><p>An animation variable is typically created to represent each visual characteristic that is to be animated. For example, an application might create two animation variables for the X and Y coordinates of an object that can move freely within a window.</p>
        /// </remarks>
        /// <doc-id>hh437137</doc-id>
        /// <unmanaged>HRESULT IUIAnimationManager2::CreateAnimationVariable([In] double initialValue,[Out] IUIAnimationVariable2** variable)</unmanaged>
        /// <unmanaged-short>IUIAnimationManager2::CreateAnimationVariable</unmanaged-short>
        public unsafe void CreateAnimationVariable(System.Double initialValue, out SharpDX.Animation.Variable2 variable)
        {
            System.IntPtr variable_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, initialValue, &variable_, (*(void ***)this._nativePointer)[4]);
            if (variable_ != System.IntPtr.Zero)
                variable = new SharpDX.Animation.Variable2(variable_);
            else
                variable = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates and schedules a single-transition storyboard.</p>
        /// </summary>
        /// <param name = "variable"><dd> <p> The animation variable.</p> </dd></param>
        /// <param name = "transition"><dd> <p> A transition to be applied to the animation variable.</p> </dd></param>
        /// <param name = "timeNow"><dd> <p> The current system time.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method schedules a new storyboard by creating the storyboard, applying the specified transition to the specified variable, and then scheduling the storyboard.</p>
        /// </remarks>
        /// <doc-id>hh437157</doc-id>
        /// <unmanaged>HRESULT IUIAnimationManager2::ScheduleTransition([In] IUIAnimationVariable2* variable,[In] IUIAnimationTransition2* transition,[In] double timeNow)</unmanaged>
        /// <unmanaged-short>IUIAnimationManager2::ScheduleTransition</unmanaged-short>
        public unsafe void ScheduleTransition(SharpDX.Animation.Variable2 variable, SharpDX.Animation.Transition2 transition, System.Double timeNow)
        {
            System.IntPtr variable_ = System.IntPtr.Zero;
            System.IntPtr transition_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            variable_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.Variable2>(variable);
            transition_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.Transition2>(transition);
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)variable_, (void *)transition_, timeNow, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a new storyboard.</p>
        /// </summary>
        /// <param name = "storyboard"><dd> <p>The new storyboard.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <doc-id>hh437141</doc-id>
        /// <unmanaged>HRESULT IUIAnimationManager2::CreateStoryboard([Out] IUIAnimationStoryboard2** storyboard)</unmanaged>
        /// <unmanaged-short>IUIAnimationManager2::CreateStoryboard</unmanaged-short>
        public unsafe void CreateStoryboard(out SharpDX.Animation.Storyboard2 storyboard)
        {
            System.IntPtr storyboard_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, &storyboard_, (*(void ***)this._nativePointer)[6]);
            if (storyboard_ != System.IntPtr.Zero)
                storyboard = new SharpDX.Animation.Storyboard2(storyboard_);
            else
                storyboard = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Finishes all active storyboards within the specified time interval.</p>
        /// </summary>
        /// <param name = "completionDeadline"><dd> <p> The maximum time interval during which all storyboards must be finished.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p> Calling the <strong>FinishAllStoryboards</strong> method ensures that all active storyboards finish within the specified completion deadline. If a storyboard is scheduled to play past the deadline, it is compressed.</p><p>A storyboard is considered active if a call to the <strong>IUIAnimationStoryboard::GetStatus</strong> method returns <strong>UI_ANIMATION_STORYBOARD_PLAYING</strong> or <strong>UI_ANIMATION_STORYBOARD_SCHEDULED</strong>.</p>
        /// </remarks>
        /// <doc-id>hh437145</doc-id>
        /// <unmanaged>HRESULT IUIAnimationManager2::FinishAllStoryboards([In] double completionDeadline)</unmanaged>
        /// <unmanaged-short>IUIAnimationManager2::FinishAllStoryboards</unmanaged-short>
        public unsafe void FinishAllStoryboards(System.Double completionDeadline)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, completionDeadline, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Abandons all active storyboards.</p>
        /// </summary>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Calling this method is equivalent to calling the <strong>IUIAnimationStoryboard::Abandon</strong> method for each active storyboard. </p><p>A storyboard is considered active if a call to the <strong>IUIAnimationStoryboard::GetStatus</strong> method returns <strong>UI_ANIMATION_STORYBOARD_PLAYING</strong> or <strong>UI_ANIMATION_STORYBOARD_SCHEDULED</strong>.</p>
        /// </remarks>
        /// <doc-id>hh437136</doc-id>
        /// <unmanaged>HRESULT IUIAnimationManager2::AbandonAllStoryboards()</unmanaged>
        /// <unmanaged-short>IUIAnimationManager2::AbandonAllStoryboards</unmanaged-short>
        public unsafe void AbandonAllStoryboards()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Updates the values of all animation variables.</p>
        /// </summary>
        /// <param name = "timeNow"><dd> <p> The current system time. This parameter must be greater than or equal to 0.0.</p> </dd></param>
        /// <param name = "updateResult"><dd> <p>The result of the update. You can omit this parameter from calls to this method.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Calling this method advances the animation manager to <em>timeNow</em>, changes the status of all storyboards as necessary, and updates any animation variables to appropriate interpolated values. If the animation manager is paused, no storyboards or variables are updated. If the animation  mode is <strong>UI_ANIMATION_MODE_DISABLED</strong>, all scheduled storyboards finish playing immediately. If the values of any variables change during this call, the value of <em>updateResult</em> is <strong>UI_ANIMATION_UPDATE_VARIABLES_CHANGED</strong>; otherwise, it is <strong>UI_ANIMATION_UPDATE_NO_CHANGE</strong>. </p>
        /// </remarks>
        /// <doc-id>hh437171</doc-id>
        /// <unmanaged>HRESULT IUIAnimationManager2::Update([In] double timeNow,[Out, Optional] UI_ANIMATION_UPDATE_RESULT* updateResult)</unmanaged>
        /// <unmanaged-short>IUIAnimationManager2::Update</unmanaged-short>
        public unsafe void Update(System.Double timeNow, out SharpDX.Animation.UpdateResult updateResult)
        {
            SharpDX.Result __result__;
            fixed (void *updateResult_ = &updateResult)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, timeNow, updateResult_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Gets the animation variable with the specified tag.</p>
        /// </summary>
        /// <param name = "@object"><dd> <p> The object portion of the tag. This parameter can be <c>null</c>.</p> </dd></param>
        /// <param name = "id"><dd> <p> The identifier portion of the tag.</p> </dd></param>
        /// <param name = "variable"><dd> <p> The animation variable that matches the specified tag, or <strong><c>null</c></strong> if no match is found.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p> A tag is a pairing of an integer identifier (<em>id</em>) with a COM object (<em>object</em>). An application can use tags to identify animation variables and storyboards. <c>null</c> is a valid object component of a tag; therefore, the <em>object</em> parameter can be <c>null</c>.</p><p>Tags are not necessarily unique; this method returns <strong>UI_E_AMBIGUOUS_MATCH</strong> if more than one animation variable exists with the specified tag.</p>
        /// </remarks>
        /// <doc-id>hh437151</doc-id>
        /// <unmanaged>HRESULT IUIAnimationManager2::GetVariableFromTag([In, Optional] IUnknown* object,[In] unsigned int id,[Out] IUIAnimationVariable2** variable)</unmanaged>
        /// <unmanaged-short>IUIAnimationManager2::GetVariableFromTag</unmanaged-short>
        public unsafe void GetVariableFromTag(SharpDX.IUnknown @object, System.Int32 id, out SharpDX.Animation.Variable2 variable)
        {
            System.IntPtr @object_ = System.IntPtr.Zero;
            System.IntPtr variable_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            @object_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(@object);
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)@object_, id, &variable_, (*(void ***)this._nativePointer)[10]);
            if (variable_ != System.IntPtr.Zero)
                variable = new SharpDX.Animation.Variable2(variable_);
            else
                variable = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Gets the storyboard with the specified tag.</p>
        /// </summary>
        /// <param name = "@object"><dd> <p> The object portion of the tag. This parameter can be <c>null</c>.</p> </dd></param>
        /// <param name = "id"><dd> <p> The identifier portion of the tag.</p> </dd></param>
        /// <param name = "storyboard"><dd> <p> The storyboard that matches the specified tag, or <strong><c>null</c></strong> if no match is found.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>A tag is a pairing of an integer identifier (<em>id</em>) with a COM object (<em>object</em>). An application can use tags to identify animation variables and storyboards. <c>null</c> is a valid object component of a tag; therefore, the <em>object</em> parameter can be <c>null</c>.</p><p>Tags are not necessarily unique; this method returns UI_E_AMBIGUOUS_MATCH if more than one storyboard exists with the specified tag.</p>
        /// </remarks>
        /// <doc-id>hh437149</doc-id>
        /// <unmanaged>HRESULT IUIAnimationManager2::GetStoryboardFromTag([In, Optional] IUnknown* object,[In] unsigned int id,[Out] IUIAnimationStoryboard2** storyboard)</unmanaged>
        /// <unmanaged-short>IUIAnimationManager2::GetStoryboardFromTag</unmanaged-short>
        public unsafe void GetStoryboardFromTag(SharpDX.IUnknown @object, System.Int32 id, out SharpDX.Animation.Storyboard2 storyboard)
        {
            System.IntPtr @object_ = System.IntPtr.Zero;
            System.IntPtr storyboard_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            @object_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(@object);
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)@object_, id, &storyboard_, (*(void ***)this._nativePointer)[11]);
            if (storyboard_ != System.IntPtr.Zero)
                storyboard = new SharpDX.Animation.Storyboard2(storyboard_);
            else
                storyboard = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves an estimate of  the time interval before the next animation event.</p>
        /// </summary>
        /// <param name = "seconds"><dd> <p>The estimated time, in seconds.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <doc-id>hh437143</doc-id>
        /// <unmanaged>HRESULT IUIAnimationManager2::EstimateNextEventTime([Out] double* seconds)</unmanaged>
        /// <unmanaged-short>IUIAnimationManager2::EstimateNextEventTime</unmanaged-short>
        public unsafe void EstimateNextEventTime(out System.Double seconds)
        {
            SharpDX.Result __result__;
            fixed (void *seconds_ = &seconds)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, seconds_, (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Gets the status of the animation manager.</p>
        /// </summary>
        /// <param name = "status"><dd> <p> The status of the animation manager.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <doc-id>hh437147</doc-id>
        /// <unmanaged>HRESULT IUIAnimationManager2::GetStatus([Out] UI_ANIMATION_MANAGER_STATUS* status)</unmanaged>
        /// <unmanaged-short>IUIAnimationManager2::GetStatus</unmanaged-short>
        internal unsafe void GetStatus(out SharpDX.Animation.ManagerStatus status)
        {
            SharpDX.Result __result__;
            fixed (void *status_ = &status)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, status_, (*(void ***)this._nativePointer)[13]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Sets the animation mode.</p>
        /// </summary>
        /// <param name = "mode"><dd> <p> The animation mode.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Use this method to enable or disable animation globally. While animation is disabled, all storyboards finish immediately when they are scheduled. The default mode is <strong>UI_ANIMATION_MODE_SYSTEM_DEFAULT</strong>, which lets Windows decide when to enable or disable animation in the application.</p>
        /// </remarks>
        /// <doc-id>hh437159</doc-id>
        /// <unmanaged>HRESULT IUIAnimationManager2::SetAnimationMode([In] UI_ANIMATION_MODE mode)</unmanaged>
        /// <unmanaged-short>IUIAnimationManager2::SetAnimationMode</unmanaged-short>
        internal unsafe void SetAnimationMode(SharpDX.Animation.Mode mode)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)mode), (*(void ***)this._nativePointer)[14]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Pauses all animations.</p>
        /// </summary>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p> When an animation manager is paused, its status is set to <strong>UI_ANIMATION_MANAGER_IDLE</strong>.</p>
        /// </remarks>
        /// <doc-id>hh437153</doc-id>
        /// <unmanaged>HRESULT IUIAnimationManager2::Pause()</unmanaged>
        /// <unmanaged-short>IUIAnimationManager2::Pause</unmanaged-short>
        public unsafe void Pause()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[15]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Resumes all animations.</p>
        /// </summary>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p> When an animation manager is resumed, and at least one animation is currently scheduled or playing, its status is set to <strong>UI_ANIMATION_MANAGER_BUSY</strong>.</p>
        /// </remarks>
        /// <doc-id>hh437155</doc-id>
        /// <unmanaged>HRESULT IUIAnimationManager2::Resume()</unmanaged>
        /// <unmanaged-short>IUIAnimationManager2::Resume</unmanaged-short>
        public unsafe void Resume()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[16]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Specifies a handler for animation manager status updates.</p>
        /// </summary>
        /// <param name = "handler"><dd> <p>The event handler to be called when the status of the animation manager changes.   The specified object must implement the <strong><see cref = "SharpDX.Animation.ManagerEventHandler"/></strong> interface or be <strong><c>null</c></strong>. See Remarks for more info.</p> </dd></param>
        /// <param name = "fRegisterForNextAnimationEvent"><dd> <p>If <strong>TRUE</strong>, specifies that <strong>IUIAnimationManager2::EstimateNextEventTime</strong> will incorporate <em>handler</em> into its estimate of the time interval until the next animation event. No default value.</p> </dd></param>
        /// <returns><p>Returns <strong><see cref = "SharpDX.Result.Ok"/></strong> if successful; otherwise an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Passing <strong><c>null</c></strong> for the <em>handler</em> parameter causes Windows Animation to release its reference to any handler object that you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong>IUIAnimationManager2::Shutdown</strong> method.</p>
        /// </remarks>
        /// <doc-id>hh437168</doc-id>
        /// <unmanaged>HRESULT IUIAnimationManager2::SetManagerEventHandler([In, Optional] IUIAnimationManagerEventHandler2* handler,[In] BOOL fRegisterForNextAnimationEvent)</unmanaged>
        /// <unmanaged-short>IUIAnimationManager2::SetManagerEventHandler</unmanaged-short>
        internal unsafe void SetManagerEventHandler(SharpDX.Animation.ManagerEventHandler2 handler, SharpDX.Mathematics.Interop.RawBool fRegisterForNextAnimationEvent)
        {
            System.IntPtr handler_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            handler_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.ManagerEventHandler2>(handler);
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint0(this._nativePointer, (void *)handler_, fRegisterForNextAnimationEvent, (*(void ***)this._nativePointer)[17]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Sets the priority comparison handler that determines whether  a scheduled storyboard can be canceled.</p>
        /// </summary>
        /// <param name = "comparison"><dd> <p> The priority comparison handler for cancelation.   The specified object must implement the <strong><see cref = "SharpDX.Animation.PriorityComparison2"/></strong> interface or be <strong><c>null</c></strong>. See Remarks for more info.</p> </dd></param>
        /// <returns><p>Returns <strong><see cref = "SharpDX.Result.Ok"/></strong> if successful; otherwise an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Setting a priority comparison handler with this method enables the application to indicate when scheduling conflicts can be resolved by canceling storyboards.</p><p>A scheduled storyboard can be canceled only if it hasn't started playing and the priority comparison object registered with this method returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Canceled storyboards are completely removed from the schedule.</p><p>Passing <strong><c>null</c></strong> for the <em>comparison</em> parameter causes Windows Animation to release its reference to any priority comparison handler object that you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong>IUIAnimationManager2::Shutdown</strong> method.</p>
        /// </remarks>
        /// <doc-id>hh437161</doc-id>
        /// <unmanaged>HRESULT IUIAnimationManager2::SetCancelPriorityComparison([In, Optional] IUIAnimationPriorityComparison2* comparison)</unmanaged>
        /// <unmanaged-short>IUIAnimationManager2::SetCancelPriorityComparison</unmanaged-short>
        internal unsafe void SetCancelPriorityComparison(SharpDX.Animation.PriorityComparison2 comparison)
        {
            System.IntPtr comparison_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            comparison_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.PriorityComparison2>(comparison);
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)comparison_, (*(void ***)this._nativePointer)[18]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Sets the priority comparison handler that determines whether  a scheduled storyboard can be trimmed.</p>
        /// </summary>
        /// <param name = "comparison"><dd> <p>The priority comparison handler for trimming.   The specified object must implement the <strong><see cref = "SharpDX.Animation.PriorityComparison"/></strong> interface or be <strong><c>null</c></strong>. See Remarks for more info.</p> </dd></param>
        /// <returns><p>Returns <strong><see cref = "SharpDX.Result.Ok"/></strong> if successful; otherwise an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p> Setting a priority comparison handler with this method enables the application to indicate when  scheduling conflicts can be resolved by trimming the scheduled storyboard.</p><p>A scheduled storyboard can be trimmed only if the priority comparison object registered with this method returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If the new storyboard trims the scheduled storyboard,  the scheduled storyboard can no longer affect a variable after the new storyboard begins to animate that variable.</p><p>Passing <strong><c>null</c></strong> for the <em>comparison</em> parameter causes Windows Animation to release its reference to any handler object that you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong>IUIAnimationManager2::Shutdown</strong> method.</p>
        /// </remarks>
        /// <doc-id>hh437169</doc-id>
        /// <unmanaged>HRESULT IUIAnimationManager2::SetTrimPriorityComparison([In, Optional] IUIAnimationPriorityComparison2* comparison)</unmanaged>
        /// <unmanaged-short>IUIAnimationManager2::SetTrimPriorityComparison</unmanaged-short>
        internal unsafe void SetTrimPriorityComparison(SharpDX.Animation.PriorityComparison2 comparison)
        {
            System.IntPtr comparison_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            comparison_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.PriorityComparison2>(comparison);
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)comparison_, (*(void ***)this._nativePointer)[19]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Sets the priority comparison handler that determines whether  a scheduled storyboard can be compressed.</p>
        /// </summary>
        /// <param name = "comparison"><dd> <p> The priority comparison handler for compression.   The specified object must implement the <strong><see cref = "SharpDX.Animation.PriorityComparison2"/></strong> interface or be <strong><c>null</c></strong>. See Remarks for more info. </p> </dd></param>
        /// <returns><p>Returns <strong><see cref = "SharpDX.Result.Ok"/></strong> if successful; otherwise an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Setting a priority comparison handler with this method enables the application to indicate when scheduling conflicts can be resolved by compressing  the scheduled storyboard and any other storyboards animating the same variables.</p><p>A storyboard can be compressed only if the priority comparison object registered with this method returns <strong><see cref = "SharpDX.Result.Ok"/></strong> for all the other scheduled storyboards that will be affected by compression. When the storyboards are compressed, time is temporarily accelerated for affected storyboards, so they play faster.</p><p>Passing <strong><c>null</c></strong> for the <em>comparison</em> parameter causes Windows Animation to release its reference to any handler object that you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong>IUIAnimationManager2::Shutdown</strong> method.</p>
        /// </remarks>
        /// <doc-id>hh437163</doc-id>
        /// <unmanaged>HRESULT IUIAnimationManager2::SetCompressPriorityComparison([In, Optional] IUIAnimationPriorityComparison2* comparison)</unmanaged>
        /// <unmanaged-short>IUIAnimationManager2::SetCompressPriorityComparison</unmanaged-short>
        internal unsafe void SetCompressPriorityComparison(SharpDX.Animation.PriorityComparison2 comparison)
        {
            System.IntPtr comparison_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            comparison_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.PriorityComparison2>(comparison);
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)comparison_, (*(void ***)this._nativePointer)[20]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Sets the priority comparison handler that determines whether  a scheduled storyboard can be concluded.</p>
        /// </summary>
        /// <param name = "comparison"><dd> <p> The priority comparison handler for conclusion. The specified object must implement the <strong><see cref = "SharpDX.Animation.PriorityComparison2"/></strong> interface or be <strong><c>null</c></strong>. See Remarks for more info.</p> </dd></param>
        /// <returns><p>Returns <strong><see cref = "SharpDX.Result.Ok"/></strong> if successful; otherwise an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Setting a priority comparison handler with this method enables the application to indicate when scheduling conflicts can be resolved by concluding the scheduled storyboard.</p><p>A scheduled storyboard can be concluded only if it contains a loop with a repetition count of <strong>UI_ANIMATION_REPEAT_INDEFINITELY</strong> and the priority comparison object registered with this method returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If the storyboard is concluded, the current repetition of the loop completes, and the rest of the storyboard then plays. </p><p>Passing <strong><c>null</c></strong> for the <em>comparison</em> parameter causes Windows Animation to release its reference to any handler object that you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong>IUIAnimationManager2::Shutdown</strong> method.</p>
        /// </remarks>
        /// <doc-id>hh437165</doc-id>
        /// <unmanaged>HRESULT IUIAnimationManager2::SetConcludePriorityComparison([In, Optional] IUIAnimationPriorityComparison2* comparison)</unmanaged>
        /// <unmanaged-short>IUIAnimationManager2::SetConcludePriorityComparison</unmanaged-short>
        internal unsafe void SetConcludePriorityComparison(SharpDX.Animation.PriorityComparison2 comparison)
        {
            System.IntPtr comparison_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            comparison_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.PriorityComparison2>(comparison);
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)comparison_, (*(void ***)this._nativePointer)[21]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Sets the default acceptable animation delay. This is the length of time that may pass before storyboards begin.</p>
        /// </summary>
        /// <param name = "delay"><dd> <p> The default delay. This parameter can be a positive value, or <strong>UI_ANIMATION_SECONDS_EVENTUALLY</strong> (-1) to indicate that any finite delay is acceptable.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>For Windows Animation to schedule a storyboard successfully, the storyboard must begin before the longest acceptable delay has elapsed. Windows Animation determines this delay in the following order: the delay value set by calling <strong>IUIAnimationStoryboard::SetLongestAcceptableDelay</strong> for this specific storyboard, the delay value set by calling this method, or 0.0 if neither method has been called.</p>
        /// </remarks>
        /// <doc-id>hh437167</doc-id>
        /// <unmanaged>HRESULT IUIAnimationManager2::SetDefaultLongestAcceptableDelay([In] double delay)</unmanaged>
        /// <unmanaged-short>IUIAnimationManager2::SetDefaultLongestAcceptableDelay</unmanaged-short>
        internal unsafe void SetDefaultLongestAcceptableDelay(System.Double delay)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, delay, (*(void ***)this._nativePointer)[22]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Shuts down the animation manager and all its associated objects.</p>
        /// </summary>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Calling this method directs the animation manager, and all the objects it created, to  release all their references to other objects. After <strong>IUIAnimationManager2::Shutdown</strong> has been called, no other methods may be called on the animation manager or on any objects that it created. An application can call this method to clean up if there is any possibility that the application has introduced a reference cycle that includes some animation objects.</p>
        /// </remarks>
        /// <doc-id>hh437170</doc-id>
        /// <unmanaged>HRESULT IUIAnimationManager2::Shutdown()</unmanaged>
        /// <unmanaged-short>IUIAnimationManager2::Shutdown</unmanaged-short>
        public unsafe void Shutdown()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[23]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("783321ED-78A3-4366-B574-6AF607A64788")]
    internal partial interface ManagerEventHandler : SharpDX.IUnknown
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("F6E022BA-BFF3-42EC-9033-E073F33E83C3")]
    internal partial interface ManagerEventHandler2 : SharpDX.IUnknown
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("BAB20D63-4361-45DA-A24F-AB8508846B5B")]
    public partial class PrimitiveInterpolation : SharpDX.ComObject
    {
        public PrimitiveInterpolation(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator PrimitiveInterpolation(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new PrimitiveInterpolation(nativePtr);
        /// <summary>
        /// <p>Adds a cubic polynomial segment that describes the shape of a transition curve to the animation function. </p>
        /// </summary>
        /// <param name = "dimension"><dd> <p>The dimension in which to apply the new segment.</p> </dd></param>
        /// <param name = "beginOffset"><dd> <p>The begin offset for the segment, where 0 corresponds to the start of the transition.</p> </dd></param>
        /// <param name = "constantCoefficient"><dd> <p>The cubic polynomial constant coefficient.</p> </dd></param>
        /// <param name = "linearCoefficient"><dd> <p>The cubic polynomial linear coefficient.</p> </dd></param>
        /// <param name = "quadraticCoefficient"><dd> <p>The cubic polynomial quadratic coefficient.</p> </dd></param>
        /// <param name = "cubicCoefficient"><dd> <p>The cubic polynomial cubic coefficient.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method will fail with an error code of UI_E_INVALID_PRIMITIVE if the start time is either less than 0
        /// or less than the start time of  a previous segment.
        /// </p>
        /// </remarks>
        /// <doc-id>hh437175</doc-id>
        /// <unmanaged>HRESULT IUIAnimationPrimitiveInterpolation::AddCubic([In] unsigned int dimension,[In] double beginOffset,[In] float constantCoefficient,[In] float linearCoefficient,[In] float quadraticCoefficient,[In] float cubicCoefficient)</unmanaged>
        /// <unmanaged-short>IUIAnimationPrimitiveInterpolation::AddCubic</unmanaged-short>
        public unsafe void AddCubic(System.Int32 dimension, System.Double beginOffset, System.Single constantCoefficient, System.Single linearCoefficient, System.Single quadraticCoefficient, System.Single cubicCoefficient)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, dimension, beginOffset, constantCoefficient, linearCoefficient, quadraticCoefficient, cubicCoefficient, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Adds a sinusoidal segment that describes the shape of a transition curve to the animation function. </p>
        /// </summary>
        /// <param name = "dimension"><dd> <p>The dimension in which to apply the new segment.</p> </dd></param>
        /// <param name = "beginOffset"><dd> <p>The begin offset for the segment, where 0 corresponds to the start of the transition.</p> </dd></param>
        /// <param name = "bias"><dd> <p>The bias constant in the sinusoidal function.</p> </dd></param>
        /// <param name = "amplitude"><dd> <p>The amplitude constant in the sinusoidal function.</p> </dd></param>
        /// <param name = "frequency"><dd> <p>The frequency constant in the sinusoidal function.</p> </dd></param>
        /// <param name = "phase"><dd> <p>The phase constant in the sinusoidal function.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Defined by the function Y(t) = bias + amplitude*sin(360*frequency*t + phase), where 'sin' is the sin of an angle specified in degrees (for example, sin(n + 360) == sin(n) for any real number 'n').</p><p>This method will fail with an error code of UI_E_INVALID_PRIMITIVE if the start time is either less than 0
        /// or less than the start time of  a previous segment.
        /// </p>
        /// </remarks>
        /// <doc-id>jj643353</doc-id>
        /// <unmanaged>HRESULT IUIAnimationPrimitiveInterpolation::AddSinusoidal([In] unsigned int dimension,[In] double beginOffset,[In] float bias,[In] float amplitude,[In] float frequency,[In] float phase)</unmanaged>
        /// <unmanaged-short>IUIAnimationPrimitiveInterpolation::AddSinusoidal</unmanaged-short>
        public unsafe void AddSinusoidal(System.Int32 dimension, System.Double beginOffset, System.Single bias, System.Single amplitude, System.Single frequency, System.Single phase)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, dimension, beginOffset, bias, amplitude, frequency, phase, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("83FA9B74-5F86-4618-BC6A-A2FAC19B3F44")]
    internal partial interface PriorityComparison : SharpDX.IUnknown
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("5B6D7A37-4621-467C-8B05-70131DE62DDB")]
    public partial class PriorityComparison2 : SharpDX.ComObject
    {
        public PriorityComparison2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator PriorityComparison2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new PriorityComparison2(nativePtr);
        /// <summary>
        /// <p>Determines the relative priority between a scheduled storyboard and a new storyboard.</p>
        /// </summary>
        /// <param name = "scheduledStoryboard"><dd> <p> The currently scheduled storyboard.</p> </dd></param>
        /// <param name = "newStoryboard"><dd> <p> The new storyboard that is interrupting the scheduled storyboard specified by <em>scheduledStoryboard</em>.</p> </dd></param>
        /// <param name = "priorityEffect"><dd> <p> The potential effect on <em>newStoryboard</em> if <em>scheduledStoryboard</em> has a higher priority.</p> </dd></param>
        /// <returns><p>Returns the following if successful; otherwise an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p><em>newStoryboard</em> has priority.</p> </td></tr> <tr><td> <dl> <dt><strong>S_FALSE</strong></dt> </dl> </td><td> <p><em>scheduledStoryboard</em> has priority.</p> </td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p> A single animation variable can be included in multiple storyboards,  but multiple storyboards cannot animate the same variable at the same time. If a new storyboard attempts to animate one or more variables that are currently scheduled for animation by a different storyboard, a scheduling conflict occurs. To determine which storyboard has priority, the animation manager can call the <strong>HasPriority</strong> method on one or more  priority comparison handlers provided by the application.</p><p>Registering priority comparison objects is optional.  By default, all storyboards can be trimmed, concluded, or compressed to prevent failure, but none can be canceled, and by default no storyboards will be canceled or trimmed to prevent a delay.</p><p>By default, a call made in a callback method to any other animation method results in the call failing and returning <strong>UI_E_ILLEGAL_REENTRANCY</strong>. However, there are exceptions to this default. The following methods can be successfully called from <strong>HasPriority</strong>:</p><ul> <li> <strong>IUIAnimationManager2::GetStoryboardFromTag</strong> </li> <li> <strong>IUIAnimationManager2::GetVariableFromTag</strong> </li> <li> <strong>IUIAnimationStoryboard::GetTag</strong> </li> <li> <strong>IUIAnimationVariable2::GetTag</strong> </li> </ul>
        /// </remarks>
        /// <doc-id>hh437177</doc-id>
        /// <unmanaged>HRESULT IUIAnimationPriorityComparison2::HasPriority([In] IUIAnimationStoryboard2* scheduledStoryboard,[In] IUIAnimationStoryboard2* newStoryboard,[In] UI_ANIMATION_PRIORITY_EFFECT priorityEffect)</unmanaged>
        /// <unmanaged-short>IUIAnimationPriorityComparison2::HasPriority</unmanaged-short>
        public unsafe void HasPriority(SharpDX.Animation.Storyboard2 scheduledStoryboard, SharpDX.Animation.Storyboard2 newStoryboard, SharpDX.Animation.PriorityEffect priorityEffect)
        {
            System.IntPtr scheduledStoryboard_ = System.IntPtr.Zero;
            System.IntPtr newStoryboard_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            scheduledStoryboard_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.Storyboard2>(scheduledStoryboard);
            newStoryboard_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.Storyboard2>(newStoryboard);
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)scheduledStoryboard_, (void *)newStoryboard_, unchecked ((System.Int32)priorityEffect), (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("A8FF128F-9BF9-4af1-9E67-E5E410DEFB84")]
    public partial class Storyboard : SharpDX.ComObject
    {
        public Storyboard(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Storyboard(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Storyboard(nativePtr);
        /// <summary>
        /// <p> Sets the longest acceptable delay before the scheduled storyboard begins.</p>
        /// </summary>
        /// <remarks>
        /// <p>For a storyboard to be successfully scheduled, it must begin before the longest acceptable delay has elapsed. This delay is determined in the following order: the delay value set by calling this method, the delay value set by calling the <strong>IUIAnimationManager::SetDefaultLongestAcceptableDelay</strong> method, or 0.0 if neither of these methods has been called.</p>
        /// </remarks>
        /// <doc-id>dd371824</doc-id>
        /// <unmanaged>SetLongestAcceptableDelay</unmanaged>
        /// <unmanaged-short>SetLongestAcceptableDelay</unmanaged-short>
        public System.Double LongestAcceptableDelay
        {
            set => SetLongestAcceptableDelay(value);
        }

        /// <summary>
        /// <p> Gets the status of the storyboard.</p>
        /// </summary>
        /// <remarks>
        /// <p>Unless this method is called from a handler for <strong>OnStoryboardStatusChanged</strong> events, the only values it returns are <strong>UI_ANIMATION_STORYBOARD_BUILDING</strong>, <strong>UI_ANIMATION_STORYBOARD_SCHEDULED</strong>,
        /// <strong>UI_ANIMATION_STORYBOARD_PLAYING</strong>, and <strong>UI_ANIMATION_STORYBOARD_READY</strong>.</p>
        /// </remarks>
        /// <doc-id>dd371808</doc-id>
        /// <unmanaged>GetStatus</unmanaged>
        /// <unmanaged-short>GetStatus</unmanaged-short>
        public SharpDX.Animation.StoryboardStatus Status
        {
            get
            {
                GetStatus(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p> Gets the time that has elapsed since the storyboard started playing.</p>
        /// </summary>
        /// <doc-id>dd371807</doc-id>
        /// <unmanaged>GetElapsedTime</unmanaged>
        /// <unmanaged-short>GetElapsedTime</unmanaged-short>
        public System.Double ElapsedTime
        {
            get
            {
                GetElapsedTime(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p> Adds a transition to the storyboard.</p>
        /// </summary>
        /// <param name = "variable"><dd> <p> The animation variable for which the transition is to be added.</p> </dd></param>
        /// <param name = "transition"><dd> <p> The transition to be added.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>UI_E_TRANSITION_ALREADY_USED</strong></dt> </dl> </td><td> <p>This transition has already been added to a storyboard.</p> </td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>The <strong>AddTransition</strong> method applies the specified transition to the specified variable in the storyboard. If this is the first transition applied to this variable in this storyboard, the transition begins at the start of the storyboard. Otherwise, the transition is appended to the transition that was most recently added to the variable.</p>
        /// </remarks>
        /// <doc-id>dd371789</doc-id>
        /// <unmanaged>HRESULT IUIAnimationStoryboard::AddTransition([In] IUIAnimationVariable* variable,[In] IUIAnimationTransition* transition)</unmanaged>
        /// <unmanaged-short>IUIAnimationStoryboard::AddTransition</unmanaged-short>
        public unsafe void AddTransition(SharpDX.Animation.Variable variable, SharpDX.Animation.Transition transition)
        {
            System.IntPtr variable_ = System.IntPtr.Zero;
            System.IntPtr transition_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            variable_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.Variable>(variable);
            transition_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.Transition>(transition);
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)variable_, (void *)transition_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Adds a keyframe at the specified offset from an existing keyframe.</p>
        /// </summary>
        /// <param name = "existingKeyframe"><dd> <p> The existing keyframe. To add a keyframe at an offset from the start of the storyboard, use the special keyframe <strong>UI_ANIMATION_KEYFRAME_STORYBOARD_START</strong>.</p> </dd></param>
        /// <param name = "offset"><dd> <p> The offset from the existing keyframe at which a new keyframe is to be added.</p> </dd></param>
        /// <returns><dd> <p> The keyframe to be added.</p> </dd></returns>
        /// <remarks>
        /// <p>A keyframe represents a moment in time within a storyboard and can be used to specify the start and end times of transitions. Because keyframes can be added at the ends of transitions, their offsets from the start of the storyboard may not be known until the storyboard is playing.</p>
        /// </remarks>
        /// <doc-id>dd371784</doc-id>
        /// <unmanaged>HRESULT IUIAnimationStoryboard::AddKeyframeAtOffset([In] __MIDL___MIDL_itf_UIAnimation_0000_0002_0003* existingKeyframe,[In] double offset,[Out] __MIDL___MIDL_itf_UIAnimation_0000_0002_0003** keyframe)</unmanaged>
        /// <unmanaged-short>IUIAnimationStoryboard::AddKeyframeAtOffset</unmanaged-short>
        public unsafe System.IntPtr AddKeyframeAtOffset(System.IntPtr existingKeyframe, System.Double offset)
        {
            System.IntPtr keyframe;
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)existingKeyframe, offset, &keyframe, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
            return keyframe;
        }

        /// <summary>
        /// <p> Adds a keyframe at the end of the specified transition.</p>
        /// </summary>
        /// <param name = "transition"><dd> <p> The transition after which a keyframe is to be added.</p> </dd></param>
        /// <returns><dd> <p> The keyframe to be added.</p> </dd></returns>
        /// <remarks>
        /// <p> A keyframe represents a moment in time within a storyboard and can be used to specify the start and end times of transitions. Because keyframes can be added at the ends of transitions, their offsets from the start of the storyboard may not be known until the storyboard is playing.</p>
        /// </remarks>
        /// <doc-id>dd371783</doc-id>
        /// <unmanaged>HRESULT IUIAnimationStoryboard::AddKeyframeAfterTransition([In] IUIAnimationTransition* transition,[Out] __MIDL___MIDL_itf_UIAnimation_0000_0002_0003** keyframe)</unmanaged>
        /// <unmanaged-short>IUIAnimationStoryboard::AddKeyframeAfterTransition</unmanaged-short>
        public unsafe System.IntPtr AddKeyframeAfterTransition(SharpDX.Animation.Transition transition)
        {
            System.IntPtr transition_ = System.IntPtr.Zero;
            System.IntPtr keyframe;
            SharpDX.Result __result__;
            transition_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.Transition>(transition);
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)transition_, &keyframe, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
            return keyframe;
        }

        /// <summary>
        /// <p> Adds a transition that starts at the specified keyframe.</p>
        /// </summary>
        /// <param name = "variable"><dd> <p> The animation variable for which a transition is to be added.</p> </dd></param>
        /// <param name = "transition"><dd> <p> The transition to be added.</p> </dd></param>
        /// <param name = "startKeyframe"><dd> <p> The keyframe that specifies the beginning of the new transition.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>UI_E_TRANSITION_ALREADY_USED</strong></dt> </dl> </td><td> <p>This transition has already been added to a storyboard or has been added to a storyboard that has finished playing and been released.</p> </td></tr> <tr><td> <dl> <dt><strong>UI_E_TRANSITION_ECLIPSED</strong></dt> </dl> </td><td> <p>The transition might eclipse the beginning of another transition in the storyboard.</p> </td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>Transitions must be added in the order in which they will be played. A transition may begin playing before the preceding transition in the storyboard has finished, in which case the initial value and velocity seen by the new transition is determined by the state of the preceding one. A transition should not begin before the start of the preceding transition.</p><p>A keyframe represents a moment in time within a storyboard and can be used to specify the start and end times of transitions. Because keyframes can be added at the ends of transitions, their offsets from the start of the storyboard may not be known until the storyboard is playing.</p>
        /// </remarks>
        /// <doc-id>dd371795</doc-id>
        /// <unmanaged>HRESULT IUIAnimationStoryboard::AddTransitionAtKeyframe([In] IUIAnimationVariable* variable,[In] IUIAnimationTransition* transition,[In] __MIDL___MIDL_itf_UIAnimation_0000_0002_0003* startKeyframe)</unmanaged>
        /// <unmanaged-short>IUIAnimationStoryboard::AddTransitionAtKeyframe</unmanaged-short>
        public unsafe void AddTransitionAtKeyframe(SharpDX.Animation.Variable variable, SharpDX.Animation.Transition transition, System.IntPtr startKeyframe)
        {
            System.IntPtr variable_ = System.IntPtr.Zero;
            System.IntPtr transition_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            variable_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.Variable>(variable);
            transition_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.Transition>(transition);
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)variable_, (void *)transition_, (void *)startKeyframe, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Adds a transition between two keyframes.</p>
        /// </summary>
        /// <param name = "variable"><dd> <p> The animation variable for which the transition is to be added.</p> </dd></param>
        /// <param name = "transition"><dd> <p> The transition to be added.</p> </dd></param>
        /// <param name = "startKeyframe"><dd> <p> A keyframe that specifies the beginning of the new transition.</p> </dd></param>
        /// <param name = "endKeyframe"><dd> <p> A keyframe that specifies the end of the new transition. It must not be possible for <em>endKeyframe</em> to appear earlier in the storyboard than <em>startKeyframe</em>.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>UI_E_TRANSITION_ALREADY_USED</strong></dt> </dl> </td><td> <p>This transition has already been added to a storyboard or has been added to a storyboard that has finished playing and been released.</p> </td></tr> <tr><td> <dl> <dt><strong>UI_E_TRANSITION_ECLIPSED</strong></dt> </dl> </td><td> <p>The transition might eclipse the beginning of another transition in the storyboard.</p> </td></tr> <tr><td> <dl> <dt><strong>UI_E_START_KEYFRAME_AFTER_END</strong></dt> </dl> </td><td> <p>The start keyframe might occur after the end keyframe.</p> </td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>This method applies the specified transition to the specified variable in the storyboard, with the transition starting and ending at the specified keyframes.  If the transition was created with a duration parameter specified, that duration is overwritten with the duration of time between the start and end keyframes. Otherwise, Windows Animation speeds up or slows down the transition as necessary.</p><p> A keyframe represents a moment in time within a storyboard and can be used to specify the start and end times of transitions. Because keyframes can be added at the ends of transitions, their offsets from the start of the storyboard may not be known until the storyboard is playing.</p><p>Transitions must be added in the order in which they will be played. A transition may begin playing before the preceding transition in the storyboard has finished, in which case the initial value and velocity seen by the new transition will be determined by the state of the preceding one. It must not be possible for a transition to begin before the start of the preceding transition.</p>
        /// </remarks>
        /// <doc-id>dd371798</doc-id>
        /// <unmanaged>HRESULT IUIAnimationStoryboard::AddTransitionBetweenKeyframes([In] IUIAnimationVariable* variable,[In] IUIAnimationTransition* transition,[In] __MIDL___MIDL_itf_UIAnimation_0000_0002_0003* startKeyframe,[In] __MIDL___MIDL_itf_UIAnimation_0000_0002_0003* endKeyframe)</unmanaged>
        /// <unmanaged-short>IUIAnimationStoryboard::AddTransitionBetweenKeyframes</unmanaged-short>
        public unsafe void AddTransitionBetweenKeyframes(SharpDX.Animation.Variable variable, SharpDX.Animation.Transition transition, System.IntPtr startKeyframe, System.IntPtr endKeyframe)
        {
            System.IntPtr variable_ = System.IntPtr.Zero;
            System.IntPtr transition_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            variable_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.Variable>(variable);
            transition_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.Transition>(transition);
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)variable_, (void *)transition_, (void *)startKeyframe, (void *)endKeyframe, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates a loop between two specified keyframes.</p>
        /// </summary>
        /// <param name = "startKeyframe"><dd> <p> The keyframe at which the loop is to begin.</p> </dd></param>
        /// <param name = "endKeyframe"><dd> <p> The keyframe at which the loop is to end. It must not be posssible for <em>endKeyframe</em> to occur earlier in the storyboard than <em>startKeyframe</em>.</p> </dd></param>
        /// <param name = "repetitionCount"><dd> <p> The number of times the loop is to be repeated; this parameter must be 0 or a positive number. Use <strong><strong>UI_ANIMATION_REPEAT_INDEFINITELY</strong></strong> (-1) to repeat the loop indefinitely until the storyboard is trimmed or concluded.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>UI_E_START_KEYFRAME_AFTER_END</strong></dt> </dl> </td><td> <p>The start keyframe might occur after the end keyframe.</p> </td></tr> <tr><td> <dl> <dt><strong>UI_E_END_KEYFRAME_NOT_DETERMINED</strong></dt> </dl> </td><td> <p>It might not be possible to determine the end keyframe time when the start keyframe is reached.</p> </td></tr> <tr><td> <dl> <dt><strong>UI_E_LOOPS_OVERLAP</strong></dt> </dl> </td><td> <p>Two repeated portions of a storyboard might overlap.</p> </td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>This method directs a storyboard to play the interval between the given keyframes repeatedly before playing the remainder of the storyboard. If a finite repetition count is specified, the loop always plays that number of times. If <strong><strong>UI_ANIMATION_REPEAT_INDEFINITELY</strong></strong> (-1) is specified, the loop repeats until the storyboard is concluded, in which case the current iteration of the loop completes and the remainder of the storyboard plays. A storyboard that loops indefinitely also ends if it is truncated.</p><p>Nested and overlapping loops are not supported.</p><p>A keyframe represents a moment in time within a storyboard and can be used to specify the start or end times of transitions.  Because keyframes can be added at the ends of transitions, their offsets from the start of the storyboard may not be known until the storyboard is playing.</p>
        /// </remarks>
        /// <doc-id>dd371816</doc-id>
        /// <unmanaged>HRESULT IUIAnimationStoryboard::RepeatBetweenKeyframes([In] __MIDL___MIDL_itf_UIAnimation_0000_0002_0003* startKeyframe,[In] __MIDL___MIDL_itf_UIAnimation_0000_0002_0003* endKeyframe,[In] int repetitionCount)</unmanaged>
        /// <unmanaged-short>IUIAnimationStoryboard::RepeatBetweenKeyframes</unmanaged-short>
        public unsafe void RepeatBetweenKeyframes(System.IntPtr startKeyframe, System.IntPtr endKeyframe, System.Int32 repetitionCount)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)startKeyframe, (void *)endKeyframe, repetitionCount, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Directs the storyboard to hold the specified animation variable at its final value until the storyboard ends.</p>
        /// </summary>
        /// <param name = "variable"><dd> <p> The animation variable.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p> When a storyboard is playing, it has exclusive access to any variables it animates unless the storyboard is trimmed by a higher priority storyboard. Typically, this exclusive access is released  when the last transition in the storyboard for that variable finishes playing. Applications can call this method to maintain exclusive access to the animation variable and hold the variable, at the final value of the last transition, until the end of the storyboard.</p>
        /// </remarks>
        /// <doc-id>dd371812</doc-id>
        /// <unmanaged>HRESULT IUIAnimationStoryboard::HoldVariable([In] IUIAnimationVariable* variable)</unmanaged>
        /// <unmanaged-short>IUIAnimationStoryboard::HoldVariable</unmanaged-short>
        public unsafe void HoldVariable(SharpDX.Animation.Variable variable)
        {
            System.IntPtr variable_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            variable_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.Variable>(variable);
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)variable_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Sets the longest acceptable delay before the scheduled storyboard begins.</p>
        /// </summary>
        /// <param name = "delay"><dd> <p> The longest acceptable delay. This parameter can be a positive value, or <strong>UI_ANIMATION_SECONDS_EVENTUALLY</strong> (-1) to indicate that any finite delay is acceptable.</p> </dd></param>
        /// <returns><p> If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.             </p></returns>
        /// <remarks>
        /// <p>For a storyboard to be successfully scheduled, it must begin before the longest acceptable delay has elapsed. This delay is determined in the following order: the delay value set by calling this method, the delay value set by calling the <strong>IUIAnimationManager::SetDefaultLongestAcceptableDelay</strong> method, or 0.0 if neither of these methods has been called.</p>
        /// </remarks>
        /// <doc-id>dd371824</doc-id>
        /// <unmanaged>HRESULT IUIAnimationStoryboard::SetLongestAcceptableDelay([In] double delay)</unmanaged>
        /// <unmanaged-short>IUIAnimationStoryboard::SetLongestAcceptableDelay</unmanaged-short>
        internal unsafe void SetLongestAcceptableDelay(System.Double delay)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, delay, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Directs the storyboard to schedule itself for play.</p>
        /// </summary>
        /// <param name = "timeNow"><dd> <p> The current time.</p> </dd></param>
        /// <returns><dd> <p>The result of the scheduling request. This parameter can be omitted from calls to this method.</p> </dd></returns>
        /// <remarks>
        /// <p>This method directs a storyboard to attempt to add itself to the schedule of playing storyboards. The rules are as follows:</p><ul> <li> <p>If there are no playing storyboards animating any of the same animation variables, the attempt succeeds and the storyboard starts playing immediately.</p> </li> <li> <p>If the storyboard has priority to cancel, trim, conclude, or compress conflicting storyboards, the attempt to schedule succeeds and the storyboard begins playing as soon as possible.</p> </li> <li> <p>If the storyboard does not have priority, the attempt fails and the <em>schedulingResult</em> parameter is set to <strong>UI_ANIMATION_SCHEDULING_INSUFFICIENT_PRIORITY</strong>.</p> </li> </ul><p>If this method is called from a handler for <strong>OnStoryboardStatusChanged</strong> events, the <em>schedulingResult</em> parameter is set to <strong>UI_ANIMATION_SCHEDULING_DEFERRED</strong>.  The only way to determine whether the storyboard is successfully scheduled is to set a storyboard event handler and check whether the storyboard's status ever becomes <strong>UI_ANIMATION_STORYBOARD_INSUFFICIENT_PRIORITY</strong>.</p><p>It is possible reuse a storyboard by calling <strong>Schedule</strong> again after its status has reached <strong>UI_ANIMATION_STORYBOARD_READY</strong>.  An attempt to schedule a storyboard when it is in any state other than <strong>UI_ANIMATION_STORYBOARD_BUILDING</strong> or <strong>UI_ANIMATION_STORYBOARD_READY</strong> fails, and  <em>schedulingResult</em> is set to <strong>UI_ANIMATION_SCHEDULING_ALREADY_SCHEDULED</strong>.</p>
        /// </remarks>
        /// <doc-id>dd371820</doc-id>
        /// <unmanaged>HRESULT IUIAnimationStoryboard::Schedule([In] double timeNow,[Out, Optional] UI_ANIMATION_SCHEDULING_RESULT* schedulingResult)</unmanaged>
        /// <unmanaged-short>IUIAnimationStoryboard::Schedule</unmanaged-short>
        public unsafe SharpDX.Animation.SchedulingResult Schedule(System.Double timeNow)
        {
            SharpDX.Animation.SchedulingResult schedulingResult;
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, timeNow, &schedulingResult, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
            return schedulingResult;
        }

        /// <summary>
        /// <p>Completes the current iteration of a keyframe loop that is in progress (where the loop is set to <strong>UI_ANIMATION_REPEAT_INDEFINITELY</strong>), terminates the loop, and continues with the storyboard. </p>
        /// </summary>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method specifies that any subsequent  keyframe loops that have a repetition count of <strong><strong>UI_ANIMATION_REPEAT_INDEFINITELY</strong></strong> (-1) will be skipped while the remainder of the storyboard is played.  </p><p>An iteration of a keyframe loop that is in progress will be completed before the remainder of the storyboard plays.</p><p>If this method is called  at the end  of a keyframe loop iteration, the loop is terminated and the loop value is set to the starting loop value.</p>
        /// </remarks>
        /// <doc-id>dd371801</doc-id>
        /// <unmanaged>HRESULT IUIAnimationStoryboard::Conclude()</unmanaged>
        /// <unmanaged-short>IUIAnimationStoryboard::Conclude</unmanaged-short>
        public unsafe void Conclude()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Finishes the storyboard within the specified time, compressing the storyboard if necessary.</p>
        /// </summary>
        /// <param name = "completionDeadline"><dd> <p> The maximum amount of time that the storyboard can use to finish playing.</p> </dd></param>
        /// <returns><p> If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method has no effect on storyboard events. Events continue to be raised as expected while the storyboard plays.</p>
        /// </remarks>
        /// <doc-id>dd371804</doc-id>
        /// <unmanaged>HRESULT IUIAnimationStoryboard::Finish([In] double completionDeadline)</unmanaged>
        /// <unmanaged-short>IUIAnimationStoryboard::Finish</unmanaged-short>
        public unsafe void Finish(System.Double completionDeadline)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, completionDeadline, (*(void ***)this._nativePointer)[13]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Terminates the storyboard, releases all related animation variables, and removes the storyboard from the schedule.</p>
        /// </summary>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p> This method can be called before or after the storyboard starts playing.</p><p>This method does not trigger any storyboard events.</p>
        /// </remarks>
        /// <doc-id>dd371779</doc-id>
        /// <unmanaged>HRESULT IUIAnimationStoryboard::Abandon()</unmanaged>
        /// <unmanaged-short>IUIAnimationStoryboard::Abandon</unmanaged-short>
        public unsafe void Abandon()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[14]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Sets the tag for the storyboard.</p>
        /// </summary>
        /// <param name = "@object"><dd> <p> The object portion of the tag.         This parameter can be <strong><c>null</c></strong>.</p> </dd></param>
        /// <param name = "id"><dd> <p> The identifier portion of the tag.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>UI_E_STORYBOARD_ACTIVE</strong></dt> </dl> </td><td> <p>The storyboard is currently in the schedule.</p> </td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p> A tag is a pairing of an integer identifier (<em>id</em>) with a COM object (<em>object</em>); it can be used by an application to identify a storyboard.</p>
        /// </remarks>
        /// <doc-id>dd371829</doc-id>
        /// <unmanaged>HRESULT IUIAnimationStoryboard::SetTag([In, Optional] IUnknown* object,[In] unsigned int id)</unmanaged>
        /// <unmanaged-short>IUIAnimationStoryboard::SetTag</unmanaged-short>
        internal unsafe void SetTag(System.IntPtr @object, System.Int32 id)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)@object, id, (*(void ***)this._nativePointer)[15]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Gets the tag for a storyboard.</p>
        /// </summary>
        /// <param name = "@object"><dd> <p> The object portion of the tag.</p> </dd></param>
        /// <param name = "id"><dd> <p> The identifier portion of the tag.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>UI_E_VALUE_NOT_SET</strong></dt> </dl> </td><td> <p>The storyboard's tag was not set.</p> </td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>A tag is a pairing of an integer identifier (<em>id</em>) with a COM object (<em>object</em>); it can be used by an application to identify a storyboard.</p><p>The parameters are optional so that the method can return both portions of the tag, or just the identifier or object portion.</p>
        /// </remarks>
        /// <doc-id>dd371809</doc-id>
        /// <unmanaged>HRESULT IUIAnimationStoryboard::GetTag([Out, Optional] IUnknown** object,[Out, Optional] unsigned int* id)</unmanaged>
        /// <unmanaged-short>IUIAnimationStoryboard::GetTag</unmanaged-short>
        internal unsafe void GetTag(out System.IntPtr @object, out System.Int32 id)
        {
            SharpDX.Result __result__;
            fixed (void *id_ = &id)
                fixed (void *@object_ = &@object)
                    __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, @object_, id_, (*(void ***)this._nativePointer)[16]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Gets the status of the storyboard.</p>
        /// </summary>
        /// <param name = "status"><dd> <p> The storyboard status.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Unless this method is called from a handler for <strong>OnStoryboardStatusChanged</strong> events, the only values it returns are <strong>UI_ANIMATION_STORYBOARD_BUILDING</strong>, <strong>UI_ANIMATION_STORYBOARD_SCHEDULED</strong>,
        /// <strong>UI_ANIMATION_STORYBOARD_PLAYING</strong>, and <strong>UI_ANIMATION_STORYBOARD_READY</strong>.</p>
        /// </remarks>
        /// <doc-id>dd371808</doc-id>
        /// <unmanaged>HRESULT IUIAnimationStoryboard::GetStatus([Out] UI_ANIMATION_STORYBOARD_STATUS* status)</unmanaged>
        /// <unmanaged-short>IUIAnimationStoryboard::GetStatus</unmanaged-short>
        internal unsafe void GetStatus(out SharpDX.Animation.StoryboardStatus status)
        {
            SharpDX.Result __result__;
            fixed (void *status_ = &status)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, status_, (*(void ***)this._nativePointer)[17]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Gets the time that has elapsed since the storyboard started playing.</p>
        /// </summary>
        /// <param name = "elapsedTime"><dd> <p> The elapsed time.</p> </dd></param>
        /// <returns><p> If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.             See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>UI_E_STORYBOARD_NOT_PLAYING</strong></dt> </dl> </td><td> <p>The storyboard is not playing.</p> </td></tr> </table><p>?</p></returns>
        /// <doc-id>dd371807</doc-id>
        /// <unmanaged>HRESULT IUIAnimationStoryboard::GetElapsedTime([Out] double* elapsedTime)</unmanaged>
        /// <unmanaged-short>IUIAnimationStoryboard::GetElapsedTime</unmanaged-short>
        internal unsafe void GetElapsedTime(out System.Double elapsedTime)
        {
            SharpDX.Result __result__;
            fixed (void *elapsedTime_ = &elapsedTime)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, elapsedTime_, (*(void ***)this._nativePointer)[18]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Specifies a handler for storyboard events.</p>
        /// </summary>
        /// <param name = "handler"><dd> <p> The handler to be called whenever storyboard status and update events occur. The specified object must implement the <strong><see cref = "SharpDX.Animation.StoryboardEventHandler"/></strong> interface or be <strong><c>null</c></strong>. See Remarks.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Passing <strong><c>null</c></strong> for the <em>handler</em> parameter causes Windows Animation to release its reference to any handler object you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong>IUIAnimationManager::Shutdown</strong> method.</p>
        /// </remarks>
        /// <doc-id>dd371827</doc-id>
        /// <unmanaged>HRESULT IUIAnimationStoryboard::SetStoryboardEventHandler([In, Optional] IUIAnimationStoryboardEventHandler* handler)</unmanaged>
        /// <unmanaged-short>IUIAnimationStoryboard::SetStoryboardEventHandler</unmanaged-short>
        internal unsafe void SetStoryboardEventHandler(SharpDX.Animation.StoryboardEventHandler handler)
        {
            System.IntPtr handler_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            handler_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.StoryboardEventHandler>(handler);
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)handler_, (*(void ***)this._nativePointer)[19]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("AE289CD2-12D4-4945-9419-9E41BE034DF2")]
    public partial class Storyboard2 : SharpDX.ComObject
    {
        public Storyboard2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Storyboard2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Storyboard2(nativePtr);
        /// <summary>
        /// <p> Sets the longest acceptable delay before the scheduled storyboard begins.</p>
        /// </summary>
        /// <remarks>
        /// <p>For Windows Animation to schedule a storyboard successfully, the storyboard must begin before the longest acceptable delay has elapsed. Windows Animation determines this delay in the following order: the delay value set by calling this method, the delay value set by calling the <strong>IUIAnimationManager2::SetDefaultLongestAcceptableDelay</strong> method, or 0.0 if neither of these methods has been called.</p><p> Use <strong>IUIAnimationStoryboard2::SetSkipDuration</strong> to start a storyboard animation at a specified offset instead of delaying the start of a storyboard.</p>
        /// </remarks>
        /// <doc-id>hh448595</doc-id>
        /// <unmanaged>SetLongestAcceptableDelay</unmanaged>
        /// <unmanaged-short>SetLongestAcceptableDelay</unmanaged-short>
        public System.Double LongestAcceptableDelay
        {
            set => SetLongestAcceptableDelay(value);
        }

        /// <summary>
        /// <p>Specifies an offset from the beginning of a storyboard at which to start animating.</p>
        /// </summary>
        /// <remarks>
        /// <p>Calls to <strong>SetSkipDuration</strong> fail if the storyboard has been scheduled.</p><p><strong>SetSkipDuration</strong> does not delay the start of a scheduled storyboard. See <strong>IUIAnimationStoryboard2::SetLongestAcceptableDelay</strong> for more info on how to set a delay for a scheduled storyboard.</p><p>This diagram shows a skip duration, or offset, for a storyboard. </p><p></p>
        /// </remarks>
        /// <doc-id>hh448596</doc-id>
        /// <unmanaged>SetSkipDuration</unmanaged>
        /// <unmanaged-short>SetSkipDuration</unmanaged-short>
        public System.Double SkipDuration
        {
            set => SetSkipDuration(value);
        }

        /// <summary>
        /// <p> Gets the status of the storyboard.</p>
        /// </summary>
        /// <remarks>
        /// <p>Unless this method is called from a handler for <strong>OnStoryboardStatusChanged</strong> events, the only values it returns are <strong>UI_ANIMATION_STORYBOARD_BUILDING</strong>, <strong>UI_ANIMATION_STORYBOARD_SCHEDULED</strong>,
        /// <strong>UI_ANIMATION_STORYBOARD_PLAYING</strong>, and <strong>UI_ANIMATION_STORYBOARD_READY</strong>.</p>
        /// </remarks>
        /// <doc-id>hh437188</doc-id>
        /// <unmanaged>GetStatus</unmanaged>
        /// <unmanaged-short>GetStatus</unmanaged-short>
        public SharpDX.Animation.StoryboardStatus Status
        {
            get
            {
                GetStatus(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p> Gets the time that has elapsed since the storyboard started playing.</p>
        /// </summary>
        /// <doc-id>hh437187</doc-id>
        /// <unmanaged>GetElapsedTime</unmanaged>
        /// <unmanaged-short>GetElapsedTime</unmanaged-short>
        public System.Double ElapsedTime
        {
            get
            {
                GetElapsedTime(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p> Adds a transition to the storyboard.</p>
        /// </summary>
        /// <param name = "variable"><dd> <p> The animation variable for which the transition is to be added.</p> </dd></param>
        /// <param name = "transition"><dd> <p> The transition to be added.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>UI_E_TRANSITION_ALREADY_USED</strong></dt> </dl> </td><td> <p>This transition has already been added to a storyboard.</p> </td></tr> </table><p>?</p><p>See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>The <strong>AddTransition</strong> method applies the specified transition to the specified variable in the storyboard. If this is the first transition applied to this variable in this storyboard, the transition begins at the start of the storyboard. Otherwise, the transition is appended to the transition that was most recently added to the variable.</p>
        /// </remarks>
        /// <doc-id>hh437182</doc-id>
        /// <unmanaged>HRESULT IUIAnimationStoryboard2::AddTransition([In] IUIAnimationVariable2* variable,[In] IUIAnimationTransition2* transition)</unmanaged>
        /// <unmanaged-short>IUIAnimationStoryboard2::AddTransition</unmanaged-short>
        public unsafe void AddTransition(SharpDX.Animation.Variable2 variable, SharpDX.Animation.Transition2 transition)
        {
            System.IntPtr variable_ = System.IntPtr.Zero;
            System.IntPtr transition_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            variable_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.Variable2>(variable);
            transition_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.Transition2>(transition);
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)variable_, (void *)transition_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Adds a keyframe at the specified offset from an existing keyframe.</p>
        /// </summary>
        /// <param name = "existingKeyframe"><dd> <p> The existing keyframe. To add a keyframe at an offset from the start of the storyboard, use the special keyframe <strong>UI_ANIMATION_KEYFRAME_STORYBOARD_START</strong>.</p> </dd></param>
        /// <param name = "offset"><dd> <p> The offset from the existing keyframe at which a new keyframe is to be added.</p> </dd></param>
        /// <param name = "keyframe"><dd> <p> The keyframe to be added.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>A keyframe represents a moment in time within a storyboard and can be used to specify the start and end times of transitions. Because keyframes can be added at the ends of transitions, their offsets from the start of the storyboard may not be known until the storyboard is playing.</p>
        /// </remarks>
        /// <doc-id>hh437181</doc-id>
        /// <unmanaged>HRESULT IUIAnimationStoryboard2::AddKeyframeAtOffset([In] __MIDL___MIDL_itf_UIAnimation_0000_0002_0003* existingKeyframe,[In] double offset,[Out] __MIDL___MIDL_itf_UIAnimation_0000_0002_0003** keyframe)</unmanaged>
        /// <unmanaged-short>IUIAnimationStoryboard2::AddKeyframeAtOffset</unmanaged-short>
        public unsafe void AddKeyframeAtOffset(System.IntPtr existingKeyframe, System.Double offset, out System.IntPtr keyframe)
        {
            SharpDX.Result __result__;
            fixed (void *keyframe_ = &keyframe)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)existingKeyframe, offset, keyframe_, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Adds a keyframe at the end of the specified transition.</p>
        /// </summary>
        /// <param name = "transition"><dd> <p> The transition after which a keyframe is to be added.</p> </dd></param>
        /// <param name = "keyframe"><dd> <p> The keyframe to be added.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>UI_E_TRANSITION_NOT_IN_STORYBOARD</strong></dt> </dl> </td><td> <p>The transition has not been added to the storyboard.</p> </td></tr> </table><p>?</p><p>See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p> A keyframe represents a moment in time within a storyboard and can be used to specify the start and end times of transitions. Because keyframes can be added at the ends of transitions, their offsets from the start of the storyboard may not be known until the storyboard is playing.</p>
        /// </remarks>
        /// <doc-id>hh437180</doc-id>
        /// <unmanaged>HRESULT IUIAnimationStoryboard2::AddKeyframeAfterTransition([In] IUIAnimationTransition2* transition,[Out] __MIDL___MIDL_itf_UIAnimation_0000_0002_0003** keyframe)</unmanaged>
        /// <unmanaged-short>IUIAnimationStoryboard2::AddKeyframeAfterTransition</unmanaged-short>
        public unsafe void AddKeyframeAfterTransition(SharpDX.Animation.Transition2 transition, out System.IntPtr keyframe)
        {
            System.IntPtr transition_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            transition_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.Transition2>(transition);
            fixed (void *keyframe_ = &keyframe)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)transition_, keyframe_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Adds a transition that starts at the specified keyframe.</p>
        /// </summary>
        /// <param name = "variable"><dd> <p> The animation variable for which a transition is to be added.</p> </dd></param>
        /// <param name = "transition"><dd> <p> The transition to be added.</p> </dd></param>
        /// <param name = "startKeyframe"><dd> <p> The keyframe that specifies the beginning of the new transition.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>UI_E_TRANSITION_ALREADY_USED</strong></dt> </dl> </td><td> <p>This transition has already been added to a storyboard or has been added to a storyboard that has finished playing and been released.</p> </td></tr> <tr><td> <dl> <dt><strong>UI_E_TRANSITION_ECLIPSED</strong></dt> </dl> </td><td> <p>The transition might eclipse the beginning of another transition in the storyboard.</p> </td></tr> </table><p>?</p><p>See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Transitions must be added in the order in which they will be played. A transition may begin playing before the preceding transition in the storyboard has finished, in which case the initial value and velocity seen by the new transition is determined by the state of the preceding one. A transition should not begin before the start of the preceding transition.</p><p>A keyframe represents a moment in time within a storyboard and can be used to specify the start and end times of transitions. Because keyframes can be added at the ends of transitions, their offsets from the start of the storyboard may not be known until the storyboard is playing.</p>
        /// </remarks>
        /// <doc-id>hh437183</doc-id>
        /// <unmanaged>HRESULT IUIAnimationStoryboard2::AddTransitionAtKeyframe([In] IUIAnimationVariable2* variable,[In] IUIAnimationTransition2* transition,[In] __MIDL___MIDL_itf_UIAnimation_0000_0002_0003* startKeyframe)</unmanaged>
        /// <unmanaged-short>IUIAnimationStoryboard2::AddTransitionAtKeyframe</unmanaged-short>
        public unsafe void AddTransitionAtKeyframe(SharpDX.Animation.Variable2 variable, SharpDX.Animation.Transition2 transition, System.IntPtr startKeyframe)
        {
            System.IntPtr variable_ = System.IntPtr.Zero;
            System.IntPtr transition_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            variable_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.Variable2>(variable);
            transition_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.Transition2>(transition);
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)variable_, (void *)transition_, (void *)startKeyframe, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Adds a transition between two keyframes.</p>
        /// </summary>
        /// <param name = "variable"><dd> <p> The animation variable for which the transition is to be added.</p> </dd></param>
        /// <param name = "transition"><dd> <p> The transition to be added.</p> </dd></param>
        /// <param name = "startKeyframe"><dd> <p> A keyframe that specifies the beginning of the new transition.</p> </dd></param>
        /// <param name = "endKeyframe"><dd> <p> A keyframe that specifies the end of the new transition. It must not be possible for <em>endKeyframe</em> to appear earlier in the storyboard than <em>startKeyframe</em>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>UI_E_TRANSITION_ALREADY_USED</strong></dt> </dl> </td><td> <p>This transition has already been added to a storyboard or has been added to a storyboard that has finished playing and been released.</p> </td></tr> <tr><td> <dl> <dt><strong>UI_E_TRANSITION_ECLIPSED</strong></dt> </dl> </td><td> <p>The transition might eclipse the beginning of another transition in the storyboard.</p> </td></tr> <tr><td> <dl> <dt><strong>UI_E_START_KEYFRAME_AFTER_END</strong></dt> </dl> </td><td> <p>The start keyframe might occur after the end keyframe.</p> </td></tr> </table><p>?</p><p>See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method applies the specified transition to the specified variable in the storyboard, with the transition starting and ending at the specified keyframes.  If the transition was created with a duration parameter specified, that duration is overwritten with the duration of time between the start and end keyframes. Otherwise, Windows Animation speeds up or slows down the transition as necessary.</p><p> A keyframe represents a moment in time within a storyboard and can be used to specify the start and end times of transitions. Because keyframes can be added at the ends of transitions, their offsets from the start of the storyboard may not be known until the storyboard is playing.</p><p>Transitions must be added in the order in which they will be played. A transition may begin playing before the preceding transition in the storyboard has finished, in which case the initial value and velocity seen by the new transition will be determined by the state of the preceding one. It must not be possible for a transition to begin before the start of the preceding transition.</p>
        /// </remarks>
        /// <doc-id>hh437184</doc-id>
        /// <unmanaged>HRESULT IUIAnimationStoryboard2::AddTransitionBetweenKeyframes([In] IUIAnimationVariable2* variable,[In] IUIAnimationTransition2* transition,[In] __MIDL___MIDL_itf_UIAnimation_0000_0002_0003* startKeyframe,[In] __MIDL___MIDL_itf_UIAnimation_0000_0002_0003* endKeyframe)</unmanaged>
        /// <unmanaged-short>IUIAnimationStoryboard2::AddTransitionBetweenKeyframes</unmanaged-short>
        public unsafe void AddTransitionBetweenKeyframes(SharpDX.Animation.Variable2 variable, SharpDX.Animation.Transition2 transition, System.IntPtr startKeyframe, System.IntPtr endKeyframe)
        {
            System.IntPtr variable_ = System.IntPtr.Zero;
            System.IntPtr transition_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            variable_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.Variable2>(variable);
            transition_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.Transition2>(transition);
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)variable_, (void *)transition_, (void *)startKeyframe, (void *)endKeyframe, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a loop between two keyframes.</p>
        /// </summary>
        /// <param name = "startKeyframe"><dd> <p>The keyframe at which the loop is to begin.</p> </dd></param>
        /// <param name = "endKeyframe"><dd> <p>The keyframe at which the loop is to end. <em>endKeyframe</em> must not occur earlier in the storyboard than <em>startKeyframe</em>.</p> </dd></param>
        /// <param name = "cRepetition"><dd> <p>The number of times the loop is to be repeated; the last iteration of a loop can terminate fractionally between keyframes. A value of  zero indicates that the specified portion of a storyboard will not be played.  A value of <strong>UI_ANIMATION_REPEAT_INDEFINITELY</strong> (-1) indicates that the loop will repeat indefinitely until the storyboard is trimmed or concluded.</p> </dd></param>
        /// <param name = "repeatMode"><dd> <p>The pattern for the loop iteration. </p> <p>A value of <strong>UI_ANIMATION_REPEAT_MODE_ALTERNATE</strong> (1) specifies that the  start of the loop must alternate between keyframes (k1-&gt;k2, k2-&gt;k1, k1-&gt;k2, and so on).</p> <p>A value of <strong>UI_ANIMATION_REPEAT_MODE_NORMAL</strong> (0) specifies that the start of the  loop must begin with the first keyframe (k1-&gt;k2, k1-&gt;k2, k1-&gt;k2, and so on).</p> <strong>Note</strong>??If <em>repeatMode</em> has a value of <strong>UI_ANIMATION_REPEAT_MODE_ALTERNATE</strong> (1) and <em>cRepetition</em> has a value of <strong>UI_ANIMATION_REPEAT_INDEFINITELY</strong> (-1), the loop terminates on the end keyframe. ? </dd></param>
        /// <param name = "iterationChangeHandlerRef"><dd> <p>The handler for each loop iteration event. The default value is 0.</p> </dd></param>
        /// <param name = "id"><dd> <p>The loop ID to pass to <em>pIterationChangeHandler</em>. The default value is 0.</p> </dd></param>
        /// <param name = "fRegisterForNextAnimationEvent"><dd> <p>If true, specifies that <em>pIterationChangeHandler</em> will be incorporated into the estimate of the time interval until the next animation event that is returned by the <strong>IUIAnimationManager2::EstimateNextEventTime</strong> method. The default value is 0, or false.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method directs a storyboard to play the interval between the given keyframes repeatedly before playing the remainder of the storyboard. If a finite repetition count is specified, the loop always plays that number of times. If <strong>UI_ANIMATION_REPEAT_INDEFINITELY</strong> (-1) is specified, the loop repeats until the storyboard is concluded, in which case the current iteration of the loop completes and the remainder of the storyboard plays. A storyboard that loops indefinitely also ends if it is truncated.</p><p>Nested and overlapping loops are not supported.</p><p>A keyframe represents a moment in time within a storyboard and can be used to specify the start or end times of transitions.  Because keyframes can be added at the ends of transitions, their offsets from the start of the storyboard may not be known until the storyboard is playing.</p>
        /// </remarks>
        /// <doc-id>hh448593</doc-id>
        /// <unmanaged>HRESULT IUIAnimationStoryboard2::RepeatBetweenKeyframes([In] __MIDL___MIDL_itf_UIAnimation_0000_0002_0003* startKeyframe,[In] __MIDL___MIDL_itf_UIAnimation_0000_0002_0003* endKeyframe,[In] double cRepetition,[In] UI_ANIMATION_REPEAT_MODE repeatMode,[In, Optional] IUIAnimationLoopIterationChangeHandler2* pIterationChangeHandler,[In] UINT_PTR id,[In] BOOL fRegisterForNextAnimationEvent)</unmanaged>
        /// <unmanaged-short>IUIAnimationStoryboard2::RepeatBetweenKeyframes</unmanaged-short>
        internal unsafe void RepeatBetweenKeyframes(System.IntPtr startKeyframe, System.IntPtr endKeyframe, System.Double cRepetition, SharpDX.Animation.RepeatMode repeatMode, SharpDX.Animation.LoopIterationChangeHandler2 iterationChangeHandlerRef, System.IntPtr id, SharpDX.Mathematics.Interop.RawBool fRegisterForNextAnimationEvent)
        {
            System.IntPtr iterationChangeHandlerRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            iterationChangeHandlerRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.LoopIterationChangeHandler2>(iterationChangeHandlerRef);
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint0(this._nativePointer, (void *)startKeyframe, (void *)endKeyframe, cRepetition, unchecked ((System.Int32)repeatMode), (void *)iterationChangeHandlerRef_, (void *)id, fRegisterForNextAnimationEvent, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Directs the storyboard to hold the specified animation variable at its final value until the storyboard ends.</p>
        /// </summary>
        /// <param name = "variable"><dd> <p> The animation variable.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p> When a storyboard is playing, it has exclusive access to any variables it animates unless the storyboard is trimmed by a higher-priority storyboard. Typically, this exclusive access is released  when the last transition in the storyboard for that variable finishes playing. Applications can call this method to maintain exclusive access to the animation variable and hold the variable, at the final value of the last transition, until the end of the storyboard.</p>
        /// </remarks>
        /// <doc-id>hh448592</doc-id>
        /// <unmanaged>HRESULT IUIAnimationStoryboard2::HoldVariable([In] IUIAnimationVariable2* variable)</unmanaged>
        /// <unmanaged-short>IUIAnimationStoryboard2::HoldVariable</unmanaged-short>
        public unsafe void HoldVariable(SharpDX.Animation.Variable2 variable)
        {
            System.IntPtr variable_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            variable_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.Variable2>(variable);
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)variable_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Sets the longest acceptable delay before the scheduled storyboard begins.</p>
        /// </summary>
        /// <param name = "delay"><dd> <p> The longest acceptable delay. This parameter can be a positive value, or <strong>UI_ANIMATION_SECONDS_EVENTUALLY</strong> (-1) to indicate that any finite delay is acceptable.</p> </dd></param>
        /// <returns><p>Returns <strong><see cref = "SharpDX.Result.Ok"/></strong> if successful; otherwise an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>For Windows Animation to schedule a storyboard successfully, the storyboard must begin before the longest acceptable delay has elapsed. Windows Animation determines this delay in the following order: the delay value set by calling this method, the delay value set by calling the <strong>IUIAnimationManager2::SetDefaultLongestAcceptableDelay</strong> method, or 0.0 if neither of these methods has been called.</p><p> Use <strong>IUIAnimationStoryboard2::SetSkipDuration</strong> to start a storyboard animation at a specified offset instead of delaying the start of a storyboard.</p>
        /// </remarks>
        /// <doc-id>hh448595</doc-id>
        /// <unmanaged>HRESULT IUIAnimationStoryboard2::SetLongestAcceptableDelay([In] double delay)</unmanaged>
        /// <unmanaged-short>IUIAnimationStoryboard2::SetLongestAcceptableDelay</unmanaged-short>
        internal unsafe void SetLongestAcceptableDelay(System.Double delay)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, delay, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Specifies an offset from the beginning of a storyboard at which to start animating.</p>
        /// </summary>
        /// <param name = "secondsDuration"><dd> <p>The offset, or amount of time, to skip at the beginning of the storyboard.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Calls to <strong>SetSkipDuration</strong> fail if the storyboard has been scheduled.</p><p><strong>SetSkipDuration</strong> does not delay the start of a scheduled storyboard. See <strong>IUIAnimationStoryboard2::SetLongestAcceptableDelay</strong> for more info on how to set a delay for a scheduled storyboard.</p><p>This diagram shows a skip duration, or offset, for a storyboard. </p><p></p>
        /// </remarks>
        /// <doc-id>hh448596</doc-id>
        /// <unmanaged>HRESULT IUIAnimationStoryboard2::SetSkipDuration([In] double secondsDuration)</unmanaged>
        /// <unmanaged-short>IUIAnimationStoryboard2::SetSkipDuration</unmanaged-short>
        internal unsafe void SetSkipDuration(System.Double secondsDuration)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, secondsDuration, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Directs the storyboard to schedule itself for play.</p>
        /// </summary>
        /// <param name = "timeNow"><dd> <p> The current time.</p> </dd></param>
        /// <param name = "schedulingResult"><dd> <p>The result of the scheduling request. You can omit this parameter from calls to this method.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method directs a storyboard to try to add itself to the schedule of playing storyboards, using these rules:</p><ul> <li> <p>If there are no playing storyboards animating any of the same animation variables, the attempt succeeds and the storyboard starts playing immediately.</p> </li> <li> <p>If the storyboard has priority to cancel, trim, conclude, or compress conflicting storyboards, the attempt to schedule succeeds and the storyboard starts playing as soon as possible.</p> </li> <li> <p>If the storyboard does not have priority, the attempt fails and the <em>schedulingResult</em> parameter is set to <strong>UI_ANIMATION_SCHEDULING_INSUFFICIENT_PRIORITY</strong>.</p> </li> </ul><p>If this method is called from a handler for <strong>OnStoryboardStatusChanged</strong> events, the <em>schedulingResult</em> parameter is set to <strong>UI_ANIMATION_SCHEDULING_DEFERRED</strong>.  The only way to determine whether the storyboard is successfully scheduled is to set a storyboard event handler and check whether the storyboard's status ever becomes <strong>UI_ANIMATION_SCHEDULING_INSUFFICIENT_PRIORITY</strong>.</p><p>It is possible to reuse a storyboard by calling <strong>Schedule</strong> again after its status has reached <strong>UI_ANIMATION_STORYBOARD_READY</strong>.  An attempt to schedule a storyboard when it is in any state other than <strong>UI_ANIMATION_STORYBOARD_BUILDING</strong> or <strong>UI_ANIMATION_STORYBOARD_READY</strong> fails, and  <em>schedulingResult</em> is set to <strong>UI_ANIMATION_SCHEDULING_ALREADY_SCHEDULED</strong>.</p>
        /// </remarks>
        /// <doc-id>hh448594</doc-id>
        /// <unmanaged>HRESULT IUIAnimationStoryboard2::Schedule([In] double timeNow,[Out, Optional] UI_ANIMATION_SCHEDULING_RESULT* schedulingResult)</unmanaged>
        /// <unmanaged-short>IUIAnimationStoryboard2::Schedule</unmanaged-short>
        public unsafe void Schedule(System.Double timeNow, out SharpDX.Animation.SchedulingResult schedulingResult)
        {
            SharpDX.Result __result__;
            fixed (void *schedulingResult_ = &schedulingResult)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, timeNow, schedulingResult_, (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Completes the current iteration of a keyframe loop that is in progress (where the loop is set to <strong>UI_ANIMATION_REPEAT_INDEFINITELY</strong>), terminates the loop, and continues with the storyboard. </p>
        /// </summary>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method specifies that any subsequent  keyframe loops that have a repetition count of <strong><strong>UI_ANIMATION_REPEAT_INDEFINITELY</strong></strong> (-1) will be skipped while the remainder of the storyboard is played.  </p><p>An iteration of a keyframe loop that is in progress will be completed before the remainder of the storyboard plays.</p><p>If this method is called at the end of an alternating keyframe loop iteration, the loop is terminated with the  loop value set to the ending loop value.</p><p> If this method is called at the end of a non-alternating keyframe loop iteration, where  "loop wrapping" results in the loop value being set to the starting value of the next iteration, the loop is executed once more in order for the loop value to be set to the ending loop value.</p><p>For alternating keyframe loops, each iteration has a starting value that is equivalent to the ending value of the preceding loop. In this case, "loop wrapping" is not an issue.</p>
        /// </remarks>
        /// <doc-id>hh437185</doc-id>
        /// <unmanaged>HRESULT IUIAnimationStoryboard2::Conclude()</unmanaged>
        /// <unmanaged-short>IUIAnimationStoryboard2::Conclude</unmanaged-short>
        public unsafe void Conclude()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[13]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Finishes the storyboard within the specified time, compressing the storyboard if necessary.</p>
        /// </summary>
        /// <param name = "completionDeadline"><dd> <p> The maximum amount of time that the storyboard can use to finish playing.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method has no effect on storyboard events. Events continue to be raised as expected while the storyboard plays.</p>
        /// </remarks>
        /// <doc-id>hh437186</doc-id>
        /// <unmanaged>HRESULT IUIAnimationStoryboard2::Finish([In] double completionDeadline)</unmanaged>
        /// <unmanaged-short>IUIAnimationStoryboard2::Finish</unmanaged-short>
        public unsafe void Finish(System.Double completionDeadline)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, completionDeadline, (*(void ***)this._nativePointer)[14]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Terminates the storyboard, releases all related animation variables, and removes the storyboard from the schedule.</p>
        /// </summary>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p> This method can be called before or after the storyboard starts playing.</p><p>This method does not trigger any storyboard events.</p>
        /// </remarks>
        /// <doc-id>hh437179</doc-id>
        /// <unmanaged>HRESULT IUIAnimationStoryboard2::Abandon()</unmanaged>
        /// <unmanaged-short>IUIAnimationStoryboard2::Abandon</unmanaged-short>
        public unsafe void Abandon()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[15]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Sets the tag for the storyboard.</p>
        /// </summary>
        /// <param name = "@object"><dd> <p> The object portion of the tag.         This parameter can be <c>null</c>.</p> </dd></param>
        /// <param name = "id"><dd> <p> The identifier portion of the tag.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p> A tag is a pairing of an integer identifier (<em>id</em>) with a COM object (<em>object</em>). It can be used by an application to identify a storyboard.</p>
        /// </remarks>
        /// <doc-id>hh448598</doc-id>
        /// <unmanaged>HRESULT IUIAnimationStoryboard2::SetTag([In, Optional] IUnknown* object,[In] unsigned int id)</unmanaged>
        /// <unmanaged-short>IUIAnimationStoryboard2::SetTag</unmanaged-short>
        public unsafe void SetTag(SharpDX.IUnknown @object, System.Int32 id)
        {
            System.IntPtr @object_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            @object_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(@object);
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)@object_, id, (*(void ***)this._nativePointer)[16]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Gets the tag for a storyboard.</p>
        /// </summary>
        /// <param name = "@object"><dd> <p> The object portion of the tag.</p> </dd></param>
        /// <param name = "id"><dd> <p> The identifier portion of the tag.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>UI_E_VALUE_NOT_SET</strong></dt> </dl> </td><td> <p>The storyboard tag was not set.</p> </td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>A tag is a pairing of an integer identifier (<em>id</em>) with a COM object (<em>object</em>); it can be used by an application to identify a storyboard.</p><p>This method can return the identifier, the object, or both portions of the tag.</p>
        /// </remarks>
        /// <doc-id>hh437189</doc-id>
        /// <unmanaged>HRESULT IUIAnimationStoryboard2::GetTag([Out, Optional] IUnknown** object,[Out, Optional] unsigned int* id)</unmanaged>
        /// <unmanaged-short>IUIAnimationStoryboard2::GetTag</unmanaged-short>
        public unsafe void GetTag(out SharpDX.IUnknown @object, out System.Int32 id)
        {
            System.IntPtr @object_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *id_ = &id)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, &@object_, id_, (*(void ***)this._nativePointer)[17]);
            if (@object_ != System.IntPtr.Zero)
                @object = new SharpDX.ComObject(@object_);
            else
                @object = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Gets the status of the storyboard.</p>
        /// </summary>
        /// <param name = "status"><dd> <p> The storyboard status.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Unless this method is called from a handler for <strong>OnStoryboardStatusChanged</strong> events, the only values it returns are <strong>UI_ANIMATION_STORYBOARD_BUILDING</strong>, <strong>UI_ANIMATION_STORYBOARD_SCHEDULED</strong>,
        /// <strong>UI_ANIMATION_STORYBOARD_PLAYING</strong>, and <strong>UI_ANIMATION_STORYBOARD_READY</strong>.</p>
        /// </remarks>
        /// <doc-id>hh437188</doc-id>
        /// <unmanaged>HRESULT IUIAnimationStoryboard2::GetStatus([Out] UI_ANIMATION_STORYBOARD_STATUS* status)</unmanaged>
        /// <unmanaged-short>IUIAnimationStoryboard2::GetStatus</unmanaged-short>
        internal unsafe void GetStatus(out SharpDX.Animation.StoryboardStatus status)
        {
            SharpDX.Result __result__;
            fixed (void *status_ = &status)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, status_, (*(void ***)this._nativePointer)[18]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Gets the time that has elapsed since the storyboard started playing.</p>
        /// </summary>
        /// <param name = "elapsedTime"><dd> <p> The elapsed time.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>UI_E_STORYBOARD_NOT_PLAYING</strong></dt> </dl> </td><td> <p>The storyboard is not playing.</p> </td></tr> </table><p>?</p></returns>
        /// <doc-id>hh437187</doc-id>
        /// <unmanaged>HRESULT IUIAnimationStoryboard2::GetElapsedTime([Out] double* elapsedTime)</unmanaged>
        /// <unmanaged-short>IUIAnimationStoryboard2::GetElapsedTime</unmanaged-short>
        internal unsafe void GetElapsedTime(out System.Double elapsedTime)
        {
            SharpDX.Result __result__;
            fixed (void *elapsedTime_ = &elapsedTime)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, elapsedTime_, (*(void ***)this._nativePointer)[19]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Specifies a handler for storyboard events.</p>
        /// </summary>
        /// <param name = "handler"><dd> <p> The handler that Windows Animation should call whenever storyboard status and update events occur. The specified object must implement the <strong><see cref = "SharpDX.Animation.StoryboardEventHandler2"/></strong> interface or be <strong><c>null</c></strong>. See Remarks for more info.</p> </dd></param>
        /// <param name = "fRegisterStatusChangeForNextAnimationEvent"><dd> <p>If <strong>TRUE</strong>, registers the <strong>OnStoryboardStatusChanged</strong> event and includes those events in <strong>IUIAnimationManager2::EstimateNextEventTime</strong>, which estimates the time interval until the next animation event. No default value.</p> </dd></param>
        /// <param name = "fRegisterUpdateForNextAnimationEvent"><dd> <p>If <strong>TRUE</strong>, registers the <strong>OnStoryboardUpdated</strong> event and includes those events in <strong>IUIAnimationManager2::EstimateNextEventTime</strong>, which estimates the time interval until the next animation event. No default value.</p> </dd></param>
        /// <returns><p>Returns <strong><see cref = "SharpDX.Result.Ok"/></strong> if successful; otherwise an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Passing <strong><c>null</c></strong> for the <em>handler</em> parameter causes Windows Animation to release its reference to any handler object that you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong>IUIAnimationManager2::Shutdown</strong> method.</p>
        /// </remarks>
        /// <doc-id>hh448597</doc-id>
        /// <unmanaged>HRESULT IUIAnimationStoryboard2::SetStoryboardEventHandler([In, Optional] IUIAnimationStoryboardEventHandler2* handler,[In] BOOL fRegisterStatusChangeForNextAnimationEvent,[In] BOOL fRegisterUpdateForNextAnimationEvent)</unmanaged>
        /// <unmanaged-short>IUIAnimationStoryboard2::SetStoryboardEventHandler</unmanaged-short>
        internal unsafe void SetStoryboardEventHandler(SharpDX.Animation.StoryboardEventHandler2 handler, SharpDX.Mathematics.Interop.RawBool fRegisterStatusChangeForNextAnimationEvent, SharpDX.Mathematics.Interop.RawBool fRegisterUpdateForNextAnimationEvent)
        {
            System.IntPtr handler_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            handler_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.StoryboardEventHandler2>(handler);
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint0(this._nativePointer, (void *)handler_, fRegisterStatusChangeForNextAnimationEvent, fRegisterUpdateForNextAnimationEvent, (*(void ***)this._nativePointer)[20]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("3D5C9008-EC7C-4364-9F8A-9AF3C58CBAE6")]
    internal partial interface StoryboardEventHandler : SharpDX.IUnknown
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("BAC5F55A-BA7C-414C-B599-FBF850F553C6")]
    internal partial interface StoryboardEventHandler2 : SharpDX.IUnknown
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("6B0EFAD1-A053-41d6-9085-33A689144665")]
    public partial class Timer : SharpDX.ComObject
    {
        public Timer(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Timer(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Timer(nativePtr);
        /// <summary>
        /// <p> Gets the current time.</p>
        /// </summary>
        /// <remarks>
        /// <p> This method can be used in both the application-driven and timer-driven  configurations to retrieve the system time in <strong>UI_ANIMATION_SECONDS</strong>, the units used throughout the Windows Animation API.</p>
        /// </remarks>
        /// <doc-id>dd371869</doc-id>
        /// <unmanaged>GetTime</unmanaged>
        /// <unmanaged-short>GetTime</unmanaged-short>
        public System.Double Time
        {
            get
            {
                GetTime(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p> Sets the frame rate below which the timer notifies the application that rendering is too slow.</p>
        /// </summary>
        /// <remarks>
        /// <p> If the rendering frame rate for an animation falls below the specified frame rate, an  <strong>IUIAnimationTimerEventHandler::OnRenderingTooSlow</strong> event is raised.</p>
        /// </remarks>
        /// <doc-id>dd756727</doc-id>
        /// <unmanaged>SetFrameRateThreshold</unmanaged>
        /// <unmanaged-short>SetFrameRateThreshold</unmanaged-short>
        public System.Int32 FrameRateThreshold
        {
            set => SetFrameRateThreshold(value);
        }

        /// <summary>
        /// <p> Specifies a timer update handler.</p>
        /// </summary>
        /// <param name = "updateHandler"><dd> <p> A timer update handler, or <strong><c>null</c></strong> (see Remarks).  The specified object must implement the <strong><see cref = "SharpDX.Animation.TimerUpdateHandler"/></strong> interface.</p> </dd></param>
        /// <param name = "idleBehavior"><dd> <p> A member of  <strong><see cref = "SharpDX.Animation.IdleBehavior"/></strong> that specifies the behavior of the timer when it is idle.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. If the update handler is already connected to a timer, this method returns <strong>UI_E_TIMER_CLIENT_ALREADY_CONNECTED</strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p> The timer update handler receives time updates (ticks) from the timer. The timer indicates an update by calling  the <strong>IUIAnimationTimerUpdateHandler::OnUpdate</strong> method on the specified handler.</p><p>Passing <strong><c>null</c></strong> for the <em>updateHandler</em> parameter causes Windows Animation to release its reference to any handler object you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong>IUIAnimationManager::Shutdown</strong> method.</p>
        /// </remarks>
        /// <doc-id>dd371884</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTimer::SetTimerUpdateHandler([In, Optional] IUIAnimationTimerUpdateHandler* updateHandler,[In] UI_ANIMATION_IDLE_BEHAVIOR idleBehavior)</unmanaged>
        /// <unmanaged-short>IUIAnimationTimer::SetTimerUpdateHandler</unmanaged-short>
        internal unsafe void SetTimerUpdateHandler(SharpDX.Animation.TimerUpdateHandler updateHandler, SharpDX.Animation.IdleBehavior idleBehavior)
        {
            System.IntPtr updateHandler_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            updateHandler_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.TimerUpdateHandler>(updateHandler);
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)updateHandler_, unchecked ((System.Int32)idleBehavior), (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Specifies a timer event handler.</p>
        /// </summary>
        /// <param name = "handler"><dd> <p> A timer event handler.  The specified object must implement the <strong><see cref = "SharpDX.Animation.TimerEventHandler"/></strong> interface or be <strong><c>null</c></strong>. See Remarks.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p> Timing events include the <strong>OnPreUpdate</strong>, <strong>OnPostUpdate</strong>, and <strong>OnRenderingTooSlow</strong> methods of the <strong><see cref = "SharpDX.Animation.TimerEventHandler"/></strong> interface.</p><p>Passing <strong><c>null</c></strong> for the <em>handler</em> parameter causes Windows Animation to release its reference to any handler object you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong>IUIAnimationManager::Shutdown</strong> method.</p>
        /// </remarks>
        /// <doc-id>dd371881</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTimer::SetTimerEventHandler([In, Optional] IUIAnimationTimerEventHandler* handler)</unmanaged>
        /// <unmanaged-short>IUIAnimationTimer::SetTimerEventHandler</unmanaged-short>
        internal unsafe void SetTimerEventHandler(SharpDX.Animation.TimerEventHandler handler)
        {
            System.IntPtr handler_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            handler_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.TimerEventHandler>(handler);
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)handler_, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Enables the animation timer.</p>
        /// </summary>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <doc-id>dd371866</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTimer::Enable()</unmanaged>
        /// <unmanaged-short>IUIAnimationTimer::Enable</unmanaged-short>
        public unsafe void Enable()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Disables the animation timer.</p>
        /// </summary>
        /// <returns><p> If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <doc-id>dd371863</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTimer::Disable()</unmanaged>
        /// <unmanaged-short>IUIAnimationTimer::Disable</unmanaged-short>
        public unsafe void Disable()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Determines whether the timer is currently enabled.</p>
        /// </summary>
        /// <returns><p> Returns <see cref = "SharpDX.Result.Ok"/> if the animation timer is enabled, S_FALSE if the animation timer is disabled, or an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <doc-id>dd371873</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTimer::IsEnabled()</unmanaged>
        /// <unmanaged-short>IUIAnimationTimer::IsEnabled</unmanaged-short>
        internal unsafe SharpDX.Result IsEnabled_()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[7]);
            return __result__;
        }

        /// <summary>
        /// <p> Gets the current time.</p>
        /// </summary>
        /// <param name = "seconds"><dd> <p> The current time, in <strong>UI_ANIMATION_SECONDS</strong>.</p> </dd></param>
        /// <returns><p> If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See Windows Animation Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p> This method can be used in both the application-driven and timer-driven  configurations to retrieve the system time in <strong>UI_ANIMATION_SECONDS</strong>, the units used throughout the Windows Animation API.</p>
        /// </remarks>
        /// <doc-id>dd371869</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTimer::GetTime([Out] double* seconds)</unmanaged>
        /// <unmanaged-short>IUIAnimationTimer::GetTime</unmanaged-short>
        internal unsafe void GetTime(out System.Double seconds)
        {
            SharpDX.Result __result__;
            fixed (void *seconds_ = &seconds)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, seconds_, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Sets the frame rate below which the timer notifies the application that rendering is too slow.</p>
        /// </summary>
        /// <param name = "framesPerSecond"><dd> <p> The minimum desirable frame rate, in frames per second.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p> If the rendering frame rate for an animation falls below the specified frame rate, an  <strong>IUIAnimationTimerEventHandler::OnRenderingTooSlow</strong> event is raised.</p>
        /// </remarks>
        /// <doc-id>dd756727</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTimer::SetFrameRateThreshold([In] unsigned int framesPerSecond)</unmanaged>
        /// <unmanaged-short>IUIAnimationTimer::SetFrameRateThreshold</unmanaged-short>
        internal unsafe void SetFrameRateThreshold(System.Int32 framesPerSecond)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, framesPerSecond, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("BEDB4DB6-94FA-4bfb-A47F-EF2D9E408C25")]
    internal partial interface TimerClientEventHandler : SharpDX.IUnknown
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("274A7DEA-D771-4095-ABBD-8DF7ABD23CE3")]
    internal partial interface TimerEventHandler : SharpDX.IUnknown
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("195509B7-5D5E-4e3e-B278-EE3759B367AD")]
    internal partial interface TimerUpdateHandler : SharpDX.IUnknown
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("DC6CE252-F731-41cf-B610-614B6CA049AD")]
    public partial class Transition : SharpDX.ComObject
    {
        public Transition(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Transition(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Transition(nativePtr);
        /// <summary>
        /// <p> Sets the initial value for the transition.</p>
        /// </summary>
        /// <remarks>
        /// <p>This method should not be called after the transition has been added to a storyboard.</p>
        /// </remarks>
        /// <doc-id>dd371960</doc-id>
        /// <unmanaged>SetInitialValue</unmanaged>
        /// <unmanaged-short>SetInitialValue</unmanaged-short>
        public System.Double InitialValue
        {
            set => SetInitialValue(value);
        }

        /// <summary>
        /// <p> Sets the initial velocity for the transition.</p>
        /// </summary>
        /// <remarks>
        /// <p>This method should not be called after the transition has been added to a storyboard.</p>
        /// </remarks>
        /// <doc-id>dd371964</doc-id>
        /// <unmanaged>SetInitialVelocity</unmanaged>
        /// <unmanaged-short>SetInitialVelocity</unmanaged-short>
        public System.Double InitialVelocity
        {
            set => SetInitialVelocity(value);
        }

        /// <summary>
        /// <p> Gets the duration of the transition.</p>
        /// </summary>
        /// <remarks>
        /// <p>An application should typically call the <strong>IUIAnimationTransition::IsDurationKnown</strong> method before calling this method. This method should not be called when the storyboard to which the transition has been added is scheduled or playing.</p>
        /// </remarks>
        /// <doc-id>dd371951</doc-id>
        /// <unmanaged>GetDuration</unmanaged>
        /// <unmanaged-short>GetDuration</unmanaged-short>
        public System.Double Duration
        {
            get
            {
                GetDuration(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p> Sets the initial value for the transition.</p>
        /// </summary>
        /// <param name = "value"><dd> <p>The initial value for the transition.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method should not be called after the transition has been added to a storyboard.</p>
        /// </remarks>
        /// <doc-id>dd371960</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransition::SetInitialValue([In] double value)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransition::SetInitialValue</unmanaged-short>
        internal unsafe void SetInitialValue(System.Double value)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, value, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Sets the initial velocity for the transition.</p>
        /// </summary>
        /// <param name = "velocity"><dd> <p>The initial velocity for the transition.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method should not be called after the transition has been added to a storyboard.</p>
        /// </remarks>
        /// <doc-id>dd371964</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransition::SetInitialVelocity([In] double velocity)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransition::SetInitialVelocity</unmanaged-short>
        internal unsafe void SetInitialVelocity(System.Double velocity)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, velocity, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Determines whether a transition's duration is currently known.</p>
        /// </summary>
        /// <returns><p> Returns <see cref = "SharpDX.Result.Ok"/> if the duration is known, S_FALSE if the duration is not known, or an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>UI_E_STORYBOARD_ACTIVE</strong></dt> </dl> </td><td> <p>The storyboard for this transition is currently in schedule.</p> </td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>This method should not be called when the storyboard to which the transition has been added is scheduled or playing.</p>
        /// </remarks>
        /// <doc-id>dd371957</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransition::IsDurationKnown()</unmanaged>
        /// <unmanaged-short>IUIAnimationTransition::IsDurationKnown</unmanaged-short>
        internal unsafe SharpDX.Result IsDurationKnown_()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[5]);
            return __result__;
        }

        /// <summary>
        /// <p> Gets the duration of the transition.</p>
        /// </summary>
        /// <param name = "duration"><dd> <p>The duration of the transition, in seconds.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>UI_E_VALUE_NOT_DETERMINED</strong></dt> </dl> </td><td> <p>The requested value for the duration cannot be determined.</p> </td></tr> <tr><td> <dl> <dt><strong>UI_E_STORYBOARD_ACTIVE</strong></dt> </dl> </td><td> <p>The storyboard for this transition is currently in the schedule.</p> </td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>An application should typically call the <strong>IUIAnimationTransition::IsDurationKnown</strong> method before calling this method. This method should not be called when the storyboard to which the transition has been added is scheduled or playing.</p>
        /// </remarks>
        /// <doc-id>dd371951</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransition::GetDuration([Out] double* duration)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransition::GetDuration</unmanaged-short>
        internal unsafe void GetDuration(out System.Double duration)
        {
            SharpDX.Result __result__;
            fixed (void *duration_ = &duration)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, duration_, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("62FF9123-A85A-4e9b-A218-435A93E268FD")]
    public partial class Transition2 : SharpDX.ComObject
    {
        public Transition2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Transition2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Transition2(nativePtr);
        /// <summary>
        /// <p>Gets the number of dimensions in which the animation variable has a transition specified.</p>
        /// </summary>
        /// <doc-id>hh448603</doc-id>
        /// <unmanaged>GetDimension</unmanaged>
        /// <unmanaged-short>GetDimension</unmanaged-short>
        public System.Int32 Dimension
        {
            get
            {
                GetDimension(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Sets the initial value of the transition.</p>
        /// </summary>
        /// <remarks>
        /// <p>Do not call this method after the transition has been added to a storyboard.</p>
        /// </remarks>
        /// <doc-id>hh448606</doc-id>
        /// <unmanaged>SetInitialValue</unmanaged>
        /// <unmanaged-short>SetInitialValue</unmanaged-short>
        public System.Double InitialValue
        {
            set => SetInitialValue(value);
        }

        /// <summary>
        /// <p>Sets the initial velocity of the transition.</p>
        /// </summary>
        /// <doc-id>hh448609</doc-id>
        /// <unmanaged>SetInitialVelocity</unmanaged>
        /// <unmanaged-short>SetInitialVelocity</unmanaged-short>
        public System.Double InitialVelocity
        {
            set => SetInitialVelocity(value);
        }

        /// <summary>
        /// <p>Determines whether the duration of a transition is known.</p>
        /// </summary>
        /// <remarks>
        /// <p>This method should not be called when the storyboard to which the transition has been added is scheduled or playing.</p>
        /// </remarks>
        /// <doc-id>hh448605</doc-id>
        /// <unmanaged>IsDurationKnown</unmanaged>
        /// <unmanaged-short>IsDurationKnown</unmanaged-short>
        public SharpDX.Result IsDurationKnown
        {
            get => IsDurationKnown_();
        }

        /// <summary>
        /// <p> Gets the duration of the transition.</p>
        /// </summary>
        /// <remarks>
        /// <p>An application should typically call the <strong>IsDurationKnown</strong> method before calling this method. </p><p>This method should not be called when the storyboard to which the transition has been added is scheduled or playing.</p>
        /// </remarks>
        /// <doc-id>hh448604</doc-id>
        /// <unmanaged>GetDuration</unmanaged>
        /// <unmanaged-short>GetDuration</unmanaged-short>
        public System.Double Duration
        {
            get
            {
                GetDuration(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the number of dimensions in which the animation variable has a transition specified.</p>
        /// </summary>
        /// <param name = "dimension"><dd> <p>The number of dimensions.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <doc-id>hh448603</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransition2::GetDimension([Out] unsigned int* dimension)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransition2::GetDimension</unmanaged-short>
        internal unsafe void GetDimension(out System.Int32 dimension)
        {
            SharpDX.Result __result__;
            fixed (void *dimension_ = &dimension)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, dimension_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the initial value of the transition.</p>
        /// </summary>
        /// <param name = "value"><dd> <p>The initial value for the transition.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Do not call this method after the transition has been added to a storyboard.</p>
        /// </remarks>
        /// <doc-id>hh448606</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransition2::SetInitialValue([In] double value)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransition2::SetInitialValue</unmanaged-short>
        internal unsafe void SetInitialValue(System.Double value)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, value, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the initial value of the transition for each specified dimension in the animation variable.</p>
        /// </summary>
        /// <param name = "value"><dd> <p>A vector (of size <em>cDimension</em>) that contains  the initial values for the transition.</p> </dd></param>
        /// <param name = "cDimension"><dd> <p>The number of dimensions that require transition values. This parameter specifies the number of values listed in <em>value</em>.</p> </dd></param>
        /// <returns><p>Returns <strong><see cref = "SharpDX.Result.Ok"/></strong> if successful; otherwise an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>The animation manager should not call this method after the transition has been added to a storyboard.</p>
        /// </remarks>
        /// <doc-id>hh448607</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransition2::SetInitialVectorValue([In, Buffer] const double* value,[In] unsigned int cDimension)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransition2::SetInitialVectorValue</unmanaged-short>
        public unsafe void SetInitialVectorValue(System.Double[] value, System.Int32 cDimension)
        {
            SharpDX.Result __result__;
            fixed (void *value_ = value)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, value_, cDimension, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the initial velocity of the transition.</p>
        /// </summary>
        /// <param name = "velocity"><dd> <p>The initial velocity for the transition.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <doc-id>hh448609</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransition2::SetInitialVelocity([In] double velocity)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransition2::SetInitialVelocity</unmanaged-short>
        internal unsafe void SetInitialVelocity(System.Double velocity)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, velocity, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the initial velocity of the transition for each specified dimension in the animation variable.</p>
        /// </summary>
        /// <param name = "velocity"><dd> <p>A vector (of size <em>cDimension</em>) that contains  the initial velocities for the transition.</p> </dd></param>
        /// <param name = "cDimension"><dd> <p>The number of dimensions that require transition velocities. This parameter specifies the number of values listed in <em>velocity</em>.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <doc-id>hh448608</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransition2::SetInitialVectorVelocity([In, Buffer] const double* velocity,[In] unsigned int cDimension)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransition2::SetInitialVectorVelocity</unmanaged-short>
        public unsafe void SetInitialVectorVelocity(System.Double[] velocity, System.Int32 cDimension)
        {
            SharpDX.Result __result__;
            fixed (void *velocity_ = velocity)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, velocity_, cDimension, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Determines whether the duration of a transition is known.</p>
        /// </summary>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method should not be called when the storyboard to which the transition has been added is scheduled or playing.</p>
        /// </remarks>
        /// <doc-id>hh448605</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransition2::IsDurationKnown()</unmanaged>
        /// <unmanaged-short>IUIAnimationTransition2::IsDurationKnown</unmanaged-short>
        internal unsafe SharpDX.Result IsDurationKnown_()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
            return __result__;
        }

        /// <summary>
        /// <p> Gets the duration of the transition.</p>
        /// </summary>
        /// <param name = "duration"><dd> <p>The duration of the transition, in seconds.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>An application should typically call the <strong>IsDurationKnown</strong> method before calling this method. </p><p>This method should not be called when the storyboard to which the transition has been added is scheduled or playing.</p>
        /// </remarks>
        /// <doc-id>hh448604</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransition2::GetDuration([Out] double* duration)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransition2::GetDuration</unmanaged-short>
        internal unsafe void GetDuration(out System.Double duration)
        {
            SharpDX.Result __result__;
            fixed (void *duration_ = &duration)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, duration_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("FCD91E03-3E3B-45ad-BBB1-6DFC8153743D")]
    public partial class TransitionFactory : SharpDX.ComObject
    {
        public TransitionFactory(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator TransitionFactory(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new TransitionFactory(nativePtr);
        /// <summary>
        /// <p> Creates a transition from a custom interpolator.</p>
        /// </summary>
        /// <param name = "interpolator"><dd> <p> The interpolator from which a transition is to be created.   The specified object must implement the <strong><see cref = "SharpDX.Animation.Interpolator"/></strong> interface.</p> </dd></param>
        /// <param name = "transition"><dd> <p> The new transition.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <doc-id>dd371894</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransitionFactory::CreateTransition([In] IUIAnimationInterpolator* interpolator,[Out, Fast] IUIAnimationTransition** transition)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransitionFactory::CreateTransition</unmanaged-short>
        internal unsafe void CreateTransition(SharpDX.Animation.Interpolator interpolator, SharpDX.Animation.Transition transition)
        {
            System.IntPtr interpolator_ = System.IntPtr.Zero;
            System.IntPtr transition_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            interpolator_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.Interpolator>(interpolator);
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)interpolator_, &transition_, (*(void ***)this._nativePointer)[3]);
            (transition).NativePointer = transition_;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("937D4916-C1A6-42d5-88D8-30344D6EFE31")]
    public partial class TransitionFactory2 : SharpDX.ComObject
    {
        public TransitionFactory2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator TransitionFactory2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new TransitionFactory2(nativePtr);
        /// <summary>
        /// <p>Creates a transition from a custom interpolator for a given dimension.</p>
        /// </summary>
        /// <param name = "interpolator"><dd> <p> The interpolator from which a transition is to be created.   The specified object must implement the <strong><see cref = "SharpDX.Animation.Interpolator2"/></strong> interface.</p> </dd></param>
        /// <param name = "transition"><dd> <p>The new transition.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.  See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <doc-id>hh448611</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransitionFactory2::CreateTransition([In] IUIAnimationInterpolator2* interpolator,[Out] IUIAnimationTransition2** transition)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransitionFactory2::CreateTransition</unmanaged-short>
        public unsafe void CreateTransition(SharpDX.Animation.Interpolator2 interpolator, out SharpDX.Animation.Transition2 transition)
        {
            System.IntPtr interpolator_ = System.IntPtr.Zero;
            System.IntPtr transition_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            interpolator_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.Interpolator2>(interpolator);
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)interpolator_, &transition_, (*(void ***)this._nativePointer)[3]);
            if (transition_ != System.IntPtr.Zero)
                transition = new SharpDX.Animation.Transition2(transition_);
            else
                transition = null;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("CA5A14B1-D24F-48b8-8FE4-C78169BA954E")]
    public partial class TransitionLibrary : SharpDX.ComObject
    {
        public TransitionLibrary(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator TransitionLibrary(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new TransitionLibrary(nativePtr);
        /// <summary>
        /// <p> Creates an instantaneous transition.</p>
        /// </summary>
        /// <param name = "finalValue"><dd> <p> The value of the animation variable at the end of the transition.</p> </dd></param>
        /// <returns><dd> <p> The new instantaneous transition.</p> </dd></returns>
        /// <remarks>
        /// <p>During an instantaneous transition, the value of the animation variable changes instantly from its current value to a specified final value. The duration of this transition is always zero.</p><p>The figure below shows the effect on an animation variable over time during an instantaneous transition.</p><p></p>
        /// </remarks>
        /// <doc-id>dd371914</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary::CreateInstantaneousTransition([In] double finalValue,[Out] IUIAnimationTransition** transition)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransitionLibrary::CreateInstantaneousTransition</unmanaged-short>
        public unsafe SharpDX.Animation.Transition Instantaneous(System.Double finalValue)
        {
            SharpDX.Animation.Transition transition;
            System.IntPtr transition_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, finalValue, &transition_, (*(void ***)this._nativePointer)[3]);
            if (transition_ != System.IntPtr.Zero)
                transition = new SharpDX.Animation.Transition(transition_);
            else
                transition = null;
            __result__.CheckError();
            return transition;
        }

        /// <summary>
        /// <p> Creates a constant transition.</p>
        /// </summary>
        /// <param name = "duration"><dd> <p> The duration of the transition.</p> </dd></param>
        /// <returns><dd> <p> The new constant transition.</p> </dd></returns>
        /// <remarks>
        /// <p>During a constant transition, the value of an animation variable remains at the initial value over the duration of the transition.</p><p>The figure below shows the effect on an animation variable over time during a constant-duration transition.</p><p></p>
        /// </remarks>
        /// <doc-id>dd371903</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary::CreateConstantTransition([In] double duration,[Out] IUIAnimationTransition** transition)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransitionLibrary::CreateConstantTransition</unmanaged-short>
        public unsafe SharpDX.Animation.Transition Constant(System.Double duration)
        {
            SharpDX.Animation.Transition transition;
            System.IntPtr transition_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, duration, &transition_, (*(void ***)this._nativePointer)[4]);
            if (transition_ != System.IntPtr.Zero)
                transition = new SharpDX.Animation.Transition(transition_);
            else
                transition = null;
            __result__.CheckError();
            return transition;
        }

        /// <summary>
        /// <p> Creates a discrete transition.</p>
        /// </summary>
        /// <param name = "delay"><dd> <p>The amount of time by which to delay the instantaneous switch to the final value.</p> </dd></param>
        /// <param name = "finalValue"><dd> <p> The value of the animation variable at the end of the transition.</p> </dd></param>
        /// <param name = "hold"><dd> <p>The amount of time by which to hold the variable at its final value.</p> </dd></param>
        /// <returns><dd> <p> The new discrete transition.</p> </dd></returns>
        /// <remarks>
        /// <p>During a discrete transition, the animation variable remains at the initial value for a specified delay time, then switches instantaneously to a specified final value and remains at that value for a given hold time.</p><p>The figure below shows the effect on an animation variable over time during a discrete transition.</p><p></p>
        /// </remarks>
        /// <doc-id>dd371911</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary::CreateDiscreteTransition([In] double delay,[In] double finalValue,[In] double hold,[Out] IUIAnimationTransition** transition)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransitionLibrary::CreateDiscreteTransition</unmanaged-short>
        public unsafe SharpDX.Animation.Transition Discrete(System.Double delay, System.Double finalValue, System.Double hold)
        {
            SharpDX.Animation.Transition transition;
            System.IntPtr transition_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, delay, finalValue, hold, &transition_, (*(void ***)this._nativePointer)[5]);
            if (transition_ != System.IntPtr.Zero)
                transition = new SharpDX.Animation.Transition(transition_);
            else
                transition = null;
            __result__.CheckError();
            return transition;
        }

        /// <summary>
        /// <p> Creates a linear transition.</p>
        /// </summary>
        /// <param name = "duration"><dd> <p> The duration of the transition.</p> </dd></param>
        /// <param name = "finalValue"><dd> <p> The value of the animation variable at the end of the transition.</p> </dd></param>
        /// <returns><dd> <p> The new linear transition.</p> </dd></returns>
        /// <remarks>
        /// <p>During a linear transition, the value of the animation variable transitions linearly from its initial value to a  specified final value.</p><p>The figure below shows the effect on an animation variable over time during a linear transition.</p><p></p>
        /// </remarks>
        /// <doc-id>dd371920</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary::CreateLinearTransition([In] double duration,[In] double finalValue,[Out] IUIAnimationTransition** transition)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransitionLibrary::CreateLinearTransition</unmanaged-short>
        public unsafe SharpDX.Animation.Transition Linear(System.Double duration, System.Double finalValue)
        {
            SharpDX.Animation.Transition transition;
            System.IntPtr transition_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, duration, finalValue, &transition_, (*(void ***)this._nativePointer)[6]);
            if (transition_ != System.IntPtr.Zero)
                transition = new SharpDX.Animation.Transition(transition_);
            else
                transition = null;
            __result__.CheckError();
            return transition;
        }

        /// <summary>
        /// <p> Creates a linear-speed transition.</p>
        /// </summary>
        /// <param name = "speed"><dd> <p>The absolute value of the velocity.</p> </dd></param>
        /// <param name = "finalValue"><dd> <p> The value of the animation variable at the end of the transition.</p> </dd></param>
        /// <returns><dd> <p> The new linear-speed transition.</p> </dd></returns>
        /// <remarks>
        /// <p>During a linear-speed transition, the value of the animation variable changes at a specified rate. The duration of the transition is determined by  the difference between the initial value and the specified final value.</p><p>The figure below shows the effect on an animation variable over time during a linear-speed transition.</p><p></p>
        /// </remarks>
        /// <doc-id>dd371925</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary::CreateLinearTransitionFromSpeed([In] double speed,[In] double finalValue,[Out] IUIAnimationTransition** transition)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransitionLibrary::CreateLinearTransitionFromSpeed</unmanaged-short>
        public unsafe SharpDX.Animation.Transition LinearFromSpeed(System.Double speed, System.Double finalValue)
        {
            SharpDX.Animation.Transition transition;
            System.IntPtr transition_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, speed, finalValue, &transition_, (*(void ***)this._nativePointer)[7]);
            if (transition_ != System.IntPtr.Zero)
                transition = new SharpDX.Animation.Transition(transition_);
            else
                transition = null;
            __result__.CheckError();
            return transition;
        }

        /// <summary>
        /// <p> Creates a sinusoidal-velocity transition, with an amplitude determined by the initial velocity.</p>
        /// </summary>
        /// <param name = "duration"><dd> <p>The duration of the transition.</p> </dd></param>
        /// <param name = "period"><dd> <p>The period of oscillation of the sinusoidal wave in seconds.</p> </dd></param>
        /// <returns><dd> <p> The new sinusoidal-velocity transition.</p> </dd></returns>
        /// <remarks>
        /// <p>The value of the animation variable oscillates around the initial value over the entire duration of a sinusoidal-range transition. The amplitude of the oscillation is determined by the velocity when the transition begins.</p><p>The figure below shows the effect on an animation variable over time during a sinusoidal-velocity transition.</p><p></p>
        /// </remarks>
        /// <doc-id>dd371945</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary::CreateSinusoidalTransitionFromVelocity([In] double duration,[In] double period,[Out] IUIAnimationTransition** transition)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransitionLibrary::CreateSinusoidalTransitionFromVelocity</unmanaged-short>
        public unsafe SharpDX.Animation.Transition SinusoidalFromVelocity(System.Double duration, System.Double period)
        {
            SharpDX.Animation.Transition transition;
            System.IntPtr transition_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, duration, period, &transition_, (*(void ***)this._nativePointer)[8]);
            if (transition_ != System.IntPtr.Zero)
                transition = new SharpDX.Animation.Transition(transition_);
            else
                transition = null;
            __result__.CheckError();
            return transition;
        }

        /// <summary>
        /// <p> Creates a sinusoidal-range  transition, with a specified range of oscillation.</p>
        /// </summary>
        /// <param name = "duration"><dd> <p>The duration of the transition.</p> </dd></param>
        /// <param name = "minimumValue"><dd> <p>The value of the animation variable at a trough of the sinusoidal wave.</p> </dd></param>
        /// <param name = "maximumValue"><dd> <p>The value of the animation variable at a peak of the sinusoidal wave.</p> </dd></param>
        /// <param name = "period"><dd> <p>The period of oscillation of the sinusoidal wave, in seconds.</p> </dd></param>
        /// <param name = "slope"><dd> <p>The slope at the start of the transition.</p> </dd></param>
        /// <returns><dd> <p> The new sinusoidal-range transition.</p> </dd></returns>
        /// <remarks>
        /// <p>The value of the animation variable fluctuates between the specified minimum and maximum values over the entire duration of a  sinusodial-range transition. The <em>slope</em> parameter is used to disambiguate between the two possible sine waves specified by the other parameters.</p><p>The figure below shows the effect on an animation variable over time during a sinusoidal-range transition. Passing in the <strong>UI_ANIMATION_SLOPE_INCREASING</strong> enumeration value yields a wave like the solid curve shown in the figure, whereas the <strong>UI_ANIMATION_SLOPE_DECREASING</strong> value yields a wave like the dashed curve.</p>
        /// </remarks>
        /// <doc-id>dd371942</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary::CreateSinusoidalTransitionFromRange([In] double duration,[In] double minimumValue,[In] double maximumValue,[In] double period,[In] UI_ANIMATION_SLOPE slope,[Out] IUIAnimationTransition** transition)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransitionLibrary::CreateSinusoidalTransitionFromRange</unmanaged-short>
        public unsafe SharpDX.Animation.Transition SinusoidalFromRange(System.Double duration, System.Double minimumValue, System.Double maximumValue, System.Double period, SharpDX.Animation.Slope slope)
        {
            SharpDX.Animation.Transition transition;
            System.IntPtr transition_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, duration, minimumValue, maximumValue, period, unchecked ((System.Int32)slope), &transition_, (*(void ***)this._nativePointer)[9]);
            if (transition_ != System.IntPtr.Zero)
                transition = new SharpDX.Animation.Transition(transition_);
            else
                transition = null;
            __result__.CheckError();
            return transition;
        }

        /// <summary>
        /// <p> Creates an accelerate-decelerate transition.</p>
        /// </summary>
        /// <param name = "duration"><dd> <p> The duration of the transition.</p> </dd></param>
        /// <param name = "finalValue"><dd> <p> The value of the animation variable at the end of the transition.</p> </dd></param>
        /// <param name = "accelerationRatio"><dd> <p> The ratio of the time spent accelerating to the duration.</p> </dd></param>
        /// <param name = "decelerationRatio"><dd> <p> The ratio of the time spent decelerating to the duration.</p> </dd></param>
        /// <returns><dd> <p> The new accelerate-decelerate transition.</p> </dd></returns>
        /// <remarks>
        /// <p>During an accelerate-decelerate transition, the animation variable speeds up and then slows down over the duration of the transition, ending at a specified value. You can control how quickly the variable accelerates and decelerates independently, by specifying different acceleration and deceleration ratios.</p><p>When the initial velocity is zero, the acceleration ratio is the fraction of the duration that the variable will spend accelerating; likewise with the deceleration ratio. If the initial velocity is nonzero, it is the fraction of the time between the velocity reaching zero and the end of transition. The acceleration ratio and the deceleration ratio should sum to a maximum of 1.0. </p><p>The figures below show the effect on animation variables with different initial velocities during accelerate-decelerate transitions.</p><strong>Note</strong>??d' in the above figure on the right shows the time between the velocity reaching zero and the end of the transition.?
        /// </remarks>
        /// <doc-id>dd371900</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary::CreateAccelerateDecelerateTransition([In] double duration,[In] double finalValue,[In] double accelerationRatio,[In] double decelerationRatio,[Out] IUIAnimationTransition** transition)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransitionLibrary::CreateAccelerateDecelerateTransition</unmanaged-short>
        public unsafe SharpDX.Animation.Transition AccelerateDecelerate(System.Double duration, System.Double finalValue, System.Double accelerationRatio, System.Double decelerationRatio)
        {
            SharpDX.Animation.Transition transition;
            System.IntPtr transition_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, duration, finalValue, accelerationRatio, decelerationRatio, &transition_, (*(void ***)this._nativePointer)[10]);
            if (transition_ != System.IntPtr.Zero)
                transition = new SharpDX.Animation.Transition(transition_);
            else
                transition = null;
            __result__.CheckError();
            return transition;
        }

        /// <summary>
        /// <p> Creates a reversal transition.</p>
        /// </summary>
        /// <param name = "duration"><dd> <p>The duration of the transition.</p> </dd></param>
        /// <returns><dd> <p> The new reversal transition.</p> </dd></returns>
        /// <remarks>
        /// <p> A reversal transition smoothly changes direction over the specified duration. The final value will be the same as the initial value and the final velocity will be the negative of the initial velocity. The figure below shows such a reversal transition.</p><p></p>
        /// </remarks>
        /// <doc-id>dd371938</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary::CreateReversalTransition([In] double duration,[Out] IUIAnimationTransition** transition)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransitionLibrary::CreateReversalTransition</unmanaged-short>
        public unsafe SharpDX.Animation.Transition Reversal(System.Double duration)
        {
            SharpDX.Animation.Transition transition;
            System.IntPtr transition_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, duration, &transition_, (*(void ***)this._nativePointer)[11]);
            if (transition_ != System.IntPtr.Zero)
                transition = new SharpDX.Animation.Transition(transition_);
            else
                transition = null;
            __result__.CheckError();
            return transition;
        }

        /// <summary>
        /// <p> Creates a cubic transition.</p>
        /// </summary>
        /// <param name = "duration"><dd> <p> The duration of the transition.</p> </dd></param>
        /// <param name = "finalValue"><dd> <p> The value of the animation variable at the end of the transition.</p> </dd></param>
        /// <param name = "finalVelocity"><dd> <p> The velocity of the variable at the end of the transition.</p> </dd></param>
        /// <returns><dd> <p> The new cubic transition.</p> </dd></returns>
        /// <remarks>
        /// <p>During a cubic transition, the value of the animation variable changes from its initial value to a specified final value over the duration of the transition, ending at a specified velocity.</p><p>The figure below shows the effect on an animation variable over time during a cubic transition.</p>
        /// </remarks>
        /// <doc-id>dd756728</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary::CreateCubicTransition([In] double duration,[In] double finalValue,[In] double finalVelocity,[Out] IUIAnimationTransition** transition)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransitionLibrary::CreateCubicTransition</unmanaged-short>
        public unsafe SharpDX.Animation.Transition Cubic(System.Double duration, System.Double finalValue, System.Double finalVelocity)
        {
            SharpDX.Animation.Transition transition;
            System.IntPtr transition_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, duration, finalValue, finalVelocity, &transition_, (*(void ***)this._nativePointer)[12]);
            if (transition_ != System.IntPtr.Zero)
                transition = new SharpDX.Animation.Transition(transition_);
            else
                transition = null;
            __result__.CheckError();
            return transition;
        }

        /// <summary>
        /// <p> Creates a smooth-stop transition.</p>
        /// </summary>
        /// <param name = "maximumDuration"><dd> <p> The maximum duration of the transition.</p> </dd></param>
        /// <param name = "finalValue"><dd> <p> The value of the animation variable at the end of the transition.</p> </dd></param>
        /// <returns><dd> <p> The new smooth-stop transition.</p> </dd></returns>
        /// <remarks>
        /// <p>A smooth-stop transition slows down as it approaches the specified final value, and reaches it with a velocity of zero. The duration of the transition is determined by the initial velocity, the difference between the initial and final values, and the specified maximum duration. If there is no solution consisting of a single parabolic arc, this method creates a cubic transition.</p><p>The figure below shows the effect on an animation variable over time during a smooth-stop transition.</p><p></p>
        /// </remarks>
        /// <doc-id>dd756729</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary::CreateSmoothStopTransition([In] double maximumDuration,[In] double finalValue,[Out] IUIAnimationTransition** transition)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransitionLibrary::CreateSmoothStopTransition</unmanaged-short>
        public unsafe SharpDX.Animation.Transition SmoothStop(System.Double maximumDuration, System.Double finalValue)
        {
            SharpDX.Animation.Transition transition;
            System.IntPtr transition_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, maximumDuration, finalValue, &transition_, (*(void ***)this._nativePointer)[13]);
            if (transition_ != System.IntPtr.Zero)
                transition = new SharpDX.Animation.Transition(transition_);
            else
                transition = null;
            __result__.CheckError();
            return transition;
        }

        /// <summary>
        /// <p> Creates a parabolic-acceleration transition.</p>
        /// </summary>
        /// <param name = "finalValue"><dd> <p> The value of the animation variable at the end of the transition.</p> </dd></param>
        /// <param name = "finalVelocity"><dd> <p>The velocity at the end of the transition.</p> </dd></param>
        /// <param name = "acceleration"><dd> <p> The acceleration during the transition.</p> </dd></param>
        /// <returns><dd> <p> The new parabolic-acceleration transition.</p> </dd></returns>
        /// <remarks>
        /// <p> During a parabolic-acceleration transition, the value of the animation variable changes from the  initial value to the final value ending at the specified velocity.  You can control how quickly the variable reaches the final value by specifying the rate of acceleration.</p><p>The figure below shows the effect on an animation variable over time during a parabolic-acceleration transition.</p>
        /// </remarks>
        /// <doc-id>dd371934</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary::CreateParabolicTransitionFromAcceleration([In] double finalValue,[In] double finalVelocity,[In] double acceleration,[Out] IUIAnimationTransition** transition)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransitionLibrary::CreateParabolicTransitionFromAcceleration</unmanaged-short>
        public unsafe SharpDX.Animation.Transition ParabolicFromAcceleration(System.Double finalValue, System.Double finalVelocity, System.Double acceleration)
        {
            SharpDX.Animation.Transition transition;
            System.IntPtr transition_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, finalValue, finalVelocity, acceleration, &transition_, (*(void ***)this._nativePointer)[14]);
            if (transition_ != System.IntPtr.Zero)
                transition = new SharpDX.Animation.Transition(transition_);
            else
                transition = null;
            __result__.CheckError();
            return transition;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("03CFAE53-9580-4ee3-B363-2ECE51B4AF6A")]
    public partial class TransitionLibrary2 : SharpDX.ComObject
    {
        public TransitionLibrary2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator TransitionLibrary2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new TransitionLibrary2(nativePtr);
        /// <summary>
        /// <p> Creates an instantaneous scalar transition.</p>
        /// </summary>
        /// <param name = "finalValue"><dd> <p> The value of the animation variable at the end of the transition.</p> </dd></param>
        /// <param name = "transition"><dd> <p> The new instantaneous transition.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>During an instantaneous transition, the value of the animation variable changes instantly from its current value to a specified final value. The duration of this transition is always zero.</p><p>The following figure shows the change in value over time of an animation variable during an instantaneous transition.</p><p></p>
        /// </remarks>
        /// <doc-id>hh448621</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary2::CreateInstantaneousTransition([In] double finalValue,[Out] IUIAnimationTransition2** transition)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransitionLibrary2::CreateInstantaneousTransition</unmanaged-short>
        public unsafe void CreateInstantaneousTransition(System.Double finalValue, out SharpDX.Animation.Transition2 transition)
        {
            System.IntPtr transition_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, finalValue, &transition_, (*(void ***)this._nativePointer)[3]);
            if (transition_ != System.IntPtr.Zero)
                transition = new SharpDX.Animation.Transition2(transition_);
            else
                transition = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates an instantaneous vector transition for each specified dimension.</p>
        /// </summary>
        /// <param name = "finalValue"><dd> <p>A vector (of size <em>cDimension</em>) that contains  the values of the animation variable at the end of the transition.</p> </dd></param>
        /// <param name = "cDimension"><dd> <p>The number of dimensions to apply the transition. This parameter specifies the number of values listed in <em>finalValue</em>.</p> </dd></param>
        /// <param name = "transition"><dd> <p> The new instantaneous transition.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>During an instantaneous transition, the value of the animation variable changes instantly from its current value to a specified final value. The duration of this transition is always zero.</p><p>The following figure shows the change in value over time of an animation variable during an instantaneous transition.</p><p></p>
        /// </remarks>
        /// <doc-id>hh448622</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary2::CreateInstantaneousVectorTransition([In, Buffer] const double* finalValue,[In] unsigned int cDimension,[Out] IUIAnimationTransition2** transition)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransitionLibrary2::CreateInstantaneousVectorTransition</unmanaged-short>
        public unsafe void CreateInstantaneousVectorTransition(System.Double[] finalValue, System.Int32 cDimension, out SharpDX.Animation.Transition2 transition)
        {
            System.IntPtr transition_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *finalValue_ = finalValue)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, finalValue_, cDimension, &transition_, (*(void ***)this._nativePointer)[4]);
            if (transition_ != System.IntPtr.Zero)
                transition = new SharpDX.Animation.Transition2(transition_);
            else
                transition = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates a constant scalar transition.</p>
        /// </summary>
        /// <param name = "duration"><dd> <p> The duration of the transition.</p> </dd></param>
        /// <param name = "transition"><dd> <p> The new constant transition.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>During a constant transition, the value of an animation variable remains at the initial value over the duration of the transition.</p><p>The following figure shows the change in value for an animation variable over time during a constant-duration transition.</p><p></p>
        /// </remarks>
        /// <doc-id>hh448614</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary2::CreateConstantTransition([In] double duration,[Out] IUIAnimationTransition2** transition)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransitionLibrary2::CreateConstantTransition</unmanaged-short>
        public unsafe void CreateConstantTransition(System.Double duration, out SharpDX.Animation.Transition2 transition)
        {
            System.IntPtr transition_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, duration, &transition_, (*(void ***)this._nativePointer)[5]);
            if (transition_ != System.IntPtr.Zero)
                transition = new SharpDX.Animation.Transition2(transition_);
            else
                transition = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates a discrete scalar transition.</p>
        /// </summary>
        /// <param name = "delay"><dd> <p>The amount of time by which to delay the instantaneous switch to the final value.</p> </dd></param>
        /// <param name = "finalValue"><dd> <p> The value of the animation variable at the end of the transition.</p> </dd></param>
        /// <param name = "hold"><dd> <p>The amount of time by which to hold the variable at its final value.</p> </dd></param>
        /// <param name = "transition"><dd> <p> The new discrete transition.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>During a discrete transition, the animation variable remains at the initial value for a specified delay time, then switches instantaneously to a specified final value and remains at that value for a given hold time.</p><p>The following figure shows the change in value over time of an animation variable during a discrete transition.</p><p></p>
        /// </remarks>
        /// <doc-id>hh448619</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary2::CreateDiscreteTransition([In] double delay,[In] double finalValue,[In] double hold,[Out] IUIAnimationTransition2** transition)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransitionLibrary2::CreateDiscreteTransition</unmanaged-short>
        public unsafe void CreateDiscreteTransition(System.Double delay, System.Double finalValue, System.Double hold, out SharpDX.Animation.Transition2 transition)
        {
            System.IntPtr transition_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, delay, finalValue, hold, &transition_, (*(void ***)this._nativePointer)[6]);
            if (transition_ != System.IntPtr.Zero)
                transition = new SharpDX.Animation.Transition2(transition_);
            else
                transition = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates a discrete vector transition for each specified dimension.</p>
        /// </summary>
        /// <param name = "delay"><dd> <p>The amount of time by which to delay the instantaneous switch to the final value.</p> </dd></param>
        /// <param name = "finalValue"><dd> <p>A vector (of size <em>cDimension</em>) that contains  the final values of the animation variable at the end of the transition.</p> </dd></param>
        /// <param name = "cDimension"><dd> <p>The number of dimensions to apply the transition. This parameter specifies the number of values listed in <em>finalValue</em>.</p> </dd></param>
        /// <param name = "hold"><dd> <p>The amount of time by which to hold the variable at its final value.</p> </dd></param>
        /// <param name = "transition"><dd> <p> The new discrete transition.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>During a discrete transition, the animation variable remains at the initial value for a specified delay time, then switches instantaneously to a specified final value and remains at that value for a given hold time.</p><p>The following figure shows the change in value over time of an animation variable during a discrete transition.</p><p></p>
        /// </remarks>
        /// <doc-id>hh448620</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary2::CreateDiscreteVectorTransition([In] double delay,[In, Buffer] const double* finalValue,[In] unsigned int cDimension,[In] double hold,[Out] IUIAnimationTransition2** transition)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransitionLibrary2::CreateDiscreteVectorTransition</unmanaged-short>
        public unsafe void CreateDiscreteVectorTransition(System.Double delay, System.Double[] finalValue, System.Int32 cDimension, System.Double hold, out SharpDX.Animation.Transition2 transition)
        {
            System.IntPtr transition_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *finalValue_ = finalValue)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, delay, finalValue_, cDimension, hold, &transition_, (*(void ***)this._nativePointer)[7]);
            if (transition_ != System.IntPtr.Zero)
                transition = new SharpDX.Animation.Transition2(transition_);
            else
                transition = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates a linear scalar transition.</p>
        /// </summary>
        /// <param name = "duration"><dd> <p> The duration of the transition.</p> </dd></param>
        /// <param name = "finalValue"><dd> <p> The value of the animation variable at the end of the transition.</p> </dd></param>
        /// <param name = "transition"><dd> <p> The new linear transition.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>During a linear transition, the value of the animation variable transitions linearly from its initial value to a  specified final value.</p><p>The following figure shows the change in value over time of an animation variable during a linear transition.</p><p></p>
        /// </remarks>
        /// <doc-id>hh448623</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary2::CreateLinearTransition([In] double duration,[In] double finalValue,[Out] IUIAnimationTransition2** transition)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransitionLibrary2::CreateLinearTransition</unmanaged-short>
        public unsafe void CreateLinearTransition(System.Double duration, System.Double finalValue, out SharpDX.Animation.Transition2 transition)
        {
            System.IntPtr transition_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, duration, finalValue, &transition_, (*(void ***)this._nativePointer)[8]);
            if (transition_ != System.IntPtr.Zero)
                transition = new SharpDX.Animation.Transition2(transition_);
            else
                transition = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates a linear vector transition in the specified dimension.</p>
        /// </summary>
        /// <param name = "duration"><dd> <p> The duration of the transition.</p> </dd></param>
        /// <param name = "finalValue"><dd> <p>A vector (of size <em>cDimension</em>) that contains  the final values of the animation variable at the end of the transition.</p> </dd></param>
        /// <param name = "cDimension"><dd> <p>The number of dimensions to apply the transition. This parameter specifies the number of values listed in <em>finalValue</em>.</p> </dd></param>
        /// <param name = "transition"><dd> <p> The new linear transition.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>During a linear transition, the value of the animation variable transitions linearly from its initial value to a  specified final value.</p><p>The following figure shows the change in value over time of an animation variable during a linear transition.</p><p></p>
        /// </remarks>
        /// <doc-id>hh448625</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary2::CreateLinearVectorTransition([In] double duration,[In, Buffer] const double* finalValue,[In] unsigned int cDimension,[Out] IUIAnimationTransition2** transition)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransitionLibrary2::CreateLinearVectorTransition</unmanaged-short>
        public unsafe void CreateLinearVectorTransition(System.Double duration, System.Double[] finalValue, System.Int32 cDimension, out SharpDX.Animation.Transition2 transition)
        {
            System.IntPtr transition_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *finalValue_ = finalValue)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, duration, finalValue_, cDimension, &transition_, (*(void ***)this._nativePointer)[9]);
            if (transition_ != System.IntPtr.Zero)
                transition = new SharpDX.Animation.Transition2(transition_);
            else
                transition = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates a linear-speed scalar transition.</p>
        /// </summary>
        /// <param name = "speed"><dd> <p>The absolute value of the velocity in units/second.</p> </dd></param>
        /// <param name = "finalValue"><dd> <p> The value of the animation variable at the end of the transition.</p> </dd></param>
        /// <param name = "transition"><dd> <p> The new linear-speed transition.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>During a linear-speed transition, the value of the animation variable changes at a specified rate. The duration of the transition is determined by  the difference between the initial value and the specified final value.</p><p>The following figure shows the change in value over time of an animation variable during a linear-speed transition.</p><p></p>
        /// </remarks>
        /// <doc-id>hh448624</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary2::CreateLinearTransitionFromSpeed([In] double speed,[In] double finalValue,[Out] IUIAnimationTransition2** transition)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransitionLibrary2::CreateLinearTransitionFromSpeed</unmanaged-short>
        public unsafe void CreateLinearTransitionFromSpeed(System.Double speed, System.Double finalValue, out SharpDX.Animation.Transition2 transition)
        {
            System.IntPtr transition_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, speed, finalValue, &transition_, (*(void ***)this._nativePointer)[10]);
            if (transition_ != System.IntPtr.Zero)
                transition = new SharpDX.Animation.Transition2(transition_);
            else
                transition = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates a linear-speed vector transition in the specified dimension.</p>
        /// </summary>
        /// <param name = "speed"><dd> <p>The absolute value of the velocity in units/second.</p> </dd></param>
        /// <param name = "finalValue"><dd> <p>A vector (of size <em>cDimension</em>) that contains  the final values of the animation variable at the end of the transition.</p> </dd></param>
        /// <param name = "cDimension"><dd> <p>The number of dimensions to apply the transition. This parameter specifies the number of values listed in <em>finalValue</em>.</p> </dd></param>
        /// <param name = "transition"><dd> <p> The new linear-speed transition.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>During a linear-speed transition, the value of the animation variable changes at a specified rate. The duration of the transition is determined by  the difference between the initial value and the specified final value.</p><p>The following figure shows the change in value over time of an animation variable during a linear-speed transition.</p><p></p>
        /// </remarks>
        /// <doc-id>hh448626</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary2::CreateLinearVectorTransitionFromSpeed([In] double speed,[In, Buffer] const double* finalValue,[In] unsigned int cDimension,[Out] IUIAnimationTransition2** transition)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransitionLibrary2::CreateLinearVectorTransitionFromSpeed</unmanaged-short>
        public unsafe void CreateLinearVectorTransitionFromSpeed(System.Double speed, System.Double[] finalValue, System.Int32 cDimension, out SharpDX.Animation.Transition2 transition)
        {
            System.IntPtr transition_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *finalValue_ = finalValue)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, speed, finalValue_, cDimension, &transition_, (*(void ***)this._nativePointer)[11]);
            if (transition_ != System.IntPtr.Zero)
                transition = new SharpDX.Animation.Transition2(transition_);
            else
                transition = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates a sinusoidal scalar transition where amplitude is determined by initial velocity.</p>
        /// </summary>
        /// <param name = "duration"><dd> <p> The duration of the transition.</p> </dd></param>
        /// <param name = "period"><dd> <p>The period of oscillation of the sinusoidal wave.</p> </dd></param>
        /// <param name = "transition"><dd> <p> The new sinusoidal-velocity transition.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>The value of the animation variable oscillates around the initial value over the entire duration of a sinusoidal-range transition. The amplitude of the oscillation is determined by the velocity when the transition begins.</p><p>The following figure shows the change in value over time of an animation variable during a sinusoidal-velocity transition.</p><p></p>
        /// </remarks>
        /// <doc-id>hh448630</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary2::CreateSinusoidalTransitionFromVelocity([In] double duration,[In] double period,[Out] IUIAnimationTransition2** transition)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransitionLibrary2::CreateSinusoidalTransitionFromVelocity</unmanaged-short>
        public unsafe void CreateSinusoidalTransitionFromVelocity(System.Double duration, System.Double period, out SharpDX.Animation.Transition2 transition)
        {
            System.IntPtr transition_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, duration, period, &transition_, (*(void ***)this._nativePointer)[12]);
            if (transition_ != System.IntPtr.Zero)
                transition = new SharpDX.Animation.Transition2(transition_);
            else
                transition = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates a sinusoidal-range scalar  transition with a specified range of oscillation.</p>
        /// </summary>
        /// <param name = "duration"><dd> <p>The duration of the transition.</p> </dd></param>
        /// <param name = "minimumValue"><dd> <p>The value of the animation variable at a trough of the sinusoidal wave.</p> </dd></param>
        /// <param name = "maximumValue"><dd> <p>The value of the animation variable at a peak of the sinusoidal wave.</p> </dd></param>
        /// <param name = "period"><dd> <p>The period of oscillation of the sinusoidal wave.</p> </dd></param>
        /// <param name = "slope"><dd> <p>The slope at the start of the transition.</p> </dd></param>
        /// <param name = "transition"><dd> <p> The new sinusoidal-range transition.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>The value of the animation variable fluctuates between the specified minimum and maximum values over the entire duration of a  sinusodial-range transition. The <em>slope</em> parameter is used to disambiguate between the two possible sine waves specified by the other parameters.</p><p>The following figure shows the change in value over time of an animation variable during a sinusoidal-range transition. Passing in the <strong>UI_ANIMATION_SLOPE_INCREASING</strong> enumeration value yields a wave like the solid curve shown in the figure, whereas the <strong>UI_ANIMATION_SLOPE_DECREASING</strong> value yields a wave like the dashed curve.</p>
        /// </remarks>
        /// <doc-id>hh448629</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary2::CreateSinusoidalTransitionFromRange([In] double duration,[In] double minimumValue,[In] double maximumValue,[In] double period,[In] UI_ANIMATION_SLOPE slope,[Out] IUIAnimationTransition2** transition)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransitionLibrary2::CreateSinusoidalTransitionFromRange</unmanaged-short>
        public unsafe void CreateSinusoidalTransitionFromRange(System.Double duration, System.Double minimumValue, System.Double maximumValue, System.Double period, SharpDX.Animation.Slope slope, out SharpDX.Animation.Transition2 transition)
        {
            System.IntPtr transition_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, duration, minimumValue, maximumValue, period, unchecked ((System.Int32)slope), &transition_, (*(void ***)this._nativePointer)[13]);
            if (transition_ != System.IntPtr.Zero)
                transition = new SharpDX.Animation.Transition2(transition_);
            else
                transition = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates an accelerate-decelerate scalar transition.</p>
        /// </summary>
        /// <param name = "duration"><dd> <p>The duration of the transition.</p> </dd></param>
        /// <param name = "finalValue"><dd> <p> The value of the animation variable at the end of the transition.</p> </dd></param>
        /// <param name = "accelerationRatio"><dd> <p> The ratio of <em>duration</em> time spent accelerating (0 to 1).</p> </dd></param>
        /// <param name = "decelerationRatio"><dd> <p> The ratio of <em>duration</em> time spent decelerating (0 to 1).</p> </dd></param>
        /// <param name = "transition"><dd> <p> The new accelerate-decelerate transition.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>During an accelerate-decelerate transition, the animation variable speeds up and then slows down over the duration of the transition, ending at a specified value. You can control how quickly the variable accelerates and decelerates independently, by specifying different acceleration and deceleration ratios.</p><p>When the initial velocity is zero, the acceleration ratio is the fraction of the duration that the variable will spend accelerating; likewise for the deceleration ratio. If the value of initial velocity is nonzero, the value is the fraction of the time between the velocity reaching zero and the end of transition. The acceleration ratio and the deceleration ratio should sum to a maximum of 1.0. </p><p>The following figures show the change in value for animation variables with different initial velocities during accelerate-decelerate transitions.</p><strong>Note</strong>??d' in the figure on the right shows the time between the velocity reaching zero and the end of the transition.?
        /// </remarks>
        /// <doc-id>hh448613</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary2::CreateAccelerateDecelerateTransition([In] double duration,[In] double finalValue,[In] double accelerationRatio,[In] double decelerationRatio,[Out] IUIAnimationTransition2** transition)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransitionLibrary2::CreateAccelerateDecelerateTransition</unmanaged-short>
        public unsafe void CreateAccelerateDecelerateTransition(System.Double duration, System.Double finalValue, System.Double accelerationRatio, System.Double decelerationRatio, out SharpDX.Animation.Transition2 transition)
        {
            System.IntPtr transition_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, duration, finalValue, accelerationRatio, decelerationRatio, &transition_, (*(void ***)this._nativePointer)[14]);
            if (transition_ != System.IntPtr.Zero)
                transition = new SharpDX.Animation.Transition2(transition_);
            else
                transition = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates a reversal scalar transition.</p>
        /// </summary>
        /// <param name = "duration"><dd> <p>The duration of the transition.</p> </dd></param>
        /// <param name = "transition"><dd> <p> The new reversal transition.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p> A reversal transition smoothly changes direction over the specified duration. The final value will be the same as the initial value and the final velocity will be the negative of the initial velocity. The folllowing figure shows such a reversal transition.</p><p></p>
        /// </remarks>
        /// <doc-id>hh448628</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary2::CreateReversalTransition([In] double duration,[Out] IUIAnimationTransition2** transition)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransitionLibrary2::CreateReversalTransition</unmanaged-short>
        public unsafe void CreateReversalTransition(System.Double duration, out SharpDX.Animation.Transition2 transition)
        {
            System.IntPtr transition_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, duration, &transition_, (*(void ***)this._nativePointer)[15]);
            if (transition_ != System.IntPtr.Zero)
                transition = new SharpDX.Animation.Transition2(transition_);
            else
                transition = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates a cubic scalar transition.</p>
        /// </summary>
        /// <param name = "duration"><dd> <p> The duration of the transition.</p> </dd></param>
        /// <param name = "finalValue"><dd> <p> The value of the animation variable at the end of the transition.</p> </dd></param>
        /// <param name = "finalVelocity"><dd> <p> The velocity of the variable at the end of the transition.</p> </dd></param>
        /// <param name = "transition"><dd> <p> The new cubic transition.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>During a cubic transition, the value of the animation variable changes from its initial value to the <em>finalValue</em> over the <em>duration</em> of the transition, ending at the <em>finalVelocity</em>.</p><p>The following figure shows the effect on an animation variable over time during a cubic transition.</p>
        /// </remarks>
        /// <doc-id>hh448617</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary2::CreateCubicTransition([In] double duration,[In] double finalValue,[In] double finalVelocity,[Out] IUIAnimationTransition2** transition)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransitionLibrary2::CreateCubicTransition</unmanaged-short>
        public unsafe void CreateCubicTransition(System.Double duration, System.Double finalValue, System.Double finalVelocity, out SharpDX.Animation.Transition2 transition)
        {
            System.IntPtr transition_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, duration, finalValue, finalVelocity, &transition_, (*(void ***)this._nativePointer)[16]);
            if (transition_ != System.IntPtr.Zero)
                transition = new SharpDX.Animation.Transition2(transition_);
            else
                transition = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates a cubic vector transition for each specified dimension.</p>
        /// </summary>
        /// <param name = "duration"><dd> <p> The duration of the transition.</p> </dd></param>
        /// <param name = "finalValue"><dd> <p>A vector (of size <em>cDimension</em>) that contains  the final values of the animation variable at the end of the transition.</p> </dd></param>
        /// <param name = "finalVelocity"><dd> <p>A vector (of size <em>cDimension</em>) that contains  the final velocities (in units per second) of the animation variable at the end of the transition.</p> </dd></param>
        /// <param name = "cDimension"><dd> <p>The number of dimensions to apply the transition. This parameter specifies the number of values listed in <em>finalValue</em> and <em>finalVelocity</em>.</p> </dd></param>
        /// <param name = "transition"><dd> <p> The new cubic transition.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>During a cubic transition, the value of the animation variable changes from its initial value to the <em>finalValue</em> over the <em>duration</em> of the transition, ending at the <em>finalVelocity</em>.</p><p>The following figure shows the effect on an animation variable over time during a cubic transition.</p>
        /// </remarks>
        /// <doc-id>hh448618</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary2::CreateCubicVectorTransition([In] double duration,[In, Buffer] const double* finalValue,[In, Buffer] const double* finalVelocity,[In] unsigned int cDimension,[Out] IUIAnimationTransition2** transition)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransitionLibrary2::CreateCubicVectorTransition</unmanaged-short>
        public unsafe void CreateCubicVectorTransition(System.Double duration, System.Double[] finalValue, System.Double[] finalVelocity, System.Int32 cDimension, out SharpDX.Animation.Transition2 transition)
        {
            System.IntPtr transition_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *finalVelocity_ = finalVelocity)
                fixed (void *finalValue_ = finalValue)
                    __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, duration, finalValue_, finalVelocity_, cDimension, &transition_, (*(void ***)this._nativePointer)[17]);
            if (transition_ != System.IntPtr.Zero)
                transition = new SharpDX.Animation.Transition2(transition_);
            else
                transition = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates a smooth-stop scalar transition.</p>
        /// </summary>
        /// <param name = "maximumDuration"><dd> <p> The maximum duration of the transition.</p> </dd></param>
        /// <param name = "finalValue"><dd> <p> The value of the animation variable at the end of the transition.</p> </dd></param>
        /// <param name = "transition"><dd> <p> The new smooth-stop transition.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>A smooth-stop transition slows down as it approaches the specified final value, and reaches the final value with a velocity of zero. The duration of the transition is determined by the initial velocity, the difference between the initial and final values, and the specified maximum duration. If there is no solution consisting of a single parabolic arc, this method creates a cubic transition.</p><p>The following figure shows the change in value over time of an animation variable during a smooth-stop transition.</p><p></p>
        /// </remarks>
        /// <doc-id>hh448631</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary2::CreateSmoothStopTransition([In] double maximumDuration,[In] double finalValue,[Out] IUIAnimationTransition2** transition)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransitionLibrary2::CreateSmoothStopTransition</unmanaged-short>
        public unsafe void CreateSmoothStopTransition(System.Double maximumDuration, System.Double finalValue, out SharpDX.Animation.Transition2 transition)
        {
            System.IntPtr transition_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, maximumDuration, finalValue, &transition_, (*(void ***)this._nativePointer)[18]);
            if (transition_ != System.IntPtr.Zero)
                transition = new SharpDX.Animation.Transition2(transition_);
            else
                transition = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates a parabolic-acceleration scalar transition.</p>
        /// </summary>
        /// <param name = "finalValue"><dd> <p> The value of the animation variable at the end of the transition.</p> </dd></param>
        /// <param name = "finalVelocity"><dd> <p>The velocity, in units/second, at the end of the transition.</p> </dd></param>
        /// <param name = "acceleration"><dd> <p> The acceleration, in units/second?, during the transition.</p> </dd></param>
        /// <param name = "transition"><dd> <p> The new parabolic-acceleration transition.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p> During a parabolic-acceleration transition, the value of the animation variable changes from the  initial value to the final value, ending at the specified velocity.  You can control how quickly the variable reaches the final value by specifying the rate of acceleration.</p><p>The following figure shows the change in value over time of an animation variable during a parabolic-acceleration transition.</p>
        /// </remarks>
        /// <doc-id>hh448627</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary2::CreateParabolicTransitionFromAcceleration([In] double finalValue,[In] double finalVelocity,[In] double acceleration,[Out] IUIAnimationTransition2** transition)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransitionLibrary2::CreateParabolicTransitionFromAcceleration</unmanaged-short>
        public unsafe void CreateParabolicTransitionFromAcceleration(System.Double finalValue, System.Double finalVelocity, System.Double acceleration, out SharpDX.Animation.Transition2 transition)
        {
            System.IntPtr transition_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, finalValue, finalVelocity, acceleration, &transition_, (*(void ***)this._nativePointer)[19]);
            if (transition_ != System.IntPtr.Zero)
                transition = new SharpDX.Animation.Transition2(transition_);
            else
                transition = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates a cubic B?zier linear scalar transition.</p>
        /// </summary>
        /// <param name = "duration"><dd> <p> The duration of the transition.</p> </dd></param>
        /// <param name = "finalValue"><dd> <p> The value of the animation variable at the end of the transition.</p> </dd></param>
        /// <param name = "x1"><dd> <p>The x-coordinate of the first control point.</p> </dd></param>
        /// <param name = "y1"><dd> <p>The y-coordinate of the first control point.</p> </dd></param>
        /// <param name = "x2"><dd> <p>The x-coordinate of the second control point.</p> </dd></param>
        /// <param name = "y2"><dd> <p>The y-coordinate of the second control point.</p> </dd></param>
        /// <param name = "transitionOut"><dd> <p>The new cubic B?zier linear transition.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>During a cubic B?zier linear transition, the value of the animation variable changes from its initial value to the <em>finalValue</em> over the <em>duration</em> of the transition. The ordered pairs, (x1, y1) and (x2, y2), act as control points that provide directional information to transform the linear path of the transition into a smooth parametric curve.</p><p>The following figure shows the change in value over time for an animation variable during a cubic B?zier linear transition.</p>
        /// </remarks>
        /// <doc-id>hh448615</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary2::CreateCubicBezierLinearTransition([In] double duration,[In] double finalValue,[In] double x1,[In] double y1,[In] double x2,[In] double y2,[Out] IUIAnimationTransition2** ppTransition)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransitionLibrary2::CreateCubicBezierLinearTransition</unmanaged-short>
        public unsafe void CreateCubicBezierLinearTransition(System.Double duration, System.Double finalValue, System.Double x1, System.Double y1, System.Double x2, System.Double y2, out SharpDX.Animation.Transition2 transitionOut)
        {
            System.IntPtr transitionOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, duration, finalValue, x1, y1, x2, y2, &transitionOut_, (*(void ***)this._nativePointer)[20]);
            if (transitionOut_ != System.IntPtr.Zero)
                transitionOut = new SharpDX.Animation.Transition2(transitionOut_);
            else
                transitionOut = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates a cubic B?zier linear vector transition for each specified dimension.</p>
        /// </summary>
        /// <param name = "duration"><dd> <p> The duration of the transition.</p> </dd></param>
        /// <param name = "finalValue"><dd> <p>A vector (of size <em>cDimension</em>) that contains  the final values of the animation variable at the end of the transition.</p> </dd></param>
        /// <param name = "cDimension"><dd> <p>The number of dimensions to apply the transition. This parameter specifies the number of values listed in <em>finalValue</em>.</p> </dd></param>
        /// <param name = "x1"><dd> <p>The x-coordinate of the first control point.</p> </dd></param>
        /// <param name = "y1"><dd> <p>The y-coordinate of the first control point.</p> </dd></param>
        /// <param name = "x2"><dd> <p>The x-coordinate of the second control point.</p> </dd></param>
        /// <param name = "y2"><dd> <p>The y-coordinate of the second control point.</p> </dd></param>
        /// <param name = "transitionOut"><dd> <p>The new cubic B?zier linear transition.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>During a cubic B?zier linear transition, the value of the animation variable changes from its initial value to the <em>finalValue</em> over the <em>duration</em> of the transition. The ordered pairs, (x1, y1) and (x2, y2), act as control points that provide directional information to transform the linear path of the transition into a smooth parametric curve.</p><p>The following figure shows the change in value over time of an animation variable during a cubic B?zier linear transition.</p>
        /// </remarks>
        /// <doc-id>hh448616</doc-id>
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary2::CreateCubicBezierLinearVectorTransition([In] double duration,[In, Buffer] const double* finalValue,[In] unsigned int cDimension,[In] double x1,[In] double y1,[In] double x2,[In] double y2,[Out] IUIAnimationTransition2** ppTransition)</unmanaged>
        /// <unmanaged-short>IUIAnimationTransitionLibrary2::CreateCubicBezierLinearVectorTransition</unmanaged-short>
        public unsafe void CreateCubicBezierLinearVectorTransition(System.Double duration, System.Double[] finalValue, System.Int32 cDimension, System.Double x1, System.Double y1, System.Double x2, System.Double y2, out SharpDX.Animation.Transition2 transitionOut)
        {
            System.IntPtr transitionOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *finalValue_ = finalValue)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, duration, finalValue_, cDimension, x1, y1, x2, y2, &transitionOut_, (*(void ***)this._nativePointer)[21]);
            if (transitionOut_ != System.IntPtr.Zero)
                transitionOut = new SharpDX.Animation.Transition2(transitionOut_);
            else
                transitionOut = null;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("8CEEB155-2849-4ce5-9448-91FF70E1E4D9")]
    public partial class Variable : SharpDX.ComObject
    {
        public Variable(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Variable(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Variable(nativePtr);
        /// <summary>
        /// <p> Gets the current value of the animation variable.</p>
        /// </summary>
        /// <remarks>
        /// <p>The results can be affected by the lower and upper bounds determined by <strong>IUIAnimationVariable::SetLowerBound</strong> and <strong>IUIAnimationVariable::SetUpperBound</strong>, respectively.</p>
        /// </remarks>
        /// <doc-id>dd317002</doc-id>
        /// <unmanaged>GetValue</unmanaged>
        /// <unmanaged-short>GetValue</unmanaged-short>
        public System.Double Value
        {
            get
            {
                GetValue(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p> Gets the final value of the animation variable.   This is the value after all currently scheduled animations have completed.</p>
        /// </summary>
        /// <remarks>
        /// <p>The result can be affected by the lower and upper bounds determined by <strong>IUIAnimationVariable::SetLowerBound</strong> and <strong>IUIAnimationVariable::SetUpperBound</strong>, respectively.</p>
        /// </remarks>
        /// <doc-id>dd316990</doc-id>
        /// <unmanaged>GetFinalValue</unmanaged>
        /// <unmanaged-short>GetFinalValue</unmanaged-short>
        public System.Double FinalValue
        {
            get
            {
                GetFinalValue(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p> Gets the previous value of the animation variable. This is the value of the animation variable before the most recent update.</p>
        /// </summary>
        /// <remarks>
        /// <p>The results can be affected by the lower and upper bounds determined by <strong>IUIAnimationVariable::SetLowerBound</strong> and <strong>IUIAnimationVariable::SetUpperBound</strong>, respectively.</p>
        /// </remarks>
        /// <doc-id>dd316996</doc-id>
        /// <unmanaged>GetPreviousValue</unmanaged>
        /// <unmanaged-short>GetPreviousValue</unmanaged-short>
        public System.Double PreviousValue
        {
            get
            {
                GetPreviousValue(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p> Gets the current value of the animation variable as an integer.</p>
        /// </summary>
        /// <remarks>
        /// <p>To specify the rounding mode to be used when converting the value, use the <strong>IUIAnimationVariable::SetRoundingMode</strong> method.</p><p>The result can also be affected by the lower and upper bounds determined by <strong>IUIAnimationVariable::SetLowerBound</strong> and <strong>IUIAnimationVariable::SetUpperBound</strong>, respectively.</p>
        /// </remarks>
        /// <doc-id>dd316991</doc-id>
        /// <unmanaged>GetIntegerValue</unmanaged>
        /// <unmanaged-short>GetIntegerValue</unmanaged-short>
        public System.Int32 IntegerValue
        {
            get
            {
                GetIntegerValue(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p> Gets the final value of the animation variable as an integer.       This is the value after all currently scheduled animations have completed.</p>
        /// </summary>
        /// <remarks>
        /// <p>To specify the rounding mode to be used when converting the value, use the <strong>IUIAnimationVariable::SetRoundingMode</strong> method.</p><p>The result can also be affected by the lower and upper bounds determined by <strong>IUIAnimationVariable::SetLowerBound</strong> and <strong>IUIAnimationVariable::SetUpperBound</strong>, respectively.</p>
        /// </remarks>
        /// <doc-id>dd316836</doc-id>
        /// <unmanaged>GetFinalIntegerValue</unmanaged>
        /// <unmanaged-short>GetFinalIntegerValue</unmanaged-short>
        public System.Int32 FinalIntegerValue
        {
            get
            {
                GetFinalIntegerValue(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p> Gets the previous value of the animation variable as an integer.       This is the value of the animation variable before the most recent update.</p>
        /// </summary>
        /// <remarks>
        /// <p>To specify the rounding mode to be used when converting the value, use the <strong>IUIAnimationVariable::SetRoundingMode</strong> method.</p><p>The result can also be affected by the lower and upper bounds determined by <strong>IUIAnimationVariable::SetLowerBound</strong> and <strong>IUIAnimationVariable::SetUpperBound</strong>, respectively.</p>
        /// </remarks>
        /// <doc-id>dd316994</doc-id>
        /// <unmanaged>GetPreviousIntegerValue</unmanaged>
        /// <unmanaged-short>GetPreviousIntegerValue</unmanaged-short>
        public System.Int32 PreviousIntegerValue
        {
            get
            {
                GetPreviousIntegerValue(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p> Gets the storyboard that is currently animating the animation variable.</p>
        /// </summary>
        /// <doc-id>dd316831</doc-id>
        /// <unmanaged>GetCurrentStoryboard</unmanaged>
        /// <unmanaged-short>GetCurrentStoryboard</unmanaged-short>
        public SharpDX.Animation.Storyboard CurrentStoryboard
        {
            get
            {
                GetCurrentStoryboard(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p> Sets the lower bound (floor) for the animation variable. The value of the animation variable should not fall below the specified value.</p>
        /// </summary>
        /// <doc-id>dd317005</doc-id>
        /// <unmanaged>SetLowerBound</unmanaged>
        /// <unmanaged-short>SetLowerBound</unmanaged-short>
        public System.Double LowerBound
        {
            set => SetLowerBound(value);
        }

        /// <summary>
        /// <p> Sets an upper bound (ceiling) for the animation variable. The value of the animation variable should not rise above the specified value.</p>
        /// </summary>
        /// <doc-id>dd317010</doc-id>
        /// <unmanaged>SetUpperBound</unmanaged>
        /// <unmanaged-short>SetUpperBound</unmanaged-short>
        public System.Double UpperBound
        {
            set => SetUpperBound(value);
        }

        /// <summary>
        /// <p> Specifies the rounding mode for the animation variable.</p>
        /// </summary>
        /// <remarks>
        /// <p> An animation variable's rounding mode determines how a floating-point value is converted to an integer. The default mode for each variable is <strong>UI_ANIMATION_ROUNDING_NEAREST</strong>.</p>
        /// </remarks>
        /// <doc-id>dd317006</doc-id>
        /// <unmanaged>SetRoundingMode</unmanaged>
        /// <unmanaged-short>SetRoundingMode</unmanaged-short>
        public SharpDX.Animation.RoundingMode RoundingMode
        {
            set => SetRoundingMode(value);
        }

        /// <summary>
        /// <p> Gets the current value of the animation variable.</p>
        /// </summary>
        /// <param name = "value"><dd> <p> The current value of the animation variable.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>The results can be affected by the lower and upper bounds determined by <strong>IUIAnimationVariable::SetLowerBound</strong> and <strong>IUIAnimationVariable::SetUpperBound</strong>, respectively.</p>
        /// </remarks>
        /// <doc-id>dd317002</doc-id>
        /// <unmanaged>HRESULT IUIAnimationVariable::GetValue([Out] double* value)</unmanaged>
        /// <unmanaged-short>IUIAnimationVariable::GetValue</unmanaged-short>
        internal unsafe void GetValue(out System.Double value)
        {
            SharpDX.Result __result__;
            fixed (void *value_ = &value)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, value_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Gets the final value of the animation variable.   This is the value after all currently scheduled animations have completed.</p>
        /// </summary>
        /// <param name = "finalValue"><dd> <p> The final value of the animation variable.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>UI_E_VALUE_NOT_DETERMINED</strong></dt> </dl> </td><td> <p>The final value of the animation variable cannot be determined at this time.</p> </td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>The result can be affected by the lower and upper bounds determined by <strong>IUIAnimationVariable::SetLowerBound</strong> and <strong>IUIAnimationVariable::SetUpperBound</strong>, respectively.</p>
        /// </remarks>
        /// <doc-id>dd316990</doc-id>
        /// <unmanaged>HRESULT IUIAnimationVariable::GetFinalValue([Out] double* finalValue)</unmanaged>
        /// <unmanaged-short>IUIAnimationVariable::GetFinalValue</unmanaged-short>
        internal unsafe void GetFinalValue(out System.Double finalValue)
        {
            SharpDX.Result __result__;
            fixed (void *finalValue_ = &finalValue)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, finalValue_, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Gets the previous value of the animation variable. This is the value of the animation variable before the most recent update.</p>
        /// </summary>
        /// <param name = "reviousValueRef"><dd> <p> The previous value of the animation variable.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>The results can be affected by the lower and upper bounds determined by <strong>IUIAnimationVariable::SetLowerBound</strong> and <strong>IUIAnimationVariable::SetUpperBound</strong>, respectively.</p>
        /// </remarks>
        /// <doc-id>dd316996</doc-id>
        /// <unmanaged>HRESULT IUIAnimationVariable::GetPreviousValue([Out] double* previousValue)</unmanaged>
        /// <unmanaged-short>IUIAnimationVariable::GetPreviousValue</unmanaged-short>
        internal unsafe void GetPreviousValue(out System.Double reviousValueRef)
        {
            SharpDX.Result __result__;
            fixed (void *reviousValueRef_ = &reviousValueRef)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, reviousValueRef_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Gets the current value of the animation variable as an integer.</p>
        /// </summary>
        /// <param name = "value"><dd> <p> The current value of the animation variable, converted to an <strong>INT32</strong> value.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>To specify the rounding mode to be used when converting the value, use the <strong>IUIAnimationVariable::SetRoundingMode</strong> method.</p><p>The result can also be affected by the lower and upper bounds determined by <strong>IUIAnimationVariable::SetLowerBound</strong> and <strong>IUIAnimationVariable::SetUpperBound</strong>, respectively.</p>
        /// </remarks>
        /// <doc-id>dd316991</doc-id>
        /// <unmanaged>HRESULT IUIAnimationVariable::GetIntegerValue([Out] int* value)</unmanaged>
        /// <unmanaged-short>IUIAnimationVariable::GetIntegerValue</unmanaged-short>
        internal unsafe void GetIntegerValue(out System.Int32 value)
        {
            SharpDX.Result __result__;
            fixed (void *value_ = &value)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, value_, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Gets the final value of the animation variable as an integer.       This is the value after all currently scheduled animations have completed.</p>
        /// </summary>
        /// <param name = "finalValue"><dd> <p> The final value of the animation variable, converted to an <strong>INT32</strong> value.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>UI_E_VALUE_NOT_DETERMINED</strong></dt> </dl> </td><td> <p>The final value of the animation variable cannot be determined at this time.</p> </td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>To specify the rounding mode to be used when converting the value, use the <strong>IUIAnimationVariable::SetRoundingMode</strong> method.</p><p>The result can also be affected by the lower and upper bounds determined by <strong>IUIAnimationVariable::SetLowerBound</strong> and <strong>IUIAnimationVariable::SetUpperBound</strong>, respectively.</p>
        /// </remarks>
        /// <doc-id>dd316836</doc-id>
        /// <unmanaged>HRESULT IUIAnimationVariable::GetFinalIntegerValue([Out] int* finalValue)</unmanaged>
        /// <unmanaged-short>IUIAnimationVariable::GetFinalIntegerValue</unmanaged-short>
        internal unsafe void GetFinalIntegerValue(out System.Int32 finalValue)
        {
            SharpDX.Result __result__;
            fixed (void *finalValue_ = &finalValue)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, finalValue_, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Gets the previous value of the animation variable as an integer.       This is the value of the animation variable before the most recent update.</p>
        /// </summary>
        /// <param name = "reviousValueRef"><dd> <p> The previous value of the animation variable, converted to an <strong>INT32</strong> value.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>To specify the rounding mode to be used when converting the value, use the <strong>IUIAnimationVariable::SetRoundingMode</strong> method.</p><p>The result can also be affected by the lower and upper bounds determined by <strong>IUIAnimationVariable::SetLowerBound</strong> and <strong>IUIAnimationVariable::SetUpperBound</strong>, respectively.</p>
        /// </remarks>
        /// <doc-id>dd316994</doc-id>
        /// <unmanaged>HRESULT IUIAnimationVariable::GetPreviousIntegerValue([Out] int* previousValue)</unmanaged>
        /// <unmanaged-short>IUIAnimationVariable::GetPreviousIntegerValue</unmanaged-short>
        internal unsafe void GetPreviousIntegerValue(out System.Int32 reviousValueRef)
        {
            SharpDX.Result __result__;
            fixed (void *reviousValueRef_ = &reviousValueRef)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, reviousValueRef_, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Gets the storyboard that is currently animating the animation variable.</p>
        /// </summary>
        /// <param name = "storyboard"><dd> <p>The current storyboard, or <strong><c>null</c></strong> if no storyboard is currently animating the animation variable.</p> </dd></param>
        /// <returns><p> If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>UIAnimation Error Codes</strong> for a list of error codes.</p></returns>
        /// <doc-id>dd316831</doc-id>
        /// <unmanaged>HRESULT IUIAnimationVariable::GetCurrentStoryboard([Out] IUIAnimationStoryboard** storyboard)</unmanaged>
        /// <unmanaged-short>IUIAnimationVariable::GetCurrentStoryboard</unmanaged-short>
        internal unsafe void GetCurrentStoryboard(out SharpDX.Animation.Storyboard storyboard)
        {
            System.IntPtr storyboard_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, &storyboard_, (*(void ***)this._nativePointer)[9]);
            if (storyboard_ != System.IntPtr.Zero)
                storyboard = new SharpDX.Animation.Storyboard(storyboard_);
            else
                storyboard = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Sets the lower bound (floor) for the animation variable. The value of the animation variable should not fall below the specified value.</p>
        /// </summary>
        /// <param name = "bound"><dd> <p> The lower bound for the animation variable.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <doc-id>dd317005</doc-id>
        /// <unmanaged>HRESULT IUIAnimationVariable::SetLowerBound([In] double bound)</unmanaged>
        /// <unmanaged-short>IUIAnimationVariable::SetLowerBound</unmanaged-short>
        internal unsafe void SetLowerBound(System.Double bound)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, bound, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Sets an upper bound (ceiling) for the animation variable. The value of the animation variable should not rise above the specified value.</p>
        /// </summary>
        /// <param name = "bound"><dd> <p> The upper bound for the animation variable.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <doc-id>dd317010</doc-id>
        /// <unmanaged>HRESULT IUIAnimationVariable::SetUpperBound([In] double bound)</unmanaged>
        /// <unmanaged-short>IUIAnimationVariable::SetUpperBound</unmanaged-short>
        internal unsafe void SetUpperBound(System.Double bound)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, bound, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Specifies the rounding mode for the animation variable.</p>
        /// </summary>
        /// <param name = "mode"><dd> <p> The rounding mode for the animation variable.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p> An animation variable's rounding mode determines how a floating-point value is converted to an integer. The default mode for each variable is <strong>UI_ANIMATION_ROUNDING_NEAREST</strong>.</p>
        /// </remarks>
        /// <doc-id>dd317006</doc-id>
        /// <unmanaged>HRESULT IUIAnimationVariable::SetRoundingMode([In] UI_ANIMATION_ROUNDING_MODE mode)</unmanaged>
        /// <unmanaged-short>IUIAnimationVariable::SetRoundingMode</unmanaged-short>
        internal unsafe void SetRoundingMode(SharpDX.Animation.RoundingMode mode)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)mode), (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Sets the tag for an animation variable.</p>
        /// </summary>
        /// <param name = "@object"><dd> <p> The object portion of the tag. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>
        /// <param name = "id"><dd> <p> The identifier portion  of the tag.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p> A tag is a pairing of an integer identifier (<em>id</em>) with a COM object (<em>object</em>); it can be used by an application to identify an animation variable.           Because <strong><c>null</c></strong> is a valid object component of a tag, the <em>object</em> parameter can be <strong><c>null</c></strong>.</p>
        /// </remarks>
        /// <doc-id>dd317008</doc-id>
        /// <unmanaged>HRESULT IUIAnimationVariable::SetTag([In, Optional] IUnknown* object,[In] unsigned int id)</unmanaged>
        /// <unmanaged-short>IUIAnimationVariable::SetTag</unmanaged-short>
        internal unsafe void SetTag(System.IntPtr @object, System.Int32 id)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)@object, id, (*(void ***)this._nativePointer)[13]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Gets the tag for an animation variable.</p>
        /// </summary>
        /// <param name = "@object"><dd> <p> The object portion of the tag.</p> </dd></param>
        /// <param name = "id"><dd> <p> The identifier portion of the tag.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>UI_E_VALUE_NOT_SET</strong></dt> </dl> </td><td> <p>The animation variable's tag was not set.</p> </td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>A tag is a pairing of an integer identifier (<em>id</em>) with a COM object (<em>object</em>); it can be used by an application to identify an animation variable.</p><p>The parameters are optional so that the method can return both portions of the tag, or just the identifier or object portion.</p>
        /// </remarks>
        /// <doc-id>dd316998</doc-id>
        /// <unmanaged>HRESULT IUIAnimationVariable::GetTag([Out, Optional] IUnknown** object,[Out, Optional] unsigned int* id)</unmanaged>
        /// <unmanaged-short>IUIAnimationVariable::GetTag</unmanaged-short>
        internal unsafe void GetTag(out System.IntPtr @object, out System.Int32 id)
        {
            SharpDX.Result __result__;
            fixed (void *id_ = &id)
                fixed (void *@object_ = &@object)
                    __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, @object_, id_, (*(void ***)this._nativePointer)[14]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Specifies a variable change handler. This handler is notified of changes to the value of the animation variable.</p>
        /// </summary>
        /// <param name = "handler"><dd> <p> A variable change handler.   The specified object must implement the <strong><see cref = "SharpDX.Animation.VariableChangeHandler"/></strong> interface or be <strong><c>null</c></strong>. See Remarks.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Passing <strong><c>null</c></strong> for the <em>handler</em> parameter causes Windows Animation to release its reference to any handler object you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong>IUIAnimationManager::Shutdown</strong> method.</p>
        /// </remarks>
        /// <doc-id>dd317011</doc-id>
        /// <unmanaged>HRESULT IUIAnimationVariable::SetVariableChangeHandler([In, Optional] IUIAnimationVariableChangeHandler* handler)</unmanaged>
        /// <unmanaged-short>IUIAnimationVariable::SetVariableChangeHandler</unmanaged-short>
        internal unsafe void SetVariableChangeHandler(SharpDX.Animation.VariableChangeHandler handler)
        {
            System.IntPtr handler_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            handler_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.VariableChangeHandler>(handler);
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)handler_, (*(void ***)this._nativePointer)[15]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Specifies an integer variable change handler. This handler is notified of changes to the integer value of the animation variable.</p>
        /// </summary>
        /// <param name = "handler"><dd> <p> An integer variable change handler.   The specified object must implement the <strong><see cref = "SharpDX.Animation.VariableIntegerChangeHandler"/></strong> interface or be <c>null</c>. See Remarks.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Winodws Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Passing <c>null</c> for the <em>handler</em> parameter causes Windows Animation to release its reference to any handler object you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong>IUIAnimationManager::Shutdown</strong> method.</p><p> <strong>IUIAnimationVariableIntegerChangeHandler::OnIntegerValueChanged</strong> is called only if the rounded value has changed since the last update.</p>
        /// </remarks>
        /// <doc-id>dd317013</doc-id>
        /// <unmanaged>HRESULT IUIAnimationVariable::SetVariableIntegerChangeHandler([In, Optional] IUIAnimationVariableIntegerChangeHandler* handler)</unmanaged>
        /// <unmanaged-short>IUIAnimationVariable::SetVariableIntegerChangeHandler</unmanaged-short>
        internal unsafe void SetVariableIntegerChangeHandler(SharpDX.Animation.VariableIntegerChangeHandler handler)
        {
            System.IntPtr handler_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            handler_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.VariableIntegerChangeHandler>(handler);
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)handler_, (*(void ***)this._nativePointer)[16]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("4914B304-96AB-44d9-9E77-D5109B7E7466")]
    public partial class Variable2 : SharpDX.ComObject
    {
        public Variable2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Variable2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Variable2(nativePtr);
        /// <summary>
        /// <p>Gets the number of dimensions that the animation variable is to be animated in.</p>
        /// </summary>
        /// <doc-id>hh448635</doc-id>
        /// <unmanaged>GetDimension</unmanaged>
        /// <unmanaged-short>GetDimension</unmanaged-short>
        public System.Int32 Dimension
        {
            get
            {
                GetDimension(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the value of the animation variable in the specified dimension.</p>
        /// </summary>
        /// <doc-id>hh448649</doc-id>
        /// <unmanaged>GetValue</unmanaged>
        /// <unmanaged-short>GetValue</unmanaged-short>
        public System.Double Value
        {
            get
            {
                GetValue(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the final value of the animation variable. This is the value after all currently scheduled animations have completed.</p>
        /// </summary>
        /// <doc-id>hh448638</doc-id>
        /// <unmanaged>GetFinalValue</unmanaged>
        /// <unmanaged-short>GetFinalValue</unmanaged-short>
        public System.Double FinalValue
        {
            get
            {
                GetFinalValue(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the previous value of the animation variable. This is the value of the animation variable before the most recent update.</p>
        /// </summary>
        /// <doc-id>hh448644</doc-id>
        /// <unmanaged>GetPreviousValue</unmanaged>
        /// <unmanaged-short>GetPreviousValue</unmanaged-short>
        public System.Double PreviousValue
        {
            get
            {
                GetPreviousValue(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the integer value of the animation variable.</p>
        /// </summary>
        /// <doc-id>hh448640</doc-id>
        /// <unmanaged>GetIntegerValue</unmanaged>
        /// <unmanaged-short>GetIntegerValue</unmanaged-short>
        public System.Int32 IntegerValue
        {
            get
            {
                GetIntegerValue(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the final integer value of the animation variable. This is the value after all currently scheduled animations have completed.</p>
        /// </summary>
        /// <doc-id>hh448636</doc-id>
        /// <unmanaged>GetFinalIntegerValue</unmanaged>
        /// <unmanaged-short>GetFinalIntegerValue</unmanaged-short>
        public System.Int32 FinalIntegerValue
        {
            get
            {
                GetFinalIntegerValue(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the previous integer value of the animation variable in the specified dimension. This is the value of the animation variable before the most recent update.</p>
        /// </summary>
        /// <doc-id>hh448642</doc-id>
        /// <unmanaged>GetPreviousIntegerValue</unmanaged>
        /// <unmanaged-short>GetPreviousIntegerValue</unmanaged-short>
        public System.Int32 PreviousIntegerValue
        {
            get
            {
                GetPreviousIntegerValue(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the active storyboard for the animation variable.</p>
        /// </summary>
        /// <doc-id>hh448633</doc-id>
        /// <unmanaged>GetCurrentStoryboard</unmanaged>
        /// <unmanaged-short>GetCurrentStoryboard</unmanaged-short>
        public SharpDX.Animation.Storyboard2 CurrentStoryboard
        {
            get
            {
                GetCurrentStoryboard(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Sets the lower bound (floor) for the value of the animation variable. The value of the animation variable should not fall below the specified value.</p>
        /// </summary>
        /// <doc-id>hh448650</doc-id>
        /// <unmanaged>SetLowerBound</unmanaged>
        /// <unmanaged-short>SetLowerBound</unmanaged-short>
        public System.Double LowerBound
        {
            set => SetLowerBound(value);
        }

        /// <summary>
        /// <p>Sets the upper bound (ceiling) for the value of the animation variable. The value of the animation variable should not rise above the specified value.</p>
        /// </summary>
        /// <doc-id>hh448654</doc-id>
        /// <unmanaged>SetUpperBound</unmanaged>
        /// <unmanaged-short>SetUpperBound</unmanaged-short>
        public System.Double UpperBound
        {
            set => SetUpperBound(value);
        }

        /// <summary>
        /// <p>Sets the rounding mode of the animation variable.</p>
        /// </summary>
        /// <remarks>
        /// <p> An animation variable's rounding mode determines how a floating-point value is converted to an integer. The default mode for each variable is <strong>UI_ANIMATION_ROUNDING_NEAREST</strong>.</p>
        /// </remarks>
        /// <doc-id>hh448652</doc-id>
        /// <unmanaged>SetRoundingMode</unmanaged>
        /// <unmanaged-short>SetRoundingMode</unmanaged-short>
        public SharpDX.Animation.RoundingMode RoundingMode
        {
            set => SetRoundingMode(value);
        }

        /// <summary>
        /// <p>Gets the number of dimensions that the animation variable is to be animated in.</p>
        /// </summary>
        /// <param name = "dimension"><dd> <p>The number of dimensions.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <doc-id>hh448635</doc-id>
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetDimension([Out] unsigned int* dimension)</unmanaged>
        /// <unmanaged-short>IUIAnimationVariable2::GetDimension</unmanaged-short>
        internal unsafe void GetDimension(out System.Int32 dimension)
        {
            SharpDX.Result __result__;
            fixed (void *dimension_ = &dimension)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, dimension_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the value of the animation variable in the specified dimension.</p>
        /// </summary>
        /// <param name = "value"><dd> <p>The value of the animation variable.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <doc-id>hh448649</doc-id>
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetValue([Out] double* value)</unmanaged>
        /// <unmanaged-short>IUIAnimationVariable2::GetValue</unmanaged-short>
        internal unsafe void GetValue(out System.Double value)
        {
            SharpDX.Result __result__;
            fixed (void *value_ = &value)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, value_, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the value of the animation variable in the specified dimension.</p>
        /// </summary>
        /// <param name = "value"><dd> <p>The value of the animation variable.</p> </dd></param>
        /// <param name = "cDimension"><dd> <p>The dimension from which to get the value of the animation variable.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <doc-id>hh448649</doc-id>
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetVectorValue([Out, Buffer] double* value,[In] unsigned int cDimension)</unmanaged>
        /// <unmanaged-short>IUIAnimationVariable2::GetVectorValue</unmanaged-short>
        public unsafe void GetVectorValue(System.Double[] value, System.Int32 cDimension)
        {
            SharpDX.Result __result__;
            fixed (void *value_ = value)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, value_, cDimension, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the animation curve of the animation variable.</p>
        /// </summary>
        /// <param name = "animation"><dd> <p>The object that generates a sequence of animation curve primitives.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>The application implements the <strong><see cref = "SharpDX.DirectComposition.Animation"/></strong> object that is referenced by the <em>animation</em> parameter.</p>
        /// </remarks>
        /// <doc-id>hh448634</doc-id>
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetCurve([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IUIAnimationVariable2::GetCurve</unmanaged-short>
        public unsafe void GetCurve(SharpDX.IUnknown animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(animation);
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the animation curve of the animation variable for the specified dimension.</p>
        /// </summary>
        /// <param name = "animation"><dd> <p>The object that generates a sequence of animation curve primitives.</p> </dd></param>
        /// <param name = "cDimension"><dd> <p>The number of animation curves.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>The application implements the <strong><see cref = "SharpDX.DirectComposition.Animation"/></strong> object that is referenced by the <em>animation</em> parameter.</p>
        /// </remarks>
        /// <doc-id>hh448648</doc-id>
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetVectorCurve([In, Buffer] IDCompositionAnimation** animation,[In] unsigned int cDimension)</unmanaged>
        /// <unmanaged-short>IUIAnimationVariable2::GetVectorCurve</unmanaged-short>
        public unsafe void GetVectorCurve(SharpDX.IUnknown[] animation, System.Int32 cDimension)
        {
            System.IntPtr*animation_;
            animation_ = (System.IntPtr*)0;
            if (animation != null)
            {
                System.IntPtr*_animation = stackalloc System.IntPtr[animation.Length];
                animation_ = _animation;
            }

            SharpDX.Result __result__;
            if (animation != null)
                for (int i = 0; i < animation.Length; ++i)
                    (animation_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(animation[i]);
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, cDimension, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the final value of the animation variable. This is the value after all currently scheduled animations have completed.</p>
        /// </summary>
        /// <param name = "finalValue"><dd> <p>The final value of the animation variable.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <doc-id>hh448638</doc-id>
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetFinalValue([Out] double* finalValue)</unmanaged>
        /// <unmanaged-short>IUIAnimationVariable2::GetFinalValue</unmanaged-short>
        internal unsafe void GetFinalValue(out System.Double finalValue)
        {
            SharpDX.Result __result__;
            fixed (void *finalValue_ = &finalValue)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, finalValue_, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the final value of the animation variable for the specified dimension. This is the value after all currently scheduled animations have completed.</p>
        /// </summary>
        /// <param name = "finalValue"><dd> <p>The final value of the animation variable.</p> </dd></param>
        /// <param name = "cDimension"><dd> <p>The dimension from which to get the value of the animation variable.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <doc-id>hh448639</doc-id>
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetFinalVectorValue([Out, Buffer] double* finalValue,[In] unsigned int cDimension)</unmanaged>
        /// <unmanaged-short>IUIAnimationVariable2::GetFinalVectorValue</unmanaged-short>
        public unsafe void GetFinalVectorValue(System.Double[] finalValue, System.Int32 cDimension)
        {
            SharpDX.Result __result__;
            fixed (void *finalValue_ = finalValue)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, finalValue_, cDimension, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the previous value of the animation variable. This is the value of the animation variable before the most recent update.</p>
        /// </summary>
        /// <param name = "reviousValueRef"><dd> <p>The previous value of the animation variable.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <doc-id>hh448644</doc-id>
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetPreviousValue([Out] double* previousValue)</unmanaged>
        /// <unmanaged-short>IUIAnimationVariable2::GetPreviousValue</unmanaged-short>
        internal unsafe void GetPreviousValue(out System.Double reviousValueRef)
        {
            SharpDX.Result __result__;
            fixed (void *reviousValueRef_ = &reviousValueRef)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, reviousValueRef_, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the previous value of the animation variable for the specified dimension. This is the value of the animation variable before the most recent update.</p>
        /// </summary>
        /// <param name = "reviousValueRef"><dd> <p>The previous value of the animation variable.</p> </dd></param>
        /// <param name = "cDimension"><dd> <p>The dimension from which to get the value of the animation variable.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <doc-id>hh448645</doc-id>
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetPreviousVectorValue([Out, Buffer] double* previousValue,[In] unsigned int cDimension)</unmanaged>
        /// <unmanaged-short>IUIAnimationVariable2::GetPreviousVectorValue</unmanaged-short>
        public unsafe void GetPreviousVectorValue(System.Double[] reviousValueRef, System.Int32 cDimension)
        {
            SharpDX.Result __result__;
            fixed (void *reviousValueRef_ = reviousValueRef)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, reviousValueRef_, cDimension, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the integer value of the animation variable.</p>
        /// </summary>
        /// <param name = "value"><dd> <p>The value of the animation variable as an integer.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <doc-id>hh448640</doc-id>
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetIntegerValue([Out] int* value)</unmanaged>
        /// <unmanaged-short>IUIAnimationVariable2::GetIntegerValue</unmanaged-short>
        internal unsafe void GetIntegerValue(out System.Int32 value)
        {
            SharpDX.Result __result__;
            fixed (void *value_ = &value)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, value_, (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the integer value of the animation variable for the specified dimension.</p>
        /// </summary>
        /// <param name = "value"><dd> <p>The value of the animation variable as an integer.</p> </dd></param>
        /// <param name = "cDimension"><dd> <p>The dimension from which to get the value of the animation variable.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <doc-id>hh448641</doc-id>
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetIntegerVectorValue([Out, Buffer] int* value,[In] unsigned int cDimension)</unmanaged>
        /// <unmanaged-short>IUIAnimationVariable2::GetIntegerVectorValue</unmanaged-short>
        public unsafe void GetIntegerVectorValue(System.Int32[] value, System.Int32 cDimension)
        {
            SharpDX.Result __result__;
            fixed (void *value_ = value)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, value_, cDimension, (*(void ***)this._nativePointer)[13]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the final integer value of the animation variable. This is the value after all currently scheduled animations have completed.</p>
        /// </summary>
        /// <param name = "finalValue"><dd> <p>The final value of the animation variable as an integer.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <doc-id>hh448636</doc-id>
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetFinalIntegerValue([Out] int* finalValue)</unmanaged>
        /// <unmanaged-short>IUIAnimationVariable2::GetFinalIntegerValue</unmanaged-short>
        internal unsafe void GetFinalIntegerValue(out System.Int32 finalValue)
        {
            SharpDX.Result __result__;
            fixed (void *finalValue_ = &finalValue)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, finalValue_, (*(void ***)this._nativePointer)[14]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the final integer value of the animation variable for the specified dimension. This is the value after all currently scheduled animations have completed.</p>
        /// </summary>
        /// <param name = "finalValue"><dd> <p>The final value of the animation variable as an integer.</p> </dd></param>
        /// <param name = "cDimension"><dd> <p>The dimension from which to get the value of the animation variable.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <doc-id>hh448637</doc-id>
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetFinalIntegerVectorValue([Out, Buffer] int* finalValue,[In] unsigned int cDimension)</unmanaged>
        /// <unmanaged-short>IUIAnimationVariable2::GetFinalIntegerVectorValue</unmanaged-short>
        public unsafe void GetFinalIntegerVectorValue(System.Int32[] finalValue, System.Int32 cDimension)
        {
            SharpDX.Result __result__;
            fixed (void *finalValue_ = finalValue)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, finalValue_, cDimension, (*(void ***)this._nativePointer)[15]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the previous integer value of the animation variable in the specified dimension. This is the value of the animation variable before the most recent update.</p>
        /// </summary>
        /// <param name = "reviousValueRef"><dd> <p>The previous value of the animation variable as an integer.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <doc-id>hh448642</doc-id>
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetPreviousIntegerValue([Out] int* previousValue)</unmanaged>
        /// <unmanaged-short>IUIAnimationVariable2::GetPreviousIntegerValue</unmanaged-short>
        internal unsafe void GetPreviousIntegerValue(out System.Int32 reviousValueRef)
        {
            SharpDX.Result __result__;
            fixed (void *reviousValueRef_ = &reviousValueRef)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, reviousValueRef_, (*(void ***)this._nativePointer)[16]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the previous integer value of the animation variable for the specified dimension. This is the value of the animation variable before the most recent update.</p>
        /// </summary>
        /// <param name = "reviousValueRef"><dd> <p>The previous value of the animation variable as an integer.</p> </dd></param>
        /// <param name = "cDimension"><dd> <p>The dimension from which to get the value of the animation variable.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <doc-id>hh448643</doc-id>
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetPreviousIntegerVectorValue([Out, Buffer] int* previousValue,[In] unsigned int cDimension)</unmanaged>
        /// <unmanaged-short>IUIAnimationVariable2::GetPreviousIntegerVectorValue</unmanaged-short>
        public unsafe void GetPreviousIntegerVectorValue(System.Int32[] reviousValueRef, System.Int32 cDimension)
        {
            SharpDX.Result __result__;
            fixed (void *reviousValueRef_ = reviousValueRef)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, reviousValueRef_, cDimension, (*(void ***)this._nativePointer)[17]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the active storyboard for the animation variable.</p>
        /// </summary>
        /// <param name = "storyboard"><dd> <p>The active storyboard, or <c>null</c> if the animation variable is not being animated.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <doc-id>hh448633</doc-id>
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetCurrentStoryboard([Out] IUIAnimationStoryboard2** storyboard)</unmanaged>
        /// <unmanaged-short>IUIAnimationVariable2::GetCurrentStoryboard</unmanaged-short>
        internal unsafe void GetCurrentStoryboard(out SharpDX.Animation.Storyboard2 storyboard)
        {
            System.IntPtr storyboard_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, &storyboard_, (*(void ***)this._nativePointer)[18]);
            if (storyboard_ != System.IntPtr.Zero)
                storyboard = new SharpDX.Animation.Storyboard2(storyboard_);
            else
                storyboard = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the lower bound (floor) for the value of the animation variable. The value of the animation variable should not fall below the specified value.</p>
        /// </summary>
        /// <param name = "bound"><dd> <p>The lower bound for the value of the animation variable.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <doc-id>hh448650</doc-id>
        /// <unmanaged>HRESULT IUIAnimationVariable2::SetLowerBound([In] double bound)</unmanaged>
        /// <unmanaged-short>IUIAnimationVariable2::SetLowerBound</unmanaged-short>
        internal unsafe void SetLowerBound(System.Double bound)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, bound, (*(void ***)this._nativePointer)[19]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the lower bound (floor) value of each specified dimension for the animation variable. The value of each animation variable should not fall below its lower bound.</p>
        /// </summary>
        /// <param name = "bound"><dd> <p>A vector (of size <em>cDimension</em>) that contains  the lower bound values of each dimension.</p> </dd></param>
        /// <param name = "cDimension"><dd> <p>The number of dimensions that require lower bound values. This parameter specifies the number of values listed in <em>bound</em>.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <doc-id>hh448651</doc-id>
        /// <unmanaged>HRESULT IUIAnimationVariable2::SetLowerBoundVector([In, Buffer] const double* bound,[In] unsigned int cDimension)</unmanaged>
        /// <unmanaged-short>IUIAnimationVariable2::SetLowerBoundVector</unmanaged-short>
        public unsafe void SetLowerBoundVector(System.Double[] bound, System.Int32 cDimension)
        {
            SharpDX.Result __result__;
            fixed (void *bound_ = bound)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, bound_, cDimension, (*(void ***)this._nativePointer)[20]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the upper bound (ceiling) for the value of the animation variable. The value of the animation variable should not rise above the specified value.</p>
        /// </summary>
        /// <param name = "bound"><dd> <p>The upper bound for the value of the animation variable.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <doc-id>hh448654</doc-id>
        /// <unmanaged>HRESULT IUIAnimationVariable2::SetUpperBound([In] double bound)</unmanaged>
        /// <unmanaged-short>IUIAnimationVariable2::SetUpperBound</unmanaged-short>
        internal unsafe void SetUpperBound(System.Double bound)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, bound, (*(void ***)this._nativePointer)[21]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the upper bound (ceiling) value of each specified dimension for the animation variable. The value of each animation variable should not rise above its upper bound.</p>
        /// </summary>
        /// <param name = "bound"><dd> <p>A vector (of size <em>cDimension</em>) that contains  the upper bound values of each dimension.</p> </dd></param>
        /// <param name = "cDimension"><dd> <p>The number of dimensions that require upper bound values. This parameter specifies the number of values listed in <em>bound</em>.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <doc-id>hh448655</doc-id>
        /// <unmanaged>HRESULT IUIAnimationVariable2::SetUpperBoundVector([In, Buffer] const double* bound,[In] unsigned int cDimension)</unmanaged>
        /// <unmanaged-short>IUIAnimationVariable2::SetUpperBoundVector</unmanaged-short>
        public unsafe void SetUpperBoundVector(System.Double[] bound, System.Int32 cDimension)
        {
            SharpDX.Result __result__;
            fixed (void *bound_ = bound)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, bound_, cDimension, (*(void ***)this._nativePointer)[22]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the rounding mode of the animation variable.</p>
        /// </summary>
        /// <param name = "mode"><dd> <p>The rounding mode.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p> An animation variable's rounding mode determines how a floating-point value is converted to an integer. The default mode for each variable is <strong>UI_ANIMATION_ROUNDING_NEAREST</strong>.</p>
        /// </remarks>
        /// <doc-id>hh448652</doc-id>
        /// <unmanaged>HRESULT IUIAnimationVariable2::SetRoundingMode([In] UI_ANIMATION_ROUNDING_MODE mode)</unmanaged>
        /// <unmanaged-short>IUIAnimationVariable2::SetRoundingMode</unmanaged-short>
        internal unsafe void SetRoundingMode(SharpDX.Animation.RoundingMode mode)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)mode), (*(void ***)this._nativePointer)[23]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the tag of the animation variable. </p>
        /// </summary>
        /// <param name = "@object"><dd> <p>The object portion of the tag. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>
        /// <param name = "id"><dd> <p>The identifier portion of the tag. </p> </dd></param>
        /// <returns><p>Returns <strong><see cref = "SharpDX.Result.Ok"/></strong> if successful; otherwise an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p> A tag is a pairing of an integer identifier (<em>id</em>) with a COM object (<em>object</em>), and it can be used by an application to identify an animation variable.           Because <strong><c>null</c></strong> is a valid object component of a tag, the <em>object</em> parameter can be <strong><c>null</c></strong>.</p>
        /// </remarks>
        /// <doc-id>hh448653</doc-id>
        /// <unmanaged>HRESULT IUIAnimationVariable2::SetTag([In, Optional] IUnknown* object,[In] unsigned int id)</unmanaged>
        /// <unmanaged-short>IUIAnimationVariable2::SetTag</unmanaged-short>
        public unsafe void SetTag(SharpDX.IUnknown @object, System.Int32 id)
        {
            System.IntPtr @object_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            @object_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(@object);
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)@object_, id, (*(void ***)this._nativePointer)[24]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Gets the tag of the animation variable.</p>
        /// </summary>
        /// <param name = "@object"><dd> <p> The object portion of the tag.</p> </dd></param>
        /// <param name = "id"><dd> <p> The identifier portion of the tag.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>A tag is a pairing of an integer identifier (<em>id</em>) with a COM object (<em>object</em>); it can be used by an application to identify an animation variable.</p><p>The parameters are optional, so that the method can return both portions of the tag, or just the identifier or object portion.</p>
        /// </remarks>
        /// <doc-id>hh448646</doc-id>
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetTag([Out, Optional] IUnknown** object,[Out, Optional] unsigned int* id)</unmanaged>
        /// <unmanaged-short>IUIAnimationVariable2::GetTag</unmanaged-short>
        public unsafe void GetTag(out SharpDX.IUnknown @object, out System.Int32 id)
        {
            System.IntPtr @object_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *id_ = &id)
                __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, &@object_, id_, (*(void ***)this._nativePointer)[25]);
            if (@object_ != System.IntPtr.Zero)
                @object = new SharpDX.ComObject(@object_);
            else
                @object = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Specifies a handler for changes to the value of the animation variable. </p>
        /// </summary>
        /// <param name = "handler"><dd> <p>The handler for changes to the value of the animation variable. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>
        /// <param name = "fRegisterForNextAnimationEvent"><dd> <p>If <strong>TRUE</strong>, specifies that the <strong>EstimateNextEventTime</strong> method will incorporate <em>handler</em> into its estimate of the time interval until the next animation event. No default value.</p> </dd></param>
        /// <returns><p>Returns <strong><see cref = "SharpDX.Result.Ok"/></strong> if successful; otherwise an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Passing <strong><c>null</c></strong> for the <em>handler</em> parameter causes Windows Animation to release its reference to any handler object that you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong>IUIAnimationManager2::Shutdown</strong> method.</p>
        /// </remarks>
        /// <doc-id>hh448656</doc-id>
        /// <unmanaged>HRESULT IUIAnimationVariable2::SetVariableChangeHandler([In, Optional] IUIAnimationVariableChangeHandler2* handler,[In] BOOL fRegisterForNextAnimationEvent)</unmanaged>
        /// <unmanaged-short>IUIAnimationVariable2::SetVariableChangeHandler</unmanaged-short>
        internal unsafe void SetVariableChangeHandler(SharpDX.Animation.VariableChangeHandler2 handler, SharpDX.Mathematics.Interop.RawBool fRegisterForNextAnimationEvent)
        {
            System.IntPtr handler_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            handler_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.VariableChangeHandler2>(handler);
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint0(this._nativePointer, (void *)handler_, fRegisterForNextAnimationEvent, (*(void ***)this._nativePointer)[26]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Specifies a handler for changes to the integer value of the animation variable. </p>
        /// </summary>
        /// <param name = "handler"><dd> <p>A reference to the handler for changes to the integer value of the animation variable. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>
        /// <param name = "fRegisterForNextAnimationEvent"><dd> <p>If <strong>TRUE</strong>, specifies that the <strong>EstimateNextEventTime</strong> method will incorporate <em>handler</em> into its estimate of the time interval until the next animation event. No default value.</p> </dd></param>
        /// <returns><p>Returns <strong><see cref = "SharpDX.Result.Ok"/></strong> if successful; otherwise an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Passing <strong><c>null</c></strong> for the <em>handler</em> parameter causes Windows Animation to release its reference to any handler object that you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong>Shutdown</strong> method.</p><p> <strong>IUIAnimationVariableIntegerChangeHandler2::OnIntegerValueChanged</strong> is called only if the rounded value has changed since the last update.</p>
        /// </remarks>
        /// <doc-id>hh448658</doc-id>
        /// <unmanaged>HRESULT IUIAnimationVariable2::SetVariableIntegerChangeHandler([In, Optional] IUIAnimationVariableIntegerChangeHandler2* handler,[In] BOOL fRegisterForNextAnimationEvent)</unmanaged>
        /// <unmanaged-short>IUIAnimationVariable2::SetVariableIntegerChangeHandler</unmanaged-short>
        internal unsafe void SetVariableIntegerChangeHandler(SharpDX.Animation.VariableIntegerChangeHandler2 handler, SharpDX.Mathematics.Interop.RawBool fRegisterForNextAnimationEvent)
        {
            System.IntPtr handler_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            handler_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.VariableIntegerChangeHandler2>(handler);
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint0(this._nativePointer, (void *)handler_, fRegisterForNextAnimationEvent, (*(void ***)this._nativePointer)[27]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Specifies a handler for changes to the animation curve of the animation variable. </p>
        /// </summary>
        /// <param name = "handler"><dd> <p>A reference to the handler for changes to the animation curve of the animation variable. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise an <strong><see cref = "SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>
        /// <doc-id>hh448657</doc-id>
        /// <unmanaged>HRESULT IUIAnimationVariable2::SetVariableCurveChangeHandler([In, Optional] IUIAnimationVariableCurveChangeHandler2* handler)</unmanaged>
        /// <unmanaged-short>IUIAnimationVariable2::SetVariableCurveChangeHandler</unmanaged-short>
        internal unsafe void SetVariableCurveChangeHandler(SharpDX.Animation.VariableCurveChangeHandler2 handler)
        {
            System.IntPtr handler_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            handler_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Animation.VariableCurveChangeHandler2>(handler);
            __result__ = SharpDX.Animation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)handler_, (*(void ***)this._nativePointer)[28]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("6358B7BA-87D2-42d5-BF71-82E919DD5862")]
    internal partial interface VariableChangeHandler : SharpDX.IUnknown
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("63ACC8D2-6EAE-4bb0-B879-586DD8CFBE42")]
    internal partial interface VariableChangeHandler2 : SharpDX.IUnknown
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("72895E91-0145-4C21-9192-5AAB40EDDF80")]
    internal partial interface VariableCurveChangeHandler2 : SharpDX.IUnknown
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("BB3E1550-356E-44b0-99DA-85AC6017865E")]
    internal partial interface VariableIntegerChangeHandler : SharpDX.IUnknown
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("829B6CF1-4F3A-4412-AE09-B243EB4C6B58")]
    internal partial interface VariableIntegerChangeHandler2 : SharpDX.IUnknown
    {
    }
}
// <auto-generated/>

namespace SharpDX.Direct2D1
{
    /// <summary>
    /// Functions
    /// </summary>
    static partial class D2D1
    {
        /// <summary>
        /// <p>Creates a factory object  that can be used to create Direct2D resources.</p>
        /// </summary>
        /// <param name = "factoryType"><dd>  <p>The threading model of the factory and the resources it creates.</p> </dd></param>
        /// <param name = "riid"><dd>  <p>A reference to the IID of <strong><see cref = "SharpDX.Direct2D1.Factory"/></strong> that is obtained by using __uuidof(<see cref = "SharpDX.Direct2D1.Factory"/>).</p> </dd></param>
        /// <param name = "factoryOptionsRef"><dd>  <p>The level of detail provided to the debugging layer.</p> </dd></param>
        /// <param name = "iFactoryOut"><dd>  <p>When this method returns, contains the address to a reference to the new factory.</p> </dd></param>
        /// <returns><p>If this function succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The <strong><see cref = "SharpDX.Direct2D1.Factory"/></strong> interface provides the starting point for  Direct2D. In general, objects created from a single instance of a factory object can be used with other resources created from that instance, but not with resources created by other factory instances.   </p>
        /// </remarks>
        /// <doc-id>dd368034</doc-id>
        /// <unmanaged>HRESULT D2D1CreateFactory([In] D2D1_FACTORY_TYPE factoryType,[In] const GUID&amp; riid,[In, Optional] const D2D1_FACTORY_OPTIONS* pFactoryOptions,[Out] void** ppIFactory)</unmanaged>
        /// <unmanaged-short>D2D1CreateFactory</unmanaged-short>
        public static unsafe void CreateFactory(SharpDX.Direct2D1.FactoryType factoryType, System.Guid riid, SharpDX.Direct2D1.FactoryOptions? factoryOptionsRef, out System.IntPtr iFactoryOut)
        {
            SharpDX.Direct2D1.FactoryOptions factoryOptionsRef_;
            SharpDX.Result __result__;
            if (factoryOptionsRef != null)
                factoryOptionsRef_ = factoryOptionsRef.Value;
            fixed (void *iFactoryOut_ = &iFactoryOut)
                __result__ = D2D1CreateFactory_(unchecked ((System.Int32)factoryType), &riid, factoryOptionsRef == null ? (void *)0 : &factoryOptionsRef_, iFactoryOut_);
            __result__.CheckError();
        }

        [System.Runtime.InteropServices.DllImportAttribute("d2d1.dll", EntryPoint = "D2D1CreateFactory", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern int D2D1CreateFactory_(int param0, void *param1, void *param2, void *param3);
        /// <summary>
        /// <p>Creates a rotation transformation that rotates by the specified angle about the specified point.</p>
        /// </summary>
        /// <param name = "angle"><dd>  <p>The clockwise rotation angle, in degrees. </p> </dd></param>
        /// <param name = "center"><dd>  <p>The point about which to rotate.</p> </dd></param>
        /// <param name = "matrix"><dd>  <p>When this method returns, contains the new rotation transformation. You must allocate storage for this parameter.  </p> </dd></param>
        /// <remarks>
        /// <p>Rotation occurs in the plane of the 2-D surface.</p>
        /// </remarks>
        /// <doc-id>dd368049</doc-id>
        /// <unmanaged>void D2D1MakeRotateMatrix([In] float angle,[In] D2D_POINT_2F center,[Out] D2D_MATRIX_3X2_F* matrix)</unmanaged>
        /// <unmanaged-short>D2D1MakeRotateMatrix</unmanaged-short>
        public static unsafe void MakeRotateMatrix(System.Single angle, SharpDX.Mathematics.Interop.RawVector2 center, out SharpDX.Mathematics.Interop.RawMatrix3x2 matrix)
        {
            matrix = default (SharpDX.Mathematics.Interop.RawMatrix3x2);
            fixed (void *matrix_ = &matrix)
                D2D1MakeRotateMatrix_(angle, center, matrix_);
        }

        [System.Runtime.InteropServices.DllImportAttribute("d2d1.dll", EntryPoint = "D2D1MakeRotateMatrix", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern void D2D1MakeRotateMatrix_(float param0, SharpDX.Mathematics.Interop.RawVector2 param1, void *param2);
        /// <summary>
        /// <p>Creates a skew transformation that has the specified x-axis angle, y-axis angle, and center point. </p>
        /// </summary>
        /// <param name = "angleX"><dd>  <p>The x-axis skew angle, which is measured in degrees counterclockwise from the y-axis.</p> </dd></param>
        /// <param name = "angleY"><dd>  <p>The y-axis skew angle, which is measured in degrees counterclockwise from the x-axis.</p> </dd></param>
        /// <param name = "center"><dd>  <p>The center point of the skew operation.</p> </dd></param>
        /// <param name = "matrix"><dd>  <p>When this method returns, contains the rotation transformation. You must allocate storate for this parameter.</p> </dd></param>
        /// <doc-id>dd368052</doc-id>
        /// <unmanaged>void D2D1MakeSkewMatrix([In] float angleX,[In] float angleY,[In] D2D_POINT_2F center,[Out] D2D_MATRIX_3X2_F* matrix)</unmanaged>
        /// <unmanaged-short>D2D1MakeSkewMatrix</unmanaged-short>
        public static unsafe void MakeSkewMatrix(System.Single angleX, System.Single angleY, SharpDX.Mathematics.Interop.RawVector2 center, out SharpDX.Mathematics.Interop.RawMatrix3x2 matrix)
        {
            matrix = default (SharpDX.Mathematics.Interop.RawMatrix3x2);
            fixed (void *matrix_ = &matrix)
                D2D1MakeSkewMatrix_(angleX, angleY, center, matrix_);
        }

        [System.Runtime.InteropServices.DllImportAttribute("d2d1.dll", EntryPoint = "D2D1MakeSkewMatrix", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern void D2D1MakeSkewMatrix_(float param0, float param1, SharpDX.Mathematics.Interop.RawVector2 param2, void *param3);
        /// <summary>
        /// <p>Indicates whether the specified matrix is invertible.</p>
        /// </summary>
        /// <param name = "matrix"><dd>  <p>The matrix to test.</p> </dd></param>
        /// <returns><p><strong>true</strong> if the matrix was inverted; otherwise, <strong>false</strong>.</p></returns>
        /// <doc-id>dd368045</doc-id>
        /// <unmanaged>BOOL D2D1IsMatrixInvertible([In] const D2D_MATRIX_3X2_F* matrix)</unmanaged>
        /// <unmanaged-short>D2D1IsMatrixInvertible</unmanaged-short>
        public static unsafe SharpDX.Mathematics.Interop.RawBool IsMatrixInvertible(ref SharpDX.Mathematics.Interop.RawMatrix3x2 matrix)
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            fixed (void *matrix_ = &matrix)
                __result__ = D2D1IsMatrixInvertible_(matrix_);
            return __result__;
        }

        [System.Runtime.InteropServices.DllImportAttribute("d2d1.dll", EntryPoint = "D2D1IsMatrixInvertible", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern SharpDX.Mathematics.Interop.RawBool D2D1IsMatrixInvertible_(void *param0);
        /// <summary>
        /// <p>Tries to invert the specified matrix.</p>
        /// </summary>
        /// <param name = "matrix"><dd>  <p>The matrix to invert.</p> </dd></param>
        /// <returns><p><strong>true</strong> if the matrix was inverted; otherwise, <strong>false</strong>.</p></returns>
        /// <doc-id>dd368044</doc-id>
        /// <unmanaged>BOOL D2D1InvertMatrix([InOut] D2D_MATRIX_3X2_F* matrix)</unmanaged>
        /// <unmanaged-short>D2D1InvertMatrix</unmanaged-short>
        public static unsafe SharpDX.Mathematics.Interop.RawBool InvertMatrix(ref SharpDX.Mathematics.Interop.RawMatrix3x2 matrix)
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            fixed (void *matrix_ = &matrix)
                __result__ = D2D1InvertMatrix_(matrix_);
            return __result__;
        }

        [System.Runtime.InteropServices.DllImportAttribute("d2d1.dll", EntryPoint = "D2D1InvertMatrix", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern SharpDX.Mathematics.Interop.RawBool D2D1InvertMatrix_(void *param0);
        /// <summary>
        /// <p>Creates a new Direct2D device associated with the provided DXGI device. </p>
        /// </summary>
        /// <param name = "dxgiDevice"><dd> <p>The DXGI device the Direct2D device is associated with.</p> </dd></param>
        /// <param name = "creationProperties"><dd> <p>The properties to apply to the Direct2D device.</p> </dd></param>
        /// <param name = "d2dDevice"><dd> <p>When this function returns, contains the address of a reference to a Direct2D device.</p> </dd></param>
        /// <returns><p>The function returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>This function will also create a new <strong><see cref = "SharpDX.Direct2D1.Factory1"/></strong> that can be retrieved through <strong>ID2D1Resource::GetFactory</strong>.</p><p>If the creation properties are not specified, then <em>d2dDevice</em> will inherit its threading mode from <em>dxgiDevice</em> and debug tracing will not be enabled.</p>
        /// </remarks>
        /// <doc-id>hh404272</doc-id>
        /// <unmanaged>HRESULT D2D1CreateDevice([In] IDXGIDevice* dxgiDevice,[In, Optional] const D2D1_CREATION_PROPERTIES* creationProperties,[Out, Fast] ID2D1Device** d2dDevice)</unmanaged>
        /// <unmanaged-short>D2D1CreateDevice</unmanaged-short>
        public static unsafe void CreateDevice(SharpDX.DXGI.Device dxgiDevice, SharpDX.Direct2D1.CreationProperties? creationProperties, SharpDX.Direct2D1.Device d2dDevice)
        {
            System.IntPtr dxgiDevice_ = System.IntPtr.Zero;
            SharpDX.Direct2D1.CreationProperties creationProperties_;
            System.IntPtr d2dDevice_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            dxgiDevice_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DXGI.Device>(dxgiDevice);
            if (creationProperties != null)
                creationProperties_ = creationProperties.Value;
            __result__ = D2D1CreateDevice_((void *)dxgiDevice_, creationProperties == null ? (void *)0 : &creationProperties_, &d2dDevice_);
            (d2dDevice).NativePointer = d2dDevice_;
            __result__.CheckError();
        }

        [System.Runtime.InteropServices.DllImportAttribute("d2d1.dll", EntryPoint = "D2D1CreateDevice", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern int D2D1CreateDevice_(void *param0, void *param1, void *param2);
        /// <summary>
        /// <p>Creates a new Direct2D device context associated with a DXGI surface. </p>
        /// </summary>
        /// <param name = "dxgiSurface"><dd> <p>The DXGI surface the Direct2D device context is associated with.</p> </dd></param>
        /// <param name = "creationProperties"><dd> <p>The properties to apply to the Direct2D device context.</p> </dd></param>
        /// <param name = "d2dDeviceContext"><dd> <p>When this function returns, contains the address of a reference to a Direct2D device context.</p> </dd></param>
        /// <returns><p>The function returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>This function will also create a new <strong><see cref = "SharpDX.Direct2D1.Factory1"/></strong> that can be retrieved through <strong>ID2D1Resource::GetFactory</strong>.</p><p>This function will also create a new <strong><see cref = "SharpDX.Direct2D1.Device"/></strong> that can be retrieved through <strong>ID2D1DeviceContext::GetDevice</strong>.</p><p>The DXGI device will be specified implicitly through <em>dxgiSurface</em>.</p><p>If <em>creationProperties</em> are not specified, the Direct2D device will inherit its threading mode from the DXGI device implied by <em>dxgiSurface</em> and debug tracing will not be enabled.</p>
        /// </remarks>
        /// <doc-id>hh404273</doc-id>
        /// <unmanaged>HRESULT D2D1CreateDeviceContext([In] IDXGISurface* dxgiSurface,[In, Optional] const D2D1_CREATION_PROPERTIES* creationProperties,[Out, Fast] ID2D1DeviceContext** d2dDeviceContext)</unmanaged>
        /// <unmanaged-short>D2D1CreateDeviceContext</unmanaged-short>
        public static unsafe void CreateDeviceContext(SharpDX.DXGI.Surface dxgiSurface, SharpDX.Direct2D1.CreationProperties? creationProperties, SharpDX.Direct2D1.DeviceContext d2dDeviceContext)
        {
            System.IntPtr dxgiSurface_ = System.IntPtr.Zero;
            SharpDX.Direct2D1.CreationProperties creationProperties_;
            System.IntPtr d2dDeviceContext_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            dxgiSurface_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DXGI.Surface>(dxgiSurface);
            if (creationProperties != null)
                creationProperties_ = creationProperties.Value;
            __result__ = D2D1CreateDeviceContext_((void *)dxgiSurface_, creationProperties == null ? (void *)0 : &creationProperties_, &d2dDeviceContext_);
            (d2dDeviceContext).NativePointer = d2dDeviceContext_;
            __result__.CheckError();
        }

        [System.Runtime.InteropServices.DllImportAttribute("d2d1.dll", EntryPoint = "D2D1CreateDeviceContext", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern int D2D1CreateDeviceContext_(void *param0, void *param1, void *param2);
        /// <summary>
        /// <p>Converts the given color from one colorspace to another.</p>
        /// </summary>
        /// <param name = "sourceColorSpace"><dd>  <p>The source color space.</p> </dd></param>
        /// <param name = "destinationColorSpace"><dd>  <p>The destination color space.</p> </dd></param>
        /// <param name = "color"><dd>  <p>The source color.</p> </dd></param>
        /// <returns><p>The converted color.</p></returns>
        /// <doc-id>hh847939</doc-id>
        /// <unmanaged>D2D_COLOR_F D2D1ConvertColorSpace([In] D2D1_COLOR_SPACE sourceColorSpace,[In] D2D1_COLOR_SPACE destinationColorSpace,[In] const D2D_COLOR_F* color)</unmanaged>
        /// <unmanaged-short>D2D1ConvertColorSpace</unmanaged-short>
        public static unsafe SharpDX.Mathematics.Interop.RawColor4 ConvertColorSpace(SharpDX.Direct2D1.ColorSpace sourceColorSpace, SharpDX.Direct2D1.ColorSpace destinationColorSpace, SharpDX.Mathematics.Interop.RawColor4 color)
        {
            SharpDX.Mathematics.Interop.RawColor4 __result__;
            D2D1ConvertColorSpace_(&__result__, unchecked ((System.Int32)sourceColorSpace), unchecked ((System.Int32)destinationColorSpace), &color);
            return __result__;
        }

        [System.Runtime.InteropServices.DllImportAttribute("d2d1.dll", EntryPoint = "D2D1ConvertColorSpace", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern void *D2D1ConvertColorSpace_(void *param0, int param1, int param2, void *param3);
        /// <summary>
        /// <p>Returns the sine and cosine of an angle.</p>
        /// </summary>
        /// <param name = "angle"><dd>  <p>The angle to calculate.</p> </dd></param>
        /// <param name = "s"><dd>  <p>The sine of the angle.</p> </dd></param>
        /// <param name = "c"><dd>  <p>The cosine of the angle.</p> </dd></param>
        /// <doc-id>hh847940</doc-id>
        /// <unmanaged>void D2D1SinCos([In] float angle,[Out] float* s,[Out] float* c)</unmanaged>
        /// <unmanaged-short>D2D1SinCos</unmanaged-short>
        public static unsafe void SinCos(System.Single angle, out System.Single s, out System.Single c)
        {
            fixed (void *c_ = &c)
                fixed (void *s_ = &s)
                    D2D1SinCos_(angle, s_, c_);
        }

        [System.Runtime.InteropServices.DllImportAttribute("d2d1.dll", EntryPoint = "D2D1SinCos", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern void D2D1SinCos_(float param0, void *param1, void *param2);
        /// <summary>
        /// <p>Returns the tangent of an angle.</p>
        /// </summary>
        /// <param name = "angle"><dd>  <p>The angle to calculate the tangent for.</p> </dd></param>
        /// <returns><p>The tangent of the angle.</p></returns>
        /// <doc-id>hh847941</doc-id>
        /// <unmanaged>float D2D1Tan([In] float angle)</unmanaged>
        /// <unmanaged-short>D2D1Tan</unmanaged-short>
        public static unsafe System.Single Tan(System.Single angle)
        {
            System.Single __result__;
            __result__ = D2D1Tan_(angle);
            return __result__;
        }

        [System.Runtime.InteropServices.DllImportAttribute("d2d1.dll", EntryPoint = "D2D1Tan", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern float D2D1Tan_(float param0);
        /// <summary>
        /// <p>Returns the length of a 3 dimensional vector.</p>
        /// </summary>
        /// <param name = "x"><dd>  <p>The  x value of the vector.</p> </dd></param>
        /// <param name = "y"><dd>  <p>The  y value of the vector.</p> </dd></param>
        /// <param name = "z"><dd>  <p>The  z value of the vector.</p> </dd></param>
        /// <returns><p>The length of the vector.</p></returns>
        /// <doc-id>hh847942</doc-id>
        /// <unmanaged>float D2D1Vec3Length([In] float x,[In] float y,[In] float z)</unmanaged>
        /// <unmanaged-short>D2D1Vec3Length</unmanaged-short>
        public static unsafe System.Single Vec3Length(System.Single x, System.Single y, System.Single z)
        {
            System.Single __result__;
            __result__ = D2D1Vec3Length_(x, y, z);
            return __result__;
        }

        [System.Runtime.InteropServices.DllImportAttribute("d2d1.dll", EntryPoint = "D2D1Vec3Length", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern float D2D1Vec3Length_(float param0, float param1, float param2);
        /// <summary>
        /// <p>Computes the maximum factor by which a given transform can stretch any vector.</p>
        /// </summary>
        /// <param name = "matrix"><dd> <p>The input transform matrix.</p> </dd></param>
        /// <returns><p>The scale factor.</p></returns>
        /// <remarks>
        /// <p>Formally, if M is the input matrix, this method will return the maximum value of |V * M| / |V| for all vectors V, where |.| denotes length. </p><strong>Note</strong>??Since this describes how M affects vectors (rather than points), the translation components (_31 and _32) of M are ignored.?
        /// </remarks>
        /// <doc-id>dn280381</doc-id>
        /// <unmanaged>float D2D1ComputeMaximumScaleFactor([In] const D2D_MATRIX_3X2_F* matrix)</unmanaged>
        /// <unmanaged-short>D2D1ComputeMaximumScaleFactor</unmanaged-short>
        public static unsafe System.Single ComputeMaximumScaleFactor(ref SharpDX.Mathematics.Interop.RawMatrix3x2 matrix)
        {
            System.Single __result__;
            fixed (void *matrix_ = &matrix)
                __result__ = D2D1ComputeMaximumScaleFactor_(matrix_);
            return __result__;
        }

        [System.Runtime.InteropServices.DllImportAttribute("d2d1.dll", EntryPoint = "D2D1ComputeMaximumScaleFactor", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern float D2D1ComputeMaximumScaleFactor_(void *param0);
        /// <summary>
        /// <p>Returns the interior points for a gradient mesh patch based on the points defining a Coons patch.</p><strong>Note</strong>??<p>This function is called by the <strong>GradientMeshPatchFromCoonsPatch</strong> function and is not intended to be used directly.</p>?
        /// </summary>
        /// <param name = "point0Ref">No documentation.</param>
        /// <param name = "point1Ref">No documentation.</param>
        /// <param name = "point2Ref">No documentation.</param>
        /// <param name = "point3Ref">No documentation.</param>
        /// <param name = "point4Ref">No documentation.</param>
        /// <param name = "point5Ref">No documentation.</param>
        /// <param name = "point6Ref">No documentation.</param>
        /// <param name = "point7Ref">No documentation.</param>
        /// <param name = "point8Ref">No documentation.</param>
        /// <param name = "point9Ref">No documentation.</param>
        /// <param name = "point10Ref">No documentation.</param>
        /// <param name = "point11Ref">No documentation.</param>
        /// <param name = "tensorPoint11Ref">No documentation.</param>
        /// <param name = "tensorPoint12Ref">No documentation.</param>
        /// <param name = "tensorPoint21Ref">No documentation.</param>
        /// <param name = "tensorPoint22Ref">No documentation.</param>
        /// <remarks>
        /// <p>This function is called by the <strong>GradientMeshPatchFromCoonsPatch</strong> function and is not intended to be used directly.</p>
        /// </remarks>
        /// <doc-id>mt149083</doc-id>
        /// <unmanaged>void D2D1GetGradientMeshInteriorPointsFromCoonsPatch([In] const D2D_POINT_2F* pPoint0,[In] const D2D_POINT_2F* pPoint1,[In] const D2D_POINT_2F* pPoint2,[In] const D2D_POINT_2F* pPoint3,[In] const D2D_POINT_2F* pPoint4,[In] const D2D_POINT_2F* pPoint5,[In] const D2D_POINT_2F* pPoint6,[In] const D2D_POINT_2F* pPoint7,[In] const D2D_POINT_2F* pPoint8,[In] const D2D_POINT_2F* pPoint9,[In] const D2D_POINT_2F* pPoint10,[In] const D2D_POINT_2F* pPoint11,[Out] D2D_POINT_2F* pTensorPoint11,[Out] D2D_POINT_2F* pTensorPoint12,[Out] D2D_POINT_2F* pTensorPoint21,[Out] D2D_POINT_2F* pTensorPoint22)</unmanaged>
        /// <unmanaged-short>D2D1GetGradientMeshInteriorPointsFromCoonsPatch</unmanaged-short>
        public static unsafe void GetGradientMeshInteriorPointsFromCoonsPatch(SharpDX.Mathematics.Interop.RawVector2 point0Ref, SharpDX.Mathematics.Interop.RawVector2 point1Ref, SharpDX.Mathematics.Interop.RawVector2 point2Ref, SharpDX.Mathematics.Interop.RawVector2 point3Ref, SharpDX.Mathematics.Interop.RawVector2 point4Ref, SharpDX.Mathematics.Interop.RawVector2 point5Ref, SharpDX.Mathematics.Interop.RawVector2 point6Ref, SharpDX.Mathematics.Interop.RawVector2 point7Ref, SharpDX.Mathematics.Interop.RawVector2 point8Ref, SharpDX.Mathematics.Interop.RawVector2 point9Ref, SharpDX.Mathematics.Interop.RawVector2 point10Ref, SharpDX.Mathematics.Interop.RawVector2 point11Ref, out SharpDX.Mathematics.Interop.RawVector2 tensorPoint11Ref, out SharpDX.Mathematics.Interop.RawVector2 tensorPoint12Ref, out SharpDX.Mathematics.Interop.RawVector2 tensorPoint21Ref, out SharpDX.Mathematics.Interop.RawVector2 tensorPoint22Ref)
        {
            tensorPoint11Ref = default (SharpDX.Mathematics.Interop.RawVector2);
            tensorPoint12Ref = default (SharpDX.Mathematics.Interop.RawVector2);
            tensorPoint21Ref = default (SharpDX.Mathematics.Interop.RawVector2);
            tensorPoint22Ref = default (SharpDX.Mathematics.Interop.RawVector2);
            fixed (void *tensorPoint22Ref_ = &tensorPoint22Ref)
                fixed (void *tensorPoint21Ref_ = &tensorPoint21Ref)
                    fixed (void *tensorPoint12Ref_ = &tensorPoint12Ref)
                        fixed (void *tensorPoint11Ref_ = &tensorPoint11Ref)
                            D2D1GetGradientMeshInteriorPointsFromCoonsPatch_(&point0Ref, &point1Ref, &point2Ref, &point3Ref, &point4Ref, &point5Ref, &point6Ref, &point7Ref, &point8Ref, &point9Ref, &point10Ref, &point11Ref, tensorPoint11Ref_, tensorPoint12Ref_, tensorPoint21Ref_, tensorPoint22Ref_);
        }

        [System.Runtime.InteropServices.DllImportAttribute("d2d1.dll", EntryPoint = "D2D1GetGradientMeshInteriorPointsFromCoonsPatch", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern void D2D1GetGradientMeshInteriorPointsFromCoonsPatch_(void *param0, void *param1, void *param2, void *param3, void *param4, void *param5, void *param6, void *param7, void *param8, void *param9, void *param10, void *param11, void *param12, void *param13, void *param14, void *param15);
    }

    /// <summary>
    /// Functions
    /// </summary>
    public partial class ResultCode
    {
                ///<summary>Constant WrongState</summary>
        ///<unmanaged>D2DERR_WRONG_STATE</unmanaged>
        public static readonly SharpDX.ResultDescriptor WrongState = new SharpDX.ResultDescriptor(unchecked ((int)2291728385UL), "SharpDX.Direct2D1", "D2DERR_WRONG_STATE", "WrongState");
                ///<summary>Constant NotInitializeD</summary>
        ///<unmanaged>D2DERR_NOT_INITIALIZED</unmanaged>
        public static readonly SharpDX.ResultDescriptor NotInitializeD = new SharpDX.ResultDescriptor(unchecked ((int)2291728386UL), "SharpDX.Direct2D1", "D2DERR_NOT_INITIALIZED", "NotInitializeD");
                ///<summary>Constant UnsupportedOperation</summary>
        ///<unmanaged>D2DERR_UNSUPPORTED_OPERATION</unmanaged>
        public static readonly SharpDX.ResultDescriptor UnsupportedOperation = new SharpDX.ResultDescriptor(unchecked ((int)2291728387UL), "SharpDX.Direct2D1", "D2DERR_UNSUPPORTED_OPERATION", "UnsupportedOperation");
                ///<summary>Constant ScannerFailed</summary>
        ///<unmanaged>D2DERR_SCANNER_FAILED</unmanaged>
        public static readonly SharpDX.ResultDescriptor ScannerFailed = new SharpDX.ResultDescriptor(unchecked ((int)2291728388UL), "SharpDX.Direct2D1", "D2DERR_SCANNER_FAILED", "ScannerFailed");
                ///<summary>Constant ScreenAccessDenied</summary>
        ///<unmanaged>D2DERR_SCREEN_ACCESS_DENIED</unmanaged>
        public static readonly SharpDX.ResultDescriptor ScreenAccessDenied = new SharpDX.ResultDescriptor(unchecked ((int)2291728389UL), "SharpDX.Direct2D1", "D2DERR_SCREEN_ACCESS_DENIED", "ScreenAccessDenied");
                ///<summary>Constant DisplayStateInvalid</summary>
        ///<unmanaged>D2DERR_DISPLAY_STATE_INVALID</unmanaged>
        public static readonly SharpDX.ResultDescriptor DisplayStateInvalid = new SharpDX.ResultDescriptor(unchecked ((int)2291728390UL), "SharpDX.Direct2D1", "D2DERR_DISPLAY_STATE_INVALID", "DisplayStateInvalid");
                ///<summary>Constant ZeroVector</summary>
        ///<unmanaged>D2DERR_ZERO_VECTOR</unmanaged>
        public static readonly SharpDX.ResultDescriptor ZeroVector = new SharpDX.ResultDescriptor(unchecked ((int)2291728391UL), "SharpDX.Direct2D1", "D2DERR_ZERO_VECTOR", "ZeroVector");
                ///<summary>Constant InternalError</summary>
        ///<unmanaged>D2DERR_INTERNAL_ERROR</unmanaged>
        public static readonly SharpDX.ResultDescriptor InternalError = new SharpDX.ResultDescriptor(unchecked ((int)2291728392UL), "SharpDX.Direct2D1", "D2DERR_INTERNAL_ERROR", "InternalError");
                ///<summary>Constant DisplayFormatNotSupported</summary>
        ///<unmanaged>D2DERR_DISPLAY_FORMAT_NOT_SUPPORTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor DisplayFormatNotSupported = new SharpDX.ResultDescriptor(unchecked ((int)2291728393UL), "SharpDX.Direct2D1", "D2DERR_DISPLAY_FORMAT_NOT_SUPPORTED", "DisplayFormatNotSupported");
                ///<summary>Constant InvalidCall</summary>
        ///<unmanaged>D2DERR_INVALID_CALL</unmanaged>
        public static readonly SharpDX.ResultDescriptor InvalidCall = new SharpDX.ResultDescriptor(unchecked ((int)2291728394UL), "SharpDX.Direct2D1", "D2DERR_INVALID_CALL", "InvalidCall");
                ///<summary>Constant NoHardwareDevice</summary>
        ///<unmanaged>D2DERR_NO_HARDWARE_DEVICE</unmanaged>
        public static readonly SharpDX.ResultDescriptor NoHardwareDevice = new SharpDX.ResultDescriptor(unchecked ((int)2291728395UL), "SharpDX.Direct2D1", "D2DERR_NO_HARDWARE_DEVICE", "NoHardwareDevice");
                ///<summary>Constant RecreateTarget</summary>
        ///<unmanaged>D2DERR_RECREATE_TARGET</unmanaged>
        public static readonly SharpDX.ResultDescriptor RecreateTarget = new SharpDX.ResultDescriptor(unchecked ((int)2291728396UL), "SharpDX.Direct2D1", "D2DERR_RECREATE_TARGET", "RecreateTarget");
                ///<summary>Constant TooManyShaderElements</summary>
        ///<unmanaged>D2DERR_TOO_MANY_SHADER_ELEMENTS</unmanaged>
        public static readonly SharpDX.ResultDescriptor TooManyShaderElements = new SharpDX.ResultDescriptor(unchecked ((int)2291728397UL), "SharpDX.Direct2D1", "D2DERR_TOO_MANY_SHADER_ELEMENTS", "TooManyShaderElements");
                ///<summary>Constant ShaderCompileFailed</summary>
        ///<unmanaged>D2DERR_SHADER_COMPILE_FAILED</unmanaged>
        public static readonly SharpDX.ResultDescriptor ShaderCompileFailed = new SharpDX.ResultDescriptor(unchecked ((int)2291728398UL), "SharpDX.Direct2D1", "D2DERR_SHADER_COMPILE_FAILED", "ShaderCompileFailed");
                ///<summary>Constant MaximumTextureSizeExceeded</summary>
        ///<unmanaged>D2DERR_MAX_TEXTURE_SIZE_EXCEEDED</unmanaged>
        public static readonly SharpDX.ResultDescriptor MaximumTextureSizeExceeded = new SharpDX.ResultDescriptor(unchecked ((int)2291728399UL), "SharpDX.Direct2D1", "D2DERR_MAX_TEXTURE_SIZE_EXCEEDED", "MaximumTextureSizeExceeded");
                ///<summary>Constant UnsupportedVersion</summary>
        ///<unmanaged>D2DERR_UNSUPPORTED_VERSION</unmanaged>
        public static readonly SharpDX.ResultDescriptor UnsupportedVersion = new SharpDX.ResultDescriptor(unchecked ((int)2291728400UL), "SharpDX.Direct2D1", "D2DERR_UNSUPPORTED_VERSION", "UnsupportedVersion");
                ///<summary>Constant BadNumber</summary>
        ///<unmanaged>D2DERR_BAD_NUMBER</unmanaged>
        public static readonly SharpDX.ResultDescriptor BadNumber = new SharpDX.ResultDescriptor(unchecked ((int)2291728401UL), "SharpDX.Direct2D1", "D2DERR_BAD_NUMBER", "BadNumber");
                ///<summary>Constant WrongFactory</summary>
        ///<unmanaged>D2DERR_WRONG_FACTORY</unmanaged>
        public static readonly SharpDX.ResultDescriptor WrongFactory = new SharpDX.ResultDescriptor(unchecked ((int)2291728402UL), "SharpDX.Direct2D1", "D2DERR_WRONG_FACTORY", "WrongFactory");
                ///<summary>Constant LayerAlreadyInUse</summary>
        ///<unmanaged>D2DERR_LAYER_ALREADY_IN_USE</unmanaged>
        public static readonly SharpDX.ResultDescriptor LayerAlreadyInUse = new SharpDX.ResultDescriptor(unchecked ((int)2291728403UL), "SharpDX.Direct2D1", "D2DERR_LAYER_ALREADY_IN_USE", "LayerAlreadyInUse");
                ///<summary>Constant PopCallDidNotMatchPush</summary>
        ///<unmanaged>D2DERR_POP_CALL_DID_NOT_MATCH_PUSH</unmanaged>
        public static readonly SharpDX.ResultDescriptor PopCallDidNotMatchPush = new SharpDX.ResultDescriptor(unchecked ((int)2291728404UL), "SharpDX.Direct2D1", "D2DERR_POP_CALL_DID_NOT_MATCH_PUSH", "PopCallDidNotMatchPush");
                ///<summary>Constant WrongResourceDomain</summary>
        ///<unmanaged>D2DERR_WRONG_RESOURCE_DOMAIN</unmanaged>
        public static readonly SharpDX.ResultDescriptor WrongResourceDomain = new SharpDX.ResultDescriptor(unchecked ((int)2291728405UL), "SharpDX.Direct2D1", "D2DERR_WRONG_RESOURCE_DOMAIN", "WrongResourceDomain");
                ///<summary>Constant PushPopUnbalanced</summary>
        ///<unmanaged>D2DERR_PUSH_POP_UNBALANCED</unmanaged>
        public static readonly SharpDX.ResultDescriptor PushPopUnbalanced = new SharpDX.ResultDescriptor(unchecked ((int)2291728406UL), "SharpDX.Direct2D1", "D2DERR_PUSH_POP_UNBALANCED", "PushPopUnbalanced");
                ///<summary>Constant RenderTargetHasLayerOrCliprect</summary>
        ///<unmanaged>D2DERR_RENDER_TARGET_HAS_LAYER_OR_CLIPRECT</unmanaged>
        public static readonly SharpDX.ResultDescriptor RenderTargetHasLayerOrCliprect = new SharpDX.ResultDescriptor(unchecked ((int)2291728407UL), "SharpDX.Direct2D1", "D2DERR_RENDER_TARGET_HAS_LAYER_OR_CLIPRECT", "RenderTargetHasLayerOrCliprect");
                ///<summary>Constant IncompatibleBrushTypes</summary>
        ///<unmanaged>D2DERR_INCOMPATIBLE_BRUSH_TYPES</unmanaged>
        public static readonly SharpDX.ResultDescriptor IncompatibleBrushTypes = new SharpDX.ResultDescriptor(unchecked ((int)2291728408UL), "SharpDX.Direct2D1", "D2DERR_INCOMPATIBLE_BRUSH_TYPES", "IncompatibleBrushTypes");
                ///<summary>Constant Win32Error</summary>
        ///<unmanaged>D2DERR_WIN32_ERROR</unmanaged>
        public static readonly SharpDX.ResultDescriptor Win32Error = new SharpDX.ResultDescriptor(unchecked ((int)2291728409UL), "SharpDX.Direct2D1", "D2DERR_WIN32_ERROR", "Win32Error");
                ///<summary>Constant TargetNotGdiCompatible</summary>
        ///<unmanaged>D2DERR_TARGET_NOT_GDI_COMPATIBLE</unmanaged>
        public static readonly SharpDX.ResultDescriptor TargetNotGdiCompatible = new SharpDX.ResultDescriptor(unchecked ((int)2291728410UL), "SharpDX.Direct2D1", "D2DERR_TARGET_NOT_GDI_COMPATIBLE", "TargetNotGdiCompatible");
                ///<summary>Constant TextEffectIsWrongType</summary>
        ///<unmanaged>D2DERR_TEXT_EFFECT_IS_WRONG_TYPE</unmanaged>
        public static readonly SharpDX.ResultDescriptor TextEffectIsWrongType = new SharpDX.ResultDescriptor(unchecked ((int)2291728411UL), "SharpDX.Direct2D1", "D2DERR_TEXT_EFFECT_IS_WRONG_TYPE", "TextEffectIsWrongType");
                ///<summary>Constant TextRendererNotReleased</summary>
        ///<unmanaged>D2DERR_TEXT_RENDERER_NOT_RELEASED</unmanaged>
        public static readonly SharpDX.ResultDescriptor TextRendererNotReleased = new SharpDX.ResultDescriptor(unchecked ((int)2291728412UL), "SharpDX.Direct2D1", "D2DERR_TEXT_RENDERER_NOT_RELEASED", "TextRendererNotReleased");
                ///<summary>Constant ExceedsMaximumBitmapSize</summary>
        ///<unmanaged>D2DERR_EXCEEDS_MAX_BITMAP_SIZE</unmanaged>
        public static readonly SharpDX.ResultDescriptor ExceedsMaximumBitmapSize = new SharpDX.ResultDescriptor(unchecked ((int)2291728413UL), "SharpDX.Direct2D1", "D2DERR_EXCEEDS_MAX_BITMAP_SIZE", "ExceedsMaximumBitmapSize");
                ///<summary>Constant InvalidGraphConfiguration</summary>
        ///<unmanaged>D2DERR_INVALID_GRAPH_CONFIGURATION</unmanaged>
        public static readonly SharpDX.ResultDescriptor InvalidGraphConfiguration = new SharpDX.ResultDescriptor(unchecked ((int)2291728414UL), "SharpDX.Direct2D1", "D2DERR_INVALID_GRAPH_CONFIGURATION", "InvalidGraphConfiguration");
                ///<summary>Constant InvalidInternalGraphConfiguration</summary>
        ///<unmanaged>D2DERR_INVALID_INTERNAL_GRAPH_CONFIGURATION</unmanaged>
        public static readonly SharpDX.ResultDescriptor InvalidInternalGraphConfiguration = new SharpDX.ResultDescriptor(unchecked ((int)2291728415UL), "SharpDX.Direct2D1", "D2DERR_INVALID_INTERNAL_GRAPH_CONFIGURATION", "InvalidInternalGraphConfiguration");
                ///<summary>Constant CyclicGraph</summary>
        ///<unmanaged>D2DERR_CYCLIC_GRAPH</unmanaged>
        public static readonly SharpDX.ResultDescriptor CyclicGraph = new SharpDX.ResultDescriptor(unchecked ((int)2291728416UL), "SharpDX.Direct2D1", "D2DERR_CYCLIC_GRAPH", "CyclicGraph");
                ///<summary>Constant BitmapCannotDraw</summary>
        ///<unmanaged>D2DERR_BITMAP_CANNOT_DRAW</unmanaged>
        public static readonly SharpDX.ResultDescriptor BitmapCannotDraw = new SharpDX.ResultDescriptor(unchecked ((int)2291728417UL), "SharpDX.Direct2D1", "D2DERR_BITMAP_CANNOT_DRAW", "BitmapCannotDraw");
                ///<summary>Constant OutstandingBitmapReferences</summary>
        ///<unmanaged>D2DERR_OUTSTANDING_BITMAP_REFERENCES</unmanaged>
        public static readonly SharpDX.ResultDescriptor OutstandingBitmapReferences = new SharpDX.ResultDescriptor(unchecked ((int)2291728418UL), "SharpDX.Direct2D1", "D2DERR_OUTSTANDING_BITMAP_REFERENCES", "OutstandingBitmapReferences");
                ///<summary>Constant OriginalTargetNotBound</summary>
        ///<unmanaged>D2DERR_ORIGINAL_TARGET_NOT_BOUND</unmanaged>
        public static readonly SharpDX.ResultDescriptor OriginalTargetNotBound = new SharpDX.ResultDescriptor(unchecked ((int)2291728419UL), "SharpDX.Direct2D1", "D2DERR_ORIGINAL_TARGET_NOT_BOUND", "OriginalTargetNotBound");
                ///<summary>Constant InvalidTarget</summary>
        ///<unmanaged>D2DERR_INVALID_TARGET</unmanaged>
        public static readonly SharpDX.ResultDescriptor InvalidTarget = new SharpDX.ResultDescriptor(unchecked ((int)2291728420UL), "SharpDX.Direct2D1", "D2DERR_INVALID_TARGET", "InvalidTarget");
                ///<summary>Constant BitmapBoundAsTarget</summary>
        ///<unmanaged>D2DERR_BITMAP_BOUND_AS_TARGET</unmanaged>
        public static readonly SharpDX.ResultDescriptor BitmapBoundAsTarget = new SharpDX.ResultDescriptor(unchecked ((int)2291728421UL), "SharpDX.Direct2D1", "D2DERR_BITMAP_BOUND_AS_TARGET", "BitmapBoundAsTarget");
                ///<summary>Constant InsufficientDeviceCapabilities</summary>
        ///<unmanaged>D2DERR_INSUFFICIENT_DEVICE_CAPABILITIES</unmanaged>
        public static readonly SharpDX.ResultDescriptor InsufficientDeviceCapabilities = new SharpDX.ResultDescriptor(unchecked ((int)2291728422UL), "SharpDX.Direct2D1", "D2DERR_INSUFFICIENT_DEVICE_CAPABILITIES", "InsufficientDeviceCapabilities");
                ///<summary>Constant IntermediateTooLarge</summary>
        ///<unmanaged>D2DERR_INTERMEDIATE_TOO_LARGE</unmanaged>
        public static readonly SharpDX.ResultDescriptor IntermediateTooLarge = new SharpDX.ResultDescriptor(unchecked ((int)2291728423UL), "SharpDX.Direct2D1", "D2DERR_INTERMEDIATE_TOO_LARGE", "IntermediateTooLarge");
                ///<summary>Constant EffectIsNotRegistered</summary>
        ///<unmanaged>D2DERR_EFFECT_IS_NOT_REGISTERED</unmanaged>
        public static readonly SharpDX.ResultDescriptor EffectIsNotRegistered = new SharpDX.ResultDescriptor(unchecked ((int)2291728424UL), "SharpDX.Direct2D1", "D2DERR_EFFECT_IS_NOT_REGISTERED", "EffectIsNotRegistered");
                ///<summary>Constant InvalidProperty</summary>
        ///<unmanaged>D2DERR_INVALID_PROPERTY</unmanaged>
        public static readonly SharpDX.ResultDescriptor InvalidProperty = new SharpDX.ResultDescriptor(unchecked ((int)2291728425UL), "SharpDX.Direct2D1", "D2DERR_INVALID_PROPERTY", "InvalidProperty");
                ///<summary>Constant NoSubProperties</summary>
        ///<unmanaged>D2DERR_NO_SUBPROPERTIES</unmanaged>
        public static readonly SharpDX.ResultDescriptor NoSubProperties = new SharpDX.ResultDescriptor(unchecked ((int)2291728426UL), "SharpDX.Direct2D1", "D2DERR_NO_SUBPROPERTIES", "NoSubProperties");
                ///<summary>Constant PrintJobClosed</summary>
        ///<unmanaged>D2DERR_PRINT_JOB_CLOSED</unmanaged>
        public static readonly SharpDX.ResultDescriptor PrintJobClosed = new SharpDX.ResultDescriptor(unchecked ((int)2291728427UL), "SharpDX.Direct2D1", "D2DERR_PRINT_JOB_CLOSED", "PrintJobClosed");
                ///<summary>Constant PrintFormatNotSupported</summary>
        ///<unmanaged>D2DERR_PRINT_FORMAT_NOT_SUPPORTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor PrintFormatNotSupported = new SharpDX.ResultDescriptor(unchecked ((int)2291728428UL), "SharpDX.Direct2D1", "D2DERR_PRINT_FORMAT_NOT_SUPPORTED", "PrintFormatNotSupported");
                ///<summary>Constant TooManyTransformInputs</summary>
        ///<unmanaged>D2DERR_TOO_MANY_TRANSFORM_INPUTS</unmanaged>
        public static readonly SharpDX.ResultDescriptor TooManyTransformInputs = new SharpDX.ResultDescriptor(unchecked ((int)2291728429UL), "SharpDX.Direct2D1", "D2DERR_TOO_MANY_TRANSFORM_INPUTS", "TooManyTransformInputs");
                ///<summary>Constant InvalidGlyphImage</summary>
        ///<unmanaged>D2DERR_INVALID_GLYPH_IMAGE</unmanaged>
        public static readonly SharpDX.ResultDescriptor InvalidGlyphImage = new SharpDX.ResultDescriptor(unchecked ((int)2291728430UL), "SharpDX.Direct2D1", "D2DERR_INVALID_GLYPH_IMAGE", "InvalidGlyphImage");
                ///<summary>Constant UnsupportedPixelFormat</summary>
        ///<unmanaged>D2DERR_UNSUPPORTED_PIXEL_FORMAT</unmanaged>
        public static readonly SharpDX.ResultDescriptor UnsupportedPixelFormat = new SharpDX.ResultDescriptor(unchecked ((int)2291675008UL), "SharpDX.Direct2D1", "D2DERR_UNSUPPORTED_PIXEL_FORMAT", "UnsupportedPixelFormat");
                ///<summary>Constant InsufficientBuffer</summary>
        ///<unmanaged>D2DERR_INSUFFICIENT_BUFFER</unmanaged>
        public static readonly SharpDX.ResultDescriptor InsufficientBuffer = new SharpDX.ResultDescriptor(unchecked ((int)122L), "SharpDX.Direct2D1", "D2DERR_INSUFFICIENT_BUFFER", "InsufficientBuffer");
                ///<summary>Constant FileNotFound</summary>
        ///<unmanaged>D2DERR_FILE_NOT_FOUND</unmanaged>
        public static readonly SharpDX.ResultDescriptor FileNotFound = new SharpDX.ResultDescriptor(unchecked ((int)2L), "SharpDX.Direct2D1", "D2DERR_FILE_NOT_FOUND", "FileNotFound");
    }
}
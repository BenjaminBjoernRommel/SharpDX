// <auto-generated/>

namespace SharpDX.Direct2D1
{
    /// <summary>
    /// <p>Describes an elliptical arc between two points.</p>
    /// </summary>
    /// <doc-id>dd368065</doc-id>
    /// <unmanaged>D2D1_ARC_SEGMENT</unmanaged>
    /// <unmanaged-short>D2D1_ARC_SEGMENT</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct ArcSegment
    {
        /// <summary>
        /// <dd> <p>The end point of the arc.</p> </dd>
        /// </summary>
        /// <doc-id>dd368065</doc-id>
        /// <unmanaged>point</unmanaged>
        /// <unmanaged-short>point</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 Point;
        /// <summary>
        /// <dd> <p>The x-radius and y-radius of the arc.</p> </dd>
        /// </summary>
        /// <doc-id>dd368065</doc-id>
        /// <unmanaged>size</unmanaged>
        /// <unmanaged-short>size</unmanaged-short>
        public SharpDX.Size2F Size;
        /// <summary>
        /// <dd> <p>A value that specifies how many degrees in the clockwise direction the ellipse is rotated relative to the current coordinate system.</p> </dd>
        /// </summary>
        /// <doc-id>dd368065</doc-id>
        /// <unmanaged>rotationAngle</unmanaged>
        /// <unmanaged-short>rotationAngle</unmanaged-short>
        public System.Single RotationAngle;
        /// <summary>
        /// <dd> <p>A value that specifies whether the arc sweep is clockwise or counterclockwise.</p> </dd>
        /// </summary>
        /// <doc-id>dd368065</doc-id>
        /// <unmanaged>sweepDirection</unmanaged>
        /// <unmanaged-short>sweepDirection</unmanaged-short>
        public SharpDX.Direct2D1.SweepDirection SweepDirection;
        /// <summary>
        /// <dd> <p>A value that specifies whether the given arc is larger than 180 degrees.</p> </dd>
        /// </summary>
        /// <doc-id>dd368065</doc-id>
        /// <unmanaged>arcSize</unmanaged>
        /// <unmanaged-short>arcSize</unmanaged-short>
        public SharpDX.Direct2D1.ArcSize ArcSize;
    }

    /// <summary>
    /// <p>Represents a cubic bezier segment drawn  between two points.</p>
    /// </summary>
    /// <remarks>
    /// <p> A cubic Bezier curve is defined by four points: a start point, an end point (<em>point3</em>), and two control points (<em>point1</em> and <em>point2</em>). A Bezier segment does not contain a property for the starting point of the curve; it defines only the end point. The beginning point of the curve is the current point of the path to which the Bezier curve is added.</p><p> The two control points of a cubic Bezier curve behave like magnets, attracting portions of what would otherwise be a straight line toward themselves and producing a curve. The first control point, <em>point1</em>, affects the beginning portion of the curve; the second control point, <em>point2</em>, affects the ending portion of the curve. </p><strong>Note</strong>??The curve doesn't necessarily pass through either of the control points; each control point moves its portion of the line toward itself, but not through itself.?
    /// </remarks>
    /// <doc-id>dd368070</doc-id>
    /// <unmanaged>D2D1_BEZIER_SEGMENT</unmanaged>
    /// <unmanaged-short>D2D1_BEZIER_SEGMENT</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct BezierSegment
    {
        /// <summary>
        /// <dd> <p>The first control point for the Bezier segment.</p> </dd>
        /// </summary>
        /// <doc-id>dd368070</doc-id>
        /// <unmanaged>point1</unmanaged>
        /// <unmanaged-short>point1</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 Point1;
        /// <summary>
        /// <dd> <p>The second control point for the Bezier segment.</p> </dd>
        /// </summary>
        /// <doc-id>dd368070</doc-id>
        /// <unmanaged>point2</unmanaged>
        /// <unmanaged-short>point2</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 Point2;
        /// <summary>
        /// <dd> <p>The end point for the Bezier segment.</p> </dd>
        /// </summary>
        /// <doc-id>dd368070</doc-id>
        /// <unmanaged>point3</unmanaged>
        /// <unmanaged-short>point3</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 Point3;
    }

    /// <summary>
    /// <p> Describes the extend modes and the interpolation mode of an <strong><see cref = "SharpDX.Direct2D1.BitmapBrush"/></strong>.</p>
    /// </summary>
    /// <doc-id>dd368071</doc-id>
    /// <unmanaged>D2D1_BITMAP_BRUSH_PROPERTIES</unmanaged>
    /// <unmanaged-short>D2D1_BITMAP_BRUSH_PROPERTIES</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct BitmapBrushProperties
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd368071</doc-id>
        /// <unmanaged>extendModeX</unmanaged>
        /// <unmanaged-short>extendModeX</unmanaged-short>
        public SharpDX.Direct2D1.ExtendMode ExtendModeX;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd368071</doc-id>
        /// <unmanaged>extendModeY</unmanaged>
        /// <unmanaged-short>extendModeY</unmanaged-short>
        public SharpDX.Direct2D1.ExtendMode ExtendModeY;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd368071</doc-id>
        /// <unmanaged>interpolationMode</unmanaged>
        /// <unmanaged-short>interpolationMode</unmanaged-short>
        public SharpDX.Direct2D1.BitmapInterpolationMode InterpolationMode;
    }

    /// <summary>
    /// <p> Describes the extend modes and the interpolation mode of an <strong><see cref = "SharpDX.Direct2D1.BitmapBrush"/></strong>.</p>
    /// </summary>
    /// <doc-id>hh847943</doc-id>
    /// <unmanaged>D2D1_BITMAP_BRUSH_PROPERTIES1</unmanaged>
    /// <unmanaged-short>D2D1_BITMAP_BRUSH_PROPERTIES1</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct BitmapBrushProperties1
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh847943</doc-id>
        /// <unmanaged>extendModeX</unmanaged>
        /// <unmanaged-short>extendModeX</unmanaged-short>
        public SharpDX.Direct2D1.ExtendMode ExtendModeX;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh847943</doc-id>
        /// <unmanaged>extendModeY</unmanaged>
        /// <unmanaged-short>extendModeY</unmanaged-short>
        public SharpDX.Direct2D1.ExtendMode ExtendModeY;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh847943</doc-id>
        /// <unmanaged>interpolationMode</unmanaged>
        /// <unmanaged-short>interpolationMode</unmanaged-short>
        public SharpDX.Direct2D1.InterpolationMode InterpolationMode;
    }

    /// <summary>
    /// <p>Describes the pixel format and dpi  of a bitmap.</p>
    /// </summary>
    /// <doc-id>dd368075</doc-id>
    /// <unmanaged>D2D1_BITMAP_PROPERTIES</unmanaged>
    /// <unmanaged-short>D2D1_BITMAP_PROPERTIES</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct BitmapProperties
    {
        /// <summary>
        /// <dd> <p>The bitmap's pixel format and alpha mode.</p> </dd>
        /// </summary>
        /// <doc-id>dd368075</doc-id>
        /// <unmanaged>pixelFormat</unmanaged>
        /// <unmanaged-short>pixelFormat</unmanaged-short>
        public SharpDX.Direct2D1.PixelFormat PixelFormat;
        /// <summary>
        /// <dd> <p>The horizontal dpi of the bitmap.</p> </dd>
        /// </summary>
        /// <doc-id>dd368075</doc-id>
        /// <unmanaged>dpiX</unmanaged>
        /// <unmanaged-short>dpiX</unmanaged-short>
        public System.Single DpiX;
        /// <summary>
        /// <dd> <p>The vertical dpi of the bitmap.</p> </dd>
        /// </summary>
        /// <doc-id>dd368075</doc-id>
        /// <unmanaged>dpiY</unmanaged>
        /// <unmanaged-short>dpiY</unmanaged-short>
        public System.Single DpiY;
    }

    /// <summary>
    /// <p>This structure allows a <strong><see cref = "SharpDX.Direct2D1.Bitmap1"/></strong> to be created with bitmap options and color context information available.
    /// </p>
    /// </summary>
    /// <remarks>
    /// <p>If both <strong>dpiX</strong> and <strong>dpiY</strong> are 0, the dpi of the bitmap will be set to the desktop dpi if the device context is a windowed context, or 96 dpi for any other device context.</p>
    /// </remarks>
    /// <doc-id>hh404275</doc-id>
    /// <unmanaged>D2D1_BITMAP_PROPERTIES1</unmanaged>
    /// <unmanaged-short>D2D1_BITMAP_PROPERTIES1</unmanaged-short>
    public partial class BitmapProperties1
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh404275</doc-id>
        /// <unmanaged>pixelFormat</unmanaged>
        /// <unmanaged-short>pixelFormat</unmanaged-short>
        public SharpDX.Direct2D1.PixelFormat PixelFormat;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh404275</doc-id>
        /// <unmanaged>dpiX</unmanaged>
        /// <unmanaged-short>dpiX</unmanaged-short>
        public System.Single DpiX;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh404275</doc-id>
        /// <unmanaged>dpiY</unmanaged>
        /// <unmanaged-short>dpiY</unmanaged-short>
        public System.Single DpiY;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh404275</doc-id>
        /// <unmanaged>bitmapOptions</unmanaged>
        /// <unmanaged-short>bitmapOptions</unmanaged-short>
        public SharpDX.Direct2D1.BitmapOptions BitmapOptions;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh404275</doc-id>
        /// <unmanaged>colorContext</unmanaged>
        /// <unmanaged-short>colorContext</unmanaged-short>
        public SharpDX.Direct2D1.ColorContext ColorContext;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.Direct2D1.PixelFormat PixelFormat;
            public System.Single DpiX;
            public System.Single DpiY;
            public SharpDX.Direct2D1.BitmapOptions BitmapOptions;
            public System.IntPtr ColorContext;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            PixelFormat = @ref.PixelFormat;
            DpiX = @ref.DpiX;
            DpiY = @ref.DpiY;
            BitmapOptions = @ref.BitmapOptions;
            if (@ref.ColorContext != System.IntPtr.Zero)
                ColorContext = new SharpDX.Direct2D1.ColorContext(@ref.ColorContext);
            else
                ColorContext = null;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.PixelFormat = PixelFormat;
            @ref.DpiX = DpiX;
            @ref.DpiY = DpiY;
            @ref.BitmapOptions = BitmapOptions;
            @ref.ColorContext = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.ColorContext>(ColorContext);
        }
    }

    /// <summary>
    /// <p>Defines a blend description to be used in a particular blend transform.</p>
    /// </summary>
    /// <remarks>
    /// <p>This description closely matches the <strong><see cref = "SharpDX.Direct3D11.BlendStateDescription"/></strong> struct with some omissions and the addition of the blend factor in the description.</p>
    /// </remarks>
    /// <doc-id>hh404277</doc-id>
    /// <unmanaged>D2D1_BLEND_DESCRIPTION</unmanaged>
    /// <unmanaged-short>D2D1_BLEND_DESCRIPTION</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct BlendDescription
    {
        /// <summary>
        /// <dd> <p>Specifies the first RGB data source and includes an optional preblend operation.</p> </dd>
        /// </summary>
        /// <doc-id>hh404277</doc-id>
        /// <unmanaged>sourceBlend</unmanaged>
        /// <unmanaged-short>sourceBlend</unmanaged-short>
        public SharpDX.Direct2D1.Blend SourceBlend;
        /// <summary>
        /// <dd> <p>Specifies the second RGB data source and includes an optional preblend operation.</p> </dd>
        /// </summary>
        /// <doc-id>hh404277</doc-id>
        /// <unmanaged>destinationBlend</unmanaged>
        /// <unmanaged-short>destinationBlend</unmanaged-short>
        public SharpDX.Direct2D1.Blend DestinationBlend;
        /// <summary>
        /// <dd> <p>Specifies how to combine the RGB data sources.</p> </dd>
        /// </summary>
        /// <doc-id>hh404277</doc-id>
        /// <unmanaged>blendOperation</unmanaged>
        /// <unmanaged-short>blendOperation</unmanaged-short>
        public SharpDX.Direct2D1.BlendOperation BlendOperation;
        /// <summary>
        /// <dd> <p>Specifies the first alpha data source and includes an optional preblend operation. Blend options that end in _COLOR are not allowed.</p> </dd>
        /// </summary>
        /// <doc-id>hh404277</doc-id>
        /// <unmanaged>sourceBlendAlpha</unmanaged>
        /// <unmanaged-short>sourceBlendAlpha</unmanaged-short>
        public SharpDX.Direct2D1.Blend SourceBlendAlpha;
        /// <summary>
        /// <dd> <p>Specifies the second alpha data source and includes an optional preblend operation. Blend options that end in _COLOR are not allowed.</p> </dd>
        /// </summary>
        /// <doc-id>hh404277</doc-id>
        /// <unmanaged>destinationBlendAlpha</unmanaged>
        /// <unmanaged-short>destinationBlendAlpha</unmanaged-short>
        public SharpDX.Direct2D1.Blend DestinationBlendAlpha;
        /// <summary>
        /// <dd> <p>Specifies how to combine the alpha data sources.</p> </dd>
        /// </summary>
        /// <doc-id>hh404277</doc-id>
        /// <unmanaged>blendOperationAlpha</unmanaged>
        /// <unmanaged-short>blendOperationAlpha</unmanaged-short>
        public SharpDX.Direct2D1.BlendOperation BlendOperationAlpha;
        /// <summary>
        /// <dd> <p>Parameters to the blend operations. The blend must use <strong>D2D1_BLEND_BLEND_FACTOR</strong> for this to be used.</p> </dd>
        /// </summary>
        /// <doc-id>hh404277</doc-id>
        /// <unmanaged>blendFactor</unmanaged>
        /// <unmanaged-short>blendFactor</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawColor4 BlendFactor;
    }

    /// <summary>
    /// <p> Describes the opacity and transformation of a brush.</p>
    /// </summary>
    /// <remarks>
    /// <p>This structure is used when creating a brush. For convenience, Direct2D provides the <strong>D2D1::BrushProperties</strong> function for creating <strong><see cref = "SharpDX.Direct2D1.BrushProperties"/></strong> structures.</p><p>After creating a brush, you can change its opacity or transform by calling the <strong>SetOpacity</strong> or <strong>SetTransform</strong> methods.</p>
    /// </remarks>
    /// <doc-id>dd368077</doc-id>
    /// <unmanaged>D2D1_BRUSH_PROPERTIES</unmanaged>
    /// <unmanaged-short>D2D1_BRUSH_PROPERTIES</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct BrushProperties
    {
        /// <summary>
        /// <dd> <p>A value between 0.0f and 1.0f, inclusive, that specifies the degree of opacity of the brush.</p> </dd>
        /// </summary>
        /// <doc-id>dd368077</doc-id>
        /// <unmanaged>opacity</unmanaged>
        /// <unmanaged-short>opacity</unmanaged-short>
        public System.Single Opacity;
        /// <summary>
        /// <dd> <p>The transformation that is applied to the brush.</p> </dd>
        /// </summary>
        /// <doc-id>dd368077</doc-id>
        /// <unmanaged>transform</unmanaged>
        /// <unmanaged-short>transform</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawMatrix3x2 Transform;
    }

    /// <summary>
    /// <p>Specifies the options with which the Direct2D device, factory, and device context are created.
    /// </p>
    /// </summary>
    /// <remarks>
    /// <p>The root objects referred to here are the Direct2D device, Direct2D factory and the Direct2D device context.
    /// </p>
    /// </remarks>
    /// <doc-id>hh404298</doc-id>
    /// <unmanaged>D2D1_CREATION_PROPERTIES</unmanaged>
    /// <unmanaged-short>D2D1_CREATION_PROPERTIES</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct CreationProperties
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh404298</doc-id>
        /// <unmanaged>threadingMode</unmanaged>
        /// <unmanaged-short>threadingMode</unmanaged-short>
        public SharpDX.Direct2D1.ThreadingMode ThreadingMode;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh404298</doc-id>
        /// <unmanaged>debugLevel</unmanaged>
        /// <unmanaged-short>debugLevel</unmanaged-short>
        public SharpDX.Direct2D1.DebugLevel DebugLevel;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh404298</doc-id>
        /// <unmanaged>options</unmanaged>
        /// <unmanaged-short>options</unmanaged-short>
        public SharpDX.Direct2D1.DeviceContextOptions Options;
    }

    /// <summary>
    /// <p>Defines a vertex shader and the input element description to define the input layout. The combination is used to allow a custom vertex effect to create a custom vertex shader and pass it a custom layout.</p>
    /// </summary>
    /// <remarks>
    /// <p>The vertex shader will be loaded by the <strong>CreateVertexBuffer</strong> call that accepts the vertex buffer properties.</p><p>This structure does not need to be specified if one of the standard vertex shaders is used.</p>
    /// </remarks>
    /// <doc-id>hh404301</doc-id>
    /// <unmanaged>D2D1_CUSTOM_VERTEX_BUFFER_PROPERTIES</unmanaged>
    /// <unmanaged-short>D2D1_CUSTOM_VERTEX_BUFFER_PROPERTIES</unmanaged-short>
    public partial class CustomVertexBufferProperties
    {
        /// <summary>
        /// <dd> <p>The unique ID of the vertex shader.</p> </dd>
        /// </summary>
        /// <doc-id>hh404301</doc-id>
        /// <unmanaged>shaderBufferWithInputSignature</unmanaged>
        /// <unmanaged-short>shaderBufferWithInputSignature</unmanaged-short>
        internal System.IntPtr ShaderBufferWithInputSignature;
        /// <summary>
        /// <dd> <p>An array of input assembler stage data types.</p> </dd>
        /// </summary>
        /// <doc-id>hh404301</doc-id>
        /// <unmanaged>shaderBufferSize</unmanaged>
        /// <unmanaged-short>shaderBufferSize</unmanaged-short>
        internal System.Int32 ShaderBufferSize;
        /// <summary>
        /// <dd> <p>An array of input assembler stage data types.</p> </dd>
        /// </summary>
        /// <doc-id>hh404301</doc-id>
        /// <unmanaged>inputElements</unmanaged>
        /// <unmanaged-short>inputElements</unmanaged-short>
        internal System.IntPtr InputElementsPointer;
        /// <summary>
        /// <dd> <p>The number of input elements in the vertex shader.</p> </dd>
        /// </summary>
        /// <doc-id>hh404301</doc-id>
        /// <unmanaged>elementCount</unmanaged>
        /// <unmanaged-short>elementCount</unmanaged-short>
        internal System.Int32 ElementCount;
        /// <summary>
        /// <dd> <p>The vertex stride.</p> </dd>
        /// </summary>
        /// <doc-id>hh404301</doc-id>
        /// <unmanaged>stride</unmanaged>
        /// <unmanaged-short>stride</unmanaged-short>
        public System.Int32 Stride;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.IntPtr ShaderBufferWithInputSignature;
            public System.Int32 ShaderBufferSize;
            public System.IntPtr InputElementsPointer;
            public System.Int32 ElementCount;
            public System.Int32 Stride;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            ShaderBufferWithInputSignature = @ref.ShaderBufferWithInputSignature;
            ShaderBufferSize = @ref.ShaderBufferSize;
            InputElementsPointer = @ref.InputElementsPointer;
            ElementCount = @ref.ElementCount;
            Stride = @ref.Stride;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.ShaderBufferWithInputSignature = ShaderBufferWithInputSignature;
            @ref.ShaderBufferSize = ShaderBufferSize;
            @ref.InputElementsPointer = InputElementsPointer;
            @ref.ElementCount = ElementCount;
            @ref.Stride = Stride;
        }
    }

    /// <summary>
    /// <p>Describes the drawing state of a render target.  </p>
    /// </summary>
    /// <doc-id>dd368093</doc-id>
    /// <unmanaged>D2D1_DRAWING_STATE_DESCRIPTION</unmanaged>
    /// <unmanaged-short>D2D1_DRAWING_STATE_DESCRIPTION</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct DrawingStateDescription
    {
        /// <summary>
        /// <dd> <p>The antialiasing mode for subsequent nontext drawing operations. </p> </dd>
        /// </summary>
        /// <doc-id>dd368093</doc-id>
        /// <unmanaged>antialiasMode</unmanaged>
        /// <unmanaged-short>antialiasMode</unmanaged-short>
        public SharpDX.Direct2D1.AntialiasMode AntialiasMode;
        /// <summary>
        /// <dd> <p>The antialiasing mode for subsequent text and glyph drawing operations.</p> </dd>
        /// </summary>
        /// <doc-id>dd368093</doc-id>
        /// <unmanaged>textAntialiasMode</unmanaged>
        /// <unmanaged-short>textAntialiasMode</unmanaged-short>
        public SharpDX.Direct2D1.TextAntialiasMode TextAntialiasMode;
        /// <summary>
        /// <dd> <p>A label for subsequent drawing operations.</p> </dd>
        /// </summary>
        /// <doc-id>dd368093</doc-id>
        /// <unmanaged>tag1</unmanaged>
        /// <unmanaged-short>tag1</unmanaged-short>
        public System.Int64 Tag1;
        /// <summary>
        /// <dd> <p>A label for subsequent drawing operations.</p> </dd>
        /// </summary>
        /// <doc-id>dd368093</doc-id>
        /// <unmanaged>tag2</unmanaged>
        /// <unmanaged-short>tag2</unmanaged-short>
        public System.Int64 Tag2;
        /// <summary>
        /// <dd> <p>The transformation to apply to subsequent drawing operations.</p> </dd>
        /// </summary>
        /// <doc-id>dd368093</doc-id>
        /// <unmanaged>transform</unmanaged>
        /// <unmanaged-short>transform</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawMatrix3x2 Transform;
    }

    /// <summary>
    /// <p>Describes the drawing state of a device context.</p>
    /// </summary>
    /// <doc-id>hh847946</doc-id>
    /// <unmanaged>D2D1_DRAWING_STATE_DESCRIPTION1</unmanaged>
    /// <unmanaged-short>D2D1_DRAWING_STATE_DESCRIPTION1</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct DrawingStateDescription1
    {
        /// <summary>
        /// <dd> <p>The antialiasing mode for subsequent nontext drawing operations. </p> </dd>
        /// </summary>
        /// <doc-id>hh847946</doc-id>
        /// <unmanaged>antialiasMode</unmanaged>
        /// <unmanaged-short>antialiasMode</unmanaged-short>
        public SharpDX.Direct2D1.AntialiasMode AntialiasMode;
        /// <summary>
        /// <dd> <p>The antialiasing mode for subsequent text and glyph drawing operations.</p> </dd>
        /// </summary>
        /// <doc-id>hh847946</doc-id>
        /// <unmanaged>textAntialiasMode</unmanaged>
        /// <unmanaged-short>textAntialiasMode</unmanaged-short>
        public SharpDX.Direct2D1.TextAntialiasMode TextAntialiasMode;
        /// <summary>
        /// <dd> <p>A label for subsequent drawing operations.</p> </dd>
        /// </summary>
        /// <doc-id>hh847946</doc-id>
        /// <unmanaged>tag1</unmanaged>
        /// <unmanaged-short>tag1</unmanaged-short>
        public System.Int64 Tag1;
        /// <summary>
        /// <dd> <p>A label for subsequent drawing operations.</p> </dd>
        /// </summary>
        /// <doc-id>hh847946</doc-id>
        /// <unmanaged>tag2</unmanaged>
        /// <unmanaged-short>tag2</unmanaged-short>
        public System.Int64 Tag2;
        /// <summary>
        /// <dd> <p>The transformation to apply to subsequent drawing operations.</p> </dd>
        /// </summary>
        /// <doc-id>hh847946</doc-id>
        /// <unmanaged>transform</unmanaged>
        /// <unmanaged-short>transform</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawMatrix3x2 Transform;
        /// <summary>
        /// <dd> <p>The blend mode for the device context to apply to subsequent drawing operations.</p> </dd>
        /// </summary>
        /// <doc-id>hh847946</doc-id>
        /// <unmanaged>primitiveBlend</unmanaged>
        /// <unmanaged-short>primitiveBlend</unmanaged-short>
        public SharpDX.Direct2D1.PrimitiveBlend PrimitiveBlend;
        /// <summary>
        /// <dd> <p><see cref = "SharpDX.Direct2D1.UnitMode"/></p> </dd>
        /// </summary>
        /// <doc-id>hh847946</doc-id>
        /// <unmanaged>unitMode</unmanaged>
        /// <unmanaged-short>unitMode</unmanaged-short>
        public SharpDX.Direct2D1.UnitMode UnitMode;
    }

    /// <summary>
    /// <p>Describes features of an effect.</p>
    /// </summary>
    /// <remarks>
    /// <strong>Note</strong>??The caller should not rely heavily on the input rectangles returned by this structure. They can change due to subtle changes in effect implementations and due to optimization changes in the effect rendering system.?
    /// </remarks>
    /// <doc-id>hh404305</doc-id>
    /// <unmanaged>D2D1_EFFECT_INPUT_DESCRIPTION</unmanaged>
    /// <unmanaged-short>D2D1_EFFECT_INPUT_DESCRIPTION</unmanaged-short>
    public partial class EffectInputDescription
    {
        /// <summary>
        /// <dd> <p>The effect whose input connection is being specified.</p> </dd>
        /// </summary>
        /// <doc-id>hh404305</doc-id>
        /// <unmanaged>effect</unmanaged>
        /// <unmanaged-short>effect</unmanaged-short>
        public SharpDX.Direct2D1.Effect Effect;
        /// <summary>
        /// <dd> <p>The input index of the effect that is being considered.</p> </dd>
        /// </summary>
        /// <doc-id>hh404305</doc-id>
        /// <unmanaged>inputIndex</unmanaged>
        /// <unmanaged-short>inputIndex</unmanaged-short>
        public System.Int32 InputIndex;
        /// <summary>
        /// <dd> <p>The amount of data that would be available on the input. This can be used to query this information when the data is not yet available. </p> </dd>
        /// </summary>
        /// <doc-id>hh404305</doc-id>
        /// <unmanaged>inputRectangle</unmanaged>
        /// <unmanaged-short>inputRectangle</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawRectangleF InputRectangle;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.IntPtr Effect;
            public System.Int32 InputIndex;
            public SharpDX.Mathematics.Interop.RawRectangleF InputRectangle;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            if (@ref.Effect != System.IntPtr.Zero)
                Effect = new SharpDX.Direct2D1.Effect(@ref.Effect);
            else
                Effect = null;
            InputIndex = @ref.InputIndex;
            InputRectangle = @ref.InputRectangle;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Effect = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Effect>(Effect);
            @ref.InputIndex = InputIndex;
            @ref.InputRectangle = InputRectangle;
        }
    }

    /// <summary>
    /// <p> Contains the center point, x-radius, and y-radius of an ellipse.</p>
    /// </summary>
    /// <doc-id>dd368097</doc-id>
    /// <unmanaged>D2D1_ELLIPSE</unmanaged>
    /// <unmanaged-short>D2D1_ELLIPSE</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct Ellipse
    {
        /// <summary>
        /// <dd> <p>The center point of the ellipse.</p> </dd>
        /// </summary>
        /// <doc-id>dd368097</doc-id>
        /// <unmanaged>point</unmanaged>
        /// <unmanaged-short>point</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 Point;
        /// <summary>
        /// <dd> <p>The X-radius of the ellipse.</p> </dd>
        /// </summary>
        /// <doc-id>dd368097</doc-id>
        /// <unmanaged>radiusX</unmanaged>
        /// <unmanaged-short>radiusX</unmanaged-short>
        public System.Single RadiusX;
        /// <summary>
        /// <dd> <p>The Y-radius of the ellipse.</p> </dd>
        /// </summary>
        /// <doc-id>dd368097</doc-id>
        /// <unmanaged>radiusY</unmanaged>
        /// <unmanaged-short>radiusY</unmanaged-short>
        public System.Single RadiusY;
    }

    /// <summary>
    /// <p>Contains the debugging level of an <strong><see cref = "SharpDX.Direct2D1.Factory"/></strong> object. </p>
    /// </summary>
    /// <remarks>
    /// <p>To enable debugging, you must install the Direct2D Debug Layer.</p>
    /// </remarks>
    /// <doc-id>dd368102</doc-id>
    /// <unmanaged>D2D1_FACTORY_OPTIONS</unmanaged>
    /// <unmanaged-short>D2D1_FACTORY_OPTIONS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct FactoryOptions
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd368102</doc-id>
        /// <unmanaged>debugLevel</unmanaged>
        /// <unmanaged-short>debugLevel</unmanaged-short>
        public SharpDX.Direct2D1.DebugLevel DebugLevel;
    }

    /// <summary>
    /// <p>Describes compute shader support, which is an option on D3D10 feature level.</p>
    /// </summary>
    /// <remarks>
    /// <p>You can fill this structure by passing a D2D1_ FEATURE_DATA_D3D10_X_HARDWARE_OPTIONS structure to <strong>ID2D1EffectContext::CheckFeatureSupport</strong>.</p>
    /// </remarks>
    /// <doc-id>hh871446</doc-id>
    /// <unmanaged>D2D1_FEATURE_DATA_D3D10_X_HARDWARE_OPTIONS</unmanaged>
    /// <unmanaged-short>D2D1_FEATURE_DATA_D3D10_X_HARDWARE_OPTIONS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    internal partial struct FeatureDataD3D10XHardwareOptions
    {
        /// <summary>
        /// <dd> <p>Shader model 4 compute shaders are supported.</p> </dd>
        /// </summary>
        /// <doc-id>hh871446</doc-id>
        /// <unmanaged>computeShaders_Plus_RawAndStructuredBuffers_Via_Shader_4_x</unmanaged>
        /// <unmanaged-short>computeShaders_Plus_RawAndStructuredBuffers_Via_Shader_4_x</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool ComputeShadersPlusRawAndStructuredBuffersViaShader4X;
    }

    /// <summary>
    /// <p>Describes the support for doubles in shaders.</p>
    /// </summary>
    /// <remarks>
    /// <p>Fill this structure by passing a D2D1_FEATURE_DOUBLES structure to <strong>ID2D1EffectContext::CheckFeatureSupport</strong>.</p>
    /// </remarks>
    /// <doc-id>hh871445</doc-id>
    /// <unmanaged>D2D1_FEATURE_DATA_DOUBLES</unmanaged>
    /// <unmanaged-short>D2D1_FEATURE_DATA_DOUBLES</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    internal partial struct FeatureDataDoubles
    {
        /// <summary>
        /// <dd> <p>TRUE is doubles are supported within the shaders.</p> </dd>
        /// </summary>
        /// <doc-id>hh871445</doc-id>
        /// <unmanaged>doublePrecisionFloatShaderOps</unmanaged>
        /// <unmanaged-short>doublePrecisionFloatShaderOps</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool DoublePrecisionFloatShaderOps;
    }

    /// <summary>
    /// <p> Represents a tensor patch with 16 control points, 4 corner colors, and boundary flags. An <see cref = "SharpDX.Direct2D1.GradientMesh"/> is made up of 1 or more gradient mesh patches. Use the <strong>GradientMeshPatch function</strong> or the <strong>GradientMeshPatchFromCoonsPatch function</strong> to create one. </p>
    /// </summary>
    /// <remarks>
    /// <p>The following image shows the numbering of control points on a tensor grid.</p>
    /// </remarks>
    /// <doc-id>dn890726</doc-id>
    /// <unmanaged>D2D1_GRADIENT_MESH_PATCH</unmanaged>
    /// <unmanaged-short>D2D1_GRADIENT_MESH_PATCH</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct GradientMeshPatch
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn890726</doc-id>
        /// <unmanaged>point00</unmanaged>
        /// <unmanaged-short>point00</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 Point00;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn890726</doc-id>
        /// <unmanaged>point01</unmanaged>
        /// <unmanaged-short>point01</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 Point01;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn890726</doc-id>
        /// <unmanaged>point02</unmanaged>
        /// <unmanaged-short>point02</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 Point02;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn890726</doc-id>
        /// <unmanaged>point03</unmanaged>
        /// <unmanaged-short>point03</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 Point03;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn890726</doc-id>
        /// <unmanaged>point10</unmanaged>
        /// <unmanaged-short>point10</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 Point10;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn890726</doc-id>
        /// <unmanaged>point11</unmanaged>
        /// <unmanaged-short>point11</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 Point11;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn890726</doc-id>
        /// <unmanaged>point12</unmanaged>
        /// <unmanaged-short>point12</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 Point12;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn890726</doc-id>
        /// <unmanaged>point13</unmanaged>
        /// <unmanaged-short>point13</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 Point13;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn890726</doc-id>
        /// <unmanaged>point20</unmanaged>
        /// <unmanaged-short>point20</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 Point20;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn890726</doc-id>
        /// <unmanaged>point21</unmanaged>
        /// <unmanaged-short>point21</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 Point21;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn890726</doc-id>
        /// <unmanaged>point22</unmanaged>
        /// <unmanaged-short>point22</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 Point22;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn890726</doc-id>
        /// <unmanaged>point23</unmanaged>
        /// <unmanaged-short>point23</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 Point23;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn890726</doc-id>
        /// <unmanaged>point30</unmanaged>
        /// <unmanaged-short>point30</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 Point30;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn890726</doc-id>
        /// <unmanaged>point31</unmanaged>
        /// <unmanaged-short>point31</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 Point31;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn890726</doc-id>
        /// <unmanaged>point32</unmanaged>
        /// <unmanaged-short>point32</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 Point32;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn890726</doc-id>
        /// <unmanaged>point33</unmanaged>
        /// <unmanaged-short>point33</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 Point33;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn890726</doc-id>
        /// <unmanaged>color00</unmanaged>
        /// <unmanaged-short>color00</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawColor4 Color00;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn890726</doc-id>
        /// <unmanaged>color03</unmanaged>
        /// <unmanaged-short>color03</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawColor4 Color03;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn890726</doc-id>
        /// <unmanaged>color30</unmanaged>
        /// <unmanaged-short>color30</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawColor4 Color30;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn890726</doc-id>
        /// <unmanaged>color33</unmanaged>
        /// <unmanaged-short>color33</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawColor4 Color33;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn890726</doc-id>
        /// <unmanaged>topEdgeMode</unmanaged>
        /// <unmanaged-short>topEdgeMode</unmanaged-short>
        public SharpDX.Direct2D1.PatchEdgeMode TopEdgeMode;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn890726</doc-id>
        /// <unmanaged>leftEdgeMode</unmanaged>
        /// <unmanaged-short>leftEdgeMode</unmanaged-short>
        public SharpDX.Direct2D1.PatchEdgeMode LeftEdgeMode;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn890726</doc-id>
        /// <unmanaged>bottomEdgeMode</unmanaged>
        /// <unmanaged-short>bottomEdgeMode</unmanaged-short>
        public SharpDX.Direct2D1.PatchEdgeMode BottomEdgeMode;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn890726</doc-id>
        /// <unmanaged>rightEdgeMode</unmanaged>
        /// <unmanaged-short>rightEdgeMode</unmanaged-short>
        public SharpDX.Direct2D1.PatchEdgeMode RightEdgeMode;
    }

    /// <summary>
    /// <p> Contains the position and color of a gradient stop. </p>
    /// </summary>
    /// <remarks>
    /// <p>Gradient stops can be specified in any order if they are at different positions. Two stops may share a position. In this case, the first stop specified is treated as the "low" stop (nearer 0.0f) and subsequent stops are treated as "higher" (nearer 1.0f). This behavior is useful if a caller wants an instant transition in the middle of a stop.</p><p>Typically, there are at least two points in a collection, although creation with only one stop is permitted. For example, one point is at position 0.0f, another point is at position 1.0f, and additional points are distributed in the [0, 1] range. Where the gradient progression is beyond the range of [0, 1], the stops are stored, but may affect the gradient. </p><p>When drawn, the [0, 1] range of positions is mapped to the brush, in a brush-dependent way. For details, see <strong><see cref = "SharpDX.Direct2D1.LinearGradientBrush"/></strong> and <strong><see cref = "SharpDX.Direct2D1.RadialGradientBrush"/></strong>. </p><p>Gradient stops with a position outside the [0, 1] range cannot be seen explicitly, but they can still affect the colors produced in the [0, 1] range. For example, a two-stop gradient 0.0f, Black}, {2.0f, White is indistinguishable visually from 0.0f, Black}, {1.0f, Mid-level gray. Also, the colors are clamped before interpolation.</p>
    /// </remarks>
    /// <doc-id>dd368119</doc-id>
    /// <unmanaged>D2D1_GRADIENT_STOP</unmanaged>
    /// <unmanaged-short>D2D1_GRADIENT_STOP</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct GradientStop
    {
        /// <summary>
        /// <dd> <p>A value that indicates the relative position of the gradient stop in the brush. This value must be in the [0.0f, 1.0f] range if the gradient stop is to be seen explicitly. </p> </dd>
        /// </summary>
        /// <doc-id>dd368119</doc-id>
        /// <unmanaged>position</unmanaged>
        /// <unmanaged-short>position</unmanaged-short>
        public System.Single Position;
        /// <summary>
        /// <dd> <p>The color of the gradient stop.</p> </dd>
        /// </summary>
        /// <doc-id>dd368119</doc-id>
        /// <unmanaged>color</unmanaged>
        /// <unmanaged-short>color</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawColor4 Color;
    }

    /// <summary>
    /// <p> Contains the <see cref = "System.IntPtr"/>, pixel size, and presentation options for an <strong><see cref = "SharpDX.Direct2D1.WindowRenderTarget"/></strong>.</p>
    /// </summary>
    /// <remarks>
    /// <p>Use this structure when you call the <strong>CreateHwndRenderTarget</strong> method to create a new <strong><see cref = "SharpDX.Direct2D1.WindowRenderTarget"/></strong>.</p><p>For convenience, Direct2D provides the <strong>D2D1::HwndRenderTargetProperties</strong> function for creating new <strong><see cref = "SharpDX.Direct2D1.HwndRenderTargetProperties"/></strong> structures.</p>
    /// </remarks>
    /// <doc-id>dd368122</doc-id>
    /// <unmanaged>D2D1_HWND_RENDER_TARGET_PROPERTIES</unmanaged>
    /// <unmanaged-short>D2D1_HWND_RENDER_TARGET_PROPERTIES</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct HwndRenderTargetProperties
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd368122</doc-id>
        /// <unmanaged>hwnd</unmanaged>
        /// <unmanaged-short>hwnd</unmanaged-short>
        public System.IntPtr Hwnd;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd368122</doc-id>
        /// <unmanaged>pixelSize</unmanaged>
        /// <unmanaged-short>pixelSize</unmanaged-short>
        public SharpDX.Size2 PixelSize;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd368122</doc-id>
        /// <unmanaged>presentOptions</unmanaged>
        /// <unmanaged-short>presentOptions</unmanaged-short>
        public SharpDX.Direct2D1.PresentOptions PresentOptions;
    }

    /// <summary>
    /// <p>Describes image brush features.</p>
    /// </summary>
    /// <doc-id>hh404308</doc-id>
    /// <unmanaged>D2D1_IMAGE_BRUSH_PROPERTIES</unmanaged>
    /// <unmanaged-short>D2D1_IMAGE_BRUSH_PROPERTIES</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct ImageBrushProperties
    {
        /// <summary>
        /// <dd> <p>The source rectangle in the image space from which the image will be tiled or interpolated.</p> </dd>
        /// </summary>
        /// <doc-id>hh404308</doc-id>
        /// <unmanaged>sourceRectangle</unmanaged>
        /// <unmanaged-short>sourceRectangle</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawRectangleF SourceRectangle;
        /// <summary>
        /// <dd> <p>The extend mode in the image x-axis.</p> </dd>
        /// </summary>
        /// <doc-id>hh404308</doc-id>
        /// <unmanaged>extendModeX</unmanaged>
        /// <unmanaged-short>extendModeX</unmanaged-short>
        public SharpDX.Direct2D1.ExtendMode ExtendModeX;
        /// <summary>
        /// <dd> <p>The extend mode in the image y-axis.</p> </dd>
        /// </summary>
        /// <doc-id>hh404308</doc-id>
        /// <unmanaged>extendModeY</unmanaged>
        /// <unmanaged-short>extendModeY</unmanaged-short>
        public SharpDX.Direct2D1.ExtendMode ExtendModeY;
        /// <summary>
        /// <dd> <p>The interpolation mode to use when scaling the image brush.</p> </dd>
        /// </summary>
        /// <doc-id>hh404308</doc-id>
        /// <unmanaged>interpolationMode</unmanaged>
        /// <unmanaged-short>interpolationMode</unmanaged-short>
        public SharpDX.Direct2D1.InterpolationMode InterpolationMode;
    }

    /// <summary>
    /// <p>Represents a Bezier segment to be used in the creation of an <strong><see cref = "SharpDX.Direct2D1.Ink"/></strong> object.  This structure differs from <strong><see cref = "SharpDX.Direct2D1.BezierSegment"/></strong> in that it is composed  of <strong><see cref = "SharpDX.Direct2D1.InkPoint"/></strong>s, which contain a radius in addition to x- and y-coordinates. </p>
    /// </summary>
    /// <doc-id>dn890751</doc-id>
    /// <unmanaged>D2D1_INK_BEZIER_SEGMENT</unmanaged>
    /// <unmanaged-short>D2D1_INK_BEZIER_SEGMENT</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct InkBezierSegment
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn890751</doc-id>
        /// <unmanaged>point1</unmanaged>
        /// <unmanaged-short>point1</unmanaged-short>
        public SharpDX.Direct2D1.InkPoint Point1;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn890751</doc-id>
        /// <unmanaged>point2</unmanaged>
        /// <unmanaged-short>point2</unmanaged-short>
        public SharpDX.Direct2D1.InkPoint Point2;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn890751</doc-id>
        /// <unmanaged>point3</unmanaged>
        /// <unmanaged-short>point3</unmanaged-short>
        public SharpDX.Direct2D1.InkPoint Point3;
    }

    /// <summary>
    /// <p>Represents a point, radius pair that makes up part of a <strong><see cref = "SharpDX.Direct2D1.InkBezierSegment"/></strong>.</p>
    /// </summary>
    /// <doc-id>dn890752</doc-id>
    /// <unmanaged>D2D1_INK_POINT</unmanaged>
    /// <unmanaged-short>D2D1_INK_POINT</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct InkPoint
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn890752</doc-id>
        /// <unmanaged>x</unmanaged>
        /// <unmanaged-short>x</unmanaged-short>
        public System.Single X;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn890752</doc-id>
        /// <unmanaged>y</unmanaged>
        /// <unmanaged-short>y</unmanaged-short>
        public System.Single Y;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn890752</doc-id>
        /// <unmanaged>radius</unmanaged>
        /// <unmanaged-short>radius</unmanaged-short>
        public System.Single Radius;
    }

    /// <summary>
    /// <p> Defines the general pen tip shape and the transform used in an <strong><see cref = "SharpDX.Direct2D1.InkStyle"/></strong> object. </p>
    /// </summary>
    /// <doc-id>dn890737</doc-id>
    /// <unmanaged>D2D1_INK_STYLE_PROPERTIES</unmanaged>
    /// <unmanaged-short>D2D1_INK_STYLE_PROPERTIES</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct InkStyleProperties
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn890737</doc-id>
        /// <unmanaged>nibShape</unmanaged>
        /// <unmanaged-short>nibShape</unmanaged-short>
        public SharpDX.Direct2D1.InkNibShape NibShape;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn890737</doc-id>
        /// <unmanaged>nibTransform</unmanaged>
        /// <unmanaged-short>nibTransform</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawMatrix3x2 NibTransform;
    }

    /// <summary>
    /// <p>Describes the options that transforms may set on input textures.</p>
    /// </summary>
    /// <doc-id>hh404310</doc-id>
    /// <unmanaged>D2D1_INPUT_DESCRIPTION</unmanaged>
    /// <unmanaged-short>D2D1_INPUT_DESCRIPTION</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct InputDescription
    {
        /// <summary>
        /// <dd> <p>The type of filter to apply to the input texture.</p> </dd>
        /// </summary>
        /// <doc-id>hh404310</doc-id>
        /// <unmanaged>filter</unmanaged>
        /// <unmanaged-short>filter</unmanaged-short>
        public SharpDX.Direct2D1.Filter Filter;
        /// <summary>
        /// <dd> <p>The mip level to retrieve from the upstream transform, if specified.</p> </dd>
        /// </summary>
        /// <doc-id>hh404310</doc-id>
        /// <unmanaged>levelOfDetailCount</unmanaged>
        /// <unmanaged-short>levelOfDetailCount</unmanaged-short>
        public System.Int32 LevelOfDetailCount;
    }

    /// <summary>
    /// <p>A description of a single element to the vertex layout.</p>
    /// </summary>
    /// <remarks>
    /// <p>This structure is a subset of <strong><see cref = "SharpDX.Direct3D11.InputElement"/></strong> that omits fields required to define a vertex layout.</p><p>If the <strong>D2D1_APPEND_ALIGNED_ELEMENT</strong> constant is used for  <strong>alignedByteOffset</strong>, the elements will be packed contiguously for convenience.
    /// </p>
    /// </remarks>
    /// <doc-id>hh404312</doc-id>
    /// <unmanaged>D2D1_INPUT_ELEMENT_DESC</unmanaged>
    /// <unmanaged-short>D2D1_INPUT_ELEMENT_DESC</unmanaged-short>
    public partial struct InputElement
    {
        /// <summary>
        /// <dd> <p>The HLSL semantic associated with this element in a shader input-signature.</p> </dd>
        /// </summary>
        /// <doc-id>hh404312</doc-id>
        /// <unmanaged>semanticName</unmanaged>
        /// <unmanaged-short>semanticName</unmanaged-short>
        public System.String SemanticName;
        /// <summary>
        /// <dd> <p>The semantic index for the element. A semantic index modifies a semantic, with an integer index number. A semantic index is only needed in a case where there is more than one element with the same semantic. For example, a 4x4 matrix would have four components each with the semantic name matrix; however, each of the four components would have different semantic indices (0, 1, 2, and 3).</p> </dd>
        /// </summary>
        /// <doc-id>hh404312</doc-id>
        /// <unmanaged>semanticIndex</unmanaged>
        /// <unmanaged-short>semanticIndex</unmanaged-short>
        public System.Int32 SemanticIndex;
        /// <summary>
        /// <dd> <p>The data type of the element data.</p> </dd>
        /// </summary>
        /// <doc-id>hh404312</doc-id>
        /// <unmanaged>format</unmanaged>
        /// <unmanaged-short>format</unmanaged-short>
        public SharpDX.DXGI.Format Format;
        /// <summary>
        /// <dd> <p>An integer value that identifies the input-assembler. Valid values are between 0 and 15.</p> </dd>
        /// </summary>
        /// <doc-id>hh404312</doc-id>
        /// <unmanaged>inputSlot</unmanaged>
        /// <unmanaged-short>inputSlot</unmanaged-short>
        public System.Int32 Slot;
        /// <summary>
        /// <dd> <p>The offset in bytes between each element.</p> </dd>
        /// </summary>
        /// <doc-id>hh404312</doc-id>
        /// <unmanaged>alignedByteOffset</unmanaged>
        /// <unmanaged-short>alignedByteOffset</unmanaged-short>
        public System.Int32 AlignedByteOffset;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.IntPtr SemanticName;
            public System.Int32 SemanticIndex;
            public SharpDX.DXGI.Format Format;
            public System.Int32 Slot;
            public System.Int32 AlignedByteOffset;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.SemanticName);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            SemanticName = System.Runtime.InteropServices.Marshal.PtrToStringAnsi(@ref.SemanticName);
            SemanticIndex = @ref.SemanticIndex;
            Format = @ref.Format;
            Slot = @ref.Slot;
            AlignedByteOffset = @ref.AlignedByteOffset;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.SemanticName = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(SemanticName);
            @ref.SemanticIndex = SemanticIndex;
            @ref.Format = Format;
            @ref.Slot = Slot;
            @ref.AlignedByteOffset = AlignedByteOffset;
        }
    }

    /// <summary>
    /// <p> Contains the content bounds, mask information, opacity settings, and other options for a layer resource. </p>
    /// </summary>
    /// <doc-id>dd368127</doc-id>
    /// <unmanaged>D2D1_LAYER_PARAMETERS</unmanaged>
    /// <unmanaged-short>D2D1_LAYER_PARAMETERS</unmanaged-short>
    public partial struct LayerParameters
    {
        /// <summary>
        /// <dd> <p>The content bounds of the layer. Content outside these bounds is not guaranteed to render.</p> </dd>
        /// </summary>
        /// <doc-id>dd368127</doc-id>
        /// <unmanaged>contentBounds</unmanaged>
        /// <unmanaged-short>contentBounds</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawRectangleF ContentBounds;
        /// <summary>
        /// <dd> <p>The geometric mask specifies the area of the layer that is composited into the render target. </p> </dd>
        /// </summary>
        /// <doc-id>dd368127</doc-id>
        /// <unmanaged>geometricMask</unmanaged>
        /// <unmanaged-short>geometricMask</unmanaged-short>
        public SharpDX.Direct2D1.Geometry GeometricMask;
        /// <summary>
        /// <dd> <p>A value that specifies the antialiasing mode for the geometricMask.  </p> </dd>
        /// </summary>
        /// <doc-id>dd368127</doc-id>
        /// <unmanaged>maskAntialiasMode</unmanaged>
        /// <unmanaged-short>maskAntialiasMode</unmanaged-short>
        public SharpDX.Direct2D1.AntialiasMode MaskAntialiasMode;
        /// <summary>
        /// <dd> <p> A value that specifies the transform that is applied to the geometric mask when composing the layer.</p> </dd>
        /// </summary>
        /// <doc-id>dd368127</doc-id>
        /// <unmanaged>maskTransform</unmanaged>
        /// <unmanaged-short>maskTransform</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawMatrix3x2 MaskTransform;
        /// <summary>
        /// <dd> <p>An opacity value that is applied uniformly to all resources in the layer when compositing to the target.</p> </dd>
        /// </summary>
        /// <doc-id>dd368127</doc-id>
        /// <unmanaged>opacity</unmanaged>
        /// <unmanaged-short>opacity</unmanaged-short>
        public System.Single Opacity;
        /// <summary>
        /// <dd> <p>A brush that is used to modify the opacity of the layer. The brush 
        /// is mapped to the layer, and the alpha channel of each mapped brush pixel is multiplied against the corresponding layer pixel. </p> </dd>
        /// </summary>
        /// <doc-id>dd368127</doc-id>
        /// <unmanaged>opacityBrush</unmanaged>
        /// <unmanaged-short>opacityBrush</unmanaged-short>
        public SharpDX.Direct2D1.Brush OpacityBrush;
        /// <summary>
        /// <dd> <p> A value that specifies whether the layer intends to render text with ClearType antialiasing.</p> </dd>
        /// </summary>
        /// <doc-id>dd368127</doc-id>
        /// <unmanaged>layerOptions</unmanaged>
        /// <unmanaged-short>layerOptions</unmanaged-short>
        public SharpDX.Direct2D1.LayerOptions LayerOptions;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.Mathematics.Interop.RawRectangleF ContentBounds;
            public System.IntPtr GeometricMask;
            public SharpDX.Direct2D1.AntialiasMode MaskAntialiasMode;
            public SharpDX.Mathematics.Interop.RawMatrix3x2 MaskTransform;
            public System.Single Opacity;
            public System.IntPtr OpacityBrush;
            public SharpDX.Direct2D1.LayerOptions LayerOptions;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            ContentBounds = @ref.ContentBounds;
            if (@ref.GeometricMask != System.IntPtr.Zero)
                GeometricMask = new SharpDX.Direct2D1.Geometry(@ref.GeometricMask);
            else
                GeometricMask = null;
            MaskAntialiasMode = @ref.MaskAntialiasMode;
            MaskTransform = @ref.MaskTransform;
            Opacity = @ref.Opacity;
            if (@ref.OpacityBrush != System.IntPtr.Zero)
                OpacityBrush = new SharpDX.Direct2D1.Brush(@ref.OpacityBrush);
            else
                OpacityBrush = null;
            LayerOptions = @ref.LayerOptions;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.ContentBounds = ContentBounds;
            @ref.GeometricMask = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Geometry>(GeometricMask);
            @ref.MaskAntialiasMode = MaskAntialiasMode;
            @ref.MaskTransform = MaskTransform;
            @ref.Opacity = Opacity;
            @ref.OpacityBrush = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Brush>(OpacityBrush);
            @ref.LayerOptions = LayerOptions;
        }
    }

    /// <summary>
    /// <p>Contains the content bounds, mask information, opacity settings, and other options for a layer resource.</p>
    /// </summary>
    /// <doc-id>hh847947</doc-id>
    /// <unmanaged>D2D1_LAYER_PARAMETERS1</unmanaged>
    /// <unmanaged-short>D2D1_LAYER_PARAMETERS1</unmanaged-short>
    public partial struct LayerParameters1
    {
        /// <summary>
        /// <dd> <p>The content bounds of the layer. Content outside these bounds is not guaranteed to render.</p> </dd>
        /// </summary>
        /// <doc-id>hh847947</doc-id>
        /// <unmanaged>contentBounds</unmanaged>
        /// <unmanaged-short>contentBounds</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawRectangleF ContentBounds;
        /// <summary>
        /// <dd> <p>The geometric mask specifies the area of the layer that is composited into the render target. </p> </dd>
        /// </summary>
        /// <doc-id>hh847947</doc-id>
        /// <unmanaged>geometricMask</unmanaged>
        /// <unmanaged-short>geometricMask</unmanaged-short>
        public SharpDX.Direct2D1.Geometry GeometricMask;
        /// <summary>
        /// <dd> <p>A value that specifies the antialiasing mode for the geometricMask.  </p> </dd>
        /// </summary>
        /// <doc-id>hh847947</doc-id>
        /// <unmanaged>maskAntialiasMode</unmanaged>
        /// <unmanaged-short>maskAntialiasMode</unmanaged-short>
        public SharpDX.Direct2D1.AntialiasMode MaskAntialiasMode;
        /// <summary>
        /// <dd> <p> A value that specifies the transform that is applied to the geometric mask when composing the layer.</p> </dd>
        /// </summary>
        /// <doc-id>hh847947</doc-id>
        /// <unmanaged>maskTransform</unmanaged>
        /// <unmanaged-short>maskTransform</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawMatrix3x2 MaskTransform;
        /// <summary>
        /// <dd> <p>An opacity value that is applied uniformly to all resources in the layer when compositing to the target.</p> </dd>
        /// </summary>
        /// <doc-id>hh847947</doc-id>
        /// <unmanaged>opacity</unmanaged>
        /// <unmanaged-short>opacity</unmanaged-short>
        public System.Single Opacity;
        /// <summary>
        /// <dd> <p>A brush that is used to modify the opacity of the layer. The brush 
        /// is mapped to the layer, and the alpha channel of each mapped brush pixel is multiplied against the corresponding layer pixel. </p> </dd>
        /// </summary>
        /// <doc-id>hh847947</doc-id>
        /// <unmanaged>opacityBrush</unmanaged>
        /// <unmanaged-short>opacityBrush</unmanaged-short>
        public SharpDX.Direct2D1.Brush OpacityBrush;
        /// <summary>
        /// <dd> <p>Additional options for the layer creation.</p> </dd>
        /// </summary>
        /// <doc-id>hh847947</doc-id>
        /// <unmanaged>layerOptions</unmanaged>
        /// <unmanaged-short>layerOptions</unmanaged-short>
        public SharpDX.Direct2D1.LayerOptions1 LayerOptions;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.Mathematics.Interop.RawRectangleF ContentBounds;
            public System.IntPtr GeometricMask;
            public SharpDX.Direct2D1.AntialiasMode MaskAntialiasMode;
            public SharpDX.Mathematics.Interop.RawMatrix3x2 MaskTransform;
            public System.Single Opacity;
            public System.IntPtr OpacityBrush;
            public SharpDX.Direct2D1.LayerOptions1 LayerOptions;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            ContentBounds = @ref.ContentBounds;
            if (@ref.GeometricMask != System.IntPtr.Zero)
                GeometricMask = new SharpDX.Direct2D1.Geometry(@ref.GeometricMask);
            else
                GeometricMask = null;
            MaskAntialiasMode = @ref.MaskAntialiasMode;
            MaskTransform = @ref.MaskTransform;
            Opacity = @ref.Opacity;
            if (@ref.OpacityBrush != System.IntPtr.Zero)
                OpacityBrush = new SharpDX.Direct2D1.Brush(@ref.OpacityBrush);
            else
                OpacityBrush = null;
            LayerOptions = @ref.LayerOptions;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.ContentBounds = ContentBounds;
            @ref.GeometricMask = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Geometry>(GeometricMask);
            @ref.MaskAntialiasMode = MaskAntialiasMode;
            @ref.MaskTransform = MaskTransform;
            @ref.Opacity = Opacity;
            @ref.OpacityBrush = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Brush>(OpacityBrush);
            @ref.LayerOptions = LayerOptions;
        }
    }

    /// <summary>
    /// <p> Contains the starting point and endpoint of the gradient axis for an <strong><see cref = "SharpDX.Direct2D1.LinearGradientBrush"/></strong>. </p>
    /// </summary>
    /// <remarks>
    /// <p>Use this method when creating new <strong><see cref = "SharpDX.Direct2D1.LinearGradientBrush"/></strong> objects with the <strong>CreateLinearGradientBrush</strong> method. For convenience, Direct2D provides the <strong>D2D1::LinearGradientBrushProperties</strong> helper function for creating new <strong><see cref = "SharpDX.Direct2D1.LinearGradientBrushProperties"/></strong> structures.</p><p>The following illustration shows how a linear gradient changes as you change its start and end points.  For the first gradient, the start point is set to (0,0) and the end point to (150, 50); this creates a diagonal gradient that starts at the upper-left corner and extends to the lower-right corner of the area being painted. When you set the start point to (0, 25) and the end point to (150, 25), a horizontal gradient is created. Similarly, setting the start point  to (75, 0) and the end point to (75, 50) creates a vertical gradient. Setting the start point to  (0, 50) and the end point to (150, 0)  creates a diagonal gradient that starts at the lower-left corner and extends to the upper-right corner of the area being painted.</p><p></p>
    /// </remarks>
    /// <doc-id>dd368128</doc-id>
    /// <unmanaged>D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES</unmanaged>
    /// <unmanaged-short>D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct LinearGradientBrushProperties
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd368128</doc-id>
        /// <unmanaged>startPoint</unmanaged>
        /// <unmanaged-short>startPoint</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 StartPoint;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd368128</doc-id>
        /// <unmanaged>endPoint</unmanaged>
        /// <unmanaged-short>endPoint</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 EndPoint;
    }

    /// <summary>
    /// <p> Describes mapped memory from the <strong>ID2D1Bitmap1::Map</strong> API.</p>
    /// </summary>
    /// <remarks>
    /// <p>The mapped rectangle is used to map a rectangle into the caller's address space.</p>
    /// </remarks>
    /// <doc-id>hh404314</doc-id>
    /// <unmanaged>D2D1_MAPPED_RECT</unmanaged>
    /// <unmanaged-short>D2D1_MAPPED_RECT</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    internal partial struct MappedRectangle
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh404314</doc-id>
        /// <unmanaged>pitch</unmanaged>
        /// <unmanaged-short>pitch</unmanaged-short>
        public System.Int32 Pitch;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh404314</doc-id>
        /// <unmanaged>bits</unmanaged>
        /// <unmanaged-short>bits</unmanaged-short>
        public System.IntPtr Bits;
    }

    /// <summary>
    /// <p> Contains the data format and alpha mode for a bitmap or render target. </p>
    /// </summary>
    /// <remarks>
    /// <p>For more information about the pixel formats and alpha modes supported by each render target, see Supported Pixel Formats and Alpha Modes.</p>
    /// </remarks>
    /// <doc-id>dd368138</doc-id>
    /// <unmanaged>D2D1_PIXEL_FORMAT</unmanaged>
    /// <unmanaged-short>D2D1_PIXEL_FORMAT</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct PixelFormat
    {
        /// <summary>
        /// <dd> <p>A value that specifies the size and arrangement of channels in each pixel.</p> </dd>
        /// </summary>
        /// <doc-id>dd368138</doc-id>
        /// <unmanaged>format</unmanaged>
        /// <unmanaged-short>format</unmanaged-short>
        public SharpDX.DXGI.Format Format;
        /// <summary>
        /// <dd> <p>A value that specifies whether the alpha channel is using pre-multiplied alpha, straight alpha, whether it should be ignored and considered opaque, or whether it is unkown.  </p> </dd>
        /// </summary>
        /// <doc-id>dd368138</doc-id>
        /// <unmanaged>alphaMode</unmanaged>
        /// <unmanaged-short>alphaMode</unmanaged-short>
        public SharpDX.Direct2D1.AlphaMode AlphaMode;
    }

    /// <summary>
    /// <p>Describes a point on a path geometry.</p>
    /// </summary>
    /// <doc-id>hh404318</doc-id>
    /// <unmanaged>D2D1_POINT_DESCRIPTION</unmanaged>
    /// <unmanaged-short>D2D1_POINT_DESCRIPTION</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct PointDescription
    {
        /// <summary>
        /// <dd> <p>The end point after walking the path.</p> </dd>
        /// </summary>
        /// <doc-id>hh404318</doc-id>
        /// <unmanaged>point</unmanaged>
        /// <unmanaged-short>point</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 Point;
        /// <summary>
        /// <dd> <p>A unit vector indicating the tangent point.</p> </dd>
        /// </summary>
        /// <doc-id>hh404318</doc-id>
        /// <unmanaged>unitTangentVector</unmanaged>
        /// <unmanaged-short>unitTangentVector</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 UnitTangentVector;
        /// <summary>
        /// <dd> <p>The index of the segment on which point resides. This index is global to the entire path, not just to a particular figure.</p> </dd>
        /// </summary>
        /// <doc-id>hh404318</doc-id>
        /// <unmanaged>endSegment</unmanaged>
        /// <unmanaged-short>endSegment</unmanaged-short>
        public System.Int32 EndSegment;
        /// <summary>
        /// <dd> <p>The index of the figure on which point resides.</p> </dd>
        /// </summary>
        /// <doc-id>hh404318</doc-id>
        /// <unmanaged>endFigure</unmanaged>
        /// <unmanaged-short>endFigure</unmanaged-short>
        public System.Int32 EndFigure;
        /// <summary>
        /// <dd> <p>The length of the section of the path stretching from the start of the path  to the start of <strong>endSegment</strong>.</p> </dd>
        /// </summary>
        /// <doc-id>hh404318</doc-id>
        /// <unmanaged>lengthToEndSegment</unmanaged>
        /// <unmanaged-short>lengthToEndSegment</unmanaged-short>
        public System.Single LengthToEndSegment;
    }

    /// <summary>
    /// <p>The creation properties for a <strong><see cref = "SharpDX.Direct2D1.PrintControl"/></strong> object.</p>
    /// </summary>
    /// <doc-id>hh847949</doc-id>
    /// <unmanaged>D2D1_PRINT_CONTROL_PROPERTIES</unmanaged>
    /// <unmanaged-short>D2D1_PRINT_CONTROL_PROPERTIES</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct PrintControlProperties
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh847949</doc-id>
        /// <unmanaged>fontSubset</unmanaged>
        /// <unmanaged-short>fontSubset</unmanaged-short>
        public SharpDX.Direct2D1.PrintFontSubsetMode FontSubset;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh847949</doc-id>
        /// <unmanaged>rasterDPI</unmanaged>
        /// <unmanaged-short>rasterDPI</unmanaged-short>
        public System.Single RasterDPI;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh847949</doc-id>
        /// <unmanaged>colorSpace</unmanaged>
        /// <unmanaged-short>colorSpace</unmanaged-short>
        public SharpDX.Direct2D1.ColorSpace ColorSpace;
    }

    /// <summary>
    /// <p>Defines a property binding to a pair of functions which get and set the corresponding property. </p>
    /// </summary>
    /// <remarks>
    /// <p>The <strong>propertyName</strong> is used to cross-correlate the property binding with the registration XML. The <strong>propertyName</strong> must be present in the XML call or the registration will fail. All properties must be bound.</p>
    /// </remarks>
    /// <doc-id>hh404320</doc-id>
    /// <unmanaged>D2D1_PROPERTY_BINDING</unmanaged>
    /// <unmanaged-short>D2D1_PROPERTY_BINDING</unmanaged-short>
    internal partial class PropertyBinding
    {
        /// <summary>
        /// <dd> <p> The name of the property.</p> </dd>
        /// </summary>
        /// <doc-id>hh404320</doc-id>
        /// <unmanaged>propertyName</unmanaged>
        /// <unmanaged-short>propertyName</unmanaged-short>
        public System.String PropertyName;
        /// <summary>
        /// <dd> <p> The function that will receive the data to set.</p> </dd>
        /// </summary>
        /// <doc-id>hh404320</doc-id>
        /// <unmanaged>setFunction</unmanaged>
        /// <unmanaged-short>setFunction</unmanaged-short>
        internal System.IntPtr SetFunction;
        /// <summary>
        /// <dd> <p>The function that will be asked to write the output data.</p> </dd>
        /// </summary>
        /// <doc-id>hh404320</doc-id>
        /// <unmanaged>getFunction</unmanaged>
        /// <unmanaged-short>getFunction</unmanaged-short>
        internal System.IntPtr GetFunction;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.IntPtr PropertyName;
            public System.IntPtr SetFunction;
            public System.IntPtr GetFunction;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.PropertyName);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            PropertyName = System.Runtime.InteropServices.Marshal.PtrToStringUni(@ref.PropertyName);
            SetFunction = @ref.SetFunction;
            GetFunction = @ref.GetFunction;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.PropertyName = System.Runtime.InteropServices.Marshal.StringToHGlobalUni(PropertyName);
            @ref.SetFunction = SetFunction;
            @ref.GetFunction = GetFunction;
        }
    }

    /// <summary>
    /// <p> Contains the control point and end point for a quadratic Bezier segment.</p>
    /// </summary>
    /// <doc-id>dd368147</doc-id>
    /// <unmanaged>D2D1_QUADRATIC_BEZIER_SEGMENT</unmanaged>
    /// <unmanaged-short>D2D1_QUADRATIC_BEZIER_SEGMENT</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct QuadraticBezierSegment
    {
        /// <summary>
        /// <dd> <p>The control point of the quadratic Bezier segment.</p> </dd>
        /// </summary>
        /// <doc-id>dd368147</doc-id>
        /// <unmanaged>point1</unmanaged>
        /// <unmanaged-short>point1</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 Point1;
        /// <summary>
        /// <dd> <p>The end point of the quadratic Bezier segment.</p> </dd>
        /// </summary>
        /// <doc-id>dd368147</doc-id>
        /// <unmanaged>point2</unmanaged>
        /// <unmanaged-short>point2</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 Point2;
    }

    /// <summary>
    /// <p> Contains the gradient origin offset and the size and position of the gradient ellipse for an <strong><see cref = "SharpDX.Direct2D1.RadialGradientBrush"/></strong>. </p>
    /// </summary>
    /// <remarks>
    /// <p>Different values for <em>center</em>,  <em>gradientOriginOffset</em>,  <em>radiusX</em> and/or <em>radiusY</em> produce different gradients.   The following illustration shows several radial gradients that have different gradient origin offsets, creating the appearance of the light illuminating the circles from different angles.</p><p></p><p>For convenience, Direct2D provides the <strong>D2D1::RadialGradientBrushProperties</strong> function for creating new <strong>D2D1_RADIAL_GRADIENT_BRUSH</strong> structures.</p>
    /// </remarks>
    /// <doc-id>dd368149</doc-id>
    /// <unmanaged>D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES</unmanaged>
    /// <unmanaged-short>D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct RadialGradientBrushProperties
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd368149</doc-id>
        /// <unmanaged>center</unmanaged>
        /// <unmanaged-short>center</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 Center;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd368149</doc-id>
        /// <unmanaged>gradientOriginOffset</unmanaged>
        /// <unmanaged-short>gradientOriginOffset</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 GradientOriginOffset;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd368149</doc-id>
        /// <unmanaged>radiusX</unmanaged>
        /// <unmanaged-short>radiusX</unmanaged-short>
        public System.Single RadiusX;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd368149</doc-id>
        /// <unmanaged>radiusY</unmanaged>
        /// <unmanaged-short>radiusY</unmanaged-short>
        public System.Single RadiusY;
    }

    /// <summary>
    /// <p>Describes limitations to be applied to an imaging effect renderer.</p>
    /// </summary>
    /// <remarks>
    /// <p>The renderer can allocate tiles larger than the minimum tile allocation. The allocated tiles will be powers of two of the minimum size on each axis, except that the size on each axis will not exceed the guaranteed maximum texture size for the device feature level. </p><p>The <strong>minimumPixelRenderExtent</strong> is the size of the square tile below which the renderer will expand the tile allocation rather than attempting to subdivide the rendering tile any further. When this threshold is reached, the allocation tile size is expanded. This might occur repeatedly until rendering can either proceed or it is determined that the graph cannot be rendered.</p><p>The buffer precision is used for intermediate buffers if it is otherwise unspecified by the effects or the internal effect topology. The application can also use the <strong>Output.BufferPrecision</strong> method to specify the output precision for a particular effect. This takes precedence over the context precision. In addition, the effect might set a different precision internally if required. If the buffer type on the context is <strong>D2D1_BUFFER_PRECISION_UNKNOWN</strong> and otherwise not specified by the effect or transform, the precision of the output will be the maximum precision of the inputs to the transform. The buffer precision does not affect the number of channels used. </p>
    /// </remarks>
    /// <doc-id>hh404322</doc-id>
    /// <unmanaged>D2D1_RENDERING_CONTROLS</unmanaged>
    /// <unmanaged-short>D2D1_RENDERING_CONTROLS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct RenderingControls
    {
        /// <summary>
        /// <dd> <p>The buffer precision used by default if the buffer precision is not otherwise specified by the effect or the transform.</p> </dd>
        /// </summary>
        /// <doc-id>hh404322</doc-id>
        /// <unmanaged>bufferPrecision</unmanaged>
        /// <unmanaged-short>bufferPrecision</unmanaged-short>
        public SharpDX.Direct2D1.BufferPrecision BufferPrecision;
        /// <summary>
        /// <dd> <p>The tile allocation size to be used by the imaging effect renderer.</p> </dd>
        /// </summary>
        /// <doc-id>hh404322</doc-id>
        /// <unmanaged>tileSize</unmanaged>
        /// <unmanaged-short>tileSize</unmanaged-short>
        public SharpDX.Size2 TileSize;
    }

    /// <summary>
    /// <p> Contains rendering options (hardware or software), pixel format, DPI information, remoting options, and Direct3D support requirements for a render target. </p>
    /// </summary>
    /// <remarks>
    /// <p>Use this structure when creating a render target, or use it with the <strong>ID2D1RenderTarget::IsSupported</strong> method to check the properties supported by an existing render target.</p><p>As a convenience, Direct2D provides the <strong>D2D1::RenderTargetProperties</strong> helper function for creating <strong><see cref = "SharpDX.Direct2D1.RenderTargetProperties"/></strong> structures. An easy way to create a <strong><see cref = "SharpDX.Direct2D1.RenderTargetProperties"/></strong> structure that works for most render targets is to call the function without specifying any parameters. Doing so creates a <strong><see cref = "SharpDX.Direct2D1.RenderTargetProperties"/></strong> structure that has its fields set to default values. For more information, see   <strong>D2D1::RenderTargetProperties</strong>.</p><p>Not all render targets support hardware rendering. For a list, see the Render Targets Overview.</p>
    /// </remarks>
    /// <doc-id>dd368155</doc-id>
    /// <unmanaged>D2D1_RENDER_TARGET_PROPERTIES</unmanaged>
    /// <unmanaged-short>D2D1_RENDER_TARGET_PROPERTIES</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct RenderTargetProperties
    {
        /// <summary>
        /// <dd> <p>A value that specifies whether the render target should force hardware or software rendering. A value of <strong>D2D1_RENDER_TARGET_TYPE_DEFAULT</strong> specifies that the render target should use hardware rendering if it is available; otherwise, it uses software rendering. Note that WIC bitmap render targets do not support hardware rendering.</p> </dd>
        /// </summary>
        /// <doc-id>dd368155</doc-id>
        /// <unmanaged>type</unmanaged>
        /// <unmanaged-short>type</unmanaged-short>
        public SharpDX.Direct2D1.RenderTargetType Type;
        /// <summary>
        /// <dd> <p>The pixel format and alpha mode of the render target. You can use the <strong>D2D1::PixelFormat</strong> function to create a pixel format that specifies that Direct2D should select the pixel format and alpha mode for you. For a list of pixel formats and alpha modes supported by each render target, see Supported Pixel Formats and Alpha Modes.</p> </dd>
        /// </summary>
        /// <doc-id>dd368155</doc-id>
        /// <unmanaged>pixelFormat</unmanaged>
        /// <unmanaged-short>pixelFormat</unmanaged-short>
        public SharpDX.Direct2D1.PixelFormat PixelFormat;
        /// <summary>
        /// <dd> <p>The horizontal DPI of the render target.  To use the default DPI, set <em>dpiX</em> and <em>dpiY</em> to 0. For more information, see the Remarks section. </p> </dd>
        /// </summary>
        /// <doc-id>dd368155</doc-id>
        /// <unmanaged>dpiX</unmanaged>
        /// <unmanaged-short>dpiX</unmanaged-short>
        public System.Single DpiX;
        /// <summary>
        /// <dd> <p>The vertical DPI of the render target. To use the default DPI, set <em>dpiX</em> and <em>dpiY</em> to 0.  For more information, see the Remarks section. </p> </dd>
        /// </summary>
        /// <doc-id>dd368155</doc-id>
        /// <unmanaged>dpiY</unmanaged>
        /// <unmanaged-short>dpiY</unmanaged-short>
        public System.Single DpiY;
        /// <summary>
        /// <dd> <p>A value that specifies how the render target is remoted and whether it should be GDI-compatible.  Set to <strong>D2D1_RENDER_TARGET_USAGE_NONE</strong> to create a render target that is not compatible with GDI and uses Direct3D command-stream remoting if it  is available. </p> </dd>
        /// </summary>
        /// <doc-id>dd368155</doc-id>
        /// <unmanaged>usage</unmanaged>
        /// <unmanaged-short>usage</unmanaged-short>
        public SharpDX.Direct2D1.RenderTargetUsage Usage;
        /// <summary>
        /// <dd> <p>A value that specifies the minimum Direct3D feature level required for hardware rendering. If the specified minimum level is not available, the render target uses software rendering if the <strong>type </strong> member is set to <strong>D2D1_RENDER_TARGET_TYPE_DEFAULT</strong>; if  <strong>type </strong> is set to to <strong>D2D1_RENDER_TARGET_TYPE_HARDWARE</strong>, render target creation fails. A value of <strong>D2D1_FEATURE_LEVEL_DEFAULT</strong> indicates that Direct2D should determine whether the Direct3D feature level of the device is adequate. This field is used only when creating <strong><see cref = "SharpDX.Direct2D1.WindowRenderTarget"/></strong> and <strong><see cref = "SharpDX.Direct2D1.DeviceContextRenderTarget"/></strong> objects.</p> </dd>
        /// </summary>
        /// <doc-id>dd368155</doc-id>
        /// <unmanaged>minLevel</unmanaged>
        /// <unmanaged-short>minLevel</unmanaged-short>
        public SharpDX.Direct2D1.FeatureLevel MinLevel;
    }

    /// <summary>
    /// <p>Defines a resource texture when the original resource texture is created.</p>
    /// </summary>
    /// <doc-id>hh404324</doc-id>
    /// <unmanaged>D2D1_RESOURCE_TEXTURE_PROPERTIES</unmanaged>
    /// <unmanaged-short>D2D1_RESOURCE_TEXTURE_PROPERTIES</unmanaged-short>
    public partial class ResourceTextureProperties
    {
        /// <summary>
        /// <dd> <p>The extents of the resource table in each dimension.</p> </dd>
        /// </summary>
        /// <doc-id>hh404324</doc-id>
        /// <unmanaged>extents</unmanaged>
        /// <unmanaged-short>extents</unmanaged-short>
        internal System.IntPtr ExtentsPointer;
        /// <summary>
        /// <dd> <p>The number of dimensions in the resource texture. This must be a number from 1 to 3.</p> </dd>
        /// </summary>
        /// <doc-id>hh404324</doc-id>
        /// <unmanaged>dimensions</unmanaged>
        /// <unmanaged-short>dimensions</unmanaged-short>
        public System.Int32 Dimensions;
        /// <summary>
        /// <dd> <p>The precision of the resource texture to create. </p> </dd>
        /// </summary>
        /// <doc-id>hh404324</doc-id>
        /// <unmanaged>bufferPrecision</unmanaged>
        /// <unmanaged-short>bufferPrecision</unmanaged-short>
        public SharpDX.Direct2D1.BufferPrecision BufferPrecision;
        /// <summary>
        /// <dd> <p>The number of channels in the resource texture.</p> </dd>
        /// </summary>
        /// <doc-id>hh404324</doc-id>
        /// <unmanaged>channelDepth</unmanaged>
        /// <unmanaged-short>channelDepth</unmanaged-short>
        public SharpDX.Direct2D1.ChannelDepth ChannelDepth;
        /// <summary>
        /// <dd> <p>The filtering mode to use on the texture.</p> </dd>
        /// </summary>
        /// <doc-id>hh404324</doc-id>
        /// <unmanaged>filter</unmanaged>
        /// <unmanaged-short>filter</unmanaged-short>
        public SharpDX.Direct2D1.Filter Filter;
        /// <summary>
        /// <dd> <p>Specifies how pixel values beyond the extent of the texture will be sampled, in every dimension.</p> </dd>
        /// </summary>
        /// <doc-id>hh404324</doc-id>
        /// <unmanaged>extendModes</unmanaged>
        /// <unmanaged-short>extendModes</unmanaged-short>
        internal System.IntPtr ExtendModesPointer;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.IntPtr ExtentsPointer;
            public System.Int32 Dimensions;
            public SharpDX.Direct2D1.BufferPrecision BufferPrecision;
            public SharpDX.Direct2D1.ChannelDepth ChannelDepth;
            public SharpDX.Direct2D1.Filter Filter;
            public System.IntPtr ExtendModesPointer;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            ExtentsPointer = @ref.ExtentsPointer;
            Dimensions = @ref.Dimensions;
            BufferPrecision = @ref.BufferPrecision;
            ChannelDepth = @ref.ChannelDepth;
            Filter = @ref.Filter;
            ExtendModesPointer = @ref.ExtendModesPointer;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.ExtentsPointer = ExtentsPointer;
            @ref.Dimensions = Dimensions;
            @ref.BufferPrecision = BufferPrecision;
            @ref.ChannelDepth = ChannelDepth;
            @ref.Filter = Filter;
            @ref.ExtendModesPointer = ExtendModesPointer;
        }
    }

    /// <summary>
    /// <p> Contains the dimensions and corner radii of a rounded rectangle.</p>
    /// </summary>
    /// <remarks>
    /// <p>Each corner of the rectangle specified by the <em>rect</em> is replaced with a quarter ellipse, with a radius in each direction specified by <em>radiusX</em> and <em>radiusY</em>.</p><p> If the <em>radiusX</em> is greater than or equal to half the width of the rectangle, and the <em>radiusY</em> is greater than or equal to one-half the height, the rounded rectangle is an ellipse with the same width and height of the <em>rect</em>. </p><p>Even when both <em>radiuX</em> and <em>radiusY</em> are zero, the rounded rectangle is different from a rectangle., When stroked, the corners of the rounded rectangle are roundly joined, not mitered (square). </p>
    /// </remarks>
    /// <doc-id>dd368158</doc-id>
    /// <unmanaged>D2D1_ROUNDED_RECT</unmanaged>
    /// <unmanaged-short>D2D1_ROUNDED_RECT</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct RoundedRectangle
    {
        /// <summary>
        /// <dd> <p>The coordinates of the rectangle.</p> </dd>
        /// </summary>
        /// <doc-id>dd368158</doc-id>
        /// <unmanaged>rect</unmanaged>
        /// <unmanaged-short>rect</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawRectangleF Rect;
        /// <summary>
        /// <dd> <p>The x-radius for the quarter ellipse that is drawn to replace every corner of the rectangle.</p> </dd>
        /// </summary>
        /// <doc-id>dd368158</doc-id>
        /// <unmanaged>radiusX</unmanaged>
        /// <unmanaged-short>radiusX</unmanaged-short>
        public System.Single RadiusX;
        /// <summary>
        /// <dd> <p>The y-radius for the quarter ellipse that is drawn to replace every corner of the rectangle.</p> </dd>
        /// </summary>
        /// <doc-id>dd368158</doc-id>
        /// <unmanaged>radiusY</unmanaged>
        /// <unmanaged-short>radiusY</unmanaged-short>
        public System.Single RadiusY;
    }

    /// <summary>
    /// <p>Creates a color context from a simple color profile. It is only valid to use this with the Color Management Effect in 'Best' mode.</p>
    /// </summary>
    /// <doc-id>mt797808</doc-id>
    /// <unmanaged>D2D1_SIMPLE_COLOR_PROFILE</unmanaged>
    /// <unmanaged-short>D2D1_SIMPLE_COLOR_PROFILE</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct SimpleColorProfile
    {
        /// <summary>
        /// <dd>  <p>The simple color profile to create the color context from.</p> </dd>
        /// </summary>
        /// <doc-id>mt797808</doc-id>
        /// <unmanaged>redPrimary</unmanaged>
        /// <unmanaged-short>redPrimary</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 RedPrimary;
        /// <summary>
        /// <dd>  <p>The created color context.</p> </dd>
        /// </summary>
        /// <doc-id>mt797808</doc-id>
        /// <unmanaged>greenPrimary</unmanaged>
        /// <unmanaged-short>greenPrimary</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 GreenPrimary;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>mt797808</doc-id>
        /// <unmanaged>bluePrimary</unmanaged>
        /// <unmanaged-short>bluePrimary</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 BluePrimary;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>mt797808</doc-id>
        /// <unmanaged>whitePointXZ</unmanaged>
        /// <unmanaged-short>whitePointXZ</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 WhitePointXZ;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>mt797808</doc-id>
        /// <unmanaged>gamma</unmanaged>
        /// <unmanaged-short>gamma</unmanaged-short>
        public SharpDX.Direct2D1.Gamma1 Gamma;
    }

    /// <summary>
    /// <p> Describes the stroke that outlines a shape. </p>
    /// </summary>
    /// <remarks>
    /// <p>The following illustration shows different <em>dashOffset</em> values for the same custom dash style.</p><p></p>
    /// </remarks>
    /// <doc-id>dd368164</doc-id>
    /// <unmanaged>D2D1_STROKE_STYLE_PROPERTIES</unmanaged>
    /// <unmanaged-short>D2D1_STROKE_STYLE_PROPERTIES</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct StrokeStyleProperties
    {
        /// <summary>
        /// <dd> <p>The cap applied to the start of all the open figures in a stroked geometry.</p> </dd>
        /// </summary>
        /// <doc-id>dd368164</doc-id>
        /// <unmanaged>startCap</unmanaged>
        /// <unmanaged-short>startCap</unmanaged-short>
        public SharpDX.Direct2D1.CapStyle StartCap;
        /// <summary>
        /// <dd> <p>The cap applied to the end of all the open figures in a stroked geometry.</p> </dd>
        /// </summary>
        /// <doc-id>dd368164</doc-id>
        /// <unmanaged>endCap</unmanaged>
        /// <unmanaged-short>endCap</unmanaged-short>
        public SharpDX.Direct2D1.CapStyle EndCap;
        /// <summary>
        /// <dd> <p>The shape  at either end of each dash segment.</p> </dd>
        /// </summary>
        /// <doc-id>dd368164</doc-id>
        /// <unmanaged>dashCap</unmanaged>
        /// <unmanaged-short>dashCap</unmanaged-short>
        public SharpDX.Direct2D1.CapStyle DashCap;
        /// <summary>
        /// <dd> <p>A value that describes how segments are joined. This value is ignored for a vertex if the segment flags specify that the segment should have a smooth join. </p> </dd>
        /// </summary>
        /// <doc-id>dd368164</doc-id>
        /// <unmanaged>lineJoin</unmanaged>
        /// <unmanaged-short>lineJoin</unmanaged-short>
        public SharpDX.Direct2D1.LineJoin LineJoin;
        /// <summary>
        /// <dd> <p>The limit of the thickness of the join on a mitered corner. This value is always treated as though it is greater than or equal to 1.0f. </p> </dd>
        /// </summary>
        /// <doc-id>dd368164</doc-id>
        /// <unmanaged>miterLimit</unmanaged>
        /// <unmanaged-short>miterLimit</unmanaged-short>
        public System.Single MiterLimit;
        /// <summary>
        /// <dd> <p>A value that specifies whether the stroke has a dash pattern and, if so, the dash style. </p> </dd>
        /// </summary>
        /// <doc-id>dd368164</doc-id>
        /// <unmanaged>dashStyle</unmanaged>
        /// <unmanaged-short>dashStyle</unmanaged-short>
        public SharpDX.Direct2D1.DashStyle DashStyle;
        /// <summary>
        /// <dd> <p>A value that specifies an offset in the dash sequence.   A positive dash offset value  shifts the dash pattern, in units of  stroke width, toward the start of the stroked geometry.  A negative dash offset value  shifts the dash pattern, in units of  stroke width, toward the end of the stroked geometry.</p> </dd>
        /// </summary>
        /// <doc-id>dd368164</doc-id>
        /// <unmanaged>dashOffset</unmanaged>
        /// <unmanaged-short>dashOffset</unmanaged-short>
        public System.Single DashOffset;
    }

    /// <summary>
    /// <p>Describes the stroke that outlines a shape.</p>
    /// </summary>
    /// <doc-id>hh404328</doc-id>
    /// <unmanaged>D2D1_STROKE_STYLE_PROPERTIES1</unmanaged>
    /// <unmanaged-short>D2D1_STROKE_STYLE_PROPERTIES1</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct StrokeStyleProperties1
    {
        /// <summary>
        /// <dd> <p>The cap to use at the start of each open figure.</p> </dd>
        /// </summary>
        /// <doc-id>hh404328</doc-id>
        /// <unmanaged>startCap</unmanaged>
        /// <unmanaged-short>startCap</unmanaged-short>
        public SharpDX.Direct2D1.CapStyle StartCap;
        /// <summary>
        /// <dd> <p>The cap to use at the end of each open figure.</p> </dd>
        /// </summary>
        /// <doc-id>hh404328</doc-id>
        /// <unmanaged>endCap</unmanaged>
        /// <unmanaged-short>endCap</unmanaged-short>
        public SharpDX.Direct2D1.CapStyle EndCap;
        /// <summary>
        /// <dd> <p>The cap to use at the start and end of each dash.</p> </dd>
        /// </summary>
        /// <doc-id>hh404328</doc-id>
        /// <unmanaged>dashCap</unmanaged>
        /// <unmanaged-short>dashCap</unmanaged-short>
        public SharpDX.Direct2D1.CapStyle DashCap;
        /// <summary>
        /// <dd> <p>The line join to use.</p> </dd>
        /// </summary>
        /// <doc-id>hh404328</doc-id>
        /// <unmanaged>lineJoin</unmanaged>
        /// <unmanaged-short>lineJoin</unmanaged-short>
        public SharpDX.Direct2D1.LineJoin LineJoin;
        /// <summary>
        /// <dd> <p>The limit beyond which miters are either clamped or converted to bevels.</p> </dd>
        /// </summary>
        /// <doc-id>hh404328</doc-id>
        /// <unmanaged>miterLimit</unmanaged>
        /// <unmanaged-short>miterLimit</unmanaged-short>
        public System.Single MiterLimit;
        /// <summary>
        /// <dd> <p>The type of dash to use.</p> </dd>
        /// </summary>
        /// <doc-id>hh404328</doc-id>
        /// <unmanaged>dashStyle</unmanaged>
        /// <unmanaged-short>dashStyle</unmanaged-short>
        public SharpDX.Direct2D1.DashStyle DashStyle;
        /// <summary>
        /// <dd> <p>The location of the first dash, relative to the start of the figure. </p> </dd>
        /// </summary>
        /// <doc-id>hh404328</doc-id>
        /// <unmanaged>dashOffset</unmanaged>
        /// <unmanaged-short>dashOffset</unmanaged-short>
        public System.Single DashOffset;
        /// <summary>
        /// <dd> <p>The rule that determines what render target properties affect the nib of the stroke.</p> </dd>
        /// </summary>
        /// <doc-id>hh404328</doc-id>
        /// <unmanaged>transformType</unmanaged>
        /// <unmanaged-short>transformType</unmanaged-short>
        public SharpDX.Direct2D1.StrokeTransformType TransformType;
    }

    /// <summary>
    /// <p>A 3D vector that consists of three single-precision floating-point values (x, y, z).</p>
    /// </summary>
    /// <doc-id>jj219219</doc-id>
    /// <unmanaged>D2D1_SVG_LENGTH</unmanaged>
    /// <unmanaged-short>D2D1_SVG_LENGTH</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct SvgLength
    {
        /// <summary>
        /// <dd> <p>The x value of the vector.</p> </dd>
        /// </summary>
        /// <doc-id>jj219219</doc-id>
        /// <unmanaged>value</unmanaged>
        /// <unmanaged-short>value</unmanaged-short>
        public System.Single Value;
        /// <summary>
        /// <dd> <p>The y value of the vector.</p> </dd>
        /// </summary>
        /// <doc-id>jj219219</doc-id>
        /// <unmanaged>units</unmanaged>
        /// <unmanaged-short>units</unmanaged-short>
        public SharpDX.Direct2D1.SvgLengthUnits Units;
    }

    /// <summary>
    /// <p>A description of a single element to the vertex layout.</p>
    /// </summary>
    /// <remarks>
    /// <p>This structure is a subset of <strong><see cref = "SharpDX.Direct3D11.InputElement"/></strong> that omits fields required to define a vertex layout.</p><p>If the <strong>D2D1_APPEND_ALIGNED_ELEMENT</strong> constant is used for  <strong>alignedByteOffset</strong>, the elements will be packed contiguously for convenience.
    /// </p>
    /// </remarks>
    /// <doc-id>hh404312</doc-id>
    /// <unmanaged>D2D1_SVG_PRESERVE_ASPECT_RATIO</unmanaged>
    /// <unmanaged-short>D2D1_SVG_PRESERVE_ASPECT_RATIO</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct SvgPreserveAspectRatio
    {
        /// <summary>
        /// <dd> <p>The HLSL semantic associated with this element in a shader input-signature.</p> </dd>
        /// </summary>
        /// <doc-id>hh404312</doc-id>
        /// <unmanaged>defer</unmanaged>
        /// <unmanaged-short>defer</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool Defer;
        /// <summary>
        /// <dd> <p>The semantic index for the element. A semantic index modifies a semantic, with an integer index number. A semantic index is only needed in a case where there is more than one element with the same semantic. For example, a 4x4 matrix would have four components each with the semantic name matrix; however, each of the four components would have different semantic indices (0, 1, 2, and 3).</p> </dd>
        /// </summary>
        /// <doc-id>hh404312</doc-id>
        /// <unmanaged>align</unmanaged>
        /// <unmanaged-short>align</unmanaged-short>
        public SharpDX.Direct2D1.SvgAspectAlign Align;
        /// <summary>
        /// <dd> <p>The data type of the element data.</p> </dd>
        /// </summary>
        /// <doc-id>hh404312</doc-id>
        /// <unmanaged>meetOrSlice</unmanaged>
        /// <unmanaged-short>meetOrSlice</unmanaged-short>
        public SharpDX.Direct2D1.SvgAspectScaling MeetOrSlice;
    }

    /// <summary>
    /// <p>A 3D vector that consists of three single-precision floating-point values (x, y, z).</p>
    /// </summary>
    /// <doc-id>jj219219</doc-id>
    /// <unmanaged>D2D1_SVG_VIEWBOX</unmanaged>
    /// <unmanaged-short>D2D1_SVG_VIEWBOX</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct SvgViewBox
    {
        /// <summary>
        /// <dd> <p>The x value of the vector.</p> </dd>
        /// </summary>
        /// <doc-id>jj219219</doc-id>
        /// <unmanaged>x</unmanaged>
        /// <unmanaged-short>x</unmanaged-short>
        public System.Single X;
        /// <summary>
        /// <dd> <p>The y value of the vector.</p> </dd>
        /// </summary>
        /// <doc-id>jj219219</doc-id>
        /// <unmanaged>y</unmanaged>
        /// <unmanaged-short>y</unmanaged-short>
        public System.Single Y;
        /// <summary>
        /// <dd> <p>The z value of the vector.</p> </dd>
        /// </summary>
        /// <doc-id>jj219219</doc-id>
        /// <unmanaged>width</unmanaged>
        /// <unmanaged-short>width</unmanaged-short>
        public System.Single Width;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>jj219219</doc-id>
        /// <unmanaged>height</unmanaged>
        /// <unmanaged-short>height</unmanaged-short>
        public System.Single Height;
    }

    /// <summary>
    /// <p>Properties of a transformed image source.</p>
    /// </summary>
    /// <doc-id>dn934350</doc-id>
    /// <unmanaged>D2D1_TRANSFORMED_IMAGE_SOURCE_PROPERTIES</unmanaged>
    /// <unmanaged-short>D2D1_TRANSFORMED_IMAGE_SOURCE_PROPERTIES</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct TransformedImageSourceProperties
    {
        /// <summary>
        /// <dd> <p>The orientation at which the image source is drawn.</p> </dd>
        /// </summary>
        /// <doc-id>dn934350</doc-id>
        /// <unmanaged>orientation</unmanaged>
        /// <unmanaged-short>orientation</unmanaged-short>
        public SharpDX.Direct2D1.Orientation Orientation;
        /// <summary>
        /// <dd> <p>The horizontal scale factor at which the image source is drawn.</p> </dd>
        /// </summary>
        /// <doc-id>dn934350</doc-id>
        /// <unmanaged>scaleX</unmanaged>
        /// <unmanaged-short>scaleX</unmanaged-short>
        public System.Single ScaleX;
        /// <summary>
        /// <dd> <p>The vertical scale factor at which the image source is drawn.</p> </dd>
        /// </summary>
        /// <doc-id>dn934350</doc-id>
        /// <unmanaged>scaleY</unmanaged>
        /// <unmanaged-short>scaleY</unmanaged-short>
        public System.Single ScaleY;
        /// <summary>
        /// <dd> <p>The interpolation mode used when the image source is drawn.  This is ignored if the image source is drawn using the DrawImage method, or using an image brush.</p> </dd>
        /// </summary>
        /// <doc-id>dn934350</doc-id>
        /// <unmanaged>interpolationMode</unmanaged>
        /// <unmanaged-short>interpolationMode</unmanaged-short>
        public SharpDX.Direct2D1.InterpolationMode InterpolationMode;
        /// <summary>
        /// <dd> <p>Image sourc option flags.</p> </dd>
        /// </summary>
        /// <doc-id>dn934350</doc-id>
        /// <unmanaged>options</unmanaged>
        /// <unmanaged-short>options</unmanaged-short>
        public SharpDX.Direct2D1.TransformedImageSourceOptions Options;
    }

    /// <summary>
    /// <p>Contains the three vertices that describe a triangle.</p>
    /// </summary>
    /// <doc-id>dd368172</doc-id>
    /// <unmanaged>D2D1_TRIANGLE</unmanaged>
    /// <unmanaged-short>D2D1_TRIANGLE</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct Triangle
    {
        /// <summary>
        /// <dd> <p>The first vertex of a triangle.</p> </dd>
        /// </summary>
        /// <doc-id>dd368172</doc-id>
        /// <unmanaged>point1</unmanaged>
        /// <unmanaged-short>point1</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 Point1;
        /// <summary>
        /// <dd> <p>The second vertex of a triangle.</p> </dd>
        /// </summary>
        /// <doc-id>dd368172</doc-id>
        /// <unmanaged>point2</unmanaged>
        /// <unmanaged-short>point2</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 Point2;
        /// <summary>
        /// <dd> <p>The third vertex of a triangle.</p> </dd>
        /// </summary>
        /// <doc-id>dd368172</doc-id>
        /// <unmanaged>point3</unmanaged>
        /// <unmanaged-short>point3</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 Point3;
    }

    /// <summary>
    /// <p>Defines the properties of a vertex buffer that are standard for all vertex shader definitions.</p>
    /// </summary>
    /// <remarks>
    /// <p>If <strong>usage</strong> is dynamic, the system might return a system memory buffer and copy these vertices into the rendering vertex buffer for each element.</p><p>If the initialization data is not specified, the buffer will be uninitialized.</p>
    /// </remarks>
    /// <doc-id>hh404330</doc-id>
    /// <unmanaged>D2D1_VERTEX_BUFFER_PROPERTIES</unmanaged>
    /// <unmanaged-short>D2D1_VERTEX_BUFFER_PROPERTIES</unmanaged-short>
    public partial class VertexBufferProperties
    {
        /// <summary>
        /// <dd> <p>The number of inputs to the vertex shader.</p> </dd>
        /// </summary>
        /// <doc-id>hh404330</doc-id>
        /// <unmanaged>inputCount</unmanaged>
        /// <unmanaged-short>inputCount</unmanaged-short>
        public System.Int32 InputCount;
        /// <summary>
        /// <dd> <p>Indicates how frequently the vertex buffer is likely to be updated.</p> </dd>
        /// </summary>
        /// <doc-id>hh404330</doc-id>
        /// <unmanaged>usage</unmanaged>
        /// <unmanaged-short>usage</unmanaged-short>
        public SharpDX.Direct2D1.VertexUsage Usage;
        /// <summary>
        /// <dd> <p>The initial contents of the vertex buffer.</p> </dd>
        /// </summary>
        /// <doc-id>hh404330</doc-id>
        /// <unmanaged>data</unmanaged>
        /// <unmanaged-short>data</unmanaged-short>
        internal System.IntPtr DataPointer;
        /// <summary>
        /// <dd> <p>The size of the vertex buffer, in bytes.</p> </dd>
        /// </summary>
        /// <doc-id>hh404330</doc-id>
        /// <unmanaged>byteWidth</unmanaged>
        /// <unmanaged-short>byteWidth</unmanaged-short>
        internal System.Int32 SizeInBytes;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.Int32 InputCount;
            public SharpDX.Direct2D1.VertexUsage Usage;
            public System.IntPtr DataPointer;
            public System.Int32 SizeInBytes;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            InputCount = @ref.InputCount;
            Usage = @ref.Usage;
            DataPointer = @ref.DataPointer;
            SizeInBytes = @ref.SizeInBytes;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.InputCount = InputCount;
            @ref.Usage = Usage;
            @ref.DataPointer = DataPointer;
            @ref.SizeInBytes = SizeInBytes;
        }
    }

    /// <summary>
    /// <p>Defines a range of vertices that are used when rendering less than the full contents of a vertex buffer.</p>
    /// </summary>
    /// <doc-id>hh404335</doc-id>
    /// <unmanaged>D2D1_VERTEX_RANGE</unmanaged>
    /// <unmanaged-short>D2D1_VERTEX_RANGE</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct VertexRange
    {
        /// <summary>
        /// <dd> <p>The first vertex in the range to process.</p> </dd>
        /// </summary>
        /// <doc-id>hh404335</doc-id>
        /// <unmanaged>startVertex</unmanaged>
        /// <unmanaged-short>startVertex</unmanaged-short>
        public System.Int32 StartVertex;
        /// <summary>
        /// <dd> <p>The number of vertices to use.</p> </dd>
        /// </summary>
        /// <doc-id>hh404335</doc-id>
        /// <unmanaged>vertexCount</unmanaged>
        /// <unmanaged-short>vertexCount</unmanaged-short>
        public System.Int32 VertexCount;
    }
}
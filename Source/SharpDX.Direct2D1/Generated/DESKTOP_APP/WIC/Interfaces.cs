// <auto-generated/>

namespace SharpDX.WIC
{
    [System.Runtime.InteropServices.GuidAttribute("00000121-a8f2-4877-ba0a-fd2b6645fb94")]
    public partial class Bitmap : SharpDX.WIC.BitmapSource
    {
        public Bitmap(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Bitmap(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Bitmap(nativePtr);
        /// <summary>
        /// <p>Provides access for palette modifications.</p>
        /// </summary>
        /// <doc-id>ee690189</doc-id>
        /// <unmanaged>SetPalette</unmanaged>
        /// <unmanaged-short>SetPalette</unmanaged-short>
        public SharpDX.WIC.Palette Palette
        {
            set => SetPalette(value);
        }

        /// <summary>
        /// <p>Provides access to a rectangular area of the bitmap.</p>
        /// </summary>
        /// <param name = "rcLockRef"><dd>  <p>The rectangle to be accessed.</p> </dd></param>
        /// <param name = "flags"><dd>  <p>The access mode you wish to obtain for the lock. This is a bitwise combination of <strong><see cref = "SharpDX.WIC.BitmapLockFlags"/></strong> for read, write, or read and write access.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>WICBitmapLockRead</strong></dt> </dl> </td><td> <p>The read access lock.</p> </td></tr> <tr><td><dl> <dt><strong>WICBitmapLockWrite</strong></dt> </dl> </td><td> <p>The write access lock.</p> </td></tr> </table> <p>?</p> </dd></param>
        /// <returns><dd>  <p>A reference that receives the locked memory location.</p> </dd></returns>
        /// <remarks>
        /// <p>Locks are exclusive for writing but can be shared for reading. You cannot call <strong>CopyPixels</strong> while the <strong><see cref = "SharpDX.WIC.Bitmap"/></strong> is locked for writing. Doing so will return an error, since locks are exclusive.</p>
        /// </remarks>
        /// <doc-id>ee690187</doc-id>
        /// <unmanaged>HRESULT IWICBitmap::Lock([In] const WICRect* prcLock,[In] DWORD flags,[Out] IWICBitmapLock** ppILock)</unmanaged>
        /// <unmanaged-short>IWICBitmap::Lock</unmanaged-short>
        internal unsafe SharpDX.WIC.BitmapLock Lock(System.IntPtr rcLockRef, SharpDX.WIC.BitmapLockFlags flags)
        {
            SharpDX.WIC.BitmapLock lockOut;
            System.IntPtr lockOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)rcLockRef, unchecked ((System.Int32)flags), &lockOut_, (*(void ***)this._nativePointer)[8]);
            if (lockOut_ != System.IntPtr.Zero)
                lockOut = new SharpDX.WIC.BitmapLock(lockOut_);
            else
                lockOut = null;
            __result__.CheckError();
            return lockOut;
        }

        /// <summary>
        /// <p>Provides access for palette modifications.</p>
        /// </summary>
        /// <param name = "paletteRef"><dd>  <p>The palette to use for conversion.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690189</doc-id>
        /// <unmanaged>HRESULT IWICBitmap::SetPalette([In, Optional] IWICPalette* pIPalette)</unmanaged>
        /// <unmanaged-short>IWICBitmap::SetPalette</unmanaged-short>
        internal unsafe void SetPalette(SharpDX.WIC.Palette paletteRef)
        {
            System.IntPtr paletteRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            paletteRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.Palette>(paletteRef);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)paletteRef_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the physical resolution of the image.</p>
        /// </summary>
        /// <param name = "dpiX"><dd>  <p>The horizontal resolution.</p> </dd></param>
        /// <param name = "dpiY"><dd>  <p>The vertical resolution.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p> This method has no effect on the actual pixels or samples stored in the bitmap.  Instead the interpretation of the sampling rate is modified.  This means that a 96 DPI image which is 96 pixels wide is one inch.  If the physical resolution is modified to 48 DPI, then the bitmap is considered to be 2 inches wide but has the same number of pixels.   If the resolution is less than <strong>REAL_EPSILON</strong> (1.192092896e-07F) the error code <strong><see cref = "InvalidParameter"/></strong> is returned.</p>
        /// </remarks>
        /// <doc-id>ee690191</doc-id>
        /// <unmanaged>HRESULT IWICBitmap::SetResolution([In] double dpiX,[In] double dpiY)</unmanaged>
        /// <unmanaged-short>IWICBitmap::SetResolution</unmanaged-short>
        public unsafe void SetResolution(System.Double dpiX, System.Double dpiY)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, dpiX, dpiY, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("E4FBCF03-223D-4e81-9333-D635556DD1B5")]
    public partial class BitmapClipper : SharpDX.WIC.BitmapSource
    {
        public BitmapClipper(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator BitmapClipper(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new BitmapClipper(nativePtr);
        /// <summary>
        /// <p>Initializes the bitmap clipper with the provided parameters.</p>
        /// </summary>
        /// <param name = "sourceRef"><dd>  <p>he input bitmap source.</p> </dd></param>
        /// <param name = "rectangleRef"><dd>  <p>The rectangle of the bitmap source to clip.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee719677</doc-id>
        /// <unmanaged>HRESULT IWICBitmapClipper::Initialize([In, Optional] IWICBitmapSource* pISource,[In] const WICRect* prc)</unmanaged>
        /// <unmanaged-short>IWICBitmapClipper::Initialize</unmanaged-short>
        internal unsafe void Initialize(SharpDX.WIC.BitmapSource sourceRef, System.IntPtr rectangleRef)
        {
            System.IntPtr sourceRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            sourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.BitmapSource>(sourceRef);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)sourceRef_, (void *)rectangleRef, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("E87A44C4-B76E-4c47-8B09-298EB12A2714")]
    public partial class BitmapCodecInfo : SharpDX.WIC.ComponentInfo
    {
        public BitmapCodecInfo(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator BitmapCodecInfo(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new BitmapCodecInfo(nativePtr);
        /// <summary>
        /// <p>Proxy function for the <strong>GetContainerFormat</strong> method.</p>
        /// </summary>
        /// <doc-id>ee719689</doc-id>
        /// <unmanaged>GetContainerFormat</unmanaged>
        /// <unmanaged-short>GetContainerFormat</unmanaged-short>
        public System.Guid ContainerFormat
        {
            get
            {
                GetContainerFormat(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Proxy function for the <strong>DoesSupportAnimation</strong> method.</p>
        /// </summary>
        /// <doc-id>ee719681</doc-id>
        /// <unmanaged>DoesSupportAnimation</unmanaged>
        /// <unmanaged-short>DoesSupportAnimation</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsAnimationSupported
        {
            get
            {
                IsAnimationSupported_(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Retrieves a value indicating whether the codec supports chromakeys.</p>
        /// </summary>
        /// <doc-id>ee719682</doc-id>
        /// <unmanaged>DoesSupportChromakey</unmanaged>
        /// <unmanaged-short>DoesSupportChromakey</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsChromakeySupported
        {
            get
            {
                IsChromakeySupported_(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Retrieves a value indicating whether the codec supports lossless formats.</p>
        /// </summary>
        /// <doc-id>ee719683</doc-id>
        /// <unmanaged>DoesSupportLossless</unmanaged>
        /// <unmanaged-short>DoesSupportLossless</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsLosslessSupported
        {
            get
            {
                IsLosslessSupported_(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Retrieves a value indicating whether the codec supports multi frame images.</p>
        /// </summary>
        /// <doc-id>ee719685</doc-id>
        /// <unmanaged>DoesSupportMultiframe</unmanaged>
        /// <unmanaged-short>DoesSupportMultiframe</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsMultiframeSupported
        {
            get
            {
                IsMultiframeSupported_(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Proxy function for the <strong>GetContainerFormat</strong> method.</p>
        /// </summary>
        /// <param name = "guidContainerFormatRef">No documentation.</param>
        /// <returns><p>If this function succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee719689</doc-id>
        /// <unmanaged>HRESULT IWICBitmapCodecInfo::GetContainerFormat([Out] GUID* pguidContainerFormat)</unmanaged>
        /// <unmanaged-short>IWICBitmapCodecInfo::GetContainerFormat</unmanaged-short>
        internal unsafe void GetContainerFormat(out System.Guid guidContainerFormatRef)
        {
            guidContainerFormatRef = default (System.Guid);
            SharpDX.Result __result__;
            fixed (void *guidContainerFormatRef_ = &guidContainerFormatRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, guidContainerFormatRef_, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the pixel formats the codec supports.</p>
        /// </summary>
        /// <param name = "formats"><dd>  <p>The size of the <em>pguidPixelFormats</em> array. Use <code>0</code> on first call to determine the needed array size.</p> </dd></param>
        /// <param name = "guidPixelFormatsRef"><dd>  <p>Receives the supported pixel formats. Use <code><c>null</c></code> on first call to determine needed array size.</p> </dd></param>
        /// <param name = "actualRef"><dd>  <p>The array size needed to retrieve all supported pixel formats.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p> The usage pattern for this method is a two call process. The first call retrieves the array size needed to retrieve all the supported pixel formats by calling it with <em>cFormats</em> set to <code>0</code> and <em>pguidPixelFormats</em> set to <code><c>null</c></code>. This call sets <em>pcActual</em> to the array size needed. Once the needed array size is determined, a second <strong>GetPixelFormats</strong> call with <em>pguidPixelFormats</em> set to an array of the appropriate size will retrieve the pixel formats. </p>
        /// </remarks>
        /// <doc-id>ee690082</doc-id>
        /// <unmanaged>HRESULT IWICBitmapCodecInfo::GetPixelFormats([In] unsigned int cFormats,[In, Buffer] GUID* pguidPixelFormats,[Out] unsigned int* pcActual)</unmanaged>
        /// <unmanaged-short>IWICBitmapCodecInfo::GetPixelFormats</unmanaged-short>
        internal unsafe void GetPixelFormats(System.Int32 formats, System.Guid[] guidPixelFormatsRef, out System.Int32 actualRef)
        {
            SharpDX.Result __result__;
            fixed (void *actualRef_ = &actualRef)
                fixed (void *guidPixelFormatsRef_ = guidPixelFormatsRef)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, formats, guidPixelFormatsRef_, actualRef_, (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the color manangement version number the codec supports.</p>
        /// </summary>
        /// <param name = "cchColorManagementVersion"><dd>  <p>The size of the version buffer. Use <code>0</code> on first call to determine needed buffer size.</p> </dd></param>
        /// <param name = "colorManagementVersion"><dd>  <p>Receives the color management version number. Use <code><c>null</c></code> on first call to determine needed buffer size.</p> </dd></param>
        /// <param name = "cchActualRef"><dd>  <p>The actual buffer size needed to retrieve the full color management version number.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p> The usage pattern for this method is a two call process. The first call retrieves the buffer size needed to retrieve the full color management version number by calling it with <em>cchColorManagementVersion</em> set to <code>0</code> and <em>wzColorManagementVersion</em> set to <code><c>null</c></code>. This call sets <em>pcchActual</em> to the buffer size needed. Once the needed buffer size is determined, a second <strong>GetColorManagementVersion</strong> call with <em>cchColorManagementVersion</em> set to the buffer size and <em>wzColorManagementVersion</em> set to a buffer of the appropriate size will retrieve the pixel formats. </p>
        /// </remarks>
        /// <doc-id>ee719687</doc-id>
        /// <unmanaged>HRESULT IWICBitmapCodecInfo::GetColorManagementVersion([In] unsigned int cchColorManagementVersion,[In] wchar_t* wzColorManagementVersion,[Out] unsigned int* pcchActual)</unmanaged>
        /// <unmanaged-short>IWICBitmapCodecInfo::GetColorManagementVersion</unmanaged-short>
        internal unsafe void GetColorManagementVersion(System.Int32 cchColorManagementVersion, System.IntPtr colorManagementVersion, out System.Int32 cchActualRef)
        {
            SharpDX.Result __result__;
            fixed (void *cchActualRef_ = &cchActualRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, cchColorManagementVersion, (void *)colorManagementVersion, cchActualRef_, (*(void ***)this._nativePointer)[13]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the name of the device manufacture associated with the codec.</p>
        /// </summary>
        /// <param name = "cchDeviceManufacturer"><dd>  <p>The size of the device manufacture's name. Use <code>0</code> on first call to determine needed buffer size.</p> </dd></param>
        /// <param name = "deviceManufacturer"><dd>  <p>Receives the device manufacture's name. Use <code><c>null</c></code> on first call to determine needed buffer size.</p> </dd></param>
        /// <param name = "cchActualRef"><dd>  <p>The actual buffer size needed to retrieve the device manufacture's name.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p> The usage pattern for this method is a two call process. The first call retrieves the buffer size needed to retrieve the full color management version number by calling it with <em>cchDeviceManufacturer</em> set to <code>0</code> and <em>wzDeviceManufacturer</em> set to <code><c>null</c></code>. This call sets <em>pcchActual</em> to the buffer size needed. Once the needed buffer size is determined, a second <strong>GetDeviceManufacturer</strong> call with <em>cchDeviceManufacturer</em> set to the buffer size and <em>wzDeviceManufacturer</em> set to a buffer of the appropriate size will retrieve the pixel formats. </p>
        /// </remarks>
        /// <doc-id>ee719690</doc-id>
        /// <unmanaged>HRESULT IWICBitmapCodecInfo::GetDeviceManufacturer([In] unsigned int cchDeviceManufacturer,[In] wchar_t* wzDeviceManufacturer,[Out] unsigned int* pcchActual)</unmanaged>
        /// <unmanaged-short>IWICBitmapCodecInfo::GetDeviceManufacturer</unmanaged-short>
        internal unsafe void GetDeviceManufacturer(System.Int32 cchDeviceManufacturer, System.IntPtr deviceManufacturer, out System.Int32 cchActualRef)
        {
            SharpDX.Result __result__;
            fixed (void *cchActualRef_ = &cchActualRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, cchDeviceManufacturer, (void *)deviceManufacturer, cchActualRef_, (*(void ***)this._nativePointer)[14]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves a comma delimited list of device models associated with the codec.</p>
        /// </summary>
        /// <param name = "cchDeviceModels"><dd>  <p>The size of the device models buffer. Use <code>0</code> on first call to determine needed buffer size.</p> </dd></param>
        /// <param name = "deviceModels"><dd>  <p>Receives a comma delimited list of device model names associated with the codec. Use <code><c>null</c></code> on first call to determine needed buffer size.</p> </dd></param>
        /// <param name = "cchActualRef"><dd>  <p>The actual buffer size needed to retrieve all of the device model names.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p> The usage pattern for this method is a two call process. The first call retrieves the buffer size needed to retrieve the full color management version number by calling it with <em>cchDeviceModels</em> set to <code>0</code> and <em>wzDeviceModels</em> set to <code><c>null</c></code>. This call sets <em>pcchActual</em> to the buffer size needed. Once the needed buffer size is determined, a second <strong>GetDeviceModels</strong> call with <em>cchDeviceModels</em> set to the buffer size and <em>wzDeviceModels</em> set to a buffer of the appropriate size will retrieve the pixel formats. </p>
        /// </remarks>
        /// <doc-id>ee719692</doc-id>
        /// <unmanaged>HRESULT IWICBitmapCodecInfo::GetDeviceModels([In] unsigned int cchDeviceModels,[In] wchar_t* wzDeviceModels,[Out] unsigned int* pcchActual)</unmanaged>
        /// <unmanaged-short>IWICBitmapCodecInfo::GetDeviceModels</unmanaged-short>
        internal unsafe void GetDeviceModels(System.Int32 cchDeviceModels, System.IntPtr deviceModels, out System.Int32 cchActualRef)
        {
            SharpDX.Result __result__;
            fixed (void *cchActualRef_ = &cchActualRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, cchDeviceModels, (void *)deviceModels, cchActualRef_, (*(void ***)this._nativePointer)[15]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Proxy function for the <strong>GetMimeTypes</strong> method.</p>
        /// </summary>
        /// <param name = "cchMimeTypes">No documentation.</param>
        /// <param name = "mimeTypes">No documentation.</param>
        /// <param name = "cchActualRef">No documentation.</param>
        /// <returns><p>If this function succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee719697</doc-id>
        /// <unmanaged>HRESULT IWICBitmapCodecInfo::GetMimeTypes([In] unsigned int cchMimeTypes,[In] wchar_t* wzMimeTypes,[Out] unsigned int* pcchActual)</unmanaged>
        /// <unmanaged-short>IWICBitmapCodecInfo::GetMimeTypes</unmanaged-short>
        internal unsafe void GetMimeTypes(System.Int32 cchMimeTypes, System.IntPtr mimeTypes, out System.Int32 cchActualRef)
        {
            SharpDX.Result __result__;
            fixed (void *cchActualRef_ = &cchActualRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, cchMimeTypes, (void *)mimeTypes, cchActualRef_, (*(void ***)this._nativePointer)[16]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves a comma delimited list of the file name extensions associated with the codec.</p>
        /// </summary>
        /// <param name = "cchFileExtensions"><dd>  <p>The size of the file name extension buffer. Use <code>0</code> on first call to determine needed buffer size.</p> </dd></param>
        /// <param name = "fileExtensions"><dd>  <p>Receives a comma delimited list  of file name extensions associated with the codec. Use <code><c>null</c></code> on first call to determine needed buffer size.</p> </dd></param>
        /// <param name = "cchActualRef"><dd>  <p>The actual buffer size needed to retrieve all file name extensions associated with the codec. </p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The default extension for an image encoder is the first item in the list of returned extensions.</p><p> The usage pattern for this method is a two call process. The first call retrieves the buffer size needed to retrieve the full color management version number by calling it with <em>cchFileExtensions</em> set to <code>0</code> and <em>wzFileExtensions</em> set to <code><c>null</c></code>. This call sets <em>pcchActual</em> to the buffer size needed. Once the needed buffer size is determined, a second <strong>GetFileExtensions</strong> call with <em>cchFileExtensions</em> set to the buffer size and <em>wzFileExtensions</em> set to a buffer of the appropriate size will retrieve the pixel formats. </p>
        /// </remarks>
        /// <doc-id>ee719694</doc-id>
        /// <unmanaged>HRESULT IWICBitmapCodecInfo::GetFileExtensions([In] unsigned int cchFileExtensions,[In] wchar_t* wzFileExtensions,[Out] unsigned int* pcchActual)</unmanaged>
        /// <unmanaged-short>IWICBitmapCodecInfo::GetFileExtensions</unmanaged-short>
        internal unsafe void GetFileExtensions(System.Int32 cchFileExtensions, System.IntPtr fileExtensions, out System.Int32 cchActualRef)
        {
            SharpDX.Result __result__;
            fixed (void *cchActualRef_ = &cchActualRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, cchFileExtensions, (void *)fileExtensions, cchActualRef_, (*(void ***)this._nativePointer)[17]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Proxy function for the <strong>DoesSupportAnimation</strong> method.</p>
        /// </summary>
        /// <param name = "fSupportAnimationRef">No documentation.</param>
        /// <returns><p>If this function succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee719681</doc-id>
        /// <unmanaged>HRESULT IWICBitmapCodecInfo::DoesSupportAnimation([Out] BOOL* pfSupportAnimation)</unmanaged>
        /// <unmanaged-short>IWICBitmapCodecInfo::DoesSupportAnimation</unmanaged-short>
        internal unsafe void IsAnimationSupported_(out SharpDX.Mathematics.Interop.RawBool fSupportAnimationRef)
        {
            fSupportAnimationRef = default (SharpDX.Mathematics.Interop.RawBool);
            SharpDX.Result __result__;
            fixed (void *fSupportAnimationRef_ = &fSupportAnimationRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, fSupportAnimationRef_, (*(void ***)this._nativePointer)[18]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves a value indicating whether the codec supports chromakeys.</p>
        /// </summary>
        /// <param name = "fSupportChromakeyRef"><dd>  <p>Receives <strong>TRUE</strong> if the codec supports chromakeys; otherwise, <strong><see cref = "SharpDX.Result.False"/></strong>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee719682</doc-id>
        /// <unmanaged>HRESULT IWICBitmapCodecInfo::DoesSupportChromakey([Out] BOOL* pfSupportChromakey)</unmanaged>
        /// <unmanaged-short>IWICBitmapCodecInfo::DoesSupportChromakey</unmanaged-short>
        internal unsafe void IsChromakeySupported_(out SharpDX.Mathematics.Interop.RawBool fSupportChromakeyRef)
        {
            fSupportChromakeyRef = default (SharpDX.Mathematics.Interop.RawBool);
            SharpDX.Result __result__;
            fixed (void *fSupportChromakeyRef_ = &fSupportChromakeyRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, fSupportChromakeyRef_, (*(void ***)this._nativePointer)[19]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves a value indicating whether the codec supports lossless formats.</p>
        /// </summary>
        /// <param name = "fSupportLosslessRef"><dd>  <p>Receives <strong>TRUE</strong> if the codec supports lossless formats; otherwise, <strong><see cref = "SharpDX.Result.False"/></strong>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee719683</doc-id>
        /// <unmanaged>HRESULT IWICBitmapCodecInfo::DoesSupportLossless([Out] BOOL* pfSupportLossless)</unmanaged>
        /// <unmanaged-short>IWICBitmapCodecInfo::DoesSupportLossless</unmanaged-short>
        internal unsafe void IsLosslessSupported_(out SharpDX.Mathematics.Interop.RawBool fSupportLosslessRef)
        {
            fSupportLosslessRef = default (SharpDX.Mathematics.Interop.RawBool);
            SharpDX.Result __result__;
            fixed (void *fSupportLosslessRef_ = &fSupportLosslessRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, fSupportLosslessRef_, (*(void ***)this._nativePointer)[20]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves a value indicating whether the codec supports multi frame images.</p>
        /// </summary>
        /// <param name = "fSupportMultiframeRef"><dd>  <p>Receives <strong>TRUE</strong> if the codec supports multi frame images; otherwise, <strong><see cref = "SharpDX.Result.False"/></strong>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee719685</doc-id>
        /// <unmanaged>HRESULT IWICBitmapCodecInfo::DoesSupportMultiframe([Out] BOOL* pfSupportMultiframe)</unmanaged>
        /// <unmanaged-short>IWICBitmapCodecInfo::DoesSupportMultiframe</unmanaged-short>
        internal unsafe void IsMultiframeSupported_(out SharpDX.Mathematics.Interop.RawBool fSupportMultiframeRef)
        {
            fSupportMultiframeRef = default (SharpDX.Mathematics.Interop.RawBool);
            SharpDX.Result __result__;
            fixed (void *fSupportMultiframeRef_ = &fSupportMultiframeRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, fSupportMultiframeRef_, (*(void ***)this._nativePointer)[21]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves a value indicating whether the given mime type matches the mime type of the codec.</p>
        /// </summary>
        /// <param name = "mimeType"><dd>  <p>The mime type to compare.</p> </dd></param>
        /// <returns><dd>  <p>Receives <strong>TRUE</strong> if the mime types match; otherwise, <strong><see cref = "SharpDX.Result.False"/></strong>.</p> </dd></returns>
        /// <remarks>
        /// <strong>Note</strong>??The Windows provided codecs do not implement this method and return E_NOTIMPL.?
        /// </remarks>
        /// <doc-id>ee690083</doc-id>
        /// <unmanaged>HRESULT IWICBitmapCodecInfo::MatchesMimeType([In] const wchar_t* wzMimeType,[Out] BOOL* pfMatches)</unmanaged>
        /// <unmanaged-short>IWICBitmapCodecInfo::MatchesMimeType</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool MatchesMimeType(System.String mimeType)
        {
            SharpDX.Mathematics.Interop.RawBool fMatchesRef;
            SharpDX.Result __result__;
            fixed (char *mimeType_ = mimeType)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)mimeType_, &fMatchesRef, (*(void ***)this._nativePointer)[22]);
            __result__.CheckError();
            return fMatchesRef;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("64C1024E-C3CF-4462-8078-88C2B11C46D9")]
    internal partial class BitmapCodecProgressNotification : SharpDX.ComObject
    {
        public BitmapCodecProgressNotification(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator BitmapCodecProgressNotification(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new BitmapCodecProgressNotification(nativePtr);
        /// <summary>
        /// <p>Registers a progress notification callback function.</p>
        /// </summary>
        /// <param name = "fnProgressNotificationRef"><dd>  <p>A function reference to the application defined progress notification callback function. See <strong>ProgressNotificationCallback</strong> for the callback signature.</p> </dd></param>
        /// <param name = "vDataRef"><dd>  <p>A reference to component data for the callback method.</p> </dd></param>
        /// <param name = "progressFlags"><dd>  <p>The <strong><see cref = "SharpDX.WIC.ProgressOperation"/></strong> and <strong><see cref = "SharpDX.WIC.ProgressNotification"/></strong> flags to use for progress notification.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Applications can only register a single callback. Subsequent registration calls will replace the previously registered callback. To unregister a callback, pass in <strong><c>null</c></strong> or register a new callback function.</p><p> Progress is reported in an increasing order between 0.0 and 1.0.  If <em>dwProgressFlags</em> includes <strong>WICProgressNotificationBegin</strong>, the callback is guaranteed to be called with progress 0.0. If <em>dwProgressFlags</em> includes <strong>WICProgressNotificationEnd</strong>, the callback is guaranteed to be called with progress 1.0. </p><p><strong>WICProgressNotificationFrequent</strong> increases the frequency in which the callback is called. If an operation is expected to take more than 30 seconds, <strong>WICProgressNotificationFrequent</strong> should be added to <em>dwProgressFlags</em>. </p>
        /// </remarks>
        /// <doc-id>ee690085</doc-id>
        /// <unmanaged>HRESULT IWICBitmapCodecProgressNotification::RegisterProgressNotification([In, Optional] __function__stdcall* pfnProgressNotification,[In, Optional] void* pvData,[In] DWORD dwProgressFlags)</unmanaged>
        /// <unmanaged-short>IWICBitmapCodecProgressNotification::RegisterProgressNotification</unmanaged-short>
        internal unsafe void RegisterProgressNotification(SharpDX.FunctionCallback fnProgressNotificationRef, System.IntPtr vDataRef, System.Int32 progressFlags)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, fnProgressNotificationRef, (void *)vDataRef, progressFlags, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("9EDDE9E7-8DEE-47ea-99DF-E6FAF2ED44BF")]
    public partial class BitmapDecoder : SharpDX.ComObject
    {
        public BitmapDecoder(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator BitmapDecoder(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new BitmapDecoder(nativePtr);
        /// <summary>
        /// <p>Retrieves the image's container format.</p>
        /// </summary>
        /// <doc-id>ee690095</doc-id>
        /// <unmanaged>GetContainerFormat</unmanaged>
        /// <unmanaged-short>GetContainerFormat</unmanaged-short>
        public System.Guid ContainerFormat
        {
            get
            {
                GetContainerFormat(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Retrieves an <strong><see cref = "SharpDX.WIC.BitmapDecoderInfo"/></strong> for the image.</p>
        /// </summary>
        /// <doc-id>ee690096</doc-id>
        /// <unmanaged>GetDecoderInfo</unmanaged>
        /// <unmanaged-short>GetDecoderInfo</unmanaged-short>
        public SharpDX.WIC.BitmapDecoderInfo DecoderInfo
        {
            get
            {
                GetDecoderInfo(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Proxy function for the <strong>GetMetadataQueryReader</strong> method.</p>
        /// </summary>
        /// <doc-id>ee690103</doc-id>
        /// <unmanaged>GetMetadataQueryReader</unmanaged>
        /// <unmanaged-short>GetMetadataQueryReader</unmanaged-short>
        public SharpDX.WIC.MetadataQueryReader MetadataQueryReader
        {
            get
            {
                GetMetadataQueryReader(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Retrieves a preview image, if supported.</p>
        /// </summary>
        /// <remarks>
        /// <p>Not all formats support previews. Only the native Microsoft?Windows Digital Photo (WDP) codec support previews.</p>
        /// </remarks>
        /// <doc-id>ee690104</doc-id>
        /// <unmanaged>GetPreview</unmanaged>
        /// <unmanaged-short>GetPreview</unmanaged-short>
        public SharpDX.WIC.BitmapSource Preview
        {
            get
            {
                GetPreview(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Proxy function for the <strong>GetThumbnail</strong> method.</p>
        /// </summary>
        /// <doc-id>ee690107</doc-id>
        /// <unmanaged>GetThumbnail</unmanaged>
        /// <unmanaged-short>GetThumbnail</unmanaged-short>
        public SharpDX.WIC.BitmapSource Thumbnail
        {
            get
            {
                GetThumbnail(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Retrieves the total number of frames in the image.</p>
        /// </summary>
        /// <doc-id>ee690099</doc-id>
        /// <unmanaged>GetFrameCount</unmanaged>
        /// <unmanaged-short>GetFrameCount</unmanaged-short>
        public System.Int32 FrameCount
        {
            get
            {
                GetFrameCount(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Retrieves the capabilities of the decoder based on the specified stream.</p>
        /// </summary>
        /// <param name = "streamRef"><dd>  <p>The stream to retrieve the decoder capabilities from.</p> </dd></param>
        /// <returns><dd>  <p>The <strong><see cref = "SharpDX.WIC.BitmapDecoderCapabilities"/></strong> of the decoder.</p> </dd></returns>
        /// <remarks>
        /// <p>Custom decoder implementations should save the current position of the specified <see cref = "SharpDX.Win32.IStream"/>, read whatever information is necessary in order to determine which capabilities it can provide for the supplied stream, and restore the stream position.</p>
        /// </remarks>
        /// <doc-id>ee690109</doc-id>
        /// <unmanaged>HRESULT IWICBitmapDecoder::QueryCapability([In, Optional] IStream* pIStream,[Out] DWORD* pdwCapability)</unmanaged>
        /// <unmanaged-short>IWICBitmapDecoder::QueryCapability</unmanaged-short>
        public unsafe SharpDX.WIC.BitmapDecoderCapabilities QueryCapability(SharpDX.Win32.IStream streamRef)
        {
            System.IntPtr streamRef_ = System.IntPtr.Zero;
            SharpDX.WIC.BitmapDecoderCapabilities capabilityRef;
            SharpDX.Result __result__;
            streamRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Win32.IStream>(streamRef);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)streamRef_, &capabilityRef, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
            return capabilityRef;
        }

        /// <summary>
        /// <p>Initializes the decoder with the provided stream.</p>
        /// </summary>
        /// <param name = "streamRef"><dd>  <p>The stream to use for initialization.</p> <p>The stream contains the encoded pixels which are decoded each time the <strong>CopyPixels</strong> method on the <strong><see cref = "SharpDX.WIC.BitmapFrameDecode"/></strong> interface (see <strong>GetFrame</strong>) is invoked.</p> </dd></param>
        /// <param name = "cacheOptions"><dd>  <p>The <strong><see cref = "SharpDX.WIC.DecodeOptions"/></strong> to use for initialization.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690108</doc-id>
        /// <unmanaged>HRESULT IWICBitmapDecoder::Initialize([In, Optional] IStream* pIStream,[In] WICDecodeOptions cacheOptions)</unmanaged>
        /// <unmanaged-short>IWICBitmapDecoder::Initialize</unmanaged-short>
        internal unsafe void Initialize_(SharpDX.Win32.IStream streamRef, SharpDX.WIC.DecodeOptions cacheOptions)
        {
            System.IntPtr streamRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            streamRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Win32.IStream>(streamRef);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)streamRef_, unchecked ((System.Int32)cacheOptions), (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the image's container format.</p>
        /// </summary>
        /// <param name = "guidContainerFormatRef"><dd>  <p>A reference that receives the image's container format <see cref = "System.Guid"/>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690095</doc-id>
        /// <unmanaged>HRESULT IWICBitmapDecoder::GetContainerFormat([Out] GUID* pguidContainerFormat)</unmanaged>
        /// <unmanaged-short>IWICBitmapDecoder::GetContainerFormat</unmanaged-short>
        internal unsafe void GetContainerFormat(out System.Guid guidContainerFormatRef)
        {
            guidContainerFormatRef = default (System.Guid);
            SharpDX.Result __result__;
            fixed (void *guidContainerFormatRef_ = &guidContainerFormatRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, guidContainerFormatRef_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves an <strong><see cref = "SharpDX.WIC.BitmapDecoderInfo"/></strong> for the image.</p>
        /// </summary>
        /// <param name = "decoderInfoOut">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690096</doc-id>
        /// <unmanaged>HRESULT IWICBitmapDecoder::GetDecoderInfo([Out] IWICBitmapDecoderInfo** ppIDecoderInfo)</unmanaged>
        /// <unmanaged-short>IWICBitmapDecoder::GetDecoderInfo</unmanaged-short>
        internal unsafe void GetDecoderInfo(out SharpDX.WIC.BitmapDecoderInfo decoderInfoOut)
        {
            System.IntPtr decoderInfoOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &decoderInfoOut_, (*(void ***)this._nativePointer)[6]);
            if (decoderInfoOut_ != System.IntPtr.Zero)
                decoderInfoOut = new SharpDX.WIC.BitmapDecoderInfo(decoderInfoOut_);
            else
                decoderInfoOut = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Proxy function for the <strong>CopyPalette</strong> method.</p>
        /// </summary>
        /// <param name = "paletteRef">No documentation.</param>
        /// <returns><p>If this function succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690092</doc-id>
        /// <unmanaged>HRESULT IWICBitmapDecoder::CopyPalette([In, Optional] IWICPalette* pIPalette)</unmanaged>
        /// <unmanaged-short>IWICBitmapDecoder::CopyPalette</unmanaged-short>
        public unsafe void CopyPalette(SharpDX.WIC.Palette paletteRef)
        {
            System.IntPtr paletteRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            paletteRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.Palette>(paletteRef);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)paletteRef_, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Proxy function for the <strong>GetMetadataQueryReader</strong> method.</p>
        /// </summary>
        /// <param name = "metadataQueryReaderOut">No documentation.</param>
        /// <returns><p>If this function succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690103</doc-id>
        /// <unmanaged>HRESULT IWICBitmapDecoder::GetMetadataQueryReader([Out] IWICMetadataQueryReader** ppIMetadataQueryReader)</unmanaged>
        /// <unmanaged-short>IWICBitmapDecoder::GetMetadataQueryReader</unmanaged-short>
        internal unsafe void GetMetadataQueryReader(out SharpDX.WIC.MetadataQueryReader metadataQueryReaderOut)
        {
            System.IntPtr metadataQueryReaderOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &metadataQueryReaderOut_, (*(void ***)this._nativePointer)[8]);
            if (metadataQueryReaderOut_ != System.IntPtr.Zero)
                metadataQueryReaderOut = new SharpDX.WIC.MetadataQueryReader(metadataQueryReaderOut_);
            else
                metadataQueryReaderOut = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves a preview image, if supported.</p>
        /// </summary>
        /// <param name = "bitmapSourceOut"><dd>  <p>Receives a reference to the preview bitmap if supported.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Not all formats support previews. Only the native Microsoft?Windows Digital Photo (WDP) codec support previews.</p>
        /// </remarks>
        /// <doc-id>ee690104</doc-id>
        /// <unmanaged>HRESULT IWICBitmapDecoder::GetPreview([Out] IWICBitmapSource** ppIBitmapSource)</unmanaged>
        /// <unmanaged-short>IWICBitmapDecoder::GetPreview</unmanaged-short>
        internal unsafe void GetPreview(out SharpDX.WIC.BitmapSource bitmapSourceOut)
        {
            System.IntPtr bitmapSourceOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &bitmapSourceOut_, (*(void ***)this._nativePointer)[9]);
            if (bitmapSourceOut_ != System.IntPtr.Zero)
                bitmapSourceOut = new SharpDX.WIC.BitmapSource(bitmapSourceOut_);
            else
                bitmapSourceOut = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Proxy function for the <strong>GetColorContexts</strong> method.</p>
        /// </summary>
        /// <param name = "count">No documentation.</param>
        /// <param name = "colorContextsOut">No documentation.</param>
        /// <param name = "actualCountRef">No documentation.</param>
        /// <returns><p>If this function succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690094</doc-id>
        /// <unmanaged>HRESULT IWICBitmapDecoder::GetColorContexts([In] unsigned int cCount,[InOut, Buffer, Optional] IWICColorContext** ppIColorContexts,[Out] unsigned int* pcActualCount)</unmanaged>
        /// <unmanaged-short>IWICBitmapDecoder::GetColorContexts</unmanaged-short>
        internal unsafe SharpDX.Result GetColorContexts(System.Int32 count, SharpDX.WIC.ColorContext[] colorContextsOut, out System.Int32 actualCountRef)
        {
            System.IntPtr*colorContextsOut_;
            colorContextsOut_ = (System.IntPtr*)0;
            if (colorContextsOut != null)
            {
                System.IntPtr*_colorContextsOut = stackalloc System.IntPtr[colorContextsOut.Length];
                colorContextsOut_ = _colorContextsOut;
            }

            SharpDX.Result __result__;
            if (colorContextsOut != null)
                for (int i = 0; i < colorContextsOut.Length; ++i)
                    (colorContextsOut_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.ColorContext>(colorContextsOut[i]);
            fixed (void *actualCountRef_ = &actualCountRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, count, (void *)colorContextsOut_, actualCountRef_, (*(void ***)this._nativePointer)[10]);
            return __result__;
        }

        /// <summary>
        /// <p>Proxy function for the <strong>GetThumbnail</strong> method.</p>
        /// </summary>
        /// <param name = "thumbnailOut">No documentation.</param>
        /// <returns><p>If this function succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690107</doc-id>
        /// <unmanaged>HRESULT IWICBitmapDecoder::GetThumbnail([Out] IWICBitmapSource** ppIThumbnail)</unmanaged>
        /// <unmanaged-short>IWICBitmapDecoder::GetThumbnail</unmanaged-short>
        internal unsafe void GetThumbnail(out SharpDX.WIC.BitmapSource thumbnailOut)
        {
            System.IntPtr thumbnailOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &thumbnailOut_, (*(void ***)this._nativePointer)[11]);
            if (thumbnailOut_ != System.IntPtr.Zero)
                thumbnailOut = new SharpDX.WIC.BitmapSource(thumbnailOut_);
            else
                thumbnailOut = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the total number of frames in the image.</p>
        /// </summary>
        /// <param name = "countRef"><dd>  <p>A reference that receives the total number of frames in the image.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690099</doc-id>
        /// <unmanaged>HRESULT IWICBitmapDecoder::GetFrameCount([Out] unsigned int* pCount)</unmanaged>
        /// <unmanaged-short>IWICBitmapDecoder::GetFrameCount</unmanaged-short>
        internal unsafe void GetFrameCount(out System.Int32 countRef)
        {
            SharpDX.Result __result__;
            fixed (void *countRef_ = &countRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, countRef_, (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the specified frame of the image.</p>
        /// </summary>
        /// <param name = "index"><dd>  <p>The particular frame to retrieve.</p> </dd></param>
        /// <returns><dd>  <p>A reference that receives a reference to the <strong><see cref = "SharpDX.WIC.BitmapFrameDecode"/></strong>.</p> </dd></returns>
        /// <doc-id>ee690098</doc-id>
        /// <unmanaged>HRESULT IWICBitmapDecoder::GetFrame([In] unsigned int index,[Out] IWICBitmapFrameDecode** ppIBitmapFrame)</unmanaged>
        /// <unmanaged-short>IWICBitmapDecoder::GetFrame</unmanaged-short>
        public unsafe SharpDX.WIC.BitmapFrameDecode GetFrame(System.Int32 index)
        {
            SharpDX.WIC.BitmapFrameDecode bitmapFrameOut;
            System.IntPtr bitmapFrameOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, index, &bitmapFrameOut_, (*(void ***)this._nativePointer)[13]);
            if (bitmapFrameOut_ != System.IntPtr.Zero)
                bitmapFrameOut = new SharpDX.WIC.BitmapFrameDecode(bitmapFrameOut_);
            else
                bitmapFrameOut = null;
            __result__.CheckError();
            return bitmapFrameOut;
        }

        /// <summary>
        /// <p>Proxy function for the <strong>GetColorContexts</strong> method.</p>
        /// </summary>
        /// <param name = "count">No documentation.</param>
        /// <param name = "colorContextsOut">No documentation.</param>
        /// <param name = "actualCountRef">No documentation.</param>
        /// <returns><p>If this function succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690094</doc-id>
        /// <unmanaged>HRESULT IWICBitmapDecoder::GetColorContexts([In] unsigned int cCount,[InOut, Buffer, Optional] IWICColorContext** ppIColorContexts,[Out] unsigned int* pcActualCount)</unmanaged>
        /// <unmanaged-short>IWICBitmapDecoder::GetColorContexts</unmanaged-short>
        internal unsafe SharpDX.Result GetColorContexts(System.Int32 count, SharpDX.ComArray<SharpDX.WIC.ColorContext> colorContextsOut, out System.Int32 actualCountRef)
        {
            SharpDX.Result __result__;
            fixed (void *actualCountRef_ = &actualCountRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, count, (void *)(colorContextsOut?.NativePointer ?? System.IntPtr.Zero), actualCountRef_, (*(void ***)this._nativePointer)[10]);
            return __result__;
        }

        /// <summary>
        /// <p>Proxy function for the <strong>GetColorContexts</strong> method.</p>
        /// </summary>
        /// <param name = "count">No documentation.</param>
        /// <param name = "colorContextsOut">No documentation.</param>
        /// <param name = "actualCountRef">No documentation.</param>
        /// <returns><p>If this function succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690094</doc-id>
        /// <unmanaged>HRESULT IWICBitmapDecoder::GetColorContexts([In] unsigned int cCount,[InOut, Buffer, Optional] IWICColorContext** ppIColorContexts,[Out] unsigned int* pcActualCount)</unmanaged>
        /// <unmanaged-short>IWICBitmapDecoder::GetColorContexts</unmanaged-short>
        private unsafe SharpDX.Result GetColorContexts(System.Int32 count, System.IntPtr colorContextsOut, System.IntPtr actualCountRef)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, count, (void *)colorContextsOut, (void *)actualCountRef, (*(void ***)this._nativePointer)[10]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("D8CD007F-D08F-4191-9BFC-236EA7F0E4B5")]
    public partial class BitmapDecoderInfo : SharpDX.WIC.BitmapCodecInfo
    {
        public BitmapDecoderInfo(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator BitmapDecoderInfo(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new BitmapDecoderInfo(nativePtr);
        /// <summary>
        /// <p>Retrieves the file pattern signatures supported by the decoder.</p>
        /// </summary>
        /// <param name = "sizePatterns"><dd>  <p>The array size of the <em>pPatterns</em> array.</p> </dd></param>
        /// <param name = "patternsRef"><dd>  <p>Receives a list of <strong><see cref = "SharpDX.WIC.BitmapPattern"/></strong> objects supported by the decoder.</p> </dd></param>
        /// <param name = "atternCountRef"><dd>  <p>Receives the number of patterns the decoder supports.</p> </dd></param>
        /// <param name = "patternsActualRef"><dd>  <p>Receives the actual buffer size needed to retrieve all pattern signatures supported by the decoder. </p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p> To retrieve all pattern signatures, this method should first be called with <em>pPatterns</em> set to <code><c>null</c></code> to retrieve the actual buffer size needed through <em>pcbPatternsActual</em>. Once the needed buffer size is known, allocate a buffer of the needed size and call <strong>GetPatterns</strong> again with the allocated buffer. </p>
        /// </remarks>
        /// <doc-id>ee690089</doc-id>
        /// <unmanaged>HRESULT IWICBitmapDecoderInfo::GetPatterns([In] unsigned int cbSizePatterns,[Out, Buffer, Optional] WICBitmapPattern* pPatterns,[Out] unsigned int* pcPatterns,[Out] unsigned int* pcbPatternsActual)</unmanaged>
        /// <unmanaged-short>IWICBitmapDecoderInfo::GetPatterns</unmanaged-short>
        internal unsafe void GetPatterns(System.Int32 sizePatterns, SharpDX.WIC.BitmapPattern[] patternsRef, out System.Int32 atternCountRef, out System.Int32 patternsActualRef)
        {
            SharpDX.Result __result__;
            fixed (void *patternsActualRef_ = &patternsActualRef)
                fixed (void *atternCountRef_ = &atternCountRef)
                    fixed (void *patternsRef_ = patternsRef)
                        __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, sizePatterns, patternsRef_, atternCountRef_, patternsActualRef_, (*(void ***)this._nativePointer)[23]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves a value that indicates whether the codec recognizes the pattern within a specified stream.</p>
        /// </summary>
        /// <param name = "streamRef"><dd>  <p>The stream to pattern match within.</p> </dd></param>
        /// <returns><dd>  <p>A reference that receives <strong>TRUE</strong> if the patterns match; otherwise, <strong><see cref = "SharpDX.Result.False"/></strong>.</p> </dd></returns>
        /// <doc-id>ee690090</doc-id>
        /// <unmanaged>HRESULT IWICBitmapDecoderInfo::MatchesPattern([In, Optional] IStream* pIStream,[Out] BOOL* pfMatches)</unmanaged>
        /// <unmanaged-short>IWICBitmapDecoderInfo::MatchesPattern</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool MatchesPattern(SharpDX.Win32.IStream streamRef)
        {
            System.IntPtr streamRef_ = System.IntPtr.Zero;
            SharpDX.Mathematics.Interop.RawBool fMatchesRef;
            SharpDX.Result __result__;
            streamRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Win32.IStream>(streamRef);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)streamRef_, &fMatchesRef, (*(void ***)this._nativePointer)[24]);
            __result__.CheckError();
            return fMatchesRef;
        }

        /// <summary>
        /// <p>Creates a new <strong><see cref = "SharpDX.WIC.BitmapDecoder"/></strong> instance.</p>
        /// </summary>
        /// <param name = "bitmapDecoderOut">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690088</doc-id>
        /// <unmanaged>HRESULT IWICBitmapDecoderInfo::CreateInstance([Out, Fast] IWICBitmapDecoder** ppIBitmapDecoder)</unmanaged>
        /// <unmanaged-short>IWICBitmapDecoderInfo::CreateInstance</unmanaged-short>
        internal unsafe void CreateInstance(SharpDX.WIC.BitmapDecoder bitmapDecoderOut)
        {
            System.IntPtr bitmapDecoderOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &bitmapDecoderOut_, (*(void ***)this._nativePointer)[25]);
            (bitmapDecoderOut).NativePointer = bitmapDecoderOut_;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("00000103-a8f2-4877-ba0a-fd2b6645fb94")]
    public partial class BitmapEncoder : SharpDX.ComObject
    {
        public BitmapEncoder(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator BitmapEncoder(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new BitmapEncoder(nativePtr);
        /// <summary>
        /// <p>Retrieves the encoder's container format.</p>
        /// </summary>
        /// <doc-id>ee690118</doc-id>
        /// <unmanaged>GetContainerFormat</unmanaged>
        /// <unmanaged-short>GetContainerFormat</unmanaged-short>
        public System.Guid ContainerFormat
        {
            get
            {
                GetContainerFormat(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Retrieves an <strong><see cref = "SharpDX.WIC.BitmapEncoderInfo"/></strong> for the encoder.</p>
        /// </summary>
        /// <doc-id>ee690119</doc-id>
        /// <unmanaged>GetEncoderInfo</unmanaged>
        /// <unmanaged-short>GetEncoderInfo</unmanaged-short>
        public SharpDX.WIC.BitmapEncoderInfo EncoderInfo
        {
            get
            {
                GetEncoderInfo(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Proxy function for the <strong>SetPalette</strong> method.</p>
        /// </summary>
        /// <doc-id>ee690127</doc-id>
        /// <unmanaged>SetPalette</unmanaged>
        /// <unmanaged-short>SetPalette</unmanaged-short>
        public SharpDX.WIC.Palette Palette
        {
            set => SetPalette(value);
        }

        /// <summary>
        /// <p>Sets the global thumbnail for the image.</p>
        /// </summary>
        /// <doc-id>ee690129</doc-id>
        /// <unmanaged>SetThumbnail</unmanaged>
        /// <unmanaged-short>SetThumbnail</unmanaged-short>
        public SharpDX.WIC.BitmapSource Thumbnail
        {
            set => SetThumbnail(value);
        }

        /// <summary>
        /// <p>Sets the global preview for the image.</p>
        /// </summary>
        /// <doc-id>ee690128</doc-id>
        /// <unmanaged>SetPreview</unmanaged>
        /// <unmanaged-short>SetPreview</unmanaged-short>
        public SharpDX.WIC.BitmapSource Preview
        {
            set => SetPreview(value);
        }

        /// <summary>
        /// <p>Proxy function for the <strong>GetMetadataQueryWriter</strong> method.</p>
        /// </summary>
        /// <doc-id>ee690122</doc-id>
        /// <unmanaged>GetMetadataQueryWriter</unmanaged>
        /// <unmanaged-short>GetMetadataQueryWriter</unmanaged-short>
        public SharpDX.WIC.MetadataQueryWriter MetadataQueryWriter
        {
            get
            {
                GetMetadataQueryWriter(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Initializes the encoder with an <see cref = "SharpDX.Win32.IStream"/> which tells the encoder where to encode the bits.</p>
        /// </summary>
        /// <param name = "streamRef">No documentation.</param>
        /// <param name = "cacheOption">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690123</doc-id>
        /// <unmanaged>HRESULT IWICBitmapEncoder::Initialize([In, Optional] IStream* pIStream,[In] WICBitmapEncoderCacheOption cacheOption)</unmanaged>
        /// <unmanaged-short>IWICBitmapEncoder::Initialize</unmanaged-short>
        internal unsafe void Initialize(SharpDX.Win32.IStream streamRef, SharpDX.WIC.BitmapEncoderCacheOption cacheOption)
        {
            System.IntPtr streamRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            streamRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Win32.IStream>(streamRef);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)streamRef_, unchecked ((System.Int32)cacheOption), (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the encoder's container format.</p>
        /// </summary>
        /// <param name = "guidContainerFormatRef"><dd>  <p>A reference that receives the encoder's container format <see cref = "System.Guid"/>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690118</doc-id>
        /// <unmanaged>HRESULT IWICBitmapEncoder::GetContainerFormat([Out] GUID* pguidContainerFormat)</unmanaged>
        /// <unmanaged-short>IWICBitmapEncoder::GetContainerFormat</unmanaged-short>
        internal unsafe void GetContainerFormat(out System.Guid guidContainerFormatRef)
        {
            guidContainerFormatRef = default (System.Guid);
            SharpDX.Result __result__;
            fixed (void *guidContainerFormatRef_ = &guidContainerFormatRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, guidContainerFormatRef_, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves an <strong><see cref = "SharpDX.WIC.BitmapEncoderInfo"/></strong> for the encoder.</p>
        /// </summary>
        /// <param name = "encoderInfoOut">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690119</doc-id>
        /// <unmanaged>HRESULT IWICBitmapEncoder::GetEncoderInfo([Out] IWICBitmapEncoderInfo** ppIEncoderInfo)</unmanaged>
        /// <unmanaged-short>IWICBitmapEncoder::GetEncoderInfo</unmanaged-short>
        internal unsafe void GetEncoderInfo(out SharpDX.WIC.BitmapEncoderInfo encoderInfoOut)
        {
            System.IntPtr encoderInfoOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &encoderInfoOut_, (*(void ***)this._nativePointer)[5]);
            if (encoderInfoOut_ != System.IntPtr.Zero)
                encoderInfoOut = new SharpDX.WIC.BitmapEncoderInfo(encoderInfoOut_);
            else
                encoderInfoOut = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the <strong><see cref = "SharpDX.WIC.ColorContext"/></strong> objects for the encoder.</p>
        /// </summary>
        /// <param name = "count">No documentation.</param>
        /// <param name = "colorContextOut">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690125</doc-id>
        /// <unmanaged>HRESULT IWICBitmapEncoder::SetColorContexts([In] unsigned int cCount,[In, Buffer] IWICColorContext** ppIColorContext)</unmanaged>
        /// <unmanaged-short>IWICBitmapEncoder::SetColorContexts</unmanaged-short>
        internal unsafe void SetColorContexts(System.Int32 count, SharpDX.WIC.ColorContext[] colorContextOut)
        {
            System.IntPtr*colorContextOut_;
            colorContextOut_ = (System.IntPtr*)0;
            if (colorContextOut != null)
            {
                System.IntPtr*_colorContextOut = stackalloc System.IntPtr[colorContextOut.Length];
                colorContextOut_ = _colorContextOut;
            }

            SharpDX.Result __result__;
            if (colorContextOut != null)
                for (int i = 0; i < colorContextOut.Length; ++i)
                    (colorContextOut_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.ColorContext>(colorContextOut[i]);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, count, (void *)colorContextOut_, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Proxy function for the <strong>SetPalette</strong> method.</p>
        /// </summary>
        /// <param name = "paletteRef">No documentation.</param>
        /// <returns><p>If this function succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690127</doc-id>
        /// <unmanaged>HRESULT IWICBitmapEncoder::SetPalette([In, Optional] IWICPalette* pIPalette)</unmanaged>
        /// <unmanaged-short>IWICBitmapEncoder::SetPalette</unmanaged-short>
        internal unsafe void SetPalette(SharpDX.WIC.Palette paletteRef)
        {
            System.IntPtr paletteRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            paletteRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.Palette>(paletteRef);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)paletteRef_, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the global thumbnail for the image.</p>
        /// </summary>
        /// <param name = "thumbnailRef"><dd>  <p>The <strong><see cref = "SharpDX.WIC.BitmapSource"/></strong> to set as the global thumbnail.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful, or an error value otherwise. </p><p>Returns <see cref = "UnsupportedOperation"/> if the feature is not supported by the encoder.</p></returns>
        /// <doc-id>ee690129</doc-id>
        /// <unmanaged>HRESULT IWICBitmapEncoder::SetThumbnail([In, Optional] IWICBitmapSource* pIThumbnail)</unmanaged>
        /// <unmanaged-short>IWICBitmapEncoder::SetThumbnail</unmanaged-short>
        internal unsafe void SetThumbnail(SharpDX.WIC.BitmapSource thumbnailRef)
        {
            System.IntPtr thumbnailRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            thumbnailRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.BitmapSource>(thumbnailRef);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)thumbnailRef_, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the global preview for the image.</p>
        /// </summary>
        /// <param name = "previewRef"><dd>  <p>The <strong><see cref = "SharpDX.WIC.BitmapSource"/></strong> to use as the global preview.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful, or an error value otherwise. </p><p>Returns <see cref = "UnsupportedOperation"/> if the feature is not supported by the encoder.</p></returns>
        /// <doc-id>ee690128</doc-id>
        /// <unmanaged>HRESULT IWICBitmapEncoder::SetPreview([In, Optional] IWICBitmapSource* pIPreview)</unmanaged>
        /// <unmanaged-short>IWICBitmapEncoder::SetPreview</unmanaged-short>
        internal unsafe void SetPreview(SharpDX.WIC.BitmapSource previewRef)
        {
            System.IntPtr previewRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            previewRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.BitmapSource>(previewRef);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)previewRef_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a new <strong><see cref = "SharpDX.WIC.BitmapFrameEncode"/></strong> instance.</p>
        /// </summary>
        /// <param name = "frameEncodeOut">No documentation.</param>
        /// <param name = "encoderOptionsOut">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The parameter <em>ppIEncoderOptions</em> can be used to receive an <see cref = "SharpDX.Win32.PropertyBag"/> that can then be used to specify encoder options. This is done by passing a reference to a <strong><c>null</c></strong> <see cref = "SharpDX.Win32.PropertyBag"/> reference in <em>ppIEncoderOptions</em>. The returned <see cref = "SharpDX.Win32.PropertyBag"/> is initialized with all encoder options that are available for the given format, at their default values. To specify non-default encoding behavior, set the needed encoder options on the <see cref = "SharpDX.Win32.PropertyBag"/> and pass it to <strong>IWICBitmapFrameEncode::Initialize</strong>.</p><strong>Note</strong>??Do not pass in a reference to an initialized <see cref = "SharpDX.Win32.PropertyBag"/>. The reference will be overwritten, and the original <see cref = "SharpDX.Win32.PropertyBag"/> will not be freed.?<p>Otherwise, you can pass <strong><c>null</c></strong> in <em>ppIEncoderOptions</em> if you do not intend to specify encoder options.</p><p>See Encoding Overview for an example of how to set encoder options.</p><p>For formats that support encoding multiple frames (for example, TIFF, JPEG-XR), you can work on only one frame at a time. This means that you must call <strong>IWICBitmapFrameEncode::Commit</strong> before you call <strong>CreateNewFrame</strong> again.
        /// </p>
        /// </remarks>
        /// <doc-id>ee690116</doc-id>
        /// <unmanaged>HRESULT IWICBitmapEncoder::CreateNewFrame([Out, Fast] IWICBitmapFrameEncode** ppIFrameEncode,[Out, Fast] IPropertyBag2** ppIEncoderOptions)</unmanaged>
        /// <unmanaged-short>IWICBitmapEncoder::CreateNewFrame</unmanaged-short>
        internal unsafe void CreateNewFrame(SharpDX.WIC.BitmapFrameEncode frameEncodeOut, SharpDX.Win32.PropertyBag encoderOptionsOut)
        {
            System.IntPtr frameEncodeOut_ = System.IntPtr.Zero;
            System.IntPtr encoderOptionsOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &frameEncodeOut_, &encoderOptionsOut_, (*(void ***)this._nativePointer)[10]);
            (frameEncodeOut).NativePointer = frameEncodeOut_;
            (encoderOptionsOut).NativePointer = encoderOptionsOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Commits all changes for the image and closes the stream.</p>
        /// </summary>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>To finalize an image, both the frame <strong>Commit</strong> and the encoder <strong>Commit</strong> must be called. However, only call the encoder  <strong>Commit</strong> method after all frames have been committed.</p><p>After the encoder has been committed, it can't be re-initialized or reused with another stream. A new encoder interface must be created, for example, with <strong>IWICImagingFactory::CreateEncoder</strong>.
        /// </p><p>For the encoder <strong>Commit</strong> to succeed, you must at a minimum call  <strong>IWICBitmapEncoder::Initialize</strong> and either <strong>IWICBitmapFrameEncode::WriteSource</strong> or <strong>IWICBitmapFrameEncode::WritePixels</strong>.
        /// </p><p> <strong>IWICBitmapFrameEncode::WriteSource</strong> specifies all parameters needed to encode the image data. <strong>IWICBitmapFrameEncode::WritePixels</strong> requires that you also call <strong>IWICBitmapFrameEncode::SetSize</strong>, <strong>IWICBitmapFrameEncode::SetPixelFormat</strong>, and <strong>IWICBitmapFrameEncode::SetPalette</strong> (if the pixel format is indexed).
        /// </p>
        /// </remarks>
        /// <doc-id>ee690114</doc-id>
        /// <unmanaged>HRESULT IWICBitmapEncoder::Commit()</unmanaged>
        /// <unmanaged-short>IWICBitmapEncoder::Commit</unmanaged-short>
        public unsafe void Commit()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Proxy function for the <strong>GetMetadataQueryWriter</strong> method.</p>
        /// </summary>
        /// <param name = "metadataQueryWriterOut">No documentation.</param>
        /// <returns><p>If this function succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690122</doc-id>
        /// <unmanaged>HRESULT IWICBitmapEncoder::GetMetadataQueryWriter([Out] IWICMetadataQueryWriter** ppIMetadataQueryWriter)</unmanaged>
        /// <unmanaged-short>IWICBitmapEncoder::GetMetadataQueryWriter</unmanaged-short>
        internal unsafe void GetMetadataQueryWriter(out SharpDX.WIC.MetadataQueryWriter metadataQueryWriterOut)
        {
            System.IntPtr metadataQueryWriterOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &metadataQueryWriterOut_, (*(void ***)this._nativePointer)[12]);
            if (metadataQueryWriterOut_ != System.IntPtr.Zero)
                metadataQueryWriterOut = new SharpDX.WIC.MetadataQueryWriter(metadataQueryWriterOut_);
            else
                metadataQueryWriterOut = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the <strong><see cref = "SharpDX.WIC.ColorContext"/></strong> objects for the encoder.</p>
        /// </summary>
        /// <param name = "count">No documentation.</param>
        /// <param name = "colorContextOut">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690125</doc-id>
        /// <unmanaged>HRESULT IWICBitmapEncoder::SetColorContexts([In] unsigned int cCount,[In, Buffer] IWICColorContext** ppIColorContext)</unmanaged>
        /// <unmanaged-short>IWICBitmapEncoder::SetColorContexts</unmanaged-short>
        internal unsafe void SetColorContexts(System.Int32 count, SharpDX.ComArray<SharpDX.WIC.ColorContext> colorContextOut)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, count, (void *)(colorContextOut?.NativePointer ?? System.IntPtr.Zero), (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the <strong><see cref = "SharpDX.WIC.ColorContext"/></strong> objects for the encoder.</p>
        /// </summary>
        /// <param name = "count">No documentation.</param>
        /// <param name = "colorContextOut">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690125</doc-id>
        /// <unmanaged>HRESULT IWICBitmapEncoder::SetColorContexts([In] unsigned int cCount,[In, Buffer] IWICColorContext** ppIColorContext)</unmanaged>
        /// <unmanaged-short>IWICBitmapEncoder::SetColorContexts</unmanaged-short>
        private unsafe void SetColorContexts(System.Int32 count, System.IntPtr colorContextOut)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, count, (void *)colorContextOut, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("94C9B4EE-A09F-4f92-8A1E-4A9BCE7E76FB")]
    public partial class BitmapEncoderInfo : SharpDX.WIC.BitmapCodecInfo
    {
        public BitmapEncoderInfo(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator BitmapEncoderInfo(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new BitmapEncoderInfo(nativePtr);
        /// <summary>
        /// <p>Creates a new <strong><see cref = "SharpDX.WIC.BitmapEncoder"/></strong> instance.</p>
        /// </summary>
        /// <param name = "bitmapEncoderOut">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690113</doc-id>
        /// <unmanaged>HRESULT IWICBitmapEncoderInfo::CreateInstance([Out] IWICBitmapEncoder** ppIBitmapEncoder)</unmanaged>
        /// <unmanaged-short>IWICBitmapEncoderInfo::CreateInstance</unmanaged-short>
        public unsafe void CreateInstance(out SharpDX.WIC.BitmapEncoder bitmapEncoderOut)
        {
            System.IntPtr bitmapEncoderOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &bitmapEncoderOut_, (*(void ***)this._nativePointer)[23]);
            if (bitmapEncoderOut_ != System.IntPtr.Zero)
                bitmapEncoderOut = new SharpDX.WIC.BitmapEncoder(bitmapEncoderOut_);
            else
                bitmapEncoderOut = null;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("5009834F-2D6A-41ce-9E1B-17C5AFF7A782")]
    public partial class BitmapFlipRotator : SharpDX.WIC.BitmapSource
    {
        public BitmapFlipRotator(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator BitmapFlipRotator(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new BitmapFlipRotator(nativePtr);
        /// <summary>
        /// <p>Initializes the bitmap flip rotator with the provided parameters.</p>
        /// </summary>
        /// <param name = "sourceRef"><dd>  <p>The input bitmap source.</p> </dd></param>
        /// <param name = "options"><dd>  <p>The <strong><see cref = "SharpDX.WIC.BitmapTransformOptions"/></strong> to flip or rotate the image.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690132</doc-id>
        /// <unmanaged>HRESULT IWICBitmapFlipRotator::Initialize([In, Optional] IWICBitmapSource* pISource,[In] WICBitmapTransformOptions options)</unmanaged>
        /// <unmanaged-short>IWICBitmapFlipRotator::Initialize</unmanaged-short>
        public unsafe void Initialize(SharpDX.WIC.BitmapSource sourceRef, SharpDX.WIC.BitmapTransformOptions options)
        {
            System.IntPtr sourceRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            sourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.BitmapSource>(sourceRef);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)sourceRef_, unchecked ((System.Int32)options), (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("3B16811B-6A43-4ec9-A813-3D930C13B940")]
    public partial class BitmapFrameDecode : SharpDX.WIC.BitmapSource
    {
        public BitmapFrameDecode(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator BitmapFrameDecode(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new BitmapFrameDecode(nativePtr);
        /// <summary>
        /// <p>Retrieves a metadata query reader for the frame.</p>
        /// </summary>
        /// <remarks>
        /// <p>For image formats with one frame (JPG, PNG, JPEG-XR), the frame-level query reader of the first frame is used to access all image metadata, and the decoder-level query reader isn?t used. For formats with more than one frame (GIF, TIFF), the frame-level query reader for a given frame is used to access metadata specific to that frame, and in the case of GIF a decoder-level metadata reader will be present. If the decoder doesn?t support metadata (BMP, ICO), this will return <see cref = "UnsupportedOperation"/>.
        /// </p>
        /// </remarks>
        /// <doc-id>ee690137</doc-id>
        /// <unmanaged>GetMetadataQueryReader</unmanaged>
        /// <unmanaged-short>GetMetadataQueryReader</unmanaged-short>
        public SharpDX.WIC.MetadataQueryReader MetadataQueryReader
        {
            get
            {
                GetMetadataQueryReader(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Retrieves a small preview of the frame, if supported by the codec.</p>
        /// </summary>
        /// <remarks>
        /// <p>Not all formats support thumbnails. Joint Photographic Experts Group (JPEG), Tagged Image File Format (TIFF), and Microsoft?Windows Digital Photo (WDP) support thumbnails.</p>
        /// </remarks>
        /// <doc-id>ee690139</doc-id>
        /// <unmanaged>GetThumbnail</unmanaged>
        /// <unmanaged-short>GetThumbnail</unmanaged-short>
        public SharpDX.WIC.BitmapSource Thumbnail
        {
            get
            {
                GetThumbnail(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Retrieves a metadata query reader for the frame.</p>
        /// </summary>
        /// <param name = "metadataQueryReaderOut"><dd>  <p>When this method returns, contains a reference to the frame's metadata query reader.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>For image formats with one frame (JPG, PNG, JPEG-XR), the frame-level query reader of the first frame is used to access all image metadata, and the decoder-level query reader isn?t used. For formats with more than one frame (GIF, TIFF), the frame-level query reader for a given frame is used to access metadata specific to that frame, and in the case of GIF a decoder-level metadata reader will be present. If the decoder doesn?t support metadata (BMP, ICO), this will return <see cref = "UnsupportedOperation"/>.
        /// </p>
        /// </remarks>
        /// <doc-id>ee690137</doc-id>
        /// <unmanaged>HRESULT IWICBitmapFrameDecode::GetMetadataQueryReader([Out] IWICMetadataQueryReader** ppIMetadataQueryReader)</unmanaged>
        /// <unmanaged-short>IWICBitmapFrameDecode::GetMetadataQueryReader</unmanaged-short>
        internal unsafe void GetMetadataQueryReader(out SharpDX.WIC.MetadataQueryReader metadataQueryReaderOut)
        {
            System.IntPtr metadataQueryReaderOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &metadataQueryReaderOut_, (*(void ***)this._nativePointer)[8]);
            if (metadataQueryReaderOut_ != System.IntPtr.Zero)
                metadataQueryReaderOut = new SharpDX.WIC.MetadataQueryReader(metadataQueryReaderOut_);
            else
                metadataQueryReaderOut = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the <strong><see cref = "SharpDX.WIC.ColorContext"/></strong> associated with the image frame.</p>
        /// </summary>
        /// <param name = "count">No documentation.</param>
        /// <param name = "colorContextsOut">No documentation.</param>
        /// <param name = "actualCountRef">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>If <c>null</c> is passed for <em>ppIColorContexts</em>, and 0 is passed for <em>cCount</em>, this method will return the total number of color contexts in the image in <em>pcActualCount</em>. </p><p>The <em>ppIColorContexts</em> array must be filled with valid data: each <strong><see cref = "SharpDX.WIC.ColorContext"/>*</strong> in the array must have been created using <strong>IWICImagingFactory::CreateColorContext</strong>.
        /// </p>
        /// </remarks>
        /// <doc-id>ee690135</doc-id>
        /// <unmanaged>HRESULT IWICBitmapFrameDecode::GetColorContexts([In] unsigned int cCount,[InOut, Buffer, Optional] IWICColorContext** ppIColorContexts,[Out] unsigned int* pcActualCount)</unmanaged>
        /// <unmanaged-short>IWICBitmapFrameDecode::GetColorContexts</unmanaged-short>
        internal unsafe SharpDX.Result GetColorContexts(System.Int32 count, SharpDX.WIC.ColorContext[] colorContextsOut, out System.Int32 actualCountRef)
        {
            System.IntPtr*colorContextsOut_;
            colorContextsOut_ = (System.IntPtr*)0;
            if (colorContextsOut != null)
            {
                System.IntPtr*_colorContextsOut = stackalloc System.IntPtr[colorContextsOut.Length];
                colorContextsOut_ = _colorContextsOut;
            }

            SharpDX.Result __result__;
            if (colorContextsOut != null)
                for (int i = 0; i < colorContextsOut.Length; ++i)
                    (colorContextsOut_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.ColorContext>(colorContextsOut[i]);
            fixed (void *actualCountRef_ = &actualCountRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, count, (void *)colorContextsOut_, actualCountRef_, (*(void ***)this._nativePointer)[9]);
            return __result__;
        }

        /// <summary>
        /// <p>Retrieves a small preview of the frame, if supported by the codec.</p>
        /// </summary>
        /// <param name = "thumbnailOut"><dd>  <p>A reference that receives a reference to the <strong><see cref = "SharpDX.WIC.BitmapSource"/></strong> of the thumbnail.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Not all formats support thumbnails. Joint Photographic Experts Group (JPEG), Tagged Image File Format (TIFF), and Microsoft?Windows Digital Photo (WDP) support thumbnails.</p>
        /// </remarks>
        /// <doc-id>ee690139</doc-id>
        /// <unmanaged>HRESULT IWICBitmapFrameDecode::GetThumbnail([Out] IWICBitmapSource** ppIThumbnail)</unmanaged>
        /// <unmanaged-short>IWICBitmapFrameDecode::GetThumbnail</unmanaged-short>
        internal unsafe void GetThumbnail(out SharpDX.WIC.BitmapSource thumbnailOut)
        {
            System.IntPtr thumbnailOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &thumbnailOut_, (*(void ***)this._nativePointer)[10]);
            if (thumbnailOut_ != System.IntPtr.Zero)
                thumbnailOut = new SharpDX.WIC.BitmapSource(thumbnailOut_);
            else
                thumbnailOut = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the <strong><see cref = "SharpDX.WIC.ColorContext"/></strong> associated with the image frame.</p>
        /// </summary>
        /// <param name = "count">No documentation.</param>
        /// <param name = "colorContextsOut">No documentation.</param>
        /// <param name = "actualCountRef">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>If <c>null</c> is passed for <em>ppIColorContexts</em>, and 0 is passed for <em>cCount</em>, this method will return the total number of color contexts in the image in <em>pcActualCount</em>. </p><p>The <em>ppIColorContexts</em> array must be filled with valid data: each <strong><see cref = "SharpDX.WIC.ColorContext"/>*</strong> in the array must have been created using <strong>IWICImagingFactory::CreateColorContext</strong>.
        /// </p>
        /// </remarks>
        /// <doc-id>ee690135</doc-id>
        /// <unmanaged>HRESULT IWICBitmapFrameDecode::GetColorContexts([In] unsigned int cCount,[InOut, Buffer, Optional] IWICColorContext** ppIColorContexts,[Out] unsigned int* pcActualCount)</unmanaged>
        /// <unmanaged-short>IWICBitmapFrameDecode::GetColorContexts</unmanaged-short>
        internal unsafe SharpDX.Result GetColorContexts(System.Int32 count, SharpDX.ComArray<SharpDX.WIC.ColorContext> colorContextsOut, out System.Int32 actualCountRef)
        {
            SharpDX.Result __result__;
            fixed (void *actualCountRef_ = &actualCountRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, count, (void *)(colorContextsOut?.NativePointer ?? System.IntPtr.Zero), actualCountRef_, (*(void ***)this._nativePointer)[9]);
            return __result__;
        }

        /// <summary>
        /// <p>Retrieves the <strong><see cref = "SharpDX.WIC.ColorContext"/></strong> associated with the image frame.</p>
        /// </summary>
        /// <param name = "count">No documentation.</param>
        /// <param name = "colorContextsOut">No documentation.</param>
        /// <param name = "actualCountRef">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>If <c>null</c> is passed for <em>ppIColorContexts</em>, and 0 is passed for <em>cCount</em>, this method will return the total number of color contexts in the image in <em>pcActualCount</em>. </p><p>The <em>ppIColorContexts</em> array must be filled with valid data: each <strong><see cref = "SharpDX.WIC.ColorContext"/>*</strong> in the array must have been created using <strong>IWICImagingFactory::CreateColorContext</strong>.
        /// </p>
        /// </remarks>
        /// <doc-id>ee690135</doc-id>
        /// <unmanaged>HRESULT IWICBitmapFrameDecode::GetColorContexts([In] unsigned int cCount,[InOut, Buffer, Optional] IWICColorContext** ppIColorContexts,[Out] unsigned int* pcActualCount)</unmanaged>
        /// <unmanaged-short>IWICBitmapFrameDecode::GetColorContexts</unmanaged-short>
        private unsafe SharpDX.Result GetColorContexts(System.Int32 count, System.IntPtr colorContextsOut, System.IntPtr actualCountRef)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, count, (void *)colorContextsOut, (void *)actualCountRef, (*(void ***)this._nativePointer)[9]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("00000105-a8f2-4877-ba0a-fd2b6645fb94")]
    public partial class BitmapFrameEncode : SharpDX.ComObject
    {
        public BitmapFrameEncode(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator BitmapFrameEncode(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new BitmapFrameEncode(nativePtr);
        /// <summary>
        /// <p>Sets the <strong><see cref = "SharpDX.WIC.Palette"/></strong> for indexed pixel formats.</p>
        /// </summary>
        /// <remarks>
        /// <p>This method doesn't fail if called on a frame whose pixel format is set to a non-indexed pixel format. If the target pixel format is a non-indexed format, the palette will be ignored.</p><p>If you already called <strong>IWICBitmapEncoder::SetPalette</strong> to set a global palette, this method overrides that palette for the current frame.</p><p>The palette must be specified before your first call to <strong>WritePixels</strong>/<strong>WriteSource</strong>. Doing so will cause <strong>WriteSource</strong> to use the specified palette when converting the source image to the encoder pixel format. If no palette is specified, a palette will be generated on the first call to <strong>WriteSource</strong>.
        /// </p>
        /// </remarks>
        /// <doc-id>ee690150</doc-id>
        /// <unmanaged>SetPalette</unmanaged>
        /// <unmanaged-short>SetPalette</unmanaged-short>
        public SharpDX.WIC.Palette Palette
        {
            set => SetPalette(value);
        }

        /// <summary>
        /// <p>Proxy function for the <strong>SetThumbnail</strong> method.</p>
        /// </summary>
        /// <doc-id>ee690157</doc-id>
        /// <unmanaged>SetThumbnail</unmanaged>
        /// <unmanaged-short>SetThumbnail</unmanaged-short>
        public SharpDX.WIC.BitmapSource Thumbnail
        {
            set => SetThumbnail(value);
        }

        /// <summary>
        /// <p>Gets the metadata query writer for the encoder frame.</p>
        /// </summary>
        /// <remarks>
        /// <p>If you are setting metadata on the frame, you must do this before you use <strong>IWICBitmapFrameEncode::WritePixels</strong> or <strong>IWICBitmapFrameEncode::WriteSource</strong> to write any image pixels to the frame</p>
        /// </remarks>
        /// <doc-id>ee690144</doc-id>
        /// <unmanaged>GetMetadataQueryWriter</unmanaged>
        /// <unmanaged-short>GetMetadataQueryWriter</unmanaged-short>
        public SharpDX.WIC.MetadataQueryWriter MetadataQueryWriter
        {
            get
            {
                GetMetadataQueryWriter(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Initializes the frame encoder using the given properties.</p>
        /// </summary>
        /// <param name = "encoderOptionsRef"><dd>  <p>The set of properties to use for <strong><see cref = "SharpDX.WIC.BitmapFrameEncode"/></strong> initialization.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>If you don't want any encoding options, pass <strong><c>null</c></strong> for <em>pIEncoderOptions</em>. Otherwise, pass the <see cref = "SharpDX.Win32.PropertyBag"/> that was provided by <strong>IWICBitmapEncoder::CreateNewFrame</strong> with updated values.
        /// </p><p>For a complete list of encoding options supported by the Windows-provided codecs, see Native WIC Codecs. </p>
        /// </remarks>
        /// <doc-id>ee690146</doc-id>
        /// <unmanaged>HRESULT IWICBitmapFrameEncode::Initialize([In, Optional] IPropertyBag2* pIEncoderOptions)</unmanaged>
        /// <unmanaged-short>IWICBitmapFrameEncode::Initialize</unmanaged-short>
        internal unsafe void Initialize(SharpDX.Win32.PropertyBag encoderOptionsRef)
        {
            System.IntPtr encoderOptionsRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            encoderOptionsRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Win32.PropertyBag>(encoderOptionsRef);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)encoderOptionsRef_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the output image dimensions for the frame.</p>
        /// </summary>
        /// <param name = "width"><dd>  <p>The width of the output image.</p> </dd></param>
        /// <param name = "height"><dd>  <p>The height of the output image.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690154</doc-id>
        /// <unmanaged>HRESULT IWICBitmapFrameEncode::SetSize([In] unsigned int uiWidth,[In] unsigned int uiHeight)</unmanaged>
        /// <unmanaged-short>IWICBitmapFrameEncode::SetSize</unmanaged-short>
        public unsafe void SetSize(System.Int32 width, System.Int32 height)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, width, height, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the physical resolution of the output image.</p>
        /// </summary>
        /// <param name = "dpiX"><dd>  <p>The horizontal resolution value.</p> </dd></param>
        /// <param name = "dpiY"><dd>  <p>The vertical resolution value.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Windows Imaging Component (WIC) doesn't perform any special processing as a result of DPI resolution values. For example, data returned from <strong>IWICBitmapSource::CopyPixels</strong> isn't scaled by the DPI. The app must handle DPI resolution.
        /// </p>
        /// </remarks>
        /// <doc-id>ee690152</doc-id>
        /// <unmanaged>HRESULT IWICBitmapFrameEncode::SetResolution([In] double dpiX,[In] double dpiY)</unmanaged>
        /// <unmanaged-short>IWICBitmapFrameEncode::SetResolution</unmanaged-short>
        public unsafe void SetResolution(System.Double dpiX, System.Double dpiY)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, dpiX, dpiY, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Requests that the encoder use the specified pixel format.</p>
        /// </summary>
        /// <param name = "pixelFormatRef"><dd>  <p>On input, the requested pixel format <see cref = "System.Guid"/>. On output, the closest pixel format <see cref = "System.Guid"/> supported by the encoder; this may be different than the requested format. For a list of pixel format GUIDs, see Native Pixel Formats.</p> </dd></param>
        /// <returns><p>Possible return values include the following.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "WrongState"/></strong></dt> </dl> </td><td> <p>The <strong>IWICBitmapFrameEncode::Initialize</strong> method was not called.</p> </td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>The encoder might not support the requested pixel format. If not, <strong>SetPixelFormat</strong> returns the closest match in the memory block that <em>pPixelFormat</em> points to. If the returned pixel format doesn't match the requested format, you must use an <strong><see cref = "SharpDX.WIC.FormatConverter"/></strong> object to convert the pixel data.</p>
        /// </remarks>
        /// <doc-id>ee690151</doc-id>
        /// <unmanaged>HRESULT IWICBitmapFrameEncode::SetPixelFormat([InOut] GUID* pPixelFormat)</unmanaged>
        /// <unmanaged-short>IWICBitmapFrameEncode::SetPixelFormat</unmanaged-short>
        public unsafe void SetPixelFormat(ref System.Guid pixelFormatRef)
        {
            SharpDX.Result __result__;
            fixed (void *pixelFormatRef_ = &pixelFormatRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, pixelFormatRef_, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Proxy function for the <strong>SetColorContexts</strong> method.</p>
        /// </summary>
        /// <param name = "count">No documentation.</param>
        /// <param name = "colorContextOut">No documentation.</param>
        /// <returns><p>If this function succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690149</doc-id>
        /// <unmanaged>HRESULT IWICBitmapFrameEncode::SetColorContexts([In] unsigned int cCount,[In, Buffer] IWICColorContext** ppIColorContext)</unmanaged>
        /// <unmanaged-short>IWICBitmapFrameEncode::SetColorContexts</unmanaged-short>
        internal unsafe void SetColorContexts(System.Int32 count, SharpDX.WIC.ColorContext[] colorContextOut)
        {
            System.IntPtr*colorContextOut_;
            colorContextOut_ = (System.IntPtr*)0;
            if (colorContextOut != null)
            {
                System.IntPtr*_colorContextOut = stackalloc System.IntPtr[colorContextOut.Length];
                colorContextOut_ = _colorContextOut;
            }

            SharpDX.Result __result__;
            if (colorContextOut != null)
                for (int i = 0; i < colorContextOut.Length; ++i)
                    (colorContextOut_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.ColorContext>(colorContextOut[i]);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, count, (void *)colorContextOut_, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the <strong><see cref = "SharpDX.WIC.Palette"/></strong> for indexed pixel formats.</p>
        /// </summary>
        /// <param name = "paletteRef">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>This method doesn't fail if called on a frame whose pixel format is set to a non-indexed pixel format. If the target pixel format is a non-indexed format, the palette will be ignored.</p><p>If you already called <strong>IWICBitmapEncoder::SetPalette</strong> to set a global palette, this method overrides that palette for the current frame.</p><p>The palette must be specified before your first call to <strong>WritePixels</strong>/<strong>WriteSource</strong>. Doing so will cause <strong>WriteSource</strong> to use the specified palette when converting the source image to the encoder pixel format. If no palette is specified, a palette will be generated on the first call to <strong>WriteSource</strong>.
        /// </p>
        /// </remarks>
        /// <doc-id>ee690150</doc-id>
        /// <unmanaged>HRESULT IWICBitmapFrameEncode::SetPalette([In, Optional] IWICPalette* pIPalette)</unmanaged>
        /// <unmanaged-short>IWICBitmapFrameEncode::SetPalette</unmanaged-short>
        internal unsafe void SetPalette(SharpDX.WIC.Palette paletteRef)
        {
            System.IntPtr paletteRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            paletteRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.Palette>(paletteRef);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)paletteRef_, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Proxy function for the <strong>SetThumbnail</strong> method.</p>
        /// </summary>
        /// <param name = "thumbnailRef">No documentation.</param>
        /// <returns><p>If this function succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690157</doc-id>
        /// <unmanaged>HRESULT IWICBitmapFrameEncode::SetThumbnail([In, Optional] IWICBitmapSource* pIThumbnail)</unmanaged>
        /// <unmanaged-short>IWICBitmapFrameEncode::SetThumbnail</unmanaged-short>
        internal unsafe void SetThumbnail(SharpDX.WIC.BitmapSource thumbnailRef)
        {
            System.IntPtr thumbnailRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            thumbnailRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.BitmapSource>(thumbnailRef);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)thumbnailRef_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Copies scan-line data from a caller-supplied buffer to the <strong><see cref = "SharpDX.WIC.BitmapFrameEncode"/></strong> object.
        /// </p>
        /// </summary>
        /// <param name = "lineCount">No documentation.</param>
        /// <param name = "stride">No documentation.</param>
        /// <param name = "bufferSize">No documentation.</param>
        /// <param name = "pixelsRef">No documentation.</param>
        /// <returns><p>Possible return values include the following.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "Codectoomanyscanlines"/></strong></dt> </dl> </td><td> <p>The value of <em>lineCount</em> is larger than the number of scan lines in the image.</p> </td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>Successive <strong>WritePixels</strong> calls are assumed to be sequential scan-line access in the output image.</p>
        /// </remarks>
        /// <doc-id>ee690158</doc-id>
        /// <unmanaged>HRESULT IWICBitmapFrameEncode::WritePixels([In] unsigned int lineCount,[In] unsigned int cbStride,[In] unsigned int cbBufferSize,[In, Buffer] unsigned char* pbPixels)</unmanaged>
        /// <unmanaged-short>IWICBitmapFrameEncode::WritePixels</unmanaged-short>
        internal unsafe void WritePixels(System.Int32 lineCount, System.Int32 stride, System.Int32 bufferSize, System.IntPtr pixelsRef)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, lineCount, stride, bufferSize, (void *)pixelsRef, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Encodes a bitmap source.</p>
        /// </summary>
        /// <param name = "bitmapSourceRef"><dd>  <p>The bitmap source to encode.</p> </dd></param>
        /// <param name = "rectangleRef"><dd>  <p>The size rectangle of the bitmap source.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>If <strong>SetSize</strong> is not called prior to calling <strong>WriteSource</strong>, the size given in <em>prc</em> is used if not <strong><c>null</c></strong>. Otherwise, the size of the <strong><see cref = "SharpDX.WIC.BitmapSource"/></strong> given in <em>pIBitmapSource</em> is used. </p><p>If <strong>SetPixelFormat</strong> is not called prior to calling <strong>WriteSource</strong>, the pixel format of the <strong><see cref = "SharpDX.WIC.BitmapSource"/></strong> given in <em>pIBitmapSource</em> is used.</p><p>If <strong>SetResolution</strong> is not called prior to calling <strong>WriteSource</strong>, the pixel format of <em>pIBitmapSource</em> is used.</p><p>If <strong>SetPalette</strong> is not called prior to calling <strong>WriteSource</strong>, the target pixel format is indexed, and the pixel format of <em>pIBitmapSource</em> matches the encoder frame's pixel format, then the <em>pIBitmapSource</em> pixel format is used.</p><p>When encoding a GIF image, if the global palette is set and the frame level palette is not set directly by the user or by a custom independent software vendor (ISV) GIF codec, <strong>WriteSource</strong> will use the global palette to encode the frame even when <em>pIBitmapSource</em> has a frame level palette.</p><p>Starting with  Windows?Vista, repeated <strong>WriteSource</strong> calls can be made as long as the total accumulated source rect height is the same as set through <strong>SetSize</strong>.</p><p>Starting with Windows?8.1, the source rect must be at least the dimensions set through <strong>SetSize</strong>. If the source rect width exceeds the <strong>SetSize</strong> width, extra pixels on the right side are ignored. If the source rect height exceeds the remaining unfilled height, extra scan lines on the bottom are ignored.
        /// </p>
        /// </remarks>
        /// <doc-id>ee690159</doc-id>
        /// <unmanaged>HRESULT IWICBitmapFrameEncode::WriteSource([In, Optional] IWICBitmapSource* pIBitmapSource,[In] WICRect* prc)</unmanaged>
        /// <unmanaged-short>IWICBitmapFrameEncode::WriteSource</unmanaged-short>
        internal unsafe void WriteSource(SharpDX.WIC.BitmapSource bitmapSourceRef, System.IntPtr rectangleRef)
        {
            System.IntPtr bitmapSourceRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            bitmapSourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.BitmapSource>(bitmapSourceRef);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)bitmapSourceRef_, (void *)rectangleRef, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Commits the frame to the image.</p>
        /// </summary>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>After the frame <strong>Commit</strong> has been called, you can't use or reinitialize the <strong><see cref = "SharpDX.WIC.BitmapFrameEncode"/></strong> object and any objects created from it.
        /// </p><p>To finalize the image, both the frame <strong>Commit</strong> and the encoder <strong>Commit</strong> must be called. However, only call the encoder  <strong>Commit</strong> method after all frames have been committed.</p>
        /// </remarks>
        /// <doc-id>ee690142</doc-id>
        /// <unmanaged>HRESULT IWICBitmapFrameEncode::Commit()</unmanaged>
        /// <unmanaged-short>IWICBitmapFrameEncode::Commit</unmanaged-short>
        public unsafe void Commit()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the metadata query writer for the encoder frame.</p>
        /// </summary>
        /// <param name = "metadataQueryWriterOut"><dd>  <p>When this method returns, contains a reference to metadata query writer for the encoder frame.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>If you are setting metadata on the frame, you must do this before you use <strong>IWICBitmapFrameEncode::WritePixels</strong> or <strong>IWICBitmapFrameEncode::WriteSource</strong> to write any image pixels to the frame</p>
        /// </remarks>
        /// <doc-id>ee690144</doc-id>
        /// <unmanaged>HRESULT IWICBitmapFrameEncode::GetMetadataQueryWriter([Out] IWICMetadataQueryWriter** ppIMetadataQueryWriter)</unmanaged>
        /// <unmanaged-short>IWICBitmapFrameEncode::GetMetadataQueryWriter</unmanaged-short>
        internal unsafe void GetMetadataQueryWriter(out SharpDX.WIC.MetadataQueryWriter metadataQueryWriterOut)
        {
            System.IntPtr metadataQueryWriterOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &metadataQueryWriterOut_, (*(void ***)this._nativePointer)[13]);
            if (metadataQueryWriterOut_ != System.IntPtr.Zero)
                metadataQueryWriterOut = new SharpDX.WIC.MetadataQueryWriter(metadataQueryWriterOut_);
            else
                metadataQueryWriterOut = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Proxy function for the <strong>SetColorContexts</strong> method.</p>
        /// </summary>
        /// <param name = "count">No documentation.</param>
        /// <param name = "colorContextOut">No documentation.</param>
        /// <returns><p>If this function succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690149</doc-id>
        /// <unmanaged>HRESULT IWICBitmapFrameEncode::SetColorContexts([In] unsigned int cCount,[In, Buffer] IWICColorContext** ppIColorContext)</unmanaged>
        /// <unmanaged-short>IWICBitmapFrameEncode::SetColorContexts</unmanaged-short>
        internal unsafe void SetColorContexts(System.Int32 count, SharpDX.ComArray<SharpDX.WIC.ColorContext> colorContextOut)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, count, (void *)(colorContextOut?.NativePointer ?? System.IntPtr.Zero), (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Proxy function for the <strong>SetColorContexts</strong> method.</p>
        /// </summary>
        /// <param name = "count">No documentation.</param>
        /// <param name = "colorContextOut">No documentation.</param>
        /// <returns><p>If this function succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690149</doc-id>
        /// <unmanaged>HRESULT IWICBitmapFrameEncode::SetColorContexts([In] unsigned int cCount,[In, Buffer] IWICColorContext** ppIColorContext)</unmanaged>
        /// <unmanaged-short>IWICBitmapFrameEncode::SetColorContexts</unmanaged-short>
        private unsafe void SetColorContexts(System.Int32 count, System.IntPtr colorContextOut)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, count, (void *)colorContextOut, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("00000123-a8f2-4877-ba0a-fd2b6645fb94")]
    public partial class BitmapLock : SharpDX.ComObject
    {
        public BitmapLock(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator BitmapLock(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new BitmapLock(nativePtr);
        /// <summary>
        /// <p>Provides access to the stride value for the memory.</p>
        /// </summary>
        /// <remarks>
        /// <p> Note the stride value is specific to the <strong><see cref = "SharpDX.WIC.BitmapLock"/></strong>, not the bitmap.  For example, two consecutive locks on the same rectangle of a bitmap may return different references and stride values, depending on internal implementation.  </p>
        /// </remarks>
        /// <doc-id>ee690166</doc-id>
        /// <unmanaged>GetStride</unmanaged>
        /// <unmanaged-short>GetStride</unmanaged-short>
        public System.Int32 Stride
        {
            get
            {
                GetStride(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the pixel format of for the locked area of pixels. This can be used to compute the number of bytes-per-pixel in the locked area.</p>
        /// </summary>
        /// <doc-id>ee690164</doc-id>
        /// <unmanaged>GetPixelFormat</unmanaged>
        /// <unmanaged-short>GetPixelFormat</unmanaged-short>
        public System.Guid PixelFormat
        {
            get
            {
                GetPixelFormat(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Retrieves the width and height, in pixels, of the locked rectangle.</p>
        /// </summary>
        /// <param name = "widthRef"><dd>  <p>A reference that receives the width of the locked rectangle.</p> </dd></param>
        /// <param name = "heightRef"><dd>  <p>A reference that receives the height of the locked rectangle.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690165</doc-id>
        /// <unmanaged>HRESULT IWICBitmapLock::GetSize([Out] unsigned int* puiWidth,[Out] unsigned int* puiHeight)</unmanaged>
        /// <unmanaged-short>IWICBitmapLock::GetSize</unmanaged-short>
        internal unsafe void GetSize(out System.Int32 widthRef, out System.Int32 heightRef)
        {
            SharpDX.Result __result__;
            fixed (void *heightRef_ = &heightRef)
                fixed (void *widthRef_ = &widthRef)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, widthRef_, heightRef_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Provides access to the stride value for the memory.</p>
        /// </summary>
        /// <param name = "strideRef"><dd>  </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p> Note the stride value is specific to the <strong><see cref = "SharpDX.WIC.BitmapLock"/></strong>, not the bitmap.  For example, two consecutive locks on the same rectangle of a bitmap may return different references and stride values, depending on internal implementation.  </p>
        /// </remarks>
        /// <doc-id>ee690166</doc-id>
        /// <unmanaged>HRESULT IWICBitmapLock::GetStride([Out] unsigned int* pcbStride)</unmanaged>
        /// <unmanaged-short>IWICBitmapLock::GetStride</unmanaged-short>
        internal unsafe void GetStride(out System.Int32 strideRef)
        {
            SharpDX.Result __result__;
            fixed (void *strideRef_ = &strideRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, strideRef_, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the reference to the top left pixel in the locked rectangle.</p>
        /// </summary>
        /// <param name = "bufferSizeRef"><dd>  <p>A reference that receives the size of the buffer.</p> </dd></param>
        /// <returns><dd>  <p>A reference that receives a reference to the top left pixel in the locked rectangle.</p> </dd></returns>
        /// <remarks>
        /// <p>The reference provided by this method should not be used outside of the lifetime of the lock itself.</p><p><strong>GetDataPointer</strong> is not available in multi-threaded apartment applications.</p>
        /// </remarks>
        /// <doc-id>ee690162</doc-id>
        /// <unmanaged>HRESULT IWICBitmapLock::GetDataPointer([Out] unsigned int* pcbBufferSize,[Out] unsigned char** ppbData)</unmanaged>
        /// <unmanaged-short>IWICBitmapLock::GetDataPointer</unmanaged-short>
        internal unsafe System.IntPtr GetDataPointer(out System.Int32 bufferSizeRef)
        {
            System.IntPtr dataOut;
            SharpDX.Result __result__;
            fixed (void *bufferSizeRef_ = &bufferSizeRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, bufferSizeRef_, &dataOut, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
            return dataOut;
        }

        /// <summary>
        /// <p>Gets the pixel format of for the locked area of pixels. This can be used to compute the number of bytes-per-pixel in the locked area.</p>
        /// </summary>
        /// <param name = "pixelFormatRef"><dd>  <p>A reference that receives the pixel format <see cref = "System.Guid"/> of the locked area.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690164</doc-id>
        /// <unmanaged>HRESULT IWICBitmapLock::GetPixelFormat([Out] GUID* pPixelFormat)</unmanaged>
        /// <unmanaged-short>IWICBitmapLock::GetPixelFormat</unmanaged-short>
        internal unsafe void GetPixelFormat(out System.Guid pixelFormatRef)
        {
            pixelFormatRef = default (System.Guid);
            SharpDX.Result __result__;
            fixed (void *pixelFormatRef_ = &pixelFormatRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, pixelFormatRef_, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("00000302-a8f2-4877-ba0a-fd2b6645fb94")]
    public partial class BitmapScaler : SharpDX.WIC.BitmapSource
    {
        public BitmapScaler(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator BitmapScaler(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new BitmapScaler(nativePtr);
        /// <summary>
        /// <p>Initializes the bitmap scaler with the provided parameters.</p>
        /// </summary>
        /// <param name = "sourceRef"><dd>  <p>The input bitmap source.</p> </dd></param>
        /// <param name = "width"><dd>  <p>The destination width.</p> </dd></param>
        /// <param name = "height"><dd>  <p>The desination height.</p> </dd></param>
        /// <param name = "mode"><dd>  <p>The <strong><see cref = "SharpDX.WIC.BitmapInterpolationMode"/></strong> to use when scaling.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p> <strong><see cref = "SharpDX.WIC.BitmapScaler"/></strong> can't be initialized multiple times. For example, when scaling every frame in a multi-frame image, a new <strong><see cref = "SharpDX.WIC.BitmapScaler"/></strong> must be created and initialized for each frame.</p>
        /// </remarks>
        /// <doc-id>ee690169</doc-id>
        /// <unmanaged>HRESULT IWICBitmapScaler::Initialize([In, Optional] IWICBitmapSource* pISource,[In] unsigned int uiWidth,[In] unsigned int uiHeight,[In] WICBitmapInterpolationMode mode)</unmanaged>
        /// <unmanaged-short>IWICBitmapScaler::Initialize</unmanaged-short>
        public unsafe void Initialize(SharpDX.WIC.BitmapSource sourceRef, System.Int32 width, System.Int32 height, SharpDX.WIC.BitmapInterpolationMode mode)
        {
            System.IntPtr sourceRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            sourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.BitmapSource>(sourceRef);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)sourceRef_, width, height, unchecked ((System.Int32)mode), (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("00000120-a8f2-4877-ba0a-fd2b6645fb94")]
    public partial class BitmapSource : SharpDX.ComObject
    {
        public BitmapSource(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator BitmapSource(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new BitmapSource(nativePtr);
        /// <summary>
        /// <p>Retrieves the pixel format of the bitmap source.. </p>
        /// </summary>
        /// <remarks>
        /// <p> The pixel format returned by this method is not necessarily the pixel format the image is stored as. The codec may perform a format conversion from the storage pixel format to an output pixel format. </p>
        /// </remarks>
        /// <doc-id>ee690181</doc-id>
        /// <unmanaged>GetPixelFormat</unmanaged>
        /// <unmanaged-short>GetPixelFormat</unmanaged-short>
        public System.Guid PixelFormat
        {
            get
            {
                GetPixelFormat(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Retrieves the pixel width and height of the bitmap.</p>
        /// </summary>
        /// <param name = "widthRef"><dd>  <p>A reference that receives the pixel width of the bitmap.</p> </dd></param>
        /// <param name = "heightRef"><dd>  <p>A reference that receives the pixel height of the bitmap</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690185</doc-id>
        /// <unmanaged>HRESULT IWICBitmapSource::GetSize([Out] unsigned int* puiWidth,[Out] unsigned int* puiHeight)</unmanaged>
        /// <unmanaged-short>IWICBitmapSource::GetSize</unmanaged-short>
        internal unsafe void GetSize(out System.Int32 widthRef, out System.Int32 heightRef)
        {
            SharpDX.Result __result__;
            fixed (void *heightRef_ = &heightRef)
                fixed (void *widthRef_ = &widthRef)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, widthRef_, heightRef_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the pixel format of the bitmap source.. </p>
        /// </summary>
        /// <param name = "pixelFormatRef"><dd>  <p>Receives the pixel format <see cref = "System.Guid"/> the bitmap is stored in. For a list of available pixel formats, see the Native Pixel Formats topic.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p> The pixel format returned by this method is not necessarily the pixel format the image is stored as. The codec may perform a format conversion from the storage pixel format to an output pixel format. </p>
        /// </remarks>
        /// <doc-id>ee690181</doc-id>
        /// <unmanaged>HRESULT IWICBitmapSource::GetPixelFormat([Out] GUID* pPixelFormat)</unmanaged>
        /// <unmanaged-short>IWICBitmapSource::GetPixelFormat</unmanaged-short>
        internal unsafe void GetPixelFormat(out System.Guid pixelFormatRef)
        {
            pixelFormatRef = default (System.Guid);
            SharpDX.Result __result__;
            fixed (void *pixelFormatRef_ = &pixelFormatRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, pixelFormatRef_, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the sampling rate between pixels and physical world measurements.</p>
        /// </summary>
        /// <param name = "dpiXRef"><dd>  <p>A reference that receives the x-axis dpi resolution.</p> </dd></param>
        /// <param name = "dpiYRef"><dd>  <p>A reference that receives the y-axis dpi resolution.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p> Some formats, such as GIF and ICO, do not have full DPI support. For GIF, this method calculates the DPI values from the aspect ratio, using a base DPI of (96.0, 96.0). The ICO format does not support DPI at all, and the method always returns (96.0,96.0) for ICO images. </p><p> Additionally, WIC itself does not transform images based on the DPI values in an image. It is up to the caller to transform an image based on the resolution returned. </p>
        /// </remarks>
        /// <doc-id>ee690183</doc-id>
        /// <unmanaged>HRESULT IWICBitmapSource::GetResolution([Out] double* pDpiX,[Out] double* pDpiY)</unmanaged>
        /// <unmanaged-short>IWICBitmapSource::GetResolution</unmanaged-short>
        public unsafe void GetResolution(out System.Double dpiXRef, out System.Double dpiYRef)
        {
            SharpDX.Result __result__;
            fixed (void *dpiYRef_ = &dpiYRef)
                fixed (void *dpiXRef_ = &dpiXRef)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, dpiXRef_, dpiYRef_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the color table for indexed pixel formats.</p>
        /// </summary>
        /// <param name = "paletteRef"><dd>  <p>An <strong><see cref = "SharpDX.WIC.Palette"/></strong>. A palette can be created using the <strong>CreatePalette</strong> method.</p> </dd></param>
        /// <returns><p>Returns one of the following values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "Paletteunavailable"/></strong></dt> </dl> </td><td> <p>The palette was unavailable.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The palette was successfully copied.</p> </td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p> If the <strong><see cref = "SharpDX.WIC.BitmapSource"/></strong> is an <strong><see cref = "SharpDX.WIC.BitmapFrameDecode"/></strong>, the function may return the image's global palette if a frame-level palette is not available. The global palette may also be retrieved using the <strong>CopyPalette</strong> method. </p>
        /// </remarks>
        /// <doc-id>ee690177</doc-id>
        /// <unmanaged>HRESULT IWICBitmapSource::CopyPalette([In, Optional] IWICPalette* pIPalette)</unmanaged>
        /// <unmanaged-short>IWICBitmapSource::CopyPalette</unmanaged-short>
        public unsafe void CopyPalette(SharpDX.WIC.Palette paletteRef)
        {
            System.IntPtr paletteRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            paletteRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.Palette>(paletteRef);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)paletteRef_, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Instructs the object to produce pixels.</p>
        /// </summary>
        /// <param name = "rectangleRef"><dd>  <p>The rectangle to copy. A <strong><c>null</c></strong> value specifies the entire bitmap.</p> </dd></param>
        /// <param name = "stride"><dd>  <p>The stride of the bitmap</p> </dd></param>
        /// <param name = "bufferSize"><dd>  <p>The size of the buffer.</p> </dd></param>
        /// <param name = "bufferRef"><dd>  <p>A reference to the buffer.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p><strong>CopyPixels</strong> is one of the two main image processing routines (the other being <strong>Lock</strong>) triggering the actual processing.  It instructs the object to produce pixels according to its algorithm - this may involve decoding a portion of a JPEG stored on disk, copying a block of memory, or even analytically computing a complex gradient.  The algorithm is completely dependent on the object implementing the interface. </p><p> The caller can restrict the operation to a rectangle of interest (ROI) using the prc parameter.  The ROI sub-rectangle must be fully contained in the bounds of the bitmap.  Specifying a <strong><c>null</c></strong> ROI implies that the whole bitmap should be returned. 
        /// </p><p> The caller controls the memory management and must provide an output buffer (<em>pbBuffer</em>) for the results of the copy along with the buffer's bounds (<em>cbBufferSize</em>).  The cbStride parameter defines the count of bytes between two vertically adjacent pixels in the output buffer.  The caller must ensure that there is sufficient buffer to complete the call based on the width, height and pixel format of the bitmap and the sub-rectangle provided to the copy method. </p><p> If the caller needs to perform numerous copies of an expensive <strong><see cref = "SharpDX.WIC.BitmapSource"/></strong> such as a JPEG, it is recommended to create an in-memory <strong><see cref = "SharpDX.WIC.Bitmap"/></strong> first. </p>
        /// </remarks>
        /// <doc-id>ee690179</doc-id>
        /// <unmanaged>HRESULT IWICBitmapSource::CopyPixels([In] const WICRect* prc,[In] unsigned int cbStride,[In] unsigned int cbBufferSize,[In] unsigned char* pbBuffer)</unmanaged>
        /// <unmanaged-short>IWICBitmapSource::CopyPixels</unmanaged-short>
        internal unsafe void CopyPixels(System.IntPtr rectangleRef, System.Int32 stride, System.Int32 bufferSize, System.IntPtr bufferRef)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)rectangleRef, stride, bufferSize, (void *)bufferRef, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("3B16811B-6A43-4ec9-B713-3D5A0C13B940")]
    public partial class BitmapSourceTransform : SharpDX.ComObject
    {
        public BitmapSourceTransform(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator BitmapSourceTransform(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new BitmapSourceTransform(nativePtr);
        /// <summary>
        /// <p>Copies pixel data using the supplied input parameters.</p>
        /// </summary>
        /// <param name = "rectangleRef"><dd>  <p>The rectangle of pixels to copy.</p> </dd></param>
        /// <param name = "width"><dd>  <p>The width to scale the source bitmap. This parameter must equal the value obtainable through <strong>IWICBitmapSourceTransform::GetClosestSize</strong>.</p> </dd></param>
        /// <param name = "height"><dd>  <p>The height to scale the source bitmap. This parameter must equal the value obtainable through <strong>IWICBitmapSourceTransform::GetClosestSize</strong>.</p> </dd></param>
        /// <param name = "guidDstFormatRef"><dd>  <p> The <see cref = "System.Guid"/> of desired pixel format in which the pixels should be returned.  </p> <p>This <see cref = "System.Guid"/> must be a format obtained through an <strong>GetClosestPixelFormat</strong> call.</p> </dd></param>
        /// <param name = "dstTransform"><dd>  <p> The desired rotation or flip to perform prior to the pixel copy. </p> <p>The transform must be an operation supported by an <strong>DoesSupportTransform</strong> call.</p> <p>If a <em>dstTransform</em> is specified, <em>nStride</em> is the <em>transformed stride</em> and is based on the <em>pguidDstFormat</em> pixel format, not the original source's pixel format.</p> </dd></param>
        /// <param name = "nStride"><dd>  <p>The stride of the destination buffer.</p> </dd></param>
        /// <param name = "bufferSize"><dd>  <p>The size of the destination buffer.</p> </dd></param>
        /// <param name = "bufferRef"><dd>  <p>The output buffer.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690173</doc-id>
        /// <unmanaged>HRESULT IWICBitmapSourceTransform::CopyPixels([In] const WICRect* prc,[In] unsigned int uiWidth,[In] unsigned int uiHeight,[In, Optional] GUID* pguidDstFormat,[In] WICBitmapTransformOptions dstTransform,[In] unsigned int nStride,[In] unsigned int cbBufferSize,[In] unsigned char* pbBuffer)</unmanaged>
        /// <unmanaged-short>IWICBitmapSourceTransform::CopyPixels</unmanaged-short>
        internal unsafe void CopyPixels(System.IntPtr rectangleRef, System.Int32 width, System.Int32 height, System.Guid? guidDstFormatRef, SharpDX.WIC.BitmapTransformOptions dstTransform, System.Int32 nStride, System.Int32 bufferSize, System.IntPtr bufferRef)
        {
            System.Guid guidDstFormatRef_;
            SharpDX.Result __result__;
            if (guidDstFormatRef != null)
                guidDstFormatRef_ = guidDstFormatRef.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)rectangleRef, width, height, guidDstFormatRef == null ? (void *)0 : &guidDstFormatRef_, unchecked ((System.Int32)dstTransform), nStride, bufferSize, (void *)bufferRef, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Returns the closest dimensions the implementation can natively scale to given the desired dimensions.</p>
        /// </summary>
        /// <param name = "widthRef"><dd>  <p>The desired width. A reference that receives the closest supported width.</p> </dd></param>
        /// <param name = "heightRef"><dd>  <p>The desired height. A reference that receives the closest supported height.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The Windows provided codecs provide the following support for native scaling:
        /// </p><ul> <li>BMP, ICO, GIF, TIFF: No implementation of <see cref = "SharpDX.WIC.BitmapSourceTransform"/>.</li> <li>PNG: No scaling support.</li> <li>JPEG: Native down-scaling by a factor of 8, 4, or 2.</li> <li>JPEG-XR:  Native scaling of the original image by powers of 2.
        /// </li> </ul>
        /// </remarks>
        /// <doc-id>ee690176</doc-id>
        /// <unmanaged>HRESULT IWICBitmapSourceTransform::GetClosestSize([InOut] unsigned int* puiWidth,[InOut] unsigned int* puiHeight)</unmanaged>
        /// <unmanaged-short>IWICBitmapSourceTransform::GetClosestSize</unmanaged-short>
        internal unsafe void GetClosestSize(ref System.Int32 widthRef, ref System.Int32 heightRef)
        {
            SharpDX.Result __result__;
            fixed (void *heightRef_ = &heightRef)
                fixed (void *widthRef_ = &widthRef)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, widthRef_, heightRef_, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the closest pixel format to which the implementation of <strong><see cref = "SharpDX.WIC.BitmapSourceTransform"/></strong> can natively copy pixels, given a desired format.</p>
        /// </summary>
        /// <param name = "guidDstFormatRef">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The Windows provided codecs provide the following support:</p><ul> <li>BMP, ICO, GIF, TIFF: No implementation of <strong><see cref = "SharpDX.WIC.BitmapSourceTransform"/></strong>.</li> <li>JPEG, PNG, JPEG-XR: Trivial support (always returns the same value as <strong>IWICBitmapFrameDecode::GetPixelFormat</strong>).</li> </ul>
        /// </remarks>
        /// <doc-id>ee690175</doc-id>
        /// <unmanaged>HRESULT IWICBitmapSourceTransform::GetClosestPixelFormat([InOut] GUID* pguidDstFormat)</unmanaged>
        /// <unmanaged-short>IWICBitmapSourceTransform::GetClosestPixelFormat</unmanaged-short>
        public unsafe void GetClosestPixelFormat(ref System.Guid guidDstFormatRef)
        {
            SharpDX.Result __result__;
            fixed (void *guidDstFormatRef_ = &guidDstFormatRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, guidDstFormatRef_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Determines whether a specific transform option is supported natively by the implementation of the <strong><see cref = "SharpDX.WIC.BitmapSourceTransform"/></strong> interface.</p>
        /// </summary>
        /// <param name = "dstTransform">No documentation.</param>
        /// <param name = "fIsSupportedRef">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The Windows provided codecs provide the following level of support:</p><ul> <li>BMP, ICO, GIF, TIFF: No implementation of <see cref = "SharpDX.WIC.BitmapSourceTransform"/>.</li> <li>JPEG, PNG: Trivial support (WICBitmapTransformRotate0 only).</li> <li>JPEG-XR: Support for all transformation/rotations.
        /// </li> </ul>
        /// </remarks>
        /// <doc-id>ee690174</doc-id>
        /// <unmanaged>HRESULT IWICBitmapSourceTransform::DoesSupportTransform([In] WICBitmapTransformOptions dstTransform,[Out] BOOL* pfIsSupported)</unmanaged>
        /// <unmanaged-short>IWICBitmapSourceTransform::DoesSupportTransform</unmanaged-short>
        public unsafe void IsSupportingTransform(SharpDX.WIC.BitmapTransformOptions dstTransform, out SharpDX.Mathematics.Interop.RawBool fIsSupportedRef)
        {
            fIsSupportedRef = default (SharpDX.Mathematics.Interop.RawBool);
            SharpDX.Result __result__;
            fixed (void *fIsSupportedRef_ = &fIsSupportedRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)dstTransform), fIsSupportedRef_, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("3C613A02-34B2-44ea-9A7C-45AEA9C6FD6D")]
    public partial class ColorContext : SharpDX.ComObject
    {
        public ColorContext(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ColorContext(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ColorContext(nativePtr);
        /// <summary>
        /// <p>Retrieves the color context type.</p>
        /// </summary>
        /// <doc-id>ee690196</doc-id>
        /// <unmanaged>GetType</unmanaged>
        /// <unmanaged-short>GetType</unmanaged-short>
        public SharpDX.WIC.ColorContextType TypeInfo
        {
            get
            {
                GetTypeInfo(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Retrieves the Exchangeable Image File (EXIF) color space color context.</p>
        /// </summary>
        /// <remarks>
        /// <p>This method should only be used when <strong>IWICColorContext::GetType</strong> indicates <strong>WICColorContextExifColorSpace</strong>.
        /// </p>
        /// </remarks>
        /// <doc-id>ee690194</doc-id>
        /// <unmanaged>GetExifColorSpace</unmanaged>
        /// <unmanaged-short>GetExifColorSpace</unmanaged-short>
        public System.Int32 ExifColorSpace
        {
            get
            {
                GetExifColorSpace(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Initializes the color context from the given file.</p>
        /// </summary>
        /// <param name = "filename"><dd>  <p>The name of the file.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Once a color context has been initialized, it can't be re-initialized.
        /// </p>
        /// </remarks>
        /// <doc-id>ee690198</doc-id>
        /// <unmanaged>HRESULT IWICColorContext::InitializeFromFilename([In] const wchar_t* wzFilename)</unmanaged>
        /// <unmanaged-short>IWICColorContext::InitializeFromFilename</unmanaged-short>
        public unsafe void InitializeFromFilename(System.String filename)
        {
            SharpDX.Result __result__;
            fixed (char *filename_ = filename)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)filename_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Initializes the color context from a memory block.</p>
        /// </summary>
        /// <param name = "bufferRef"><dd>  <p>The buffer used to initialize the <strong><see cref = "SharpDX.WIC.ColorContext"/></strong>.</p> </dd></param>
        /// <param name = "bufferSize"><dd>  <p>The size of the <em>pbBuffer</em> buffer.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Once a color context has been initialized, it can't be re-initialized.
        /// </p>
        /// </remarks>
        /// <doc-id>ee690199</doc-id>
        /// <unmanaged>HRESULT IWICColorContext::InitializeFromMemory([In] const unsigned char* pbBuffer,[In] unsigned int cbBufferSize)</unmanaged>
        /// <unmanaged-short>IWICColorContext::InitializeFromMemory</unmanaged-short>
        internal unsafe void InitializeFromMemory(System.IntPtr bufferRef, System.Int32 bufferSize)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)bufferRef, bufferSize, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Initializes the color context using an Exchangeable Image File (EXIF) color space.</p>
        /// </summary>
        /// <param name = "value"><dd>  <p>The value of the EXIF color space.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong></strong></dt> <dt>1</dt> </dl> </td><td> <p>A sRGB color space.</p> </td></tr> <tr><td><dl> <dt><strong></strong></dt> <dt>2</dt> </dl> </td><td> <p>An Adobe RGB color space.</p> </td></tr> </table> <p>?</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Once a color context has been initialized, it can't be re-initialized.
        /// </p>
        /// </remarks>
        /// <doc-id>ee690197</doc-id>
        /// <unmanaged>HRESULT IWICColorContext::InitializeFromExifColorSpace([In] unsigned int value)</unmanaged>
        /// <unmanaged-short>IWICColorContext::InitializeFromExifColorSpace</unmanaged-short>
        public unsafe void InitializeFromExifColorSpace(System.Int32 value)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, value, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the color context type.</p>
        /// </summary>
        /// <param name = "typeRef"><dd>  <p>A reference that receives the <strong><see cref = "SharpDX.WIC.ColorContextType"/></strong> of the color context.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690196</doc-id>
        /// <unmanaged>HRESULT IWICColorContext::GetType([Out] WICColorContextType* pType)</unmanaged>
        /// <unmanaged-short>IWICColorContext::GetType</unmanaged-short>
        internal unsafe void GetTypeInfo(out SharpDX.WIC.ColorContextType typeRef)
        {
            SharpDX.Result __result__;
            fixed (void *typeRef_ = &typeRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, typeRef_, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the color context profile.</p>
        /// </summary>
        /// <param name = "buffer"><dd>  <p>The size of the <em>pbBuffer</em> buffer.</p> </dd></param>
        /// <param name = "bufferRef"><dd>  <p>A reference that receives the color context profile.</p> </dd></param>
        /// <param name = "actualRef"><dd>  <p>A reference that receives the actual buffer size needed to retrieve the entire color context profile.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Only use this method if the context type is <strong>WICColorContextProfile</strong>.
        /// </p><p>Calling this method with <em>pbBuffer</em> set to <strong><c>null</c></strong> will cause it to return the required buffer size in <em>pcbActual</em>.
        /// </p>
        /// </remarks>
        /// <doc-id>ee690195</doc-id>
        /// <unmanaged>HRESULT IWICColorContext::GetProfileBytes([In] unsigned int cbBuffer,[In] unsigned char* pbBuffer,[Out] unsigned int* pcbActual)</unmanaged>
        /// <unmanaged-short>IWICColorContext::GetProfileBytes</unmanaged-short>
        internal unsafe void GetProfileBytes(System.Int32 buffer, System.IntPtr bufferRef, out System.Int32 actualRef)
        {
            SharpDX.Result __result__;
            fixed (void *actualRef_ = &actualRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, buffer, (void *)bufferRef, actualRef_, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the Exchangeable Image File (EXIF) color space color context.</p>
        /// </summary>
        /// <param name = "valueRef"><dd>  <p>A reference that receives the EXIF color space color context.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong></strong></dt> <dt>1</dt> </dl> </td><td> <p>A sRGB color space.</p> </td></tr> <tr><td><dl> <dt><strong></strong></dt> <dt>2</dt> </dl> </td><td> <p>An Adobe RGB color space.</p> </td></tr> <tr><td><dl> <dt><strong></strong></dt> <dt>3 through 65534</dt> </dl> </td><td> <p>Unused.</p> </td></tr> </table> <p>?</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>This method should only be used when <strong>IWICColorContext::GetType</strong> indicates <strong>WICColorContextExifColorSpace</strong>.
        /// </p>
        /// </remarks>
        /// <doc-id>ee690194</doc-id>
        /// <unmanaged>HRESULT IWICColorContext::GetExifColorSpace([Out] unsigned int* pValue)</unmanaged>
        /// <unmanaged-short>IWICColorContext::GetExifColorSpace</unmanaged-short>
        internal unsafe void GetExifColorSpace(out System.Int32 valueRef)
        {
            SharpDX.Result __result__;
            fixed (void *valueRef_ = &valueRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, valueRef_, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("B66F034F-D0E2-40ab-B436-6DE39E321A94")]
    public partial class ColorTransform : SharpDX.WIC.BitmapSource
    {
        public ColorTransform(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ColorTransform(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ColorTransform(nativePtr);
        /// <summary>
        /// <p>Initializes an <strong><see cref = "SharpDX.WIC.ColorTransform"/></strong> with a <strong><see cref = "SharpDX.WIC.BitmapSource"/></strong> and transforms it from one <strong><see cref = "SharpDX.WIC.ColorContext"/></strong> to another. </p>
        /// </summary>
        /// <param name = "bitmapSourceRef">No documentation.</param>
        /// <param name = "contextSourceRef">No documentation.</param>
        /// <param name = "contextDestRef">No documentation.</param>
        /// <param name = "ixelFmtDestRef">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The currently supported formats for the <em>pIContextSource</em> and <em>pixelFmtDest</em> parameters are: 
        /// </p><ul> <li><see cref = "Format8bppGray"/></li> <li><see cref = "Format16bppGray"/></li> <li><see cref = "Format16bppBGR555"/></li> <li><see cref = "Format16bppBGR565"/></li> <li><see cref = "Format24bppBGR"/></li> <li><see cref = "Format24bppRGB"/></li> <li><see cref = "Format32bppBGR"/></li> <li><see cref = "Format32bppBGRA"/></li> <li><see cref = "Format32bppPBGRA"/></li> <li><see cref = "Format32bppPRGBA"/> (Windows?8 and later)</li> <li><see cref = "Format32bppRGBA"/></li> <li><see cref = "Format32bppBGR101010"/></li> <li><see cref = "Format32bppCMYK"/></li> <li><see cref = "Format48bppBGR"/></li> <li><see cref = "Format64bppBGRA"/> 		(Windows?8 and later)</li> <li> <see cref = "Format64bppPBGRA"/> (Windows?8 and later)</li> <li> <see cref = "Format64bppPRGBA"/> (Windows?8 and later)</li> <li> <see cref = "Format64bppRGBA"/> 		 (Windows?8 and later)</li> </ul><p>In order to get correct behavior from a color transform, the input and output pixel formats must be compatible with the source and destination color profiles. For example, an sRGB destination color profile will produce incorrect results when used with a CMYK destination pixel format.</p>
        /// </remarks>
        /// <doc-id>ee690202</doc-id>
        /// <unmanaged>HRESULT IWICColorTransform::Initialize([In, Optional] IWICBitmapSource* pIBitmapSource,[In, Optional] IWICColorContext* pIContextSource,[In, Optional] IWICColorContext* pIContextDest,[In] const GUID&amp; pixelFmtDest)</unmanaged>
        /// <unmanaged-short>IWICColorTransform::Initialize</unmanaged-short>
        public unsafe void Initialize(SharpDX.WIC.BitmapSource bitmapSourceRef, SharpDX.WIC.ColorContext contextSourceRef, SharpDX.WIC.ColorContext contextDestRef, System.Guid ixelFmtDestRef)
        {
            System.IntPtr bitmapSourceRef_ = System.IntPtr.Zero;
            System.IntPtr contextSourceRef_ = System.IntPtr.Zero;
            System.IntPtr contextDestRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            bitmapSourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.BitmapSource>(bitmapSourceRef);
            contextSourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.ColorContext>(contextSourceRef);
            contextDestRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.ColorContext>(contextDestRef);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)bitmapSourceRef_, (void *)contextSourceRef_, (void *)contextDestRef_, &ixelFmtDestRef, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("23BC3F0A-698B-4357-886B-F24D50671334")]
    public partial class ComponentInfo : SharpDX.ComObject
    {
        public ComponentInfo(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ComponentInfo(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ComponentInfo(nativePtr);
        /// <summary>
        /// <p>Retrieves the component's <strong><see cref = "SharpDX.WIC.ComponentType"/></strong>.</p>
        /// </summary>
        /// <doc-id>ee690218</doc-id>
        /// <unmanaged>GetComponentType</unmanaged>
        /// <unmanaged-short>GetComponentType</unmanaged-short>
        public SharpDX.WIC.ComponentType ComponentType
        {
            get
            {
                GetComponentType(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Proxy function for the <strong>GetCLSID</strong> method.</p>
        /// </summary>
        /// <doc-id>ee690217</doc-id>
        /// <unmanaged>GetCLSID</unmanaged>
        /// <unmanaged-short>GetCLSID</unmanaged-short>
        public System.Guid CLSID
        {
            get
            {
                GetCLSID(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Retrieves the signing status of the component.</p>
        /// </summary>
        /// <remarks>
        /// <p>Signing is unused by WIC. Therefore, all components WICComponentSigned.</p><p>This function can be used to determine whether a component has no binary component or has been added to the disabled components list in the registry.</p>
        /// </remarks>
        /// <doc-id>ee690221</doc-id>
        /// <unmanaged>GetSigningStatus</unmanaged>
        /// <unmanaged-short>GetSigningStatus</unmanaged-short>
        public System.Int32 SigningStatus
        {
            get
            {
                GetSigningStatus(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Retrieves the vendor <see cref = "System.Guid"/>.</p>
        /// </summary>
        /// <doc-id>ee690225</doc-id>
        /// <unmanaged>GetVendorGUID</unmanaged>
        /// <unmanaged-short>GetVendorGUID</unmanaged-short>
        public System.Guid VendorGUID
        {
            get
            {
                GetVendorGUID(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Retrieves the component's <strong><see cref = "SharpDX.WIC.ComponentType"/></strong>.</p>
        /// </summary>
        /// <param name = "typeRef">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690218</doc-id>
        /// <unmanaged>HRESULT IWICComponentInfo::GetComponentType([Out] WICComponentType* pType)</unmanaged>
        /// <unmanaged-short>IWICComponentInfo::GetComponentType</unmanaged-short>
        internal unsafe void GetComponentType(out SharpDX.WIC.ComponentType typeRef)
        {
            SharpDX.Result __result__;
            fixed (void *typeRef_ = &typeRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, typeRef_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Proxy function for the <strong>GetCLSID</strong> method.</p>
        /// </summary>
        /// <param name = "clsidRef">No documentation.</param>
        /// <returns><p>If this function succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690217</doc-id>
        /// <unmanaged>HRESULT IWICComponentInfo::GetCLSID([Out] GUID* pclsid)</unmanaged>
        /// <unmanaged-short>IWICComponentInfo::GetCLSID</unmanaged-short>
        internal unsafe void GetCLSID(out System.Guid clsidRef)
        {
            clsidRef = default (System.Guid);
            SharpDX.Result __result__;
            fixed (void *clsidRef_ = &clsidRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, clsidRef_, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the signing status of the component.</p>
        /// </summary>
        /// <param name = "statusRef"><dd>  <p>A reference that receives the <strong><see cref = "SharpDX.WIC.ComponentSigning"/></strong> status of the component.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Signing is unused by WIC. Therefore, all components WICComponentSigned.</p><p>This function can be used to determine whether a component has no binary component or has been added to the disabled components list in the registry.</p>
        /// </remarks>
        /// <doc-id>ee690221</doc-id>
        /// <unmanaged>HRESULT IWICComponentInfo::GetSigningStatus([Out] DWORD* pStatus)</unmanaged>
        /// <unmanaged-short>IWICComponentInfo::GetSigningStatus</unmanaged-short>
        internal unsafe void GetSigningStatus(out System.Int32 statusRef)
        {
            SharpDX.Result __result__;
            fixed (void *statusRef_ = &statusRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, statusRef_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the name of component's author.</p>
        /// </summary>
        /// <param name = "cchAuthor"><dd>  <p>The size of the <em>wzAuthor</em> buffer.</p> </dd></param>
        /// <param name = "author"><dd>  <p>A reference that receives the name of the component's author. The locale of the string depends on the value that the codec wrote to the registry at install time. For built-in components, these strings are always in English.</p> </dd></param>
        /// <param name = "cchActualRef"><dd>  <p>A reference that receives the actual length of the component's authors name. The author name is optional; if an author name is not specified by the component, the length returned is 0.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>If <em>cchAuthor</em> is 0 and <em>wzAuthor</em> is <strong><c>null</c></strong>, the required buffer size is returned in <em>pccchActual</em>.</p>
        /// </remarks>
        /// <doc-id>ee690214</doc-id>
        /// <unmanaged>HRESULT IWICComponentInfo::GetAuthor([In] unsigned int cchAuthor,[In] wchar_t* wzAuthor,[Out] unsigned int* pcchActual)</unmanaged>
        /// <unmanaged-short>IWICComponentInfo::GetAuthor</unmanaged-short>
        internal unsafe void GetAuthor(System.Int32 cchAuthor, System.IntPtr author, out System.Int32 cchActualRef)
        {
            SharpDX.Result __result__;
            fixed (void *cchActualRef_ = &cchActualRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, cchAuthor, (void *)author, cchActualRef_, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the vendor <see cref = "System.Guid"/>.</p>
        /// </summary>
        /// <param name = "guidVendorRef"><dd>  <p>A reference that receives the component's vendor <see cref = "System.Guid"/>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690225</doc-id>
        /// <unmanaged>HRESULT IWICComponentInfo::GetVendorGUID([Out] GUID* pguidVendor)</unmanaged>
        /// <unmanaged-short>IWICComponentInfo::GetVendorGUID</unmanaged-short>
        internal unsafe void GetVendorGUID(out System.Guid guidVendorRef)
        {
            guidVendorRef = default (System.Guid);
            SharpDX.Result __result__;
            fixed (void *guidVendorRef_ = &guidVendorRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, guidVendorRef_, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Proxy function for the <strong>GetVersion</strong> method.</p>
        /// </summary>
        /// <param name = "cchVersion">No documentation.</param>
        /// <param name = "version">No documentation.</param>
        /// <param name = "cchActualRef">No documentation.</param>
        /// <returns><p>If this function succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690227</doc-id>
        /// <unmanaged>HRESULT IWICComponentInfo::GetVersion([In] unsigned int cchVersion,[In] wchar_t* wzVersion,[Out] unsigned int* pcchActual)</unmanaged>
        /// <unmanaged-short>IWICComponentInfo::GetVersion</unmanaged-short>
        internal unsafe void GetVersion(System.Int32 cchVersion, System.IntPtr version, out System.Int32 cchActualRef)
        {
            SharpDX.Result __result__;
            fixed (void *cchActualRef_ = &cchActualRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, cchVersion, (void *)version, cchActualRef_, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the component's specification version.</p>
        /// </summary>
        /// <param name = "cchSpecVersion"><dd>  <p>The size of the <em>wzSpecVersion</em> buffer.</p> </dd></param>
        /// <param name = "specVersion"><dd>  <p>When this method returns, contain a culture invarient string of the component's specification version. The version form is NN.NN.NN.NN.</p> </dd></param>
        /// <param name = "cchActualRef"><dd>  <p>A reference that receives the actual length of the component's specification version. The specification version is optional; if a value is not specified by the component, the length returned is 0.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>All built-in components return "1.0.0.0", except for pixel formats, which do not have a spec version.</p><p>If <em>cchAuthor</em> is 0 and <em>wzAuthor</em> is <strong><c>null</c></strong>, the required buffer size is returned in <em>pccchActual</em>.</p>
        /// </remarks>
        /// <doc-id>ee690223</doc-id>
        /// <unmanaged>HRESULT IWICComponentInfo::GetSpecVersion([In] unsigned int cchSpecVersion,[In] wchar_t* wzSpecVersion,[Out] unsigned int* pcchActual)</unmanaged>
        /// <unmanaged-short>IWICComponentInfo::GetSpecVersion</unmanaged-short>
        internal unsafe void GetSpecVersion(System.Int32 cchSpecVersion, System.IntPtr specVersion, out System.Int32 cchActualRef)
        {
            SharpDX.Result __result__;
            fixed (void *cchActualRef_ = &cchActualRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, cchSpecVersion, (void *)specVersion, cchActualRef_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the component's friendly name, which is a human-readable display name for the component.</p>
        /// </summary>
        /// <param name = "cchFriendlyName"><dd>  <p>The size of the <em>wzFriendlyName</em> buffer.</p> </dd></param>
        /// <param name = "friendlyName"><dd>  <p>A reference that receives the friendly name of the component. The locale of the string depends on the value that the codec wrote to the registry at install time. For built-in components, these strings are always in English.</p> </dd></param>
        /// <param name = "cchActualRef"><dd>  <p>A reference that receives the actual length of the component's friendly name.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>If <em>cchFriendlyName</em> is 0 and <em>wzFriendlyName</em> is <strong><c>null</c></strong>, the required buffer size is returned in <em>pccchActual</em>.</p>
        /// </remarks>
        /// <doc-id>ee690219</doc-id>
        /// <unmanaged>HRESULT IWICComponentInfo::GetFriendlyName([In] unsigned int cchFriendlyName,[In] wchar_t* wzFriendlyName,[Out] unsigned int* pcchActual)</unmanaged>
        /// <unmanaged-short>IWICComponentInfo::GetFriendlyName</unmanaged-short>
        internal unsafe void GetFriendlyName(System.Int32 cchFriendlyName, System.IntPtr friendlyName, out System.Int32 cchActualRef)
        {
            SharpDX.Result __result__;
            fixed (void *cchActualRef_ = &cchActualRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, cchFriendlyName, (void *)friendlyName, cchActualRef_, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("409cd537-8532-40cb-9774-e2feb2df4e9c")]
    public partial class DdsDecoder : SharpDX.ComObject
    {
        public DdsDecoder(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DdsDecoder(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DdsDecoder(nativePtr);
        /// <summary>
        /// <p>Gets DDS-specific data.</p>
        /// </summary>
        /// <doc-id>dn302081</doc-id>
        /// <unmanaged>GetParameters</unmanaged>
        /// <unmanaged-short>GetParameters</unmanaged-short>
        public SharpDX.WIC.DdsParameters Parameters
        {
            get
            {
                GetParameters(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets DDS-specific data.</p>
        /// </summary>
        /// <param name = "parametersRef"><dd>  <p>A reference to the structure where the information is returned.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn302081</doc-id>
        /// <unmanaged>HRESULT IWICDdsDecoder::GetParameters([Out] WICDdsParameters* pParameters)</unmanaged>
        /// <unmanaged-short>IWICDdsDecoder::GetParameters</unmanaged-short>
        internal unsafe void GetParameters(out SharpDX.WIC.DdsParameters parametersRef)
        {
            parametersRef = default (SharpDX.WIC.DdsParameters);
            SharpDX.Result __result__;
            fixed (void *parametersRef_ = &parametersRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, parametersRef_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the specified frame of the DDS image.</p>
        /// </summary>
        /// <param name = "arrayIndex"><dd>  <p> The requested index within the texture array.</p> </dd></param>
        /// <param name = "mipLevel"><dd>  <p> The requested mip level.</p> </dd></param>
        /// <param name = "sliceIndex"><dd>  <p>The requested slice within the 3D texture.</p> </dd></param>
        /// <param name = "bitmapFrameOut"><dd>  <p>A reference to a  <strong><see cref = "SharpDX.WIC.BitmapFrameDecode"/></strong> object.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>A DDS file can contain multiple images that are organized into a three level hierarchy. First, DDS file may contain multiple textures in a texture array. Second, each texture can have multiple mip levels. Finally, the texture may be a 3D (volume) texture and have multiple slices, each of which is a 2D texture. See the DDS documentation for more information.</p><p>WIC maps this three level hierarchy into a linear array of <strong><see cref = "SharpDX.WIC.BitmapFrameDecode"/></strong>, accessible via <strong>IWICBitmapDecoder::GetFrame</strong>. However, determining which frame corresponds to a triad of <em>arrayIndex</em>, <em>mipLevel</em>, and <em>sliceIndex</em> value is not trivial because each mip level of a 3D texture has a different depth (number of slices). This method provides additional convenience over <strong>IWICBitmapDecoder::GetFrame</strong> for DDS images by calculating the correct frame given the three indices.
        /// </p>
        /// </remarks>
        /// <doc-id>dn302080</doc-id>
        /// <unmanaged>HRESULT IWICDdsDecoder::GetFrame([In] unsigned int arrayIndex,[In] unsigned int mipLevel,[In] unsigned int sliceIndex,[Out] IWICBitmapFrameDecode** ppIBitmapFrame)</unmanaged>
        /// <unmanaged-short>IWICDdsDecoder::GetFrame</unmanaged-short>
        public unsafe void GetFrame(System.Int32 arrayIndex, System.Int32 mipLevel, System.Int32 sliceIndex, out SharpDX.WIC.BitmapFrameDecode bitmapFrameOut)
        {
            System.IntPtr bitmapFrameOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, arrayIndex, mipLevel, sliceIndex, &bitmapFrameOut_, (*(void ***)this._nativePointer)[4]);
            if (bitmapFrameOut_ != System.IntPtr.Zero)
                bitmapFrameOut = new SharpDX.WIC.BitmapFrameDecode(bitmapFrameOut_);
            else
                bitmapFrameOut = null;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("5cacdb4c-407e-41b3-b936-d0f010cd6732")]
    public partial class DdsEncoder : SharpDX.ComObject
    {
        public DdsEncoder(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DdsEncoder(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DdsEncoder(nativePtr);
        /// <summary>
        /// <p>Gets or sets DDS-specific data.</p>
        /// </summary>
        /// <remarks>
        /// <p>An application can call <strong>GetParameters</strong> to obtain the default DDS parameters, modify some or all of them, and then call <strong>SetParameters</strong>.</p>
        /// </remarks>
        /// <doc-id>dn302084</doc-id>
        /// <unmanaged>GetParameters / SetParameters</unmanaged>
        /// <unmanaged-short>GetParameters</unmanaged-short>
        public SharpDX.WIC.DdsParameters Parameters
        {
            get
            {
                GetParameters(out var __output__);
                return __output__;
            }

            set => SetParameters(ref value);
        }

        /// <summary>
        /// <p>Sets DDS-specific data.</p>
        /// </summary>
        /// <param name = "parametersRef"><dd>  <p>Points to the structure where the information is described.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>You cannot call this method after you have started to write frame data, for example by calling <strong>IWICDdsEncoder::CreateNewFrame</strong>. </p><p>Setting DDS parameters using this method provides the DDS encoder with information about the expected number of frames and the dimensions and other parameters of each frame. The DDS encoder will fail if you do not set frame data that matches these expectations. For example, if you set <strong>WICDdsParameters::Width</strong> and <strong>Height</strong> to 32, and <strong>MipLevels</strong> to 6, the DDS encoder will expect 6 frames with the following dimensions:</p><ul> <li>32x32 pixels.</li> <li>16x16 pixels.</li> <li>8x8 pixels.</li> <li>4x4 pixels.</li> <li>2x2 pixels.</li> <li>1x1 pixels.</li> </ul>
        /// </remarks>
        /// <doc-id>dn302085</doc-id>
        /// <unmanaged>HRESULT IWICDdsEncoder::SetParameters([In] WICDdsParameters* pParameters)</unmanaged>
        /// <unmanaged-short>IWICDdsEncoder::SetParameters</unmanaged-short>
        internal unsafe void SetParameters(ref SharpDX.WIC.DdsParameters parametersRef)
        {
            SharpDX.Result __result__;
            fixed (void *parametersRef_ = &parametersRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, parametersRef_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets DDS-specific data.</p>
        /// </summary>
        /// <param name = "parametersRef"><dd>  <p>Points to the structure where the information is returned.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>An application can call <strong>GetParameters</strong> to obtain the default DDS parameters, modify some or all of them, and then call <strong>SetParameters</strong>.</p>
        /// </remarks>
        /// <doc-id>dn302084</doc-id>
        /// <unmanaged>HRESULT IWICDdsEncoder::GetParameters([Out] WICDdsParameters* pParameters)</unmanaged>
        /// <unmanaged-short>IWICDdsEncoder::GetParameters</unmanaged-short>
        internal unsafe void GetParameters(out SharpDX.WIC.DdsParameters parametersRef)
        {
            parametersRef = default (SharpDX.WIC.DdsParameters);
            SharpDX.Result __result__;
            fixed (void *parametersRef_ = &parametersRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, parametersRef_, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a new frame to encode.</p>
        /// </summary>
        /// <param name = "frameEncodeOut"><dd> <p>A reference to the newly created frame object.</p> </dd></param>
        /// <param name = "arrayIndexRef"><dd> <p>Points to the location where the array index is returned.</p> </dd></param>
        /// <param name = "mipLevelRef"><dd> <p>Points to the location where the mip level index is returned.</p> </dd></param>
        /// <param name = "sliceIndexRef"><dd> <p>Points to the location where the slice index is returned.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>This is equivalent to <strong>IWICBitmapEncoder::CreateNewFrame</strong>, but returns additional information about the array index, mip level and slice of the newly created frame. In contrast to <strong>IWICBitmapEncoder::CreateNewFrame</strong>, there is no <strong><see cref = "SharpDX.Win32.PropertyBag"/></strong>* parameter because individual DDS frames do not have separate properties.</p>
        /// </remarks>
        /// <doc-id>dn302083</doc-id>
        /// <unmanaged>HRESULT IWICDdsEncoder::CreateNewFrame([Out] IWICBitmapFrameEncode** ppIFrameEncode,[Out] unsigned int* pArrayIndex,[Out] unsigned int* pMipLevel,[Out] unsigned int* pSliceIndex)</unmanaged>
        /// <unmanaged-short>IWICDdsEncoder::CreateNewFrame</unmanaged-short>
        public unsafe void CreateNewFrame(out SharpDX.WIC.BitmapFrameEncode frameEncodeOut, out System.Int32 arrayIndexRef, out System.Int32 mipLevelRef, out System.Int32 sliceIndexRef)
        {
            System.IntPtr frameEncodeOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *sliceIndexRef_ = &sliceIndexRef)
                fixed (void *mipLevelRef_ = &mipLevelRef)
                    fixed (void *arrayIndexRef_ = &arrayIndexRef)
                        __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &frameEncodeOut_, arrayIndexRef_, mipLevelRef_, sliceIndexRef_, (*(void ***)this._nativePointer)[5]);
            if (frameEncodeOut_ != System.IntPtr.Zero)
                frameEncodeOut = new SharpDX.WIC.BitmapFrameEncode(frameEncodeOut_);
            else
                frameEncodeOut = null;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("3d4c0c61-18a4-41e4-bd80-481a4fc9f464")]
    public partial class DdsFrameDecode : SharpDX.ComObject
    {
        public DdsFrameDecode(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DdsFrameDecode(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DdsFrameDecode(nativePtr);
        /// <summary>
        /// <p>Gets information about the format in which the DDS image is stored.</p>
        /// </summary>
        /// <remarks>
        /// <p>This information can be used for allocating memory or constructing Direct3D or Direct2D resources, for example by using <strong>ID3D11Device::CreateTexture2D</strong> or <strong>ID2D1DeviceContext::CreateBitmap</strong>.</p>
        /// </remarks>
        /// <doc-id>dn302088</doc-id>
        /// <unmanaged>GetFormatInfo</unmanaged>
        /// <unmanaged-short>GetFormatInfo</unmanaged-short>
        public SharpDX.WIC.DdsFormatInfo FormatInfo
        {
            get
            {
                GetFormatInfo(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the width and height, in blocks, of the DDS image.</p>
        /// </summary>
        /// <param name = "widthInBlocksRef"><dd>  <p>The width of the DDS image in blocks.</p> </dd></param>
        /// <param name = "heightInBlocksRef"><dd>  <p>The height of the DDS image in blocks.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>For block compressed textures, the returned width and height values do not completely define the texture size because the image is padded to fit the closest whole block size. For example, three BC1 textures with pixel dimensions of 1x1, 2x2 and 4x4 will all report <em>pWidthInBlocks</em> = 1 and <em>pHeightInBlocks</em> = 1. </p><p>If the texture does not use a block-compressed <strong><see cref = "SharpDX.DXGI.Format"/></strong>, this method returns the texture size in pixels; for these formats the block size returned by <strong>IWICDdsFrameDecoder::GetFormatInfo</strong> is 1x1.
        /// </p>
        /// </remarks>
        /// <doc-id>dn302089</doc-id>
        /// <unmanaged>HRESULT IWICDdsFrameDecode::GetSizeInBlocks([Out] unsigned int* pWidthInBlocks,[Out] unsigned int* pHeightInBlocks)</unmanaged>
        /// <unmanaged-short>IWICDdsFrameDecode::GetSizeInBlocks</unmanaged-short>
        internal unsafe void GetSizeInBlocks(out System.Int32 widthInBlocksRef, out System.Int32 heightInBlocksRef)
        {
            SharpDX.Result __result__;
            fixed (void *heightInBlocksRef_ = &heightInBlocksRef)
                fixed (void *widthInBlocksRef_ = &widthInBlocksRef)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, widthInBlocksRef_, heightInBlocksRef_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets information about the format in which the DDS image is stored.</p>
        /// </summary>
        /// <param name = "formatInfoRef"><dd>  <p>Information about the DDS format.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>This information can be used for allocating memory or constructing Direct3D or Direct2D resources, for example by using <strong>ID3D11Device::CreateTexture2D</strong> or <strong>ID2D1DeviceContext::CreateBitmap</strong>.</p>
        /// </remarks>
        /// <doc-id>dn302088</doc-id>
        /// <unmanaged>HRESULT IWICDdsFrameDecode::GetFormatInfo([Out] WICDdsFormatInfo* pFormatInfo)</unmanaged>
        /// <unmanaged-short>IWICDdsFrameDecode::GetFormatInfo</unmanaged-short>
        internal unsafe void GetFormatInfo(out SharpDX.WIC.DdsFormatInfo formatInfoRef)
        {
            formatInfoRef = default (SharpDX.WIC.DdsFormatInfo);
            SharpDX.Result __result__;
            fixed (void *formatInfoRef_ = &formatInfoRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, formatInfoRef_, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Requests pixel data as it is natively stored within the DDS file.</p>
        /// </summary>
        /// <param name = "rcBoundsInBlocksRef"><dd>  <p>The rectangle to copy from the source. A <c>null</c> value specifies the entire texture.</p> <p>If the texture uses a block-compressed <strong><see cref = "SharpDX.DXGI.Format"/></strong>, all values of the rectangle are expressed in number of blocks, not pixels.</p> </dd></param>
        /// <param name = "stride"><dd>  <p>The stride, in bytes, of the destination buffer. This represents the number of bytes from the buffer reference to the next row of data. If the texture uses a block-compressed <strong><see cref = "SharpDX.DXGI.Format"/></strong>, a "row of data" is defined as a row of blocks which contains multiple pixel scanlines.</p> </dd></param>
        /// <param name = "bufferSize"><dd>  <p>The size, in bytes, of the destination buffer.</p> </dd></param>
        /// <param name = "bufferRef"><dd>  <p>A reference to the destination buffer.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>If the texture does not use a block-compressed <strong><see cref = "SharpDX.DXGI.Format"/></strong>, this method behaves similarly to <strong>IWICBitmapSource::CopyPixels</strong>. However, it does not perform any pixel format conversion, and instead produces the raw data from the DDS file.</p><p>If the texture uses a block-compressed <strong><see cref = "SharpDX.DXGI.Format"/></strong>, this method copies the block data directly into the provided buffer. In this case, the <em>prcBoundsInBlocks</em> parameter is defined in blocks, not pixels. To determine if this is the case, call <strong>GetFormatInfo</strong> and read the <strong>DxgiFormat</strong> member of the returned <strong><see cref = "SharpDX.WIC.DdsFormatInfo"/></strong> structure.
        /// </p>
        /// </remarks>
        /// <doc-id>dn302087</doc-id>
        /// <unmanaged>HRESULT IWICDdsFrameDecode::CopyBlocks([In, Optional] const WICRect* prcBoundsInBlocks,[In] unsigned int cbStride,[In] unsigned int cbBufferSize,[In] unsigned char* pbBuffer)</unmanaged>
        /// <unmanaged-short>IWICDdsFrameDecode::CopyBlocks</unmanaged-short>
        internal unsafe void CopyBlocks(SharpDX.Mathematics.Interop.RawBox? rcBoundsInBlocksRef, System.Int32 stride, System.Int32 bufferSize, System.IntPtr bufferRef)
        {
            SharpDX.Mathematics.Interop.RawBox rcBoundsInBlocksRef_;
            SharpDX.Result __result__;
            if (rcBoundsInBlocksRef != null)
                rcBoundsInBlocksRef_ = rcBoundsInBlocksRef.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, rcBoundsInBlocksRef == null ? (void *)0 : &rcBoundsInBlocksRef_, stride, bufferSize, (void *)bufferRef, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("fbec5e44-f7be-4b65-b7f8-c0c81fef026d")]
    public partial class DevelopRaw : SharpDX.WIC.BitmapFrameDecode
    {
        public DevelopRaw(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DevelopRaw(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DevelopRaw(nativePtr);
        /// <summary>
        /// <p>Gets the current set of parameters.</p>
        /// </summary>
        /// <doc-id>ee690233</doc-id>
        /// <unmanaged>GetCurrentParameterSet</unmanaged>
        /// <unmanaged-short>GetCurrentParameterSet</unmanaged-short>
        public SharpDX.Win32.PropertyBag CurrentParameterSet
        {
            get
            {
                GetCurrentParameterSet(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets or sets the exposure compensation stop value of the raw image.</p>
        /// </summary>
        /// <doc-id>ee690234</doc-id>
        /// <unmanaged>GetExposureCompensation / SetExposureCompensation</unmanaged>
        /// <unmanaged-short>GetExposureCompensation</unmanaged-short>
        public System.Double ExposureCompensation
        {
            get
            {
                GetExposureCompensation(out var __output__);
                return __output__;
            }

            set => SetExposureCompensation(value);
        }

        /// <summary>
        /// <p>Gets or sets the named white point of the raw image.</p>
        /// </summary>
        /// <remarks>
        /// <p>If the named white points are not supported by the raw image or the raw file contains named white points that are not supported by this API, the codec implementer should still mark this capability as supported.</p><p>If the named white points are not supported by the raw image, a best effort should be made to adjust the image to the named white point even when it isn't a pre-defined white point of the raw file.</p><p>If the raw file containes named white points not supported by this API, the codec implementer should support the named white points in <strong><see cref = "SharpDX.WIC.NamedWhitePoint"/></strong>.</p>
        /// </remarks>
        /// <doc-id>ee690237</doc-id>
        /// <unmanaged>GetNamedWhitePoint / SetNamedWhitePoint</unmanaged>
        /// <unmanaged-short>GetNamedWhitePoint</unmanaged-short>
        public SharpDX.WIC.NamedWhitePoint NamedWhitePoint
        {
            get
            {
                GetNamedWhitePoint(out var __output__);
                return __output__;
            }

            set => SetNamedWhitePoint(value);
        }

        /// <summary>
        /// <p>Gets or sets the white point Kelvin temperature of the raw image.</p>
        /// </summary>
        /// <doc-id>ee690245</doc-id>
        /// <unmanaged>GetWhitePointKelvin / SetWhitePointKelvin</unmanaged>
        /// <unmanaged-short>GetWhitePointKelvin</unmanaged-short>
        public System.Int32 WhitePointKelvin
        {
            get
            {
                GetWhitePointKelvin(out var __output__);
                return __output__;
            }

            set => SetWhitePointKelvin(value);
        }

        /// <summary>
        /// <p>Gets or sets the contrast value of the raw image.</p>
        /// </summary>
        /// <doc-id>ee690232</doc-id>
        /// <unmanaged>GetContrast / SetContrast</unmanaged>
        /// <unmanaged-short>GetContrast</unmanaged-short>
        public System.Double Contrast
        {
            get
            {
                GetContrast(out var __output__);
                return __output__;
            }

            set => SetContrast(value);
        }

        /// <summary>
        /// <p>Gets or sets the current gamma setting of the raw image.</p>
        /// </summary>
        /// <doc-id>ee690235</doc-id>
        /// <unmanaged>GetGamma / SetGamma</unmanaged>
        /// <unmanaged-short>GetGamma</unmanaged-short>
        public System.Double Gamma
        {
            get
            {
                GetGamma(out var __output__);
                return __output__;
            }

            set => SetGamma(value);
        }

        /// <summary>
        /// <p>Gets or sets the sharpness value of the raw image.</p>
        /// </summary>
        /// <doc-id>ee690242</doc-id>
        /// <unmanaged>GetSharpness / SetSharpness</unmanaged>
        /// <unmanaged-short>GetSharpness</unmanaged-short>
        public System.Double Sharpness
        {
            get
            {
                GetSharpness(out var __output__);
                return __output__;
            }

            set => SetSharpness(value);
        }

        /// <summary>
        /// <p>Gets or sets the saturation value of the raw image.</p>
        /// </summary>
        /// <doc-id>ee690241</doc-id>
        /// <unmanaged>GetSaturation / SetSaturation</unmanaged>
        /// <unmanaged-short>GetSaturation</unmanaged-short>
        public System.Double Saturation
        {
            get
            {
                GetSaturation(out var __output__);
                return __output__;
            }

            set => SetSaturation(value);
        }

        /// <summary>
        /// <p>Gets or sets the tint value of the raw image.</p>
        /// </summary>
        /// <doc-id>ee690243</doc-id>
        /// <unmanaged>GetTint / SetTint</unmanaged>
        /// <unmanaged-short>GetTint</unmanaged-short>
        public System.Double Tint
        {
            get
            {
                GetTint(out var __output__);
                return __output__;
            }

            set => SetTint(value);
        }

        /// <summary>
        /// <p>Gets or sets the noise reduction value of the raw image.</p>
        /// </summary>
        /// <doc-id>ee690238</doc-id>
        /// <unmanaged>GetNoiseReduction / SetNoiseReduction</unmanaged>
        /// <unmanaged-short>GetNoiseReduction</unmanaged-short>
        public System.Double NoiseReduction
        {
            get
            {
                GetNoiseReduction(out var __output__);
                return __output__;
            }

            set => SetNoiseReduction(value);
        }

        /// <summary>
        /// <p>Sets the destination color context.</p>
        /// </summary>
        /// <doc-id>ee690250</doc-id>
        /// <unmanaged>SetDestinationColorContext</unmanaged>
        /// <unmanaged-short>SetDestinationColorContext</unmanaged-short>
        public SharpDX.WIC.ColorContext DestinationColorContext
        {
            set => SetDestinationColorContext(value);
        }

        /// <summary>
        /// <p>Gets or sets the current rotation angle.</p>
        /// </summary>
        /// <doc-id>ee690240</doc-id>
        /// <unmanaged>GetRotation / SetRotation</unmanaged>
        /// <unmanaged-short>GetRotation</unmanaged-short>
        public System.Double Rotation
        {
            get
            {
                GetRotation(out var __output__);
                return __output__;
            }

            set => SetRotation(value);
        }

        /// <summary>
        /// <p>Gets or sets the current <strong><see cref = "SharpDX.WIC.RawRenderMode"/></strong>.</p>
        /// </summary>
        /// <doc-id>ee690239</doc-id>
        /// <unmanaged>GetRenderMode / SetRenderMode</unmanaged>
        /// <unmanaged-short>GetRenderMode</unmanaged-short>
        public SharpDX.WIC.RawRenderMode RenderMode
        {
            get
            {
                GetRenderMode(out var __output__);
                return __output__;
            }

            set => SetRenderMode(value);
        }

        /// <summary>
        /// <p>Sets the notification callback method.</p>
        /// </summary>
        /// <doc-id>ee690255</doc-id>
        /// <unmanaged>SetNotificationCallback</unmanaged>
        /// <unmanaged-short>SetNotificationCallback</unmanaged-short>
        internal SharpDX.WIC.DevelopRawNotificationCallback NotificationCallback
        {
            set => SetNotificationCallback(value);
        }

        /// <summary>
        /// <p>Retrieves information about which capabilities are supported for a raw image.</p>
        /// </summary>
        /// <param name = "infoRef"><dd>  <p>A reference that receives <strong><see cref = "SharpDX.WIC.RawCapabilitiesInfo"/></strong> that provides the capabilities supported by the raw image.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>It is recommended that a codec report that a capability is supported even if the results at the outer range limits are not of perfect quality.</p>
        /// </remarks>
        /// <doc-id>ee690248</doc-id>
        /// <unmanaged>HRESULT IWICDevelopRaw::QueryRawCapabilitiesInfo([In] WICRawCapabilitiesInfo* pInfo)</unmanaged>
        /// <unmanaged-short>IWICDevelopRaw::QueryRawCapabilitiesInfo</unmanaged-short>
        public unsafe void QueryRawCapabilitiesInfo(ref SharpDX.WIC.RawCapabilitiesInfo infoRef)
        {
            SharpDX.Result __result__;
            fixed (void *infoRef_ = &infoRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, infoRef_, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the desired <strong><see cref = "SharpDX.WIC.RawParameterSet"/></strong> option.</p>
        /// </summary>
        /// <param name = "parameterSet">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690247</doc-id>
        /// <unmanaged>HRESULT IWICDevelopRaw::LoadParameterSet([In] WICRawParameterSet ParameterSet)</unmanaged>
        /// <unmanaged-short>IWICDevelopRaw::LoadParameterSet</unmanaged-short>
        public unsafe void LoadParameterSet(SharpDX.WIC.RawParameterSet parameterSet)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)parameterSet), (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the current set of parameters.</p>
        /// </summary>
        /// <param name = "currentParameterSetOut"><dd>  <p>A reference that receives a reference to the current set of parameters.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690233</doc-id>
        /// <unmanaged>HRESULT IWICDevelopRaw::GetCurrentParameterSet([Out] IPropertyBag2** ppCurrentParameterSet)</unmanaged>
        /// <unmanaged-short>IWICDevelopRaw::GetCurrentParameterSet</unmanaged-short>
        internal unsafe void GetCurrentParameterSet(out SharpDX.Win32.PropertyBag currentParameterSetOut)
        {
            System.IntPtr currentParameterSetOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &currentParameterSetOut_, (*(void ***)this._nativePointer)[13]);
            if (currentParameterSetOut_ != System.IntPtr.Zero)
                currentParameterSetOut = new SharpDX.Win32.PropertyBag(currentParameterSetOut_);
            else
                currentParameterSetOut = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the exposure compensation stop value.</p>
        /// </summary>
        /// <param name = "ev"><dd>  <p>The exposure compensation value. The value range for exposure compensation is -5.0 through +5.0, which equates to 10 full stops.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>It is recommended that a codec report that this method is supported even if the results at the outer range limits are not of perfect quality.</p>
        /// </remarks>
        /// <doc-id>ee690251</doc-id>
        /// <unmanaged>HRESULT IWICDevelopRaw::SetExposureCompensation([In] double ev)</unmanaged>
        /// <unmanaged-short>IWICDevelopRaw::SetExposureCompensation</unmanaged-short>
        internal unsafe void SetExposureCompensation(System.Double ev)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, ev, (*(void ***)this._nativePointer)[14]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the exposure compensation stop value of the raw image.</p>
        /// </summary>
        /// <param name = "eVRef"><dd>  <p>A reference that receives the exposure compensation stop value. The default is the "as-shot" setting.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690234</doc-id>
        /// <unmanaged>HRESULT IWICDevelopRaw::GetExposureCompensation([Out] double* pEV)</unmanaged>
        /// <unmanaged-short>IWICDevelopRaw::GetExposureCompensation</unmanaged-short>
        internal unsafe void GetExposureCompensation(out System.Double eVRef)
        {
            SharpDX.Result __result__;
            fixed (void *eVRef_ = &eVRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, eVRef_, (*(void ***)this._nativePointer)[15]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the white point RGB values.</p>
        /// </summary>
        /// <param name = "red"><dd>  <p>The red white point value.</p> </dd></param>
        /// <param name = "green"><dd>  <p>The green white point value.</p> </dd></param>
        /// <param name = "blue"><dd>  <p>The blue white point value.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Due to other white point setting methods (e.g. <strong>SetWhitePointKelvin</strong>), care must be taken by codec implementers to ensure proper interoperability. For instance, if the caller sets via a named white point then the codec implementer may whis to disable reading back the correspoinding Kelvin temperature. In specific cases where the codec implementer wishes to deny a given action because of previous calls, <strong><see cref = "WrongState"/></strong> should be returned.</p>
        /// </remarks>
        /// <doc-id>ee690263</doc-id>
        /// <unmanaged>HRESULT IWICDevelopRaw::SetWhitePointRGB([In] unsigned int Red,[In] unsigned int Green,[In] unsigned int Blue)</unmanaged>
        /// <unmanaged-short>IWICDevelopRaw::SetWhitePointRGB</unmanaged-short>
        public unsafe void SetWhitePointRGB(System.Int32 red, System.Int32 green, System.Int32 blue)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, red, green, blue, (*(void ***)this._nativePointer)[16]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the white point RGB values.</p>
        /// </summary>
        /// <param name = "redRef"><dd>  <p>A reference that receives the red white point value.</p> </dd></param>
        /// <param name = "greenRef"><dd>  <p>A reference that receives the green white point value.</p> </dd></param>
        /// <param name = "blueRef"><dd>  <p>A reference that receives the blue white point value.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690246</doc-id>
        /// <unmanaged>HRESULT IWICDevelopRaw::GetWhitePointRGB([Out] unsigned int* pRed,[Out] unsigned int* pGreen,[Out] unsigned int* pBlue)</unmanaged>
        /// <unmanaged-short>IWICDevelopRaw::GetWhitePointRGB</unmanaged-short>
        public unsafe void GetWhitePointRGB(out System.Int32 redRef, out System.Int32 greenRef, out System.Int32 blueRef)
        {
            SharpDX.Result __result__;
            fixed (void *blueRef_ = &blueRef)
                fixed (void *greenRef_ = &greenRef)
                    fixed (void *redRef_ = &redRef)
                        __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, redRef_, greenRef_, blueRef_, (*(void ***)this._nativePointer)[17]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the named white point of the raw file.</p>
        /// </summary>
        /// <param name = "whitePoint"><dd>  <p>A bitwise combination of the enumeration values.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>If the named white points are not supported by the raw image or the raw file contains named white points that are not supported by this API, the codec implementer should still mark this capability as supported.</p><p>If the named white points are not supported by the raw image, a best effort should be made to adjust the image to the named white point even when it isn't a pre-defined white point of the raw file.</p><p>If the raw file containes named white points not supported by this API, the codec implementer should support the named white points in the API.</p><p>Due to other white point setting methods (e.g. <strong>SetWhitePointKelvin</strong>), care must be taken by codec implementers to ensure proper interoperability. For instance, if the caller sets via a named white point then the codec implementer may whis to disable reading back the correspoinding Kelvin temperature. In specific cases where the codec implementer wishes to deny a given action because of previous calls, <strong><see cref = "WrongState"/></strong> should be returned.</p>
        /// </remarks>
        /// <doc-id>ee690253</doc-id>
        /// <unmanaged>HRESULT IWICDevelopRaw::SetNamedWhitePoint([In] WICNamedWhitePoint WhitePoint)</unmanaged>
        /// <unmanaged-short>IWICDevelopRaw::SetNamedWhitePoint</unmanaged-short>
        internal unsafe void SetNamedWhitePoint(SharpDX.WIC.NamedWhitePoint whitePoint)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)whitePoint), (*(void ***)this._nativePointer)[18]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the named white point of the raw image.</p>
        /// </summary>
        /// <param name = "whitePointRef"><dd>  <p>A reference that receives the bitwise combination of the enumeration values.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>If the named white points are not supported by the raw image or the raw file contains named white points that are not supported by this API, the codec implementer should still mark this capability as supported.</p><p>If the named white points are not supported by the raw image, a best effort should be made to adjust the image to the named white point even when it isn't a pre-defined white point of the raw file.</p><p>If the raw file containes named white points not supported by this API, the codec implementer should support the named white points in <strong><see cref = "SharpDX.WIC.NamedWhitePoint"/></strong>.</p>
        /// </remarks>
        /// <doc-id>ee690237</doc-id>
        /// <unmanaged>HRESULT IWICDevelopRaw::GetNamedWhitePoint([Out] WICNamedWhitePoint* pWhitePoint)</unmanaged>
        /// <unmanaged-short>IWICDevelopRaw::GetNamedWhitePoint</unmanaged-short>
        internal unsafe void GetNamedWhitePoint(out SharpDX.WIC.NamedWhitePoint whitePointRef)
        {
            SharpDX.Result __result__;
            fixed (void *whitePointRef_ = &whitePointRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, whitePointRef_, (*(void ***)this._nativePointer)[19]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the white point Kelvin value.</p>
        /// </summary>
        /// <param name = "whitePointKelvin"><dd>  <p>The white point Kelvin value. Acceptable Kelvin values are 1,500 through 30,000.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Codec implementers should faithfully adjust the color temperature within the range supported natively by the raw image. For values outside the native support range, the codec implementer should provide a best effort representation of the image at that color temperature.</p><p>Codec implementers should return <strong><see cref = "Valueoutofrange"/></strong> if the value is out of defined acceptable range.</p><p>Codec implementers must ensure proper interoperability with other white point setting methods such as <strong>SetWhitePointRGB</strong>. For example, if the caller sets the white point via <strong>SetNamedWhitePoint</strong> then the codec implementer may want to disable reading back the correspoinding Kelvin temperature. In specific cases where the codec implementer wants to deny a given action because of previous calls, <strong><see cref = "WrongState"/></strong> should be returned.</p>
        /// </remarks>
        /// <doc-id>ee690262</doc-id>
        /// <unmanaged>HRESULT IWICDevelopRaw::SetWhitePointKelvin([In] unsigned int WhitePointKelvin)</unmanaged>
        /// <unmanaged-short>IWICDevelopRaw::SetWhitePointKelvin</unmanaged-short>
        internal unsafe void SetWhitePointKelvin(System.Int32 whitePointKelvin)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, whitePointKelvin, (*(void ***)this._nativePointer)[20]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the white point Kelvin temperature of the raw image.</p>
        /// </summary>
        /// <param name = "whitePointKelvinRef"><dd>  <p>A reference that receives the white point Kelvin temperature of the raw image. The default is the "as-shot" setting value.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690245</doc-id>
        /// <unmanaged>HRESULT IWICDevelopRaw::GetWhitePointKelvin([Out] unsigned int* pWhitePointKelvin)</unmanaged>
        /// <unmanaged-short>IWICDevelopRaw::GetWhitePointKelvin</unmanaged-short>
        internal unsafe void GetWhitePointKelvin(out System.Int32 whitePointKelvinRef)
        {
            SharpDX.Result __result__;
            fixed (void *whitePointKelvinRef_ = &whitePointKelvinRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, whitePointKelvinRef_, (*(void ***)this._nativePointer)[21]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the information about the current Kelvin range of the raw image.</p>
        /// </summary>
        /// <param name = "minKelvinTempRef"><dd>  <p>A reference that receives the minimum Kelvin temperature.</p> </dd></param>
        /// <param name = "maxKelvinTempRef"><dd>  <p>A reference that receives the maximum Kelvin temperature. </p> </dd></param>
        /// <param name = "kelvinTempStepValueRef"><dd>  <p>A reference that receives the Kelvin step value.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690236</doc-id>
        /// <unmanaged>HRESULT IWICDevelopRaw::GetKelvinRangeInfo([Out] unsigned int* pMinKelvinTemp,[Out] unsigned int* pMaxKelvinTemp,[Out] unsigned int* pKelvinTempStepValue)</unmanaged>
        /// <unmanaged-short>IWICDevelopRaw::GetKelvinRangeInfo</unmanaged-short>
        public unsafe void GetKelvinRangeInfo(out System.Int32 minKelvinTempRef, out System.Int32 maxKelvinTempRef, out System.Int32 kelvinTempStepValueRef)
        {
            SharpDX.Result __result__;
            fixed (void *kelvinTempStepValueRef_ = &kelvinTempStepValueRef)
                fixed (void *maxKelvinTempRef_ = &maxKelvinTempRef)
                    fixed (void *minKelvinTempRef_ = &minKelvinTempRef)
                        __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, minKelvinTempRef_, maxKelvinTempRef_, kelvinTempStepValueRef_, (*(void ***)this._nativePointer)[22]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the contrast value of the raw image.</p>
        /// </summary>
        /// <param name = "contrast"><dd>  <p>The contrast value of the raw image.  The default value is the "as-shot" setting. The value range for contrast is 0.0 through 1.0. The 0.0 lower limit represents no contrast applied to the image, while the 1.0 upper limit represents the highest amount of contrast that can be applied.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The codec implementer must determine what the upper range value represents and must determine how to map the value to their image processing routines.</p>
        /// </remarks>
        /// <doc-id>ee690249</doc-id>
        /// <unmanaged>HRESULT IWICDevelopRaw::SetContrast([In] double Contrast)</unmanaged>
        /// <unmanaged-short>IWICDevelopRaw::SetContrast</unmanaged-short>
        internal unsafe void SetContrast(System.Double contrast)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, contrast, (*(void ***)this._nativePointer)[23]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the contrast value of the raw image.</p>
        /// </summary>
        /// <param name = "contrastRef"><dd>  <p>A reference that receives the contrast value of the raw image. The default value is the "as-shot" setting. The value range for contrast is 0.0 through 1.0. The 0.0 lower limit represents no contrast applied to the image, while the 1.0 upper limit represents the highest amount of contrast that can be applied.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690232</doc-id>
        /// <unmanaged>HRESULT IWICDevelopRaw::GetContrast([Out] double* pContrast)</unmanaged>
        /// <unmanaged-short>IWICDevelopRaw::GetContrast</unmanaged-short>
        internal unsafe void GetContrast(out System.Double contrastRef)
        {
            SharpDX.Result __result__;
            fixed (void *contrastRef_ = &contrastRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, contrastRef_, (*(void ***)this._nativePointer)[24]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the desired gamma value.</p>
        /// </summary>
        /// <param name = "gamma"><dd>  <p>The desired gamma value.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690252</doc-id>
        /// <unmanaged>HRESULT IWICDevelopRaw::SetGamma([In] double Gamma)</unmanaged>
        /// <unmanaged-short>IWICDevelopRaw::SetGamma</unmanaged-short>
        internal unsafe void SetGamma(System.Double gamma)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, gamma, (*(void ***)this._nativePointer)[25]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the current gamma setting of the raw image.</p>
        /// </summary>
        /// <param name = "gammaRef"><dd>  <p>A reference that receives the current gamma setting.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690235</doc-id>
        /// <unmanaged>HRESULT IWICDevelopRaw::GetGamma([Out] double* pGamma)</unmanaged>
        /// <unmanaged-short>IWICDevelopRaw::GetGamma</unmanaged-short>
        internal unsafe void GetGamma(out System.Double gammaRef)
        {
            SharpDX.Result __result__;
            fixed (void *gammaRef_ = &gammaRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, gammaRef_, (*(void ***)this._nativePointer)[26]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the sharpness value of the raw image.</p>
        /// </summary>
        /// <param name = "sharpness"><dd>  <p>The sharpness value of the raw image. The default value is the "as-shot" setting. The value range for sharpness is 0.0 through 1.0. The 0.0 lower limit represents no sharpening applied to the image, while the 1.0 upper limit represents the highest amount of sharpness that can be applied.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The codec implementer must determine what the upper range value represents and must determine how to map the value to their image processing routines.</p>
        /// </remarks>
        /// <doc-id>ee690259</doc-id>
        /// <unmanaged>HRESULT IWICDevelopRaw::SetSharpness([In] double Sharpness)</unmanaged>
        /// <unmanaged-short>IWICDevelopRaw::SetSharpness</unmanaged-short>
        internal unsafe void SetSharpness(System.Double sharpness)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, sharpness, (*(void ***)this._nativePointer)[27]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the sharpness value of the raw image.</p>
        /// </summary>
        /// <param name = "sharpnessRef"><dd>  <p>A reference that receives the sharpness value of the raw image. The default value is the "as-shot" setting. The value range for sharpness is 0.0 through 1.0. The 0.0 lower limit represents no sharpening applied to the image, while the 1.0 upper limit represents the highest amount of sharpness that can be applied.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690242</doc-id>
        /// <unmanaged>HRESULT IWICDevelopRaw::GetSharpness([Out] double* pSharpness)</unmanaged>
        /// <unmanaged-short>IWICDevelopRaw::GetSharpness</unmanaged-short>
        internal unsafe void GetSharpness(out System.Double sharpnessRef)
        {
            SharpDX.Result __result__;
            fixed (void *sharpnessRef_ = &sharpnessRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, sharpnessRef_, (*(void ***)this._nativePointer)[28]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the saturation value of the raw image.</p>
        /// </summary>
        /// <param name = "saturation"><dd>  <p>The saturation value of the raw image. The value range for saturation is 0.0 through 1.0. A value of 0.0 represents an image with a fully de-saturated image, while a value of 1.0 represents the highest amount of saturation that can be applied.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The codec implementer must determine what the upper range value represents and must determine how to map the value to their image processing routines.</p>
        /// </remarks>
        /// <doc-id>ee690258</doc-id>
        /// <unmanaged>HRESULT IWICDevelopRaw::SetSaturation([In] double Saturation)</unmanaged>
        /// <unmanaged-short>IWICDevelopRaw::SetSaturation</unmanaged-short>
        internal unsafe void SetSaturation(System.Double saturation)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, saturation, (*(void ***)this._nativePointer)[29]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the saturation value of the raw image.</p>
        /// </summary>
        /// <param name = "saturationRef"><dd>  <p>A reference that receives the saturation value of the raw image. The default value is the "as-shot" setting. The value range for saturation is 0.0 through 1.0. A value of 0.0 represents an image with a fully de-saturated image, while a value of 1.0 represents the highest amount of saturation that can be applied.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690241</doc-id>
        /// <unmanaged>HRESULT IWICDevelopRaw::GetSaturation([Out] double* pSaturation)</unmanaged>
        /// <unmanaged-short>IWICDevelopRaw::GetSaturation</unmanaged-short>
        internal unsafe void GetSaturation(out System.Double saturationRef)
        {
            SharpDX.Result __result__;
            fixed (void *saturationRef_ = &saturationRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, saturationRef_, (*(void ***)this._nativePointer)[30]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the tint value of the raw image.</p>
        /// </summary>
        /// <param name = "tint"><dd>  <p>The tint value of the raw image. The default value is the "as-shot" setting if it exists or 0.0. The value range for sharpness is -1.0 through +1.0. The -1.0 lower limit represents a full green bias to the image, while the 1.0 upper limit represents a full magenta bias.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The codec implementer must determine what the outer range values represent and must determine how to map the values to their image processing routines.</p>
        /// </remarks>
        /// <doc-id>ee690260</doc-id>
        /// <unmanaged>HRESULT IWICDevelopRaw::SetTint([In] double Tint)</unmanaged>
        /// <unmanaged-short>IWICDevelopRaw::SetTint</unmanaged-short>
        internal unsafe void SetTint(System.Double tint)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, tint, (*(void ***)this._nativePointer)[31]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the tint value of the raw image.</p>
        /// </summary>
        /// <param name = "tintRef"><dd>  <p>A reference that receives the tint value of the raw image. The default value is the "as-shot" setting if it exists or 0.0. The value range for sharpness is -1.0 through +1.0. The -1.0 lower limit represents a full green bias to the image, while the 1.0 upper limit represents a full magenta bias.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690243</doc-id>
        /// <unmanaged>HRESULT IWICDevelopRaw::GetTint([Out] double* pTint)</unmanaged>
        /// <unmanaged-short>IWICDevelopRaw::GetTint</unmanaged-short>
        internal unsafe void GetTint(out System.Double tintRef)
        {
            SharpDX.Result __result__;
            fixed (void *tintRef_ = &tintRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, tintRef_, (*(void ***)this._nativePointer)[32]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the noise reduction value of the raw image.</p>
        /// </summary>
        /// <param name = "noiseReduction"><dd>  <p>The noise reduction value of the raw image.  The default value is the "as-shot" setting if it exists or 0.0. The value range for noise reduction is 0.0 through 1.0. The 0.0 lower limit represents no noise reduction applied to the image, while the 1.0 upper limit represents highest noise reduction amount that can be applied.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The codec implementer must determine what the upper range value represents and must determine how to map the value to their image processing routines.</p>
        /// </remarks>
        /// <doc-id>ee690254</doc-id>
        /// <unmanaged>HRESULT IWICDevelopRaw::SetNoiseReduction([In] double NoiseReduction)</unmanaged>
        /// <unmanaged-short>IWICDevelopRaw::SetNoiseReduction</unmanaged-short>
        internal unsafe void SetNoiseReduction(System.Double noiseReduction)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, noiseReduction, (*(void ***)this._nativePointer)[33]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the noise reduction value of the raw image.</p>
        /// </summary>
        /// <param name = "noiseReductionRef"><dd>  <p>A reference that receives the noise reduction value of the raw image.  The default value is the "as-shot" setting if it exists or 0.0. The value range for noise reduction is 0.0 through 1.0. The 0.0 lower limit represents no noise reduction applied to the image, while the 1.0 upper limit represents full highest noise reduction amount that can be applied.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690238</doc-id>
        /// <unmanaged>HRESULT IWICDevelopRaw::GetNoiseReduction([Out] double* pNoiseReduction)</unmanaged>
        /// <unmanaged-short>IWICDevelopRaw::GetNoiseReduction</unmanaged-short>
        internal unsafe void GetNoiseReduction(out System.Double noiseReductionRef)
        {
            SharpDX.Result __result__;
            fixed (void *noiseReductionRef_ = &noiseReductionRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, noiseReductionRef_, (*(void ***)this._nativePointer)[34]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the destination color context.</p>
        /// </summary>
        /// <param name = "colorContextRef"><dd>  <p>The destination color context.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690250</doc-id>
        /// <unmanaged>HRESULT IWICDevelopRaw::SetDestinationColorContext([In, Optional] IWICColorContext* pColorContext)</unmanaged>
        /// <unmanaged-short>IWICDevelopRaw::SetDestinationColorContext</unmanaged-short>
        internal unsafe void SetDestinationColorContext(SharpDX.WIC.ColorContext colorContextRef)
        {
            System.IntPtr colorContextRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            colorContextRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.ColorContext>(colorContextRef);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)colorContextRef_, (*(void ***)this._nativePointer)[35]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the tone curve for the raw image.</p>
        /// </summary>
        /// <param name = "toneCurveSize"><dd>  <p>The size of the <em>pToneCurve</em> structure.</p> </dd></param>
        /// <param name = "toneCurveRef"><dd>  <p>The desired tone curve.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690261</doc-id>
        /// <unmanaged>HRESULT IWICDevelopRaw::SetToneCurve([In] unsigned int cbToneCurveSize,[In, Buffer] const WICRawToneCurve* pToneCurve)</unmanaged>
        /// <unmanaged-short>IWICDevelopRaw::SetToneCurve</unmanaged-short>
        public unsafe void SetToneCurve(System.Int32 toneCurveSize, SharpDX.WIC.RawToneCurve[] toneCurveRef)
        {
            SharpDX.WIC.RawToneCurve.__Native[] toneCurveRef_ = new SharpDX.WIC.RawToneCurve.__Native[toneCurveRef.Length];
            SharpDX.Result __result__;
            for (int i = 0; i < toneCurveRef.Length; ++i)
                toneCurveRef[i].__MarshalTo(ref (toneCurveRef_)[i]);
            fixed (void *_toneCurveRef = toneCurveRef_)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, toneCurveSize, _toneCurveRef, (*(void ***)this._nativePointer)[36]);
            for (int i = 0; i < toneCurveRef.Length; ++i)
                toneCurveRef[i].__MarshalFree(ref (toneCurveRef_)[i]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the tone curve of the raw image.</p>
        /// </summary>
        /// <param name = "toneCurveBufferSize"><dd>  <p>The size of the <em>pToneCurve</em> buffer.</p> </dd></param>
        /// <param name = "toneCurveRef"><dd>  <p>A reference that receives the <strong><see cref = "SharpDX.WIC.RawToneCurve"/></strong> of the raw image.</p> </dd></param>
        /// <param name = "actualToneCurveBufferSizeRef"><dd>  <p>A reference that receives the size needed to obtain the tone curve structure.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690244</doc-id>
        /// <unmanaged>HRESULT IWICDevelopRaw::GetToneCurve([In] unsigned int cbToneCurveBufferSize,[Out, Buffer, Optional] WICRawToneCurve* pToneCurve,[InOut, Optional] unsigned int* pcbActualToneCurveBufferSize)</unmanaged>
        /// <unmanaged-short>IWICDevelopRaw::GetToneCurve</unmanaged-short>
        public unsafe void GetToneCurve(System.Int32 toneCurveBufferSize, SharpDX.WIC.RawToneCurve[] toneCurveRef, System.IntPtr actualToneCurveBufferSizeRef)
        {
            SharpDX.WIC.RawToneCurve.__Native[] toneCurveRef_ = toneCurveRef == null ? null : new SharpDX.WIC.RawToneCurve.__Native[toneCurveRef.Length];
            SharpDX.Result __result__;
            fixed (void *_toneCurveRef = toneCurveRef_)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, toneCurveBufferSize, _toneCurveRef, (void *)actualToneCurveBufferSizeRef, (*(void ***)this._nativePointer)[37]);
            if (toneCurveRef != null)
                for (int i = 0; i < toneCurveRef.Length; ++i)
                    if (toneCurveRef != null)
                        toneCurveRef[i].__MarshalFrom(ref (toneCurveRef_)[i]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the desired rotation angle.</p>
        /// </summary>
        /// <param name = "rotation"><dd>  <p>The desired rotation angle.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690257</doc-id>
        /// <unmanaged>HRESULT IWICDevelopRaw::SetRotation([In] double Rotation)</unmanaged>
        /// <unmanaged-short>IWICDevelopRaw::SetRotation</unmanaged-short>
        internal unsafe void SetRotation(System.Double rotation)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, rotation, (*(void ***)this._nativePointer)[38]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the current rotation angle.</p>
        /// </summary>
        /// <param name = "rotationRef"><dd>  <p>A reference that receives the current rotation angle.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690240</doc-id>
        /// <unmanaged>HRESULT IWICDevelopRaw::GetRotation([Out] double* pRotation)</unmanaged>
        /// <unmanaged-short>IWICDevelopRaw::GetRotation</unmanaged-short>
        internal unsafe void GetRotation(out System.Double rotationRef)
        {
            SharpDX.Result __result__;
            fixed (void *rotationRef_ = &rotationRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, rotationRef_, (*(void ***)this._nativePointer)[39]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the current <strong><see cref = "SharpDX.WIC.RawRenderMode"/></strong>.</p>
        /// </summary>
        /// <param name = "renderMode">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690256</doc-id>
        /// <unmanaged>HRESULT IWICDevelopRaw::SetRenderMode([In] WICRawRenderMode RenderMode)</unmanaged>
        /// <unmanaged-short>IWICDevelopRaw::SetRenderMode</unmanaged-short>
        internal unsafe void SetRenderMode(SharpDX.WIC.RawRenderMode renderMode)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)renderMode), (*(void ***)this._nativePointer)[40]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the current <strong><see cref = "SharpDX.WIC.RawRenderMode"/></strong>.</p>
        /// </summary>
        /// <param name = "renderModeRef">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690239</doc-id>
        /// <unmanaged>HRESULT IWICDevelopRaw::GetRenderMode([Out] WICRawRenderMode* pRenderMode)</unmanaged>
        /// <unmanaged-short>IWICDevelopRaw::GetRenderMode</unmanaged-short>
        internal unsafe void GetRenderMode(out SharpDX.WIC.RawRenderMode renderModeRef)
        {
            SharpDX.Result __result__;
            fixed (void *renderModeRef_ = &renderModeRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, renderModeRef_, (*(void ***)this._nativePointer)[41]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the notification callback method.</p>
        /// </summary>
        /// <param name = "callbackRef"><dd>  <p>Pointer to the notification callback method.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690255</doc-id>
        /// <unmanaged>HRESULT IWICDevelopRaw::SetNotificationCallback([In, Optional] IWICDevelopRawNotificationCallback* pCallback)</unmanaged>
        /// <unmanaged-short>IWICDevelopRaw::SetNotificationCallback</unmanaged-short>
        internal unsafe void SetNotificationCallback(SharpDX.WIC.DevelopRawNotificationCallback callbackRef)
        {
            System.IntPtr callbackRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            callbackRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.DevelopRawNotificationCallback>(callbackRef);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)callbackRef_, (*(void ***)this._nativePointer)[42]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("95c75a6e-3e8c-4ec2-85a8-aebcc551e59b")]
    internal partial class DevelopRawNotificationCallback : SharpDX.ComObject
    {
        public DevelopRawNotificationCallback(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DevelopRawNotificationCallback(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DevelopRawNotificationCallback(nativePtr);
        /// <summary>
        /// <p>An application-defined callback method used for raw image parameter change notifications.</p>
        /// </summary>
        /// <param name = "notificationMask"><dd>  <p>A set of <strong><see cref = "SharpDX.WIC.DevelopRawNotificationCallback"/> Constants</strong> parameter notification flags.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690230</doc-id>
        /// <unmanaged>HRESULT IWICDevelopRawNotificationCallback::Notify([In] unsigned int NotificationMask)</unmanaged>
        /// <unmanaged-short>IWICDevelopRawNotificationCallback::Notify</unmanaged-short>
        public unsafe void Notify(System.Int32 notificationMask)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, notificationMask, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("DC2BB46D-3F07-481E-8625-220C4AEDBB33")]
    internal partial class EnumMetadataItem : SharpDX.ComObject
    {
        public EnumMetadataItem(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator EnumMetadataItem(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new EnumMetadataItem(nativePtr);
        /// <summary>
        /// <p>Skips to given number of objects.</p>
        /// </summary>
        /// <param name = "celt"><dd>  <p>The number of objects to skip.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690268</doc-id>
        /// <unmanaged>HRESULT IWICEnumMetadataItem::Skip([In] ULONG celt)</unmanaged>
        /// <unmanaged-short>IWICEnumMetadataItem::Skip</unmanaged-short>
        public unsafe void Skip(System.Int32 celt)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, celt, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Resets the current position to the beginning of the enumeration.</p>
        /// </summary>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690267</doc-id>
        /// <unmanaged>HRESULT IWICEnumMetadataItem::Reset()</unmanaged>
        /// <unmanaged-short>IWICEnumMetadataItem::Reset</unmanaged-short>
        public unsafe void Reset()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a copy of the current <strong><see cref = "SharpDX.WIC.EnumMetadataItem"/></strong>.</p>
        /// </summary>
        /// <param name = "enumMetadataItemOut">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690265</doc-id>
        /// <unmanaged>HRESULT IWICEnumMetadataItem::Clone([Out] IWICEnumMetadataItem** ppIEnumMetadataItem)</unmanaged>
        /// <unmanaged-short>IWICEnumMetadataItem::Clone</unmanaged-short>
        public unsafe void Clone(out SharpDX.WIC.EnumMetadataItem enumMetadataItemOut)
        {
            System.IntPtr enumMetadataItemOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &enumMetadataItemOut_, (*(void ***)this._nativePointer)[6]);
            if (enumMetadataItemOut_ != System.IntPtr.Zero)
                enumMetadataItemOut = new SharpDX.WIC.EnumMetadataItem(enumMetadataItemOut_);
            else
                enumMetadataItemOut = null;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("B84E2C09-78C9-4AC4-8BD3-524AE1663A2F")]
    public partial class FastMetadataEncoder : SharpDX.ComObject
    {
        public FastMetadataEncoder(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator FastMetadataEncoder(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new FastMetadataEncoder(nativePtr);
        /// <summary>
        /// <p>Proxy function for the <strong>GetMetadataQueryWriter</strong> method.</p>
        /// </summary>
        /// <doc-id>ee690273</doc-id>
        /// <unmanaged>GetMetadataQueryWriter</unmanaged>
        /// <unmanaged-short>GetMetadataQueryWriter</unmanaged-short>
        public SharpDX.WIC.MetadataQueryWriter MetadataQueryWriter
        {
            get
            {
                GetMetadataQueryWriter(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Finalizes metadata changes to the image stream.</p>
        /// </summary>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>If the commit fails and returns <strong><see cref = "StreamNotAvailable"/></strong>, ensure that the image decoder was loaded using the <strong>WICDecodeMetadataCacheOnDemand</strong> option. A fast metadata encoder is not supported when the decoder is created using the <strong>WICDecodeMetadataCacheOnLoad</strong> option. </p><p>If the commit fails for any reason, you will need to re-encode the image to ensure the new metadata is added to the image.</p>
        /// </remarks>
        /// <doc-id>ee690270</doc-id>
        /// <unmanaged>HRESULT IWICFastMetadataEncoder::Commit()</unmanaged>
        /// <unmanaged-short>IWICFastMetadataEncoder::Commit</unmanaged-short>
        public unsafe void Commit()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Proxy function for the <strong>GetMetadataQueryWriter</strong> method.</p>
        /// </summary>
        /// <param name = "metadataQueryWriterOut">No documentation.</param>
        /// <returns><p>If this function succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690273</doc-id>
        /// <unmanaged>HRESULT IWICFastMetadataEncoder::GetMetadataQueryWriter([Out] IWICMetadataQueryWriter** ppIMetadataQueryWriter)</unmanaged>
        /// <unmanaged-short>IWICFastMetadataEncoder::GetMetadataQueryWriter</unmanaged-short>
        internal unsafe void GetMetadataQueryWriter(out SharpDX.WIC.MetadataQueryWriter metadataQueryWriterOut)
        {
            System.IntPtr metadataQueryWriterOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &metadataQueryWriterOut_, (*(void ***)this._nativePointer)[4]);
            if (metadataQueryWriterOut_ != System.IntPtr.Zero)
                metadataQueryWriterOut = new SharpDX.WIC.MetadataQueryWriter(metadataQueryWriterOut_);
            else
                metadataQueryWriterOut = null;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("00000301-a8f2-4877-ba0a-fd2b6645fb94")]
    public partial class FormatConverter : SharpDX.WIC.BitmapSource
    {
        public FormatConverter(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator FormatConverter(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new FormatConverter(nativePtr);
        /// <summary>
        /// <p>Initializes the format converter.</p>
        /// </summary>
        /// <param name = "sourceRef"><dd>  <p>The input bitmap to convert</p> </dd></param>
        /// <param name = "dstFormat"><dd>  <p>The destination pixel format <see cref = "System.Guid"/>.</p> </dd></param>
        /// <param name = "dither"><dd>  <p>The <strong><see cref = "SharpDX.WIC.BitmapDitherType"/></strong> used for conversion.</p> </dd></param>
        /// <param name = "paletteRef"><dd>  <p>The palette to use for conversion.</p> </dd></param>
        /// <param name = "alphaThresholdPercent"><dd>  <p>The alpha threshold to use for conversion.</p> </dd></param>
        /// <param name = "paletteTranslate"><dd>  <p>The palette translation type to use for conversion.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p> If you do not have a predefined palette, you must first create one. Use <strong>InitializeFromBitmap</strong> to create the palette object, then pass it in along with your other parameters. </p><p><em>dither</em>, <em>pIPalette</em>, <em>alphaThresholdPercent</em>, and <em>paletteTranslate</em> are used to mitigate color loss when converting to a reduced bit-depth format. For conversions that do not need these settings, the following parameters values should be used: <em>dither</em> set to <strong>WICBitmapDitherTypeNone</strong>, <em>pIPalette</em> set to <strong><c>null</c></strong>, <em>alphaThresholdPercent</em> set to <strong>0.0f</strong>, and <em>paletteTranslate</em> set to <strong>WICBitmapPaletteTypeCustom</strong>.   </p><p> The basic algorithm involved when using an ordered dither requires a fixed palette, found in the <strong><see cref = "SharpDX.WIC.BitmapPaletteType"/></strong> enumeration, in a specific order. Often, the actual palette provided for the output may have a different ordering or some slight variation in the actual colors.  This is the case when using the Microsoft?Windows palette which has slight differences among versions of Windows. To provide for this, a palette and a palette translation are given to the format converter.  The <em>pIPalette</em> is the actual destination palette to be used and the <em>paletteTranslate</em> is a fixed palette.  Once the conversion is complete, the colors are mapped from the fixed palette to the actual colors in <em>pIPalette</em> using a nearest color matching algorithm.  </p><p> If colors in <em>pIPalette</em> do not closely match those in <em>paletteTranslate</em>, the mapping may produce undesireable results. </p><p><strong>WICBitmapDitherTypeOrdered4x4</strong> can be useful in format conversions from 8-bit formats to 5- or 6-bit formats as there is no way to accurately convert color data. </p><p><strong>WICBitmapDitherTypeErrorDiffusion</strong> selects the error diffusion algorithm and may be used with any palette.  If an arbitrary palette is provided, <strong>WICBitmapPaletteCustom</strong> should be passed in as the <em>paletteTranslate</em>.  Error diffusion often provides superior results compared to the ordered dithering algorithms especially when combined with the optimized palette generation functionality on the <strong><see cref = "SharpDX.WIC.Palette"/></strong>. </p><p> When converting a bitmap which has an alpha channel, such as a Portable Network Graphics (PNG), to 8bpp, the alpha channel is normally ignored.  Any pixels which were transparent in the original bitmap show up as black in the final output because both transparent and black have pixel values of zero in the respective formats.  </p><p> Some 8bpp content can contains an alpha color; for instance, the Graphics Interchange Format (GIF) format allows for a single palette entry to be used as a transparent color. For this type of content, <em>alphaThresholdPercent</em> specifies what percentage of transparency should map to the transparent color. Because the alpha value is directly proportional to the opacity (not transparency) of a pixel, the <em>alphaThresholdPercent</em> indicates what level of opacity is mapped to the fully transparent color.  For instance, 9.8% implies that any pixel with an alpha value of less than 25 will be mapped to the transparent color.  A value of 100% maps all pixels which are not fully opaque to the transparent color. Note that the palette should provide a transparent color. If it does not, the 'transparent' color will be the one closest to zero - often black. </p>
        /// </remarks>
        /// <doc-id>ee690279</doc-id>
        /// <unmanaged>HRESULT IWICFormatConverter::Initialize([In, Optional] IWICBitmapSource* pISource,[In] const GUID&amp; dstFormat,[In] WICBitmapDitherType dither,[In, Optional] IWICPalette* pIPalette,[In] double alphaThresholdPercent,[In] WICBitmapPaletteType paletteTranslate)</unmanaged>
        /// <unmanaged-short>IWICFormatConverter::Initialize</unmanaged-short>
        public unsafe void Initialize(SharpDX.WIC.BitmapSource sourceRef, System.Guid dstFormat, SharpDX.WIC.BitmapDitherType dither, SharpDX.WIC.Palette paletteRef, System.Double alphaThresholdPercent, SharpDX.WIC.BitmapPaletteType paletteTranslate)
        {
            System.IntPtr sourceRef_ = System.IntPtr.Zero;
            System.IntPtr paletteRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            sourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.BitmapSource>(sourceRef);
            paletteRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.Palette>(paletteRef);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)sourceRef_, &dstFormat, unchecked ((System.Int32)dither), (void *)paletteRef_, alphaThresholdPercent, unchecked ((System.Int32)paletteTranslate), (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Determines if the source pixel format can be converted to the destination pixel format.</p>
        /// </summary>
        /// <param name = "srcPixelFormat"><dd>  <p>The source pixel format.</p> </dd></param>
        /// <param name = "dstPixelFormat"><dd>  <p>The destionation pixel format.</p> </dd></param>
        /// <returns><dd>  <p>A reference that receives a value indicating whether the source pixel format can be converted to the destination pixel format.</p> </dd></returns>
        /// <doc-id>ee690278</doc-id>
        /// <unmanaged>HRESULT IWICFormatConverter::CanConvert([In] const GUID&amp; srcPixelFormat,[In] const GUID&amp; dstPixelFormat,[Out] BOOL* pfCanConvert)</unmanaged>
        /// <unmanaged-short>IWICFormatConverter::CanConvert</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool CanConvert(System.Guid srcPixelFormat, System.Guid dstPixelFormat)
        {
            SharpDX.Mathematics.Interop.RawBool fCanConvertRef;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &srcPixelFormat, &dstPixelFormat, &fCanConvertRef, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
            return fCanConvertRef;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("9F34FB65-13F4-4f15-BC57-3726B5E53D9F")]
    public partial class FormatConverterInfo : SharpDX.WIC.ComponentInfo
    {
        public FormatConverterInfo(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator FormatConverterInfo(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new FormatConverterInfo(nativePtr);
        /// <summary>
        /// <p>Retrieves a list of GUIDs that signify which pixel formats the converter supports.</p>
        /// </summary>
        /// <param name = "formats"><dd>  <p>The size of the <em>pPixelFormatGUIDs</em> array.</p> </dd></param>
        /// <param name = "pixelFormatGUIDsRef"><dd>  <p>Pointer to a <see cref = "System.Guid"/> array that receives the pixel formats the converter supports.</p> </dd></param>
        /// <param name = "actualRef"><dd>  <p>The actual array size needed to retrieve all pixel formats supported by the converter.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The format converter does not necessarily guarantee symmetricality with respect to conversion; that is, a converter may be able to convert FROM a particular format without actually being able to convert TO a particular format. In order to test symmetricality, use <strong>CanConvert</strong>.</p><p>To determine the number of pixel formats a coverter can handle, set <em>cFormats</em> to <code>0</code> and <em>pPixelFormatGUIDs</em> to <code><c>null</c></code>. The converter will fill <em>pcActual</em> with the number of formats supported by that converter.</p>
        /// </remarks>
        /// <doc-id>ee690277</doc-id>
        /// <unmanaged>HRESULT IWICFormatConverterInfo::GetPixelFormats([In] unsigned int cFormats,[Out, Buffer, Optional] GUID* pPixelFormatGUIDs,[Out] unsigned int* pcActual)</unmanaged>
        /// <unmanaged-short>IWICFormatConverterInfo::GetPixelFormats</unmanaged-short>
        internal unsafe void GetPixelFormats(System.Int32 formats, System.Guid[] pixelFormatGUIDsRef, out System.Int32 actualRef)
        {
            SharpDX.Result __result__;
            fixed (void *actualRef_ = &actualRef)
                fixed (void *pixelFormatGUIDsRef_ = pixelFormatGUIDsRef)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, formats, pixelFormatGUIDsRef_, actualRef_, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a new <strong><see cref = "SharpDX.WIC.FormatConverter"/></strong> instance.</p>
        /// </summary>
        /// <param name = "converterOut">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690276</doc-id>
        /// <unmanaged>HRESULT IWICFormatConverterInfo::CreateInstance([Out, Fast] IWICFormatConverter** ppIConverter)</unmanaged>
        /// <unmanaged-short>IWICFormatConverterInfo::CreateInstance</unmanaged-short>
        internal unsafe void CreateInstance(SharpDX.WIC.FormatConverter converterOut)
        {
            System.IntPtr converterOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &converterOut_, (*(void ***)this._nativePointer)[12]);
            (converterOut).NativePointer = converterOut_;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("04C75BF8-3CE1-473B-ACC5-3CC4F5E94999")]
    public partial class ImageEncoder : SharpDX.ComObject
    {
        public ImageEncoder(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ImageEncoder(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ImageEncoder(nativePtr);
        /// <summary>
        /// <p>Encodes the image to the frame given by the <strong><see cref = "SharpDX.WIC.BitmapFrameEncode"/></strong>.</p>
        /// </summary>
        /// <param name = "imageRef">No documentation.</param>
        /// <param name = "frameEncodeRef">No documentation.</param>
        /// <param name = "imageParametersRef">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The image passed in must be created on the same device as in <strong>IWICImagingFactory2::CreateImageEncoder</strong>. If the <em>pImageParameters</em> are not specified, a set of useful defaults will be assumed, see <strong><see cref = "SharpDX.WIC.ImageParameters"/></strong> for more info. </p><p>You must correctly and independently have set up the <see cref = "SharpDX.WIC.BitmapFrameEncode"/> before calling this API.
        /// </p>
        /// </remarks>
        /// <doc-id>hh880845</doc-id>
        /// <unmanaged>HRESULT IWICImageEncoder::WriteFrame([In] ID2D1Image* pImage,[In] IWICBitmapFrameEncode* pFrameEncode,[In, Value] const WICImageParameters* pImageParameters)</unmanaged>
        /// <unmanaged-short>IWICImageEncoder::WriteFrame</unmanaged-short>
        public unsafe void WriteFrame(SharpDX.Direct2D1.Image imageRef, SharpDX.WIC.BitmapFrameEncode frameEncodeRef, SharpDX.WIC.ImageParameters imageParametersRef)
        {
            System.IntPtr imageRef_ = System.IntPtr.Zero;
            System.IntPtr frameEncodeRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            imageRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Image>(imageRef);
            frameEncodeRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.BitmapFrameEncode>(frameEncodeRef);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)imageRef_, (void *)frameEncodeRef_, &imageParametersRef, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Encodes the image as a thumbnail to the frame given by the <strong><see cref = "SharpDX.WIC.BitmapFrameEncode"/></strong>. </p>
        /// </summary>
        /// <param name = "imageRef">No documentation.</param>
        /// <param name = "frameEncodeRef">No documentation.</param>
        /// <param name = "imageParametersRef">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The image passed in must be created on the same device as in <strong>IWICImagingFactory2::CreateImageEncoder</strong>. If the <em>pImageParameters</em> are not specified, a set of useful defaults will be assumed, see <strong><see cref = "SharpDX.WIC.ImageParameters"/></strong> for more info. </p><p>You must correctly and independently have set up the <strong><see cref = "SharpDX.WIC.BitmapFrameEncode"/></strong> before calling this API.
        /// </p>
        /// </remarks>
        /// <doc-id>hh880846</doc-id>
        /// <unmanaged>HRESULT IWICImageEncoder::WriteFrameThumbnail([In] ID2D1Image* pImage,[In] IWICBitmapFrameEncode* pFrameEncode,[In, Value] const WICImageParameters* pImageParameters)</unmanaged>
        /// <unmanaged-short>IWICImageEncoder::WriteFrameThumbnail</unmanaged-short>
        public unsafe void WriteFrameThumbnail(SharpDX.Direct2D1.Image imageRef, SharpDX.WIC.BitmapFrameEncode frameEncodeRef, SharpDX.WIC.ImageParameters imageParametersRef)
        {
            System.IntPtr imageRef_ = System.IntPtr.Zero;
            System.IntPtr frameEncodeRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            imageRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Image>(imageRef);
            frameEncodeRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.BitmapFrameEncode>(frameEncodeRef);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)imageRef_, (void *)frameEncodeRef_, &imageParametersRef, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Encodes the given image as the thumbnail to the given WIC bitmap encoder.</p>
        /// </summary>
        /// <param name = "imageRef"><dd>  <p>The Direct2D image that will be encoded.</p> </dd></param>
        /// <param name = "encoderRef"><dd>  <p>The encoder on which the thumbnail is set.</p> </dd></param>
        /// <param name = "imageParametersRef"><dd>  <p>Additional parameters to control encoding.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>You must create the image that you pass in on the same device as in <strong>IWICImagingFactory2::CreateImageEncoder</strong>. If you don't specify additional parameters in the variable that <em>pImageParameters</em> points to, the encoder uses a set of useful defaults. For info about these defaults, see <strong><see cref = "SharpDX.WIC.ImageParameters"/></strong>. </p><p>Before you call <strong>WriteThumbnail</strong>, you must set up the <strong><see cref = "SharpDX.WIC.BitmapEncoder"/></strong> interface for the encoder on which you want to set the thumbnail. </p><p>If <strong>WriteThumbnail</strong> fails, it might return E_OUTOFMEMORY, <see cref = "WrongResourceDomain"/>, or other error codes from the encoder.</p>
        /// </remarks>
        /// <doc-id>hh880847</doc-id>
        /// <unmanaged>HRESULT IWICImageEncoder::WriteThumbnail([In] ID2D1Image* pImage,[In] IWICBitmapEncoder* pEncoder,[In, Value] const WICImageParameters* pImageParameters)</unmanaged>
        /// <unmanaged-short>IWICImageEncoder::WriteThumbnail</unmanaged-short>
        public unsafe void WriteThumbnail(SharpDX.Direct2D1.Image imageRef, SharpDX.WIC.BitmapEncoder encoderRef, SharpDX.WIC.ImageParameters imageParametersRef)
        {
            System.IntPtr imageRef_ = System.IntPtr.Zero;
            System.IntPtr encoderRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            imageRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Image>(imageRef);
            encoderRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.BitmapEncoder>(encoderRef);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)imageRef_, (void *)encoderRef_, &imageParametersRef, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("ec5ec8a9-c395-4314-9c77-54d7a935ff70")]
    public partial class ImagingFactory : SharpDX.ComObject
    {
        public ImagingFactory(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ImagingFactory(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ImagingFactory(nativePtr);
                ///<summary>Constant WICImagingFactoryClsid</summary>
        ///<unmanaged>CLSID_WICImagingFactory</unmanaged>
        public static readonly System.Guid WICImagingFactoryClsid = new System.Guid("cacaf262-9370-4615-a13b-9f5539da4c0a");
        /// <summary>
        /// <p>Creates a new instance of the <strong><see cref = "SharpDX.WIC.BitmapDecoder"/></strong> class based on the given file.</p>
        /// </summary>
        /// <param name = "filename">No documentation.</param>
        /// <param name = "guidVendorRef">No documentation.</param>
        /// <param name = "desiredAccess">No documentation.</param>
        /// <param name = "metadataOptions">No documentation.</param>
        /// <param name = "decoderOut">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690307</doc-id>
        /// <unmanaged>HRESULT IWICImagingFactory::CreateDecoderFromFilename([In] const wchar_t* wzFilename,[In, Optional] const GUID* pguidVendor,[In] DWORD dwDesiredAccess,[In] WICDecodeOptions metadataOptions,[Out, Fast] IWICBitmapDecoder** ppIDecoder)</unmanaged>
        /// <unmanaged-short>IWICImagingFactory::CreateDecoderFromFilename</unmanaged-short>
        internal unsafe void CreateDecoderFromFilename(System.String filename, System.Guid? guidVendorRef, System.Int32 desiredAccess, SharpDX.WIC.DecodeOptions metadataOptions, SharpDX.WIC.BitmapDecoder decoderOut)
        {
            System.Guid guidVendorRef_;
            System.IntPtr decoderOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            if (guidVendorRef != null)
                guidVendorRef_ = guidVendorRef.Value;
            fixed (char *filename_ = filename)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)filename_, guidVendorRef == null ? (void *)0 : &guidVendorRef_, desiredAccess, unchecked ((System.Int32)metadataOptions), &decoderOut_, (*(void ***)this._nativePointer)[3]);
            (decoderOut).NativePointer = decoderOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a new instance of the <strong><see cref = "SharpDX.WIC.BitmapDecoder"/></strong> class based on the given <see cref = "SharpDX.Win32.IStream"/>.</p>
        /// </summary>
        /// <param name = "streamRef">No documentation.</param>
        /// <param name = "guidVendorRef">No documentation.</param>
        /// <param name = "metadataOptions">No documentation.</param>
        /// <param name = "decoderOut">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690309</doc-id>
        /// <unmanaged>HRESULT IWICImagingFactory::CreateDecoderFromStream([In, Optional] IStream* pIStream,[In, Optional] const GUID* pguidVendor,[In] WICDecodeOptions metadataOptions,[Out, Fast] IWICBitmapDecoder** ppIDecoder)</unmanaged>
        /// <unmanaged-short>IWICImagingFactory::CreateDecoderFromStream</unmanaged-short>
        internal unsafe void CreateDecoderFromStream(SharpDX.Win32.IStream streamRef, System.Guid? guidVendorRef, SharpDX.WIC.DecodeOptions metadataOptions, SharpDX.WIC.BitmapDecoder decoderOut)
        {
            System.IntPtr streamRef_ = System.IntPtr.Zero;
            System.Guid guidVendorRef_;
            System.IntPtr decoderOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            streamRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Win32.IStream>(streamRef);
            if (guidVendorRef != null)
                guidVendorRef_ = guidVendorRef.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)streamRef_, guidVendorRef == null ? (void *)0 : &guidVendorRef_, unchecked ((System.Int32)metadataOptions), &decoderOut_, (*(void ***)this._nativePointer)[4]);
            (decoderOut).NativePointer = decoderOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a new instance of the <strong><see cref = "SharpDX.WIC.BitmapDecoder"/></strong> based on the given file handle.</p>
        /// </summary>
        /// <param name = "hFile">No documentation.</param>
        /// <param name = "guidVendorRef">No documentation.</param>
        /// <param name = "metadataOptions">No documentation.</param>
        /// <param name = "decoderOut">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>When a decoder is created using this method, the file handle must remain alive during the lifetime of the decoder.</p>
        /// </remarks>
        /// <doc-id>ee690305</doc-id>
        /// <unmanaged>HRESULT IWICImagingFactory::CreateDecoderFromFileHandle([In] ULONG_PTR hFile,[In, Optional] const GUID* pguidVendor,[In] WICDecodeOptions metadataOptions,[Out, Fast] IWICBitmapDecoder** ppIDecoder)</unmanaged>
        /// <unmanaged-short>IWICImagingFactory::CreateDecoderFromFileHandle</unmanaged-short>
        internal unsafe void CreateDecoderFromFileHandle(System.IntPtr hFile, System.Guid? guidVendorRef, SharpDX.WIC.DecodeOptions metadataOptions, SharpDX.WIC.BitmapDecoder decoderOut)
        {
            System.Guid guidVendorRef_;
            System.IntPtr decoderOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            if (guidVendorRef != null)
                guidVendorRef_ = guidVendorRef.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)hFile, guidVendorRef == null ? (void *)0 : &guidVendorRef_, unchecked ((System.Int32)metadataOptions), &decoderOut_, (*(void ***)this._nativePointer)[5]);
            (decoderOut).NativePointer = decoderOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Proxy function for the <strong>CreateComponentInfo</strong> method.</p>
        /// </summary>
        /// <param name = "clsidComponent">No documentation.</param>
        /// <param name = "infoOut">No documentation.</param>
        /// <returns><p>If this function succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690303</doc-id>
        /// <unmanaged>HRESULT IWICImagingFactory::CreateComponentInfo([In] const GUID&amp; clsidComponent,[Out, Fast] IWICComponentInfo** ppIInfo)</unmanaged>
        /// <unmanaged-short>IWICImagingFactory::CreateComponentInfo</unmanaged-short>
        internal unsafe void CreateComponentInfo(System.Guid clsidComponent, SharpDX.WIC.ComponentInfo infoOut)
        {
            System.IntPtr infoOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &clsidComponent, &infoOut_, (*(void ***)this._nativePointer)[6]);
            (infoOut).NativePointer = infoOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a new instance of <strong><see cref = "SharpDX.WIC.BitmapDecoder"/></strong>.</p>
        /// </summary>
        /// <param name = "guidContainerFormat">No documentation.</param>
        /// <param name = "guidVendorRef">No documentation.</param>
        /// <param name = "decoderOut">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p> Other values may be available for both <em>guidContainerFormat</em> and <em>pguidVendor</em> depending on the installed WIC-enabled encoders. The values listed are those that are natively supported by the operating system. </p>
        /// </remarks>
        /// <doc-id>ee690304</doc-id>
        /// <unmanaged>HRESULT IWICImagingFactory::CreateDecoder([In] const GUID&amp; guidContainerFormat,[In, Optional] const GUID* pguidVendor,[Out, Fast] IWICBitmapDecoder** ppIDecoder)</unmanaged>
        /// <unmanaged-short>IWICImagingFactory::CreateDecoder</unmanaged-short>
        internal unsafe void CreateDecoder(System.Guid guidContainerFormat, System.Guid? guidVendorRef, SharpDX.WIC.BitmapDecoder decoderOut)
        {
            System.Guid guidVendorRef_;
            System.IntPtr decoderOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            if (guidVendorRef != null)
                guidVendorRef_ = guidVendorRef.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &guidContainerFormat, guidVendorRef == null ? (void *)0 : &guidVendorRef_, &decoderOut_, (*(void ***)this._nativePointer)[7]);
            (decoderOut).NativePointer = decoderOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a new instance of the <strong><see cref = "SharpDX.WIC.BitmapEncoder"/></strong> class.</p>
        /// </summary>
        /// <param name = "guidContainerFormat">No documentation.</param>
        /// <param name = "guidVendorRef">No documentation.</param>
        /// <param name = "encoderOut">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p> Other values may be available for both <em>guidContainerFormat</em> and <em>pguidVendor</em> depending on the installed WIC-enabled encoders. The values listed are those that are natively supported by the operating system. </p>
        /// </remarks>
        /// <doc-id>ee690311</doc-id>
        /// <unmanaged>HRESULT IWICImagingFactory::CreateEncoder([In] const GUID&amp; guidContainerFormat,[In, Optional] const GUID* pguidVendor,[Out, Fast] IWICBitmapEncoder** ppIEncoder)</unmanaged>
        /// <unmanaged-short>IWICImagingFactory::CreateEncoder</unmanaged-short>
        internal unsafe void CreateEncoder(System.Guid guidContainerFormat, System.Guid? guidVendorRef, SharpDX.WIC.BitmapEncoder encoderOut)
        {
            System.Guid guidVendorRef_;
            System.IntPtr encoderOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            if (guidVendorRef != null)
                guidVendorRef_ = guidVendorRef.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &guidContainerFormat, guidVendorRef == null ? (void *)0 : &guidVendorRef_, &encoderOut_, (*(void ***)this._nativePointer)[8]);
            (encoderOut).NativePointer = encoderOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a new instance of the <strong><see cref = "SharpDX.WIC.Palette"/></strong> class.</p>
        /// </summary>
        /// <param name = "paletteOut">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690319</doc-id>
        /// <unmanaged>HRESULT IWICImagingFactory::CreatePalette([Out, Fast] IWICPalette** ppIPalette)</unmanaged>
        /// <unmanaged-short>IWICImagingFactory::CreatePalette</unmanaged-short>
        internal unsafe void CreatePalette(SharpDX.WIC.Palette paletteOut)
        {
            System.IntPtr paletteOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &paletteOut_, (*(void ***)this._nativePointer)[9]);
            (paletteOut).NativePointer = paletteOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a new instance of the <strong><see cref = "SharpDX.WIC.FormatConverter"/></strong> class.</p>
        /// </summary>
        /// <param name = "formatConverterOut">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690317</doc-id>
        /// <unmanaged>HRESULT IWICImagingFactory::CreateFormatConverter([Out, Fast] IWICFormatConverter** ppIFormatConverter)</unmanaged>
        /// <unmanaged-short>IWICImagingFactory::CreateFormatConverter</unmanaged-short>
        internal unsafe void CreateFormatConverter(SharpDX.WIC.FormatConverter formatConverterOut)
        {
            System.IntPtr formatConverterOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &formatConverterOut_, (*(void ***)this._nativePointer)[10]);
            (formatConverterOut).NativePointer = formatConverterOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a new instance of an <strong><see cref = "SharpDX.WIC.BitmapScaler"/></strong>.</p>
        /// </summary>
        /// <param name = "bitmapScalerOut">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690296</doc-id>
        /// <unmanaged>HRESULT IWICImagingFactory::CreateBitmapScaler([Out, Fast] IWICBitmapScaler** ppIBitmapScaler)</unmanaged>
        /// <unmanaged-short>IWICImagingFactory::CreateBitmapScaler</unmanaged-short>
        internal unsafe void CreateBitmapScaler(SharpDX.WIC.BitmapScaler bitmapScalerOut)
        {
            System.IntPtr bitmapScalerOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &bitmapScalerOut_, (*(void ***)this._nativePointer)[11]);
            (bitmapScalerOut).NativePointer = bitmapScalerOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Proxy function for the <strong>CreateBitmapClipper</strong> method.</p>
        /// </summary>
        /// <param name = "bitmapClipperOut">No documentation.</param>
        /// <returns><p>If this function succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690284</doc-id>
        /// <unmanaged>HRESULT IWICImagingFactory::CreateBitmapClipper([Out, Fast] IWICBitmapClipper** ppIBitmapClipper)</unmanaged>
        /// <unmanaged-short>IWICImagingFactory::CreateBitmapClipper</unmanaged-short>
        internal unsafe void CreateBitmapClipper(SharpDX.WIC.BitmapClipper bitmapClipperOut)
        {
            System.IntPtr bitmapClipperOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &bitmapClipperOut_, (*(void ***)this._nativePointer)[12]);
            (bitmapClipperOut).NativePointer = bitmapClipperOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Proxy function for the <strong>CreateBitmapFlipRotator</strong> method.</p>
        /// </summary>
        /// <param name = "bitmapFlipRotatorOut">No documentation.</param>
        /// <returns><p>If this function succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690286</doc-id>
        /// <unmanaged>HRESULT IWICImagingFactory::CreateBitmapFlipRotator([Out, Fast] IWICBitmapFlipRotator** ppIBitmapFlipRotator)</unmanaged>
        /// <unmanaged-short>IWICImagingFactory::CreateBitmapFlipRotator</unmanaged-short>
        internal unsafe void CreateBitmapFlipRotator(SharpDX.WIC.BitmapFlipRotator bitmapFlipRotatorOut)
        {
            System.IntPtr bitmapFlipRotatorOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &bitmapFlipRotatorOut_, (*(void ***)this._nativePointer)[13]);
            (bitmapFlipRotatorOut).NativePointer = bitmapFlipRotatorOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a new instance of the <strong><see cref = "SharpDX.WIC.WICStream"/></strong> class.</p>
        /// </summary>
        /// <param name = "wICStreamOut">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690325</doc-id>
        /// <unmanaged>HRESULT IWICImagingFactory::CreateStream([Out, Fast] IWICStream** ppIWICStream)</unmanaged>
        /// <unmanaged-short>IWICImagingFactory::CreateStream</unmanaged-short>
        internal unsafe void CreateStream(SharpDX.WIC.WICStream wICStreamOut)
        {
            System.IntPtr wICStreamOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &wICStreamOut_, (*(void ***)this._nativePointer)[14]);
            (wICStreamOut).NativePointer = wICStreamOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a new instance of the <strong><see cref = "SharpDX.WIC.ColorContext"/></strong> class.</p>
        /// </summary>
        /// <param name = "wICColorContextOut">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690299</doc-id>
        /// <unmanaged>HRESULT IWICImagingFactory::CreateColorContext([Out, Fast] IWICColorContext** ppIWICColorContext)</unmanaged>
        /// <unmanaged-short>IWICImagingFactory::CreateColorContext</unmanaged-short>
        internal unsafe void CreateColorContext(SharpDX.WIC.ColorContext wICColorContextOut)
        {
            System.IntPtr wICColorContextOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &wICColorContextOut_, (*(void ***)this._nativePointer)[15]);
            (wICColorContextOut).NativePointer = wICColorContextOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a new instance of the <strong><see cref = "SharpDX.WIC.ColorTransform"/></strong> class.</p>
        /// </summary>
        /// <param name = "wICColorTransformOut">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690300</doc-id>
        /// <unmanaged>HRESULT IWICImagingFactory::CreateColorTransformer([Out, Fast] IWICColorTransform** ppIWICColorTransform)</unmanaged>
        /// <unmanaged-short>IWICImagingFactory::CreateColorTransformer</unmanaged-short>
        internal unsafe void CreateColorTransformer(SharpDX.WIC.ColorTransform wICColorTransformOut)
        {
            System.IntPtr wICColorTransformOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &wICColorTransformOut_, (*(void ***)this._nativePointer)[16]);
            (wICColorTransformOut).NativePointer = wICColorTransformOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates an <strong><see cref = "SharpDX.WIC.Bitmap"/></strong> object.</p>
        /// </summary>
        /// <param name = "width">No documentation.</param>
        /// <param name = "height">No documentation.</param>
        /// <param name = "ixelFormatRef">No documentation.</param>
        /// <param name = "option">No documentation.</param>
        /// <param name = "bitmapOut">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690282</doc-id>
        /// <unmanaged>HRESULT IWICImagingFactory::CreateBitmap([In] unsigned int uiWidth,[In] unsigned int uiHeight,[In] const GUID&amp; pixelFormat,[In] WICBitmapCreateCacheOption option,[Out, Fast] IWICBitmap** ppIBitmap)</unmanaged>
        /// <unmanaged-short>IWICImagingFactory::CreateBitmap</unmanaged-short>
        internal unsafe void CreateBitmap(System.Int32 width, System.Int32 height, System.Guid ixelFormatRef, SharpDX.WIC.BitmapCreateCacheOption option, SharpDX.WIC.Bitmap bitmapOut)
        {
            System.IntPtr bitmapOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, width, height, &ixelFormatRef, unchecked ((System.Int32)option), &bitmapOut_, (*(void ***)this._nativePointer)[17]);
            (bitmapOut).NativePointer = bitmapOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a <strong><see cref = "SharpDX.WIC.Bitmap"/></strong> from a <strong><see cref = "SharpDX.WIC.BitmapSource"/></strong>.</p>
        /// </summary>
        /// <param name = "bitmapSourceRef">No documentation.</param>
        /// <param name = "option">No documentation.</param>
        /// <param name = "bitmapOut">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690293</doc-id>
        /// <unmanaged>HRESULT IWICImagingFactory::CreateBitmapFromSource([In, Optional] IWICBitmapSource* pIBitmapSource,[In] WICBitmapCreateCacheOption option,[Out, Fast] IWICBitmap** ppIBitmap)</unmanaged>
        /// <unmanaged-short>IWICImagingFactory::CreateBitmapFromSource</unmanaged-short>
        internal unsafe void CreateBitmapFromSource(SharpDX.WIC.BitmapSource bitmapSourceRef, SharpDX.WIC.BitmapCreateCacheOption option, SharpDX.WIC.Bitmap bitmapOut)
        {
            System.IntPtr bitmapSourceRef_ = System.IntPtr.Zero;
            System.IntPtr bitmapOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            bitmapSourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.BitmapSource>(bitmapSourceRef);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)bitmapSourceRef_, unchecked ((System.Int32)option), &bitmapOut_, (*(void ***)this._nativePointer)[18]);
            (bitmapOut).NativePointer = bitmapOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates an <strong><see cref = "SharpDX.WIC.Bitmap"/></strong> from a specified rectangle of an <strong><see cref = "SharpDX.WIC.BitmapSource"/></strong>.</p>
        /// </summary>
        /// <param name = "bitmapSourceRef">No documentation.</param>
        /// <param name = "x">No documentation.</param>
        /// <param name = "y">No documentation.</param>
        /// <param name = "width">No documentation.</param>
        /// <param name = "height">No documentation.</param>
        /// <param name = "bitmapOut">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Providing a rectangle that is larger than the source will produce undefined results.</p><p>This method always creates a separate copy of the source image, similar to the cache option <strong>WICBitmapCacheOnLoad</strong>.</p>
        /// </remarks>
        /// <doc-id>ee690294</doc-id>
        /// <unmanaged>HRESULT IWICImagingFactory::CreateBitmapFromSourceRect([In, Optional] IWICBitmapSource* pIBitmapSource,[In] unsigned int x,[In] unsigned int y,[In] unsigned int width,[In] unsigned int height,[Out, Fast] IWICBitmap** ppIBitmap)</unmanaged>
        /// <unmanaged-short>IWICImagingFactory::CreateBitmapFromSourceRect</unmanaged-short>
        internal unsafe void CreateBitmapFromSourceRect(SharpDX.WIC.BitmapSource bitmapSourceRef, System.Int32 x, System.Int32 y, System.Int32 width, System.Int32 height, SharpDX.WIC.Bitmap bitmapOut)
        {
            System.IntPtr bitmapSourceRef_ = System.IntPtr.Zero;
            System.IntPtr bitmapOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            bitmapSourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.BitmapSource>(bitmapSourceRef);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)bitmapSourceRef_, x, y, width, height, &bitmapOut_, (*(void ***)this._nativePointer)[19]);
            (bitmapOut).NativePointer = bitmapOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates an <strong><see cref = "SharpDX.WIC.Bitmap"/></strong> from a memory block.</p>
        /// </summary>
        /// <param name = "width">No documentation.</param>
        /// <param name = "height">No documentation.</param>
        /// <param name = "ixelFormatRef">No documentation.</param>
        /// <param name = "stride">No documentation.</param>
        /// <param name = "bufferSize">No documentation.</param>
        /// <param name = "bufferRef">No documentation.</param>
        /// <param name = "bitmapOut">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The size of the <see cref = "SharpDX.WIC.Bitmap"/> to be created must be smaller than or equal to the size of the image in <em>pbBuffer</em>.</p><p>The stride of the destination bitmap will equal the <em>stride</em> of the source data, regardless of the width and height specified.</p><p>The <em>pixelFormat</em> parameter defines the pixel format for both the input data and the output bitmap.</p>
        /// </remarks>
        /// <doc-id>ee690291</doc-id>
        /// <unmanaged>HRESULT IWICImagingFactory::CreateBitmapFromMemory([In] unsigned int uiWidth,[In] unsigned int uiHeight,[In] const GUID&amp; pixelFormat,[In] unsigned int cbStride,[In] unsigned int cbBufferSize,[In] unsigned char* pbBuffer,[Out, Fast] IWICBitmap** ppIBitmap)</unmanaged>
        /// <unmanaged-short>IWICImagingFactory::CreateBitmapFromMemory</unmanaged-short>
        internal unsafe void CreateBitmapFromMemory(System.Int32 width, System.Int32 height, System.Guid ixelFormatRef, System.Int32 stride, System.Int32 bufferSize, System.IntPtr bufferRef, SharpDX.WIC.Bitmap bitmapOut)
        {
            System.IntPtr bitmapOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, width, height, &ixelFormatRef, stride, bufferSize, (void *)bufferRef, &bitmapOut_, (*(void ***)this._nativePointer)[20]);
            (bitmapOut).NativePointer = bitmapOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates an <strong><see cref = "SharpDX.WIC.Bitmap"/></strong> from a bitmap handle.</p>
        /// </summary>
        /// <param name = "hBitmap">No documentation.</param>
        /// <param name = "hPalette">No documentation.</param>
        /// <param name = "options">No documentation.</param>
        /// <param name = "bitmapOut">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>For a non-palletized bitmap, set <c>null</c> for the <em>hPalette</em> parameter.</p>
        /// </remarks>
        /// <doc-id>ee690287</doc-id>
        /// <unmanaged>HRESULT IWICImagingFactory::CreateBitmapFromHBITMAP([In] HBITMAP hBitmap,[In, Optional] HPALETTE hPalette,[In] WICBitmapAlphaChannelOption options,[Out, Fast] IWICBitmap** ppIBitmap)</unmanaged>
        /// <unmanaged-short>IWICImagingFactory::CreateBitmapFromHBITMAP</unmanaged-short>
        internal unsafe void CreateBitmapFromHBITMAP(System.IntPtr hBitmap, System.IntPtr hPalette, SharpDX.WIC.BitmapAlphaChannelOption options, SharpDX.WIC.Bitmap bitmapOut)
        {
            System.IntPtr bitmapOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)hBitmap, (void *)hPalette, unchecked ((System.Int32)options), &bitmapOut_, (*(void ***)this._nativePointer)[21]);
            (bitmapOut).NativePointer = bitmapOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates an <strong><see cref = "SharpDX.WIC.Bitmap"/></strong> from an icon handle.</p>
        /// </summary>
        /// <param name = "hIcon">No documentation.</param>
        /// <param name = "bitmapOut">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690289</doc-id>
        /// <unmanaged>HRESULT IWICImagingFactory::CreateBitmapFromHICON([In] HICON hIcon,[Out, Fast] IWICBitmap** ppIBitmap)</unmanaged>
        /// <unmanaged-short>IWICImagingFactory::CreateBitmapFromHICON</unmanaged-short>
        internal unsafe void CreateBitmapFromHICON(System.IntPtr hIcon, SharpDX.WIC.Bitmap bitmapOut)
        {
            System.IntPtr bitmapOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)hIcon, &bitmapOut_, (*(void ***)this._nativePointer)[22]);
            (bitmapOut).NativePointer = bitmapOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates an <see cref = "SharpDX.ComObject"/> object of the specified component types.</p>
        /// </summary>
        /// <param name = "componentTypes">No documentation.</param>
        /// <param name = "options">No documentation.</param>
        /// <param name = "enumUnknownOut">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Component types must be enumerated seperately. Combinations of component types and <strong>WICAllComponents</strong> are unsupported.</p>
        /// </remarks>
        /// <doc-id>ee690301</doc-id>
        /// <unmanaged>HRESULT IWICImagingFactory::CreateComponentEnumerator([In] DWORD componentTypes,[In] DWORD options,[Out, Fast] IEnumUnknown** ppIEnumUnknown)</unmanaged>
        /// <unmanaged-short>IWICImagingFactory::CreateComponentEnumerator</unmanaged-short>
        internal unsafe void CreateComponentEnumerator(System.Int32 componentTypes, System.Int32 options, SharpDX.ComObject enumUnknownOut)
        {
            System.IntPtr enumUnknownOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, componentTypes, options, &enumUnknownOut_, (*(void ***)this._nativePointer)[23]);
            (enumUnknownOut).NativePointer = enumUnknownOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a new instance of the fast metadata encoder based on the given <strong><see cref = "SharpDX.WIC.BitmapDecoder"/></strong>.</p>
        /// </summary>
        /// <param name = "decoderRef">No documentation.</param>
        /// <param name = "fastEncoderOut">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The Windows provided codecs do not support fast metadata encoding at the decoder level, and only support fast metadata encoding at the frame level. To create a fast metadata encoder from a frame, see <strong>CreateFastMetadataEncoderFromFrameDecode</strong>.</p>
        /// </remarks>
        /// <doc-id>ee690313</doc-id>
        /// <unmanaged>HRESULT IWICImagingFactory::CreateFastMetadataEncoderFromDecoder([In, Optional] IWICBitmapDecoder* pIDecoder,[Out, Fast] IWICFastMetadataEncoder** ppIFastEncoder)</unmanaged>
        /// <unmanaged-short>IWICImagingFactory::CreateFastMetadataEncoderFromDecoder</unmanaged-short>
        internal unsafe void CreateFastMetadataEncoderFromDecoder(SharpDX.WIC.BitmapDecoder decoderRef, SharpDX.WIC.FastMetadataEncoder fastEncoderOut)
        {
            System.IntPtr decoderRef_ = System.IntPtr.Zero;
            System.IntPtr fastEncoderOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            decoderRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.BitmapDecoder>(decoderRef);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)decoderRef_, &fastEncoderOut_, (*(void ***)this._nativePointer)[24]);
            (fastEncoderOut).NativePointer = fastEncoderOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a new instance of the fast metadata encoder based on the given image frame.</p>
        /// </summary>
        /// <param name = "frameDecoderRef"><dd>  <p>The <strong><see cref = "SharpDX.WIC.BitmapFrameDecode"/></strong> to create the <strong><see cref = "SharpDX.WIC.FastMetadataEncoder"/></strong> from.</p> </dd></param>
        /// <param name = "fastEncoderOut"><dd>  <p>When this method returns, contains a reference to a new fast metadata encoder.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>For a list of support metadata formats for fast metadata encoding, see WIC Metadata Overview.</p>
        /// </remarks>
        /// <doc-id>ee690315</doc-id>
        /// <unmanaged>HRESULT IWICImagingFactory::CreateFastMetadataEncoderFromFrameDecode([In, Optional] IWICBitmapFrameDecode* pIFrameDecoder,[Out, Fast] IWICFastMetadataEncoder** ppIFastEncoder)</unmanaged>
        /// <unmanaged-short>IWICImagingFactory::CreateFastMetadataEncoderFromFrameDecode</unmanaged-short>
        internal unsafe void CreateFastMetadataEncoderFromFrameDecode(SharpDX.WIC.BitmapFrameDecode frameDecoderRef, SharpDX.WIC.FastMetadataEncoder fastEncoderOut)
        {
            System.IntPtr frameDecoderRef_ = System.IntPtr.Zero;
            System.IntPtr fastEncoderOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            frameDecoderRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.BitmapFrameDecode>(frameDecoderRef);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)frameDecoderRef_, &fastEncoderOut_, (*(void ***)this._nativePointer)[25]);
            (fastEncoderOut).NativePointer = fastEncoderOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Proxy function for the <strong>CreateQueryWriter</strong> method.</p>
        /// </summary>
        /// <param name = "guidMetadataFormat">No documentation.</param>
        /// <param name = "guidVendorRef">No documentation.</param>
        /// <param name = "queryWriterOut">No documentation.</param>
        /// <returns><p>If this function succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690324</doc-id>
        /// <unmanaged>HRESULT IWICImagingFactory::CreateQueryWriter([In] const GUID&amp; guidMetadataFormat,[In, Optional] const GUID* pguidVendor,[Out, Fast] IWICMetadataQueryWriter** ppIQueryWriter)</unmanaged>
        /// <unmanaged-short>IWICImagingFactory::CreateQueryWriter</unmanaged-short>
        internal unsafe void CreateQueryWriter(System.Guid guidMetadataFormat, System.Guid? guidVendorRef, SharpDX.WIC.MetadataQueryWriter queryWriterOut)
        {
            System.Guid guidVendorRef_;
            System.IntPtr queryWriterOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            if (guidVendorRef != null)
                guidVendorRef_ = guidVendorRef.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &guidMetadataFormat, guidVendorRef == null ? (void *)0 : &guidVendorRef_, &queryWriterOut_, (*(void ***)this._nativePointer)[26]);
            (queryWriterOut).NativePointer = queryWriterOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Proxy function for the <strong>CreateQueryWriterFromReader</strong> method.</p>
        /// </summary>
        /// <param name = "queryReaderRef">No documentation.</param>
        /// <param name = "guidVendorRef">No documentation.</param>
        /// <param name = "queryWriterOut">No documentation.</param>
        /// <returns><p>If this function succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee690323</doc-id>
        /// <unmanaged>HRESULT IWICImagingFactory::CreateQueryWriterFromReader([In, Optional] IWICMetadataQueryReader* pIQueryReader,[In, Optional] const GUID* pguidVendor,[Out, Fast] IWICMetadataQueryWriter** ppIQueryWriter)</unmanaged>
        /// <unmanaged-short>IWICImagingFactory::CreateQueryWriterFromReader</unmanaged-short>
        internal unsafe void CreateQueryWriterFromReader(SharpDX.WIC.MetadataQueryReader queryReaderRef, System.Guid? guidVendorRef, SharpDX.WIC.MetadataQueryWriter queryWriterOut)
        {
            System.IntPtr queryReaderRef_ = System.IntPtr.Zero;
            System.Guid guidVendorRef_;
            System.IntPtr queryWriterOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            queryReaderRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.MetadataQueryReader>(queryReaderRef);
            if (guidVendorRef != null)
                guidVendorRef_ = guidVendorRef.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)queryReaderRef_, guidVendorRef == null ? (void *)0 : &guidVendorRef_, &queryWriterOut_, (*(void ***)this._nativePointer)[27]);
            (queryWriterOut).NativePointer = queryWriterOut_;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("7B816B45-1996-4476-B132-DE9E247C8AF0")]
    public partial class ImagingFactory2 : SharpDX.WIC.ImagingFactory
    {
        public ImagingFactory2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ImagingFactory2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ImagingFactory2(nativePtr);
        /// <summary>
        /// <p>Creates a new image encoder object.</p>
        /// </summary>
        /// <param name = "d2DDeviceRef"><dd> <p>The <strong><see cref = "SharpDX.Direct2D1.Device"/></strong> object on which the corresponding image encoder is created.</p> </dd></param>
        /// <param name = "wICImageEncoderOut"><dd> <p>A reference to a variable that receives a reference to the <strong><see cref = "SharpDX.WIC.ImageEncoder"/></strong> interface for the encoder object that you can use to encode Direct2D images.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>You must create images to pass to the image encoder  on the same Direct2D device that you pass to this method. </p><p>You are responsible for setting up the bitmap encoder itself through the existing <strong><see cref = "SharpDX.WIC.BitmapEncoder"/></strong> APIs. The <strong><see cref = "SharpDX.WIC.BitmapEncoder"/></strong> or the <see cref = "SharpDX.WIC.BitmapFrameEncode"/> object is passed to each of the <strong><see cref = "SharpDX.WIC.ImageEncoder"/></strong> methods: <strong>WriteThumbnail</strong>, <strong>WriteFrame</strong>, and <strong>WriteFrameThumbnail</strong>. 
        /// </p>
        /// </remarks>
        /// <doc-id>hh880849</doc-id>
        /// <unmanaged>HRESULT IWICImagingFactory2::CreateImageEncoder([In] ID2D1Device* pD2DDevice,[Out, Fast] IWICImageEncoder** ppWICImageEncoder)</unmanaged>
        /// <unmanaged-short>IWICImagingFactory2::CreateImageEncoder</unmanaged-short>
        internal unsafe void CreateImageEncoder(SharpDX.Direct2D1.Device d2DDeviceRef, SharpDX.WIC.ImageEncoder wICImageEncoderOut)
        {
            System.IntPtr d2DDeviceRef_ = System.IntPtr.Zero;
            System.IntPtr wICImageEncoderOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            d2DDeviceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Device>(d2DDeviceRef);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)d2DDeviceRef_, &wICImageEncoderOut_, (*(void ***)this._nativePointer)[28]);
            (wICImageEncoderOut).NativePointer = wICImageEncoderOut_;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("8939F66E-C46A-4c21-A9D1-98B327CE1679")]
    public partial class JpegFrameDecode : SharpDX.ComObject
    {
        public JpegFrameDecode(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator JpegFrameDecode(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new JpegFrameDecode(nativePtr);
        /// <summary>
        /// <p>Retrieves  header data from the entire frame.  The result includes parameters from the Start Of Frame (SOF) marker for the scan as well as parameters derived from other metadata such as the color model of the compressed data.</p>
        /// </summary>
        /// <doc-id>dn903851</doc-id>
        /// <unmanaged>GetFrameHeader</unmanaged>
        /// <unmanaged-short>GetFrameHeader</unmanaged-short>
        public SharpDX.WIC.JpegFrameHeader FrameHeader
        {
            get
            {
                GetFrameHeader(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Retrieves a value indicating whether this decoder supports indexing for efficient random access.</p>
        /// </summary>
        /// <param name = "fIndexingSupportedRef"><dd>  <p>True if indexing is supported; otherwise, false.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> on successful completion.</p></returns>
        /// <remarks>
        /// <p>Indexing is only supported for some JPEG types. Call this method</p>
        /// </remarks>
        /// <doc-id>dn903843</doc-id>
        /// <unmanaged>HRESULT IWICJpegFrameDecode::DoesSupportIndexing([Out] BOOL* pfIndexingSupported)</unmanaged>
        /// <unmanaged-short>IWICJpegFrameDecode::DoesSupportIndexing</unmanaged-short>
        public unsafe void DoesSupportIndexing(out SharpDX.Mathematics.Interop.RawBool fIndexingSupportedRef)
        {
            fIndexingSupportedRef = default (SharpDX.Mathematics.Interop.RawBool);
            SharpDX.Result __result__;
            fixed (void *fIndexingSupportedRef_ = &fIndexingSupportedRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, fIndexingSupportedRef_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Enables indexing of the JPEG for efficient random access.</p>
        /// </summary>
        /// <param name = "options"><dd>  <p>A value specifying whether indexes should be generated immediately or deferred until a future call to <strong>IWICBitmapSource::CopyPixels</strong>.</p> </dd></param>
        /// <param name = "horizontalIntervalSize"><dd>  <p>The granularity of the indexing, in pixels.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> upon successful completion.</p></returns>
        /// <remarks>
        /// <p>This method enables efficient random-access to the image pixels at the expense of memory usage.  The amount of memory required for indexing depends on the requested index granularity.   Unless <strong>SetIndexing</strong> is called, it is much more efficient to access a JPEG by progressing through its pixels top-down during calls to <strong>IWICBitmapSource::CopyPixels</strong>.
        /// </p><p>This method will fail if indexing is unsupported on the file.  <strong>IWICJpegFrameDecode::DoesSupportIndexing</strong> should be called to first determine whether indexing is supported.  If this method is called multiple times, the final call changes the index granularity to the requested size.
        /// </p><p>The provided interval size controls horizontal spacing of index entries.  This value is internally rounded up according to the JPEG?s MCU (minimum coded unit) size, which is typically either 8 or 16 unscaled pixels.  The vertical size of the index interval is always equal to one MCU size.</p><p> Indexes can be generated immediately, or during future calls to <strong>IWICBitmapSource::CopyPixels</strong> to reduce redundant decompression work. </p>
        /// </remarks>
        /// <doc-id>dn903861</doc-id>
        /// <unmanaged>HRESULT IWICJpegFrameDecode::SetIndexing([In] WICJpegIndexingOptions options,[In] unsigned int horizontalIntervalSize)</unmanaged>
        /// <unmanaged-short>IWICJpegFrameDecode::SetIndexing</unmanaged-short>
        public unsafe void SetIndexing(SharpDX.WIC.JpegIndexingOptions options, System.Int32 horizontalIntervalSize)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)options), horizontalIntervalSize, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Removes the indexing from a JPEG that has been indexed using <strong>IWICJpegFrameDecode::SetIndexing</strong>.</p>
        /// </summary>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> upons successful completion.</p></returns>
        /// <doc-id>dn903837</doc-id>
        /// <unmanaged>HRESULT IWICJpegFrameDecode::ClearIndexing()</unmanaged>
        /// <unmanaged-short>IWICJpegFrameDecode::ClearIndexing</unmanaged-short>
        public unsafe void ClearIndexing()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves a copy of the AC Huffman table for the specified scan and table.</p>
        /// </summary>
        /// <param name = "scanIndex"><dd>  <p>The zero-based index of the scan for which data is retrieved.</p> </dd></param>
        /// <param name = "tableIndex"><dd>  <p>The index of the AC Huffman table to retrieve. Valid indices for a given scan can be determined by retrieving the scan header with <strong>IWICJpegFrameDecode::GetScanHeader</strong>.</p> </dd></param>
        /// <param name = "acHuffmanTableRef"><dd>  <p>A reference that receives the table data. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return value</th><th>Description</th></tr> <tr><td> <dl> <dt><see cref = "SharpDX.Result.Ok"/></dt> </dl> </td><td> <p>The operation was successful.</p> </td></tr> <tr><td> <dl> <dt><see cref = "InvalidJpegscanindex"/> </dt> </dl> </td><td> <p>The specified scan index is invalid.</p> </td></tr> <tr><td> <dl> <dt><see cref = "InvalidParameter"/></dt> </dl> </td><td> <p>Can occur if <em>pAcHuffmanTable</em> is <c>null</c> or if <em>tableIndex</em> does not point to a valid table slot. Check the scan header for valid table indices.</p> </td></tr> </table><p>?</p></returns>
        /// <doc-id>dn903845</doc-id>
        /// <unmanaged>HRESULT IWICJpegFrameDecode::GetAcHuffmanTable([In] unsigned int scanIndex,[In] unsigned int tableIndex,[Out] DXGI_JPEG_AC_HUFFMAN_TABLE* pAcHuffmanTable)</unmanaged>
        /// <unmanaged-short>IWICJpegFrameDecode::GetAcHuffmanTable</unmanaged-short>
        public unsafe void GetAcHuffmanTable(System.Int32 scanIndex, System.Int32 tableIndex, out SharpDX.DXGI.JpegAcHuffmanTable acHuffmanTableRef)
        {
            SharpDX.DXGI.JpegAcHuffmanTable.__Native acHuffmanTableRef_ = default (SharpDX.DXGI.JpegAcHuffmanTable.__Native);
            acHuffmanTableRef = default (SharpDX.DXGI.JpegAcHuffmanTable);
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, scanIndex, tableIndex, &acHuffmanTableRef_, (*(void ***)this._nativePointer)[6]);
            acHuffmanTableRef.__MarshalFrom(ref acHuffmanTableRef_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves a copy of the DC Huffman table for the specified scan and table.</p>
        /// </summary>
        /// <param name = "scanIndex"><dd>  <p>The zero-based index of the scan for which data is retrieved.</p> </dd></param>
        /// <param name = "tableIndex"><dd>  <p>The index of the DC Huffman table to retrieve. Valid indices for a given scan can be determined by retrieving the scan header with <strong>IWICJpegFrameDecode::GetScanHeader</strong>.</p> </dd></param>
        /// <param name = "dcHuffmanTableRef"><dd>  <p>A reference that receives the table data. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return value</th><th>Description</th></tr> <tr><td> <dl> <dt><see cref = "SharpDX.Result.Ok"/></dt> </dl> </td><td> <p>The operation was successful.</p> </td></tr> <tr><td> <dl> <dt><see cref = "InvalidJpegscanindex"/> </dt> </dl> </td><td> <p>The specified scan index is invalid.</p> </td></tr> <tr><td> <dl> <dt><see cref = "InvalidParameter"/></dt> </dl> </td><td> <p>Can occur if <em>pTable</em> is <c>null</c> or if <em>tableIndex</em> does not point to a valid table slot. Check the scan header for valid table indices.</p> </td></tr> </table><p>?</p></returns>
        /// <doc-id>dn903848</doc-id>
        /// <unmanaged>HRESULT IWICJpegFrameDecode::GetDcHuffmanTable([In] unsigned int scanIndex,[In] unsigned int tableIndex,[Out] DXGI_JPEG_DC_HUFFMAN_TABLE* pDcHuffmanTable)</unmanaged>
        /// <unmanaged-short>IWICJpegFrameDecode::GetDcHuffmanTable</unmanaged-short>
        public unsafe void GetDcHuffmanTable(System.Int32 scanIndex, System.Int32 tableIndex, out SharpDX.DXGI.JpegDeviceContextHuffmanTable dcHuffmanTableRef)
        {
            SharpDX.DXGI.JpegDeviceContextHuffmanTable.__Native dcHuffmanTableRef_ = default (SharpDX.DXGI.JpegDeviceContextHuffmanTable.__Native);
            dcHuffmanTableRef = default (SharpDX.DXGI.JpegDeviceContextHuffmanTable);
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, scanIndex, tableIndex, &dcHuffmanTableRef_, (*(void ***)this._nativePointer)[7]);
            dcHuffmanTableRef.__MarshalFrom(ref dcHuffmanTableRef_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves a copy of the quantization table.</p>
        /// </summary>
        /// <param name = "scanIndex"><dd>  <p>The zero-based index of the scan for which data is retrieved.</p> </dd></param>
        /// <param name = "tableIndex"><dd>  <p>The index of the quantization table to retrieve. Valid indices for a given scan can be determined by retrieving the scan header with <strong>IWICJpegFrameDecode::GetScanHeader</strong>.</p> </dd></param>
        /// <param name = "quantizationTableRef"><dd>  <p>A reference that receives the table data. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return value</th><th>Description</th></tr> <tr><td> <dl> <dt><see cref = "SharpDX.Result.Ok"/></dt> </dl> </td><td> <p>The operation was successful.</p> </td></tr> <tr><td> <dl> <dt><see cref = "InvalidJpegscanindex"/> </dt> </dl> </td><td> <p>The specified scan index is invalid.</p> </td></tr> <tr><td> <dl> <dt><see cref = "InvalidParameter"/></dt> </dl> </td><td> <p>Can occur if <em>pTable</em> is <c>null</c> or if <em>tableIndex</em> does not point to a valid table slot. Check the scan header for valid table indices.</p> </td></tr> </table><p>?</p></returns>
        /// <doc-id>dn903854</doc-id>
        /// <unmanaged>HRESULT IWICJpegFrameDecode::GetQuantizationTable([In] unsigned int scanIndex,[In] unsigned int tableIndex,[Out] DXGI_JPEG_QUANTIZATION_TABLE* pQuantizationTable)</unmanaged>
        /// <unmanaged-short>IWICJpegFrameDecode::GetQuantizationTable</unmanaged-short>
        public unsafe void GetQuantizationTable(System.Int32 scanIndex, System.Int32 tableIndex, out SharpDX.DXGI.JpegQuantizationTable quantizationTableRef)
        {
            SharpDX.DXGI.JpegQuantizationTable.__Native quantizationTableRef_ = default (SharpDX.DXGI.JpegQuantizationTable.__Native);
            quantizationTableRef = default (SharpDX.DXGI.JpegQuantizationTable);
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, scanIndex, tableIndex, &quantizationTableRef_, (*(void ***)this._nativePointer)[8]);
            quantizationTableRef.__MarshalFrom(ref quantizationTableRef_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves  header data from the entire frame.  The result includes parameters from the Start Of Frame (SOF) marker for the scan as well as parameters derived from other metadata such as the color model of the compressed data.</p>
        /// </summary>
        /// <param name = "frameHeaderRef"><dd>  <p>A reference that receives the frame header data.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> on successful completion.</p></returns>
        /// <doc-id>dn903851</doc-id>
        /// <unmanaged>HRESULT IWICJpegFrameDecode::GetFrameHeader([Out] WICJpegFrameHeader* pFrameHeader)</unmanaged>
        /// <unmanaged-short>IWICJpegFrameDecode::GetFrameHeader</unmanaged-short>
        internal unsafe void GetFrameHeader(out SharpDX.WIC.JpegFrameHeader frameHeaderRef)
        {
            frameHeaderRef = default (SharpDX.WIC.JpegFrameHeader);
            SharpDX.Result __result__;
            fixed (void *frameHeaderRef_ = &frameHeaderRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, frameHeaderRef_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves parameters from the Start Of Scan (SOS) marker for the scan with the specified index.</p>
        /// </summary>
        /// <param name = "scanIndex"><dd>  <p>The index of the scan for which header data is retrieved.</p> </dd></param>
        /// <param name = "scanHeaderRef"><dd>  <p>A reference that receives the frame header data.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> on successful completion.</p></returns>
        /// <doc-id>dn903858</doc-id>
        /// <unmanaged>HRESULT IWICJpegFrameDecode::GetScanHeader([In] unsigned int scanIndex,[Out] WICJpegScanHeader* pScanHeader)</unmanaged>
        /// <unmanaged-short>IWICJpegFrameDecode::GetScanHeader</unmanaged-short>
        public unsafe void GetScanHeader(System.Int32 scanIndex, out SharpDX.WIC.JpegScanHeader scanHeaderRef)
        {
            scanHeaderRef = default (SharpDX.WIC.JpegScanHeader);
            SharpDX.Result __result__;
            fixed (void *scanHeaderRef_ = &scanHeaderRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, scanIndex, scanHeaderRef_, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves a copy of the compressed JPEG scan directly from the WIC decoder frame's output stream.</p>
        /// </summary>
        /// <param name = "scanIndex"><dd>  <p>The zero-based index of the scan for which data is retrieved.</p> </dd></param>
        /// <param name = "scanOffset"><dd>  <p>The byte position in the scan data to begin copying.  Use 0 on the first call.  If the output buffer size is insufficient to store the entire scan, this offset allows you to resume copying from the end of the previous copy operation.</p> </dd></param>
        /// <param name = "scanData"><dd>  <p>The size, in bytes, of the <em>pbScanData</em> array.</p> </dd></param>
        /// <param name = "scanDataRef"><dd>  <p>A reference that receives the table data. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <param name = "scanDataActualRef"><dd>  <p>A reference that receives the size of the scan data actually copied into <em>pbScanData</em>. The size returned may be smaller that the size of <em>cbScanData</em>. This  parameter may be <c>null</c>.</p> </dd></param>
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return value</th><th>Description</th></tr> <tr><td> <dl> <dt><see cref = "SharpDX.Result.Ok"/></dt> </dl> </td><td> <p>The operation was successful.</p> </td></tr> <tr><td> <dl> <dt><see cref = "InvalidJpegscanindex"/> </dt> </dl> </td><td> <p>The specified scan index is invalid.</p> </td></tr> </table><p>?</p></returns>
        /// <doc-id>dn903841</doc-id>
        /// <unmanaged>HRESULT IWICJpegFrameDecode::CopyScan([In] unsigned int scanIndex,[In] unsigned int scanOffset,[In] unsigned int cbScanData,[Out, Buffer] unsigned char* pbScanData,[Out] unsigned int* pcbScanDataActual)</unmanaged>
        /// <unmanaged-short>IWICJpegFrameDecode::CopyScan</unmanaged-short>
        public unsafe void CopyScan(System.Int32 scanIndex, System.Int32 scanOffset, System.Int32 scanData, System.Byte[] scanDataRef, out System.Int32 scanDataActualRef)
        {
            SharpDX.Result __result__;
            fixed (void *scanDataActualRef_ = &scanDataActualRef)
                fixed (void *scanDataRef_ = scanDataRef)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, scanIndex, scanOffset, scanData, scanDataRef_, scanDataActualRef_, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "streamOffset">No documentation.</param>
        /// <param name = "streamData">No documentation.</param>
        /// <param name = "streamDataRef">No documentation.</param>
        /// <param name = "streamDataActualRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT IWICJpegFrameDecode::CopyMinimalStream([In] unsigned int streamOffset,[In] unsigned int cbStreamData,[Out, Buffer] unsigned char* pbStreamData,[Out] unsigned int* pcbStreamDataActual)</unmanaged>
        /// <unmanaged-short>IWICJpegFrameDecode::CopyMinimalStream</unmanaged-short>
        public unsafe void CopyMinimalStream(System.Int32 streamOffset, System.Int32 streamData, System.Byte[] streamDataRef, out System.Int32 streamDataActualRef)
        {
            SharpDX.Result __result__;
            fixed (void *streamDataActualRef_ = &streamDataActualRef)
                fixed (void *streamDataRef_ = streamDataRef)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, streamOffset, streamData, streamDataRef_, streamDataActualRef_, (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("2F0C601F-D2C6-468C-ABFA-49495D983ED1")]
    public partial class JpegFrameEncode : SharpDX.ComObject
    {
        public JpegFrameEncode(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator JpegFrameEncode(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new JpegFrameEncode(nativePtr);
        /// <summary>
        /// <p>Retrieves a copy of the AC Huffman table for the specified scan and table.</p>
        /// </summary>
        /// <param name = "scanIndex"><dd>  <p>The zero-based index of the scan for which data is retrieved.</p> </dd></param>
        /// <param name = "tableIndex"><dd>  <p>The index of the AC Huffman table to retrieve.</p> </dd></param>
        /// <param name = "acHuffmanTableRef"><dd>  <p>A reference that receives the table data. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return value</th><th>Description</th></tr> <tr><td> <dl> <dt><see cref = "SharpDX.Result.Ok"/></dt> </dl> </td><td> <p>The operation was successful.</p> </td></tr> <tr><td> <dl> <dt><see cref = "InvalidJpegscanindex"/> </dt> </dl> </td><td> <p>The specified scan index is invalid.</p> </td></tr> <tr><td> <dl> <dt><see cref = "InvalidParameter"/></dt> </dl> </td><td> <p>Can occur if <em>pAcHuffmanTable</em> is <c>null</c> or if <em>tableIndex</em> does not point to a valid table slot. Check the scan header for valid table indices.</p> </td></tr> </table><p>?</p></returns>
        /// <doc-id>dn903867</doc-id>
        /// <unmanaged>HRESULT IWICJpegFrameEncode::GetAcHuffmanTable([In] unsigned int scanIndex,[In] unsigned int tableIndex,[Out] DXGI_JPEG_AC_HUFFMAN_TABLE* pAcHuffmanTable)</unmanaged>
        /// <unmanaged-short>IWICJpegFrameEncode::GetAcHuffmanTable</unmanaged-short>
        public unsafe void GetAcHuffmanTable(System.Int32 scanIndex, System.Int32 tableIndex, out SharpDX.DXGI.JpegAcHuffmanTable acHuffmanTableRef)
        {
            SharpDX.DXGI.JpegAcHuffmanTable.__Native acHuffmanTableRef_ = default (SharpDX.DXGI.JpegAcHuffmanTable.__Native);
            acHuffmanTableRef = default (SharpDX.DXGI.JpegAcHuffmanTable);
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, scanIndex, tableIndex, &acHuffmanTableRef_, (*(void ***)this._nativePointer)[3]);
            acHuffmanTableRef.__MarshalFrom(ref acHuffmanTableRef_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves a copy of the DC Huffman table for the specified scan and table.</p>
        /// </summary>
        /// <param name = "scanIndex"><dd> <p>The zero-based index of the scan for which data is retrieved.</p> </dd></param>
        /// <param name = "tableIndex"><dd> <p>The index of the DC Huffman table to retrieve. </p> </dd></param>
        /// <param name = "dcHuffmanTableRef"><dd> <p>A reference that receives the table data. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return value</th><th>Description</th></tr> <tr><td> <dl> <dt><see cref = "SharpDX.Result.Ok"/></dt> </dl> </td><td> <p>The operation was successful.</p> </td></tr> <tr><td> <dl> <dt><see cref = "InvalidJpegscanindex"/> </dt> </dl> </td><td> <p>The specified scan index is invalid.</p> </td></tr> <tr><td> <dl> <dt><see cref = "InvalidParameter"/></dt> </dl> </td><td> <p>Can occur if <em>pTable</em> is <c>null</c> or if <em>tableIndex</em> does not point to a valid table slot. Check the scan header for valid table indices.</p> </td></tr> </table><p>?</p></returns>
        /// <doc-id>dn903870</doc-id>
        /// <unmanaged>HRESULT IWICJpegFrameEncode::GetDcHuffmanTable([In] unsigned int scanIndex,[In] unsigned int tableIndex,[Out] DXGI_JPEG_DC_HUFFMAN_TABLE* pDcHuffmanTable)</unmanaged>
        /// <unmanaged-short>IWICJpegFrameEncode::GetDcHuffmanTable</unmanaged-short>
        public unsafe void GetDcHuffmanTable(System.Int32 scanIndex, System.Int32 tableIndex, out SharpDX.DXGI.JpegDeviceContextHuffmanTable dcHuffmanTableRef)
        {
            SharpDX.DXGI.JpegDeviceContextHuffmanTable.__Native dcHuffmanTableRef_ = default (SharpDX.DXGI.JpegDeviceContextHuffmanTable.__Native);
            dcHuffmanTableRef = default (SharpDX.DXGI.JpegDeviceContextHuffmanTable);
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, scanIndex, tableIndex, &dcHuffmanTableRef_, (*(void ***)this._nativePointer)[4]);
            dcHuffmanTableRef.__MarshalFrom(ref dcHuffmanTableRef_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves a copy of the quantization table.</p>
        /// </summary>
        /// <param name = "scanIndex"><dd>  <p>The zero-based index of the scan for which data is retrieved.</p> </dd></param>
        /// <param name = "tableIndex"><dd>  <p>The index of the quantization table to retrieve. </p> </dd></param>
        /// <param name = "quantizationTableRef"><dd>  <p>A reference that receives the table data. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return value</th><th>Description</th></tr> <tr><td> <dl> <dt><see cref = "SharpDX.Result.Ok"/></dt> </dl> </td><td> <p>The operation was successful.</p> </td></tr> <tr><td> <dl> <dt><see cref = "InvalidJpegscanindex"/> </dt> </dl> </td><td> <p>The specified scan index is invalid.</p> </td></tr> <tr><td> <dl> <dt><see cref = "InvalidParameter"/></dt> </dl> </td><td> <p>Can occur if <em>pTable</em> is <c>null</c> or if <em>tableIndex</em> does not point to a valid table slot. Check the scan header for valid table indices.</p> </td></tr> </table><p>?</p></returns>
        /// <doc-id>dn903873</doc-id>
        /// <unmanaged>HRESULT IWICJpegFrameEncode::GetQuantizationTable([In] unsigned int scanIndex,[In] unsigned int tableIndex,[Out] DXGI_JPEG_QUANTIZATION_TABLE* pQuantizationTable)</unmanaged>
        /// <unmanaged-short>IWICJpegFrameEncode::GetQuantizationTable</unmanaged-short>
        public unsafe void GetQuantizationTable(System.Int32 scanIndex, System.Int32 tableIndex, out SharpDX.DXGI.JpegQuantizationTable quantizationTableRef)
        {
            SharpDX.DXGI.JpegQuantizationTable.__Native quantizationTableRef_ = default (SharpDX.DXGI.JpegQuantizationTable.__Native);
            quantizationTableRef = default (SharpDX.DXGI.JpegQuantizationTable);
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, scanIndex, tableIndex, &quantizationTableRef_, (*(void ***)this._nativePointer)[5]);
            quantizationTableRef.__MarshalFrom(ref quantizationTableRef_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Writes scan data to a JPEG frame.</p>
        /// </summary>
        /// <param name = "scanData"><dd>  <p>The size of the data in the <em>pbScanData</em> parameter.</p> </dd></param>
        /// <param name = "scanDataRef"><dd>  <p>The scan data to write.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> on successful completion.</p></returns>
        /// <remarks>
        /// <p><strong>WriteScan</strong> may be called multiple times.  Each call appends the scan data specified to any previous scan data.  Complete the scan by calling <strong>IWICBitmapFrameEncode::Commit</strong>. </p><p>Any calls to set encoder parameters or image metadata that will appear before the scan data in the resulting JPEG file must be completed before the first call to this method.  This includes calls to <strong>IWICBitmapFrameEncode::SetColorContexts</strong> , <strong>IWICBitmapFrameEncode::SetPalette</strong>, <strong>IWICBitmapFrameEncode::SetPixelFormat</strong>, <strong>IWICBitmapFrameEncode::SetResolution</strong>, and <strong>IWICBitmapFrameEncode::SetThumbnail</strong>.  <strong>IWICBitmapFrameEncode::SetSize</strong> is required as it has no default value for encoded image size.
        /// </p>
        /// </remarks>
        /// <doc-id>dn903875</doc-id>
        /// <unmanaged>HRESULT IWICJpegFrameEncode::WriteScan([In] unsigned int cbScanData,[In, Buffer] const unsigned char* pbScanData)</unmanaged>
        /// <unmanaged-short>IWICJpegFrameEncode::WriteScan</unmanaged-short>
        public unsafe void WriteScan(System.Int32 scanData, System.Byte[] scanDataRef)
        {
            SharpDX.Result __result__;
            fixed (void *scanDataRef_ = scanDataRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, scanData, scanDataRef_, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("30989668-E1C9-4597-B395-458EEDB808DF")]
    public partial class MetadataQueryReader : SharpDX.ComObject
    {
        public MetadataQueryReader(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator MetadataQueryReader(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new MetadataQueryReader(nativePtr);
        /// <summary>
        /// <p>Gets the metadata query readers container format.</p>
        /// </summary>
        /// <doc-id>ee719709</doc-id>
        /// <unmanaged>GetContainerFormat</unmanaged>
        /// <unmanaged-short>GetContainerFormat</unmanaged-short>
        public System.Guid ContainerFormat
        {
            get
            {
                GetContainerFormat(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the metadata query readers container format.</p>
        /// </summary>
        /// <param name = "guidContainerFormatRef"><dd>  <p>Pointer that receives the cointainer format <see cref = "System.Guid"/>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee719709</doc-id>
        /// <unmanaged>HRESULT IWICMetadataQueryReader::GetContainerFormat([Out] GUID* pguidContainerFormat)</unmanaged>
        /// <unmanaged-short>IWICMetadataQueryReader::GetContainerFormat</unmanaged-short>
        internal unsafe void GetContainerFormat(out System.Guid guidContainerFormatRef)
        {
            guidContainerFormatRef = default (System.Guid);
            SharpDX.Result __result__;
            fixed (void *guidContainerFormatRef_ = &guidContainerFormatRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, guidContainerFormatRef_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the current path relative to the root metadata block.</p>
        /// </summary>
        /// <param name = "cchMaxLength"><dd>  <p>The length of the <em>wzNamespace</em> buffer.</p> </dd></param>
        /// <param name = "@namespace"><dd>  <p>Pointer that receives the current namespace location.</p> </dd></param>
        /// <param name = "cchActualLengthRef"><dd>  <p>The actual buffer length that was needed to retrieve the current namespace location.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>If you pass <strong><c>null</c></strong> to <em>wzNamespace</em>, <strong>GetLocation</strong> ignores <em>cchMaxLength</em> and returns the required buffer length to store the path in the variable that <em>pcchActualLength</em> points to.
        /// </p><p>If the query reader is relative to the top of the metadata hierarchy, it will return a single-char string.</p><p>If the query reader is relative to a nested metadata block, this method will return the path to the current query reader.</p>
        /// </remarks>
        /// <doc-id>ee719713</doc-id>
        /// <unmanaged>HRESULT IWICMetadataQueryReader::GetLocation([In] unsigned int cchMaxLength,[In] wchar_t* wzNamespace,[Out] unsigned int* pcchActualLength)</unmanaged>
        /// <unmanaged-short>IWICMetadataQueryReader::GetLocation</unmanaged-short>
        internal unsafe void GetLocation(System.Int32 cchMaxLength, System.IntPtr @namespace, out System.Int32 cchActualLengthRef)
        {
            SharpDX.Result __result__;
            fixed (void *cchActualLengthRef_ = &cchActualLengthRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, cchMaxLength, (void *)@namespace, cchActualLengthRef_, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the metadata block or item identified by a metadata query expression. </p>
        /// </summary>
        /// <param name = "name"><dd>  <p>The query expression to the requested metadata block or item.</p> </dd></param>
        /// <param name = "varValueRef"><dd>  <p>When this method returns, contains the metadata block or item requested.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p><strong>GetMetadataByName</strong> uses metadata query expressions to access embedded metadata. For more information on the metadata query language, see the Metadata Query Language Overview.</p><p>If multiple blocks or items exist that are expressed by the same query expression, the first metadata block or item found will be returned.</p>
        /// </remarks>
        /// <doc-id>ee719715</doc-id>
        /// <unmanaged>HRESULT IWICMetadataQueryReader::GetMetadataByName([In] const wchar_t* wzName,[In] PROPVARIANT* pvarValue)</unmanaged>
        /// <unmanaged-short>IWICMetadataQueryReader::GetMetadataByName</unmanaged-short>
        internal unsafe SharpDX.Result GetMetadataByName(System.String name, System.IntPtr varValueRef)
        {
            SharpDX.Result __result__;
            fixed (char *name_ = name)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)name_, (void *)varValueRef, (*(void ***)this._nativePointer)[5]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets an enumerator of all metadata items at the current relative location within the metadata hierarchy.</p>
        /// </summary>
        /// <returns><dd>  <p>A reference to a variable that receives a reference to the <strong><see cref = "SharpDX.ComObject"/></strong> interface for the enumerator that contains query strings that can be used in the current <strong><see cref = "SharpDX.WIC.MetadataQueryReader"/></strong>.</p> </dd></returns>
        /// <remarks>
        /// <p>The retrieved enumerator only contains query strings for the metadata blocks and items in the current level of the hierarchy.
        /// </p>
        /// </remarks>
        /// <doc-id>ee719711</doc-id>
        /// <unmanaged>HRESULT IWICMetadataQueryReader::GetEnumerator([Out] IEnumString** ppIEnumString)</unmanaged>
        /// <unmanaged-short>IWICMetadataQueryReader::GetEnumerator</unmanaged-short>
        internal unsafe System.IntPtr GetEnumerator()
        {
            System.IntPtr enumStringOut;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &enumStringOut, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
            return enumStringOut;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("A721791A-0DEF-4d06-BD91-2118BF1DB10B")]
    public partial class MetadataQueryWriter : SharpDX.WIC.MetadataQueryReader
    {
        public MetadataQueryWriter(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator MetadataQueryWriter(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new MetadataQueryWriter(nativePtr);
        /// <summary>
        /// <p>Sets a metadata item to a specific location.</p>
        /// </summary>
        /// <param name = "name"><dd>  <p>The name of the metadata item.</p> </dd></param>
        /// <param name = "varValueRef"><dd>  <p>The metadata to set.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p><strong>SetMetadataByName</strong> uses metadata query expressions to remove metadata. For more information on the metadata query language, see the Metadata Query Language Overview.</p><p> If the value set is a nested metadata block then use variant type <code>VT_UNKNOWN</code> and <em>pvarValue</em> pointing to the <strong><see cref = "SharpDX.WIC.MetadataQueryWriter"/></strong> of the new metadata block.   The ordering of metadata items is at the discretion of the query writer since relative locations are not specified. </p>
        /// </remarks>
        /// <doc-id>ee719720</doc-id>
        /// <unmanaged>HRESULT IWICMetadataQueryWriter::SetMetadataByName([In] const wchar_t* wzName,[In] const PROPVARIANT* pvarValue)</unmanaged>
        /// <unmanaged-short>IWICMetadataQueryWriter::SetMetadataByName</unmanaged-short>
        internal unsafe void SetMetadataByName(System.String name, System.IntPtr varValueRef)
        {
            SharpDX.Result __result__;
            fixed (char *name_ = name)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)name_, (void *)varValueRef, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Proxy function for the <strong>RemoveMetadataByName</strong> method.</p>
        /// </summary>
        /// <param name = "name">No documentation.</param>
        /// <returns><p>If this function succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee719719</doc-id>
        /// <unmanaged>HRESULT IWICMetadataQueryWriter::RemoveMetadataByName([In] const wchar_t* wzName)</unmanaged>
        /// <unmanaged-short>IWICMetadataQueryWriter::RemoveMetadataByName</unmanaged-short>
        public unsafe void RemoveMetadataByName(System.String name)
        {
            SharpDX.Result __result__;
            fixed (char *name_ = name)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)name_, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("00000040-a8f2-4877-ba0a-fd2b6645fb94")]
    public partial class Palette : SharpDX.ComObject
    {
        public Palette(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Palette(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Palette(nativePtr);
        /// <summary>
        /// <p>Retrieves the <strong><see cref = "SharpDX.WIC.BitmapPaletteType"/></strong> that describes the palette. </p>
        /// </summary>
        /// <remarks>
        /// <p><strong>WICBitmapPaletteCustom</strong> is used for palettes initialized from both <strong>InitializeCustom</strong> and <strong>InitializeFromBitmap</strong>. There is no distinction is made between optimized and custom palettes.</p>
        /// </remarks>
        /// <doc-id>ee719746</doc-id>
        /// <unmanaged>GetType</unmanaged>
        /// <unmanaged-short>GetType</unmanaged-short>
        public SharpDX.WIC.BitmapPaletteType TypeInfo
        {
            get
            {
                GetTypeInfo(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Proxy function for the <strong>GetColorCount</strong> method.</p>
        /// </summary>
        /// <doc-id>ee719743</doc-id>
        /// <unmanaged>GetColorCount</unmanaged>
        /// <unmanaged-short>GetColorCount</unmanaged-short>
        public System.Int32 ColorCount
        {
            get
            {
                GetColorCount(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Retrieves a value that describes whether the palette is black and white.</p>
        /// </summary>
        /// <remarks>
        /// <p>A palette is considered to be black and white only if it contains exactly two entries, one full black (0xFF000000) and one full white (0xFFFFFFF).
        /// </p>
        /// </remarks>
        /// <doc-id>ee719758</doc-id>
        /// <unmanaged>IsBlackWhite</unmanaged>
        /// <unmanaged-short>IsBlackWhite</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsBlackWhite
        {
            get
            {
                IsBlackWhite_(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Retrieves a value that describes whether a palette is grayscale.</p>
        /// </summary>
        /// <remarks>
        /// <p>A palette is considered grayscale only if, for every entry, the alpha value is 0xFF and the red, green and blue values match.
        /// </p>
        /// </remarks>
        /// <doc-id>ee719759</doc-id>
        /// <unmanaged>IsGrayscale</unmanaged>
        /// <unmanaged-short>IsGrayscale</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsGrayscale
        {
            get
            {
                IsGrayscale_(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Initializes the palette to one of the pre-defined palettes specified by <strong><see cref = "SharpDX.WIC.BitmapPaletteType"/></strong> and optionally adds a transparent color.</p>
        /// </summary>
        /// <param name = "ePaletteType">No documentation.</param>
        /// <param name = "fAddTransparentColor">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>If a transparent color is added to a palette, the palette is no longer predefined and is returned as <strong>WICBitmapPaletteTypeCustom</strong>. For palettes with less than 256 entries, the transparent entry is added to the end of the palette (that is, a 16-color palette becomes a 17-color palette). For palettes with 256 colors, the transparent palette entry will replace the last entry in the pre-defined palette.
        /// </p>
        /// </remarks>
        /// <doc-id>ee719756</doc-id>
        /// <unmanaged>HRESULT IWICPalette::InitializePredefined([In] WICBitmapPaletteType ePaletteType,[In] BOOL fAddTransparentColor)</unmanaged>
        /// <unmanaged-short>IWICPalette::InitializePredefined</unmanaged-short>
        public unsafe void Initialize(SharpDX.WIC.BitmapPaletteType ePaletteType, SharpDX.Mathematics.Interop.RawBool fAddTransparentColor)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, unchecked ((System.Int32)ePaletteType), fAddTransparentColor, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Proxy function for the <strong>InitializeCustom</strong> method.</p>
        /// </summary>
        /// <param name = "colorsRef">No documentation.</param>
        /// <param name = "count">No documentation.</param>
        /// <returns><p>If this function succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee719751</doc-id>
        /// <unmanaged>HRESULT IWICPalette::InitializeCustom([In, Buffer] unsigned int* pColors,[In] unsigned int cCount)</unmanaged>
        /// <unmanaged-short>IWICPalette::InitializeCustom</unmanaged-short>
        internal unsafe void Initialize(System.IntPtr colorsRef, System.Int32 count)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)colorsRef, count, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Initializes a palette using a computed optimized values based on the reference bitmap.</p>
        /// </summary>
        /// <param name = "surfaceRef"><dd>  <p>Pointer to the source bitmap.</p> </dd></param>
        /// <param name = "count"><dd>  <p>The number of colors to initialize the palette with.</p> </dd></param>
        /// <param name = "fAddTransparentColor"><dd>  <p>A value to indicate whether to add a transparent color.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p> The resulting palette contains the specified number of colors which best represent the colors present in the bitmap. The algorithm operates on the opaque RGB color value of each pixel in the reference bitmap and hence ignores any alpha values. If a transparent color is required, set the fAddTransparentColor parameter to <strong>TRUE</strong> and one fewer optimized color will be computed, reducing the <em>colorCount</em>, and a fully transparent color entry will be added. </p>
        /// </remarks>
        /// <doc-id>ee719752</doc-id>
        /// <unmanaged>HRESULT IWICPalette::InitializeFromBitmap([In, Optional] IWICBitmapSource* pISurface,[In] unsigned int cCount,[In] BOOL fAddTransparentColor)</unmanaged>
        /// <unmanaged-short>IWICPalette::InitializeFromBitmap</unmanaged-short>
        public unsafe void Initialize(SharpDX.WIC.BitmapSource surfaceRef, System.Int32 count, SharpDX.Mathematics.Interop.RawBool fAddTransparentColor)
        {
            System.IntPtr surfaceRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            surfaceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.BitmapSource>(surfaceRef);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, (void *)surfaceRef_, count, fAddTransparentColor, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Initialize the palette based on a given palette.</p>
        /// </summary>
        /// <param name = "paletteRef"><dd>  <p>Pointer to the source palette.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee719754</doc-id>
        /// <unmanaged>HRESULT IWICPalette::InitializeFromPalette([In, Optional] IWICPalette* pIPalette)</unmanaged>
        /// <unmanaged-short>IWICPalette::InitializeFromPalette</unmanaged-short>
        public unsafe void Initialize(SharpDX.WIC.Palette paletteRef)
        {
            System.IntPtr paletteRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            paletteRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.Palette>(paletteRef);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)paletteRef_, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the <strong><see cref = "SharpDX.WIC.BitmapPaletteType"/></strong> that describes the palette. </p>
        /// </summary>
        /// <param name = "ePaletteTypeRef">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p><strong>WICBitmapPaletteCustom</strong> is used for palettes initialized from both <strong>InitializeCustom</strong> and <strong>InitializeFromBitmap</strong>. There is no distinction is made between optimized and custom palettes.</p>
        /// </remarks>
        /// <doc-id>ee719746</doc-id>
        /// <unmanaged>HRESULT IWICPalette::GetType([Out] WICBitmapPaletteType* pePaletteType)</unmanaged>
        /// <unmanaged-short>IWICPalette::GetType</unmanaged-short>
        internal unsafe void GetTypeInfo(out SharpDX.WIC.BitmapPaletteType ePaletteTypeRef)
        {
            SharpDX.Result __result__;
            fixed (void *ePaletteTypeRef_ = &ePaletteTypeRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, ePaletteTypeRef_, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Proxy function for the <strong>GetColorCount</strong> method.</p>
        /// </summary>
        /// <param name = "countRef">No documentation.</param>
        /// <returns><p>If this function succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee719743</doc-id>
        /// <unmanaged>HRESULT IWICPalette::GetColorCount([Out] unsigned int* pcCount)</unmanaged>
        /// <unmanaged-short>IWICPalette::GetColorCount</unmanaged-short>
        internal unsafe void GetColorCount(out System.Int32 countRef)
        {
            SharpDX.Result __result__;
            fixed (void *countRef_ = &countRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, countRef_, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Fills out the supplied color array with the colors from the internal color table. The color array should be sized according to the return results from <strong>GetColorCount</strong>.</p>
        /// </summary>
        /// <param name = "count">No documentation.</param>
        /// <param name = "colorsRef">No documentation.</param>
        /// <param name = "actualColorsRef">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee719744</doc-id>
        /// <unmanaged>HRESULT IWICPalette::GetColors([In] unsigned int cCount,[Out, Buffer] unsigned int* pColors,[Out] unsigned int* pcActualColors)</unmanaged>
        /// <unmanaged-short>IWICPalette::GetColors</unmanaged-short>
        internal unsafe void GetColors(System.Int32 count, System.IntPtr colorsRef, out System.Int32 actualColorsRef)
        {
            SharpDX.Result __result__;
            fixed (void *actualColorsRef_ = &actualColorsRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, count, (void *)colorsRef, actualColorsRef_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves a value that describes whether the palette is black and white.</p>
        /// </summary>
        /// <param name = "fIsBlackWhiteRef"><dd>  <p>A reference to a variable  that receives a boolean value that indicates whether the palette is black and white. <strong>TRUE</strong> indicates that the palette is black and white; otherwise, <strong><see cref = "SharpDX.Result.False"/></strong>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>A palette is considered to be black and white only if it contains exactly two entries, one full black (0xFF000000) and one full white (0xFFFFFFF).
        /// </p>
        /// </remarks>
        /// <doc-id>ee719758</doc-id>
        /// <unmanaged>HRESULT IWICPalette::IsBlackWhite([Out] BOOL* pfIsBlackWhite)</unmanaged>
        /// <unmanaged-short>IWICPalette::IsBlackWhite</unmanaged-short>
        internal unsafe void IsBlackWhite_(out SharpDX.Mathematics.Interop.RawBool fIsBlackWhiteRef)
        {
            fIsBlackWhiteRef = default (SharpDX.Mathematics.Interop.RawBool);
            SharpDX.Result __result__;
            fixed (void *fIsBlackWhiteRef_ = &fIsBlackWhiteRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, fIsBlackWhiteRef_, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves a value that describes whether a palette is grayscale.</p>
        /// </summary>
        /// <param name = "fIsGrayscaleRef"><dd>  <p>A reference to a variable that receives a boolean value that indicates whether the palette is grayscale. <strong>TRUE</strong> indicates that the palette is grayscale; otherwise <strong><see cref = "SharpDX.Result.False"/></strong>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>A palette is considered grayscale only if, for every entry, the alpha value is 0xFF and the red, green and blue values match.
        /// </p>
        /// </remarks>
        /// <doc-id>ee719759</doc-id>
        /// <unmanaged>HRESULT IWICPalette::IsGrayscale([Out] BOOL* pfIsGrayscale)</unmanaged>
        /// <unmanaged-short>IWICPalette::IsGrayscale</unmanaged-short>
        internal unsafe void IsGrayscale_(out SharpDX.Mathematics.Interop.RawBool fIsGrayscaleRef)
        {
            fIsGrayscaleRef = default (SharpDX.Mathematics.Interop.RawBool);
            SharpDX.Result __result__;
            fixed (void *fIsGrayscaleRef_ = &fIsGrayscaleRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, fIsGrayscaleRef_, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Proxy function for the <strong>HasAlpha</strong> method.</p>
        /// </summary>
        /// <param name = "fHasAlphaRef">No documentation.</param>
        /// <returns><p>If this function succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee719749</doc-id>
        /// <unmanaged>HRESULT IWICPalette::HasAlpha([Out] BOOL* pfHasAlpha)</unmanaged>
        /// <unmanaged-short>IWICPalette::HasAlpha</unmanaged-short>
        public unsafe void HasAlpha(out SharpDX.Mathematics.Interop.RawBool fHasAlphaRef)
        {
            fHasAlphaRef = default (SharpDX.Mathematics.Interop.RawBool);
            SharpDX.Result __result__;
            fixed (void *fHasAlphaRef_ = &fHasAlphaRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, fHasAlphaRef_, (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("E8EDA601-3D48-431a-AB44-69059BE88BBE")]
    public partial class PixelFormatInfo : SharpDX.WIC.ComponentInfo
    {
        public PixelFormatInfo(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator PixelFormatInfo(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new PixelFormatInfo(nativePtr);
        /// <summary>
        /// <p>Gets the pixel format <see cref = "System.Guid"/>.</p>
        /// </summary>
        /// <doc-id>ee719774</doc-id>
        /// <unmanaged>GetFormatGUID</unmanaged>
        /// <unmanaged-short>GetFormatGUID</unmanaged-short>
        public System.Guid FormatGUID
        {
            get
            {
                GetFormatGUID(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the pixel format's <strong><see cref = "SharpDX.WIC.ColorContext"/></strong>.</p>
        /// </summary>
        /// <remarks>
        /// <p>The returned color context is the default color space for the pixel format. However, if an <see cref = "SharpDX.WIC.BitmapSource"/> specifies its own color context, the source's context should be preferred over the pixel format's default.
        /// </p>
        /// </remarks>
        /// <doc-id>ee719773</doc-id>
        /// <unmanaged>GetColorContext</unmanaged>
        /// <unmanaged-short>GetColorContext</unmanaged-short>
        public SharpDX.WIC.ColorContext ColorContext
        {
            get
            {
                GetColorContext(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Proxy function for the <strong>GetBitsPerPixel</strong> method.</p>
        /// </summary>
        /// <doc-id>ee719768</doc-id>
        /// <unmanaged>GetBitsPerPixel</unmanaged>
        /// <unmanaged-short>GetBitsPerPixel</unmanaged-short>
        public System.Int32 BitsPerPixel
        {
            get
            {
                GetBitsPerPixel(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Proxy function for the <strong>GetChannelCount</strong> method.</p>
        /// </summary>
        /// <doc-id>ee719770</doc-id>
        /// <unmanaged>GetChannelCount</unmanaged>
        /// <unmanaged-short>GetChannelCount</unmanaged-short>
        public System.Int32 ChannelCount
        {
            get
            {
                GetChannelCount(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the pixel format <see cref = "System.Guid"/>.</p>
        /// </summary>
        /// <param name = "formatRef"><dd>  <p>Pointer that receives the pixel format <see cref = "System.Guid"/>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee719774</doc-id>
        /// <unmanaged>HRESULT IWICPixelFormatInfo::GetFormatGUID([Out] GUID* pFormat)</unmanaged>
        /// <unmanaged-short>IWICPixelFormatInfo::GetFormatGUID</unmanaged-short>
        internal unsafe void GetFormatGUID(out System.Guid formatRef)
        {
            formatRef = default (System.Guid);
            SharpDX.Result __result__;
            fixed (void *formatRef_ = &formatRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, formatRef_, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the pixel format's <strong><see cref = "SharpDX.WIC.ColorContext"/></strong>.</p>
        /// </summary>
        /// <param name = "colorContextOut">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The returned color context is the default color space for the pixel format. However, if an <see cref = "SharpDX.WIC.BitmapSource"/> specifies its own color context, the source's context should be preferred over the pixel format's default.
        /// </p>
        /// </remarks>
        /// <doc-id>ee719773</doc-id>
        /// <unmanaged>HRESULT IWICPixelFormatInfo::GetColorContext([Out] IWICColorContext** ppIColorContext)</unmanaged>
        /// <unmanaged-short>IWICPixelFormatInfo::GetColorContext</unmanaged-short>
        internal unsafe void GetColorContext(out SharpDX.WIC.ColorContext colorContextOut)
        {
            System.IntPtr colorContextOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &colorContextOut_, (*(void ***)this._nativePointer)[12]);
            if (colorContextOut_ != System.IntPtr.Zero)
                colorContextOut = new SharpDX.WIC.ColorContext(colorContextOut_);
            else
                colorContextOut = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Proxy function for the <strong>GetBitsPerPixel</strong> method.</p>
        /// </summary>
        /// <param name = "bitsPerPixelRef">No documentation.</param>
        /// <returns><p>If this function succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee719768</doc-id>
        /// <unmanaged>HRESULT IWICPixelFormatInfo::GetBitsPerPixel([Out] unsigned int* puiBitsPerPixel)</unmanaged>
        /// <unmanaged-short>IWICPixelFormatInfo::GetBitsPerPixel</unmanaged-short>
        internal unsafe void GetBitsPerPixel(out System.Int32 bitsPerPixelRef)
        {
            SharpDX.Result __result__;
            fixed (void *bitsPerPixelRef_ = &bitsPerPixelRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, bitsPerPixelRef_, (*(void ***)this._nativePointer)[13]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Proxy function for the <strong>GetChannelCount</strong> method.</p>
        /// </summary>
        /// <param name = "channelCountRef">No documentation.</param>
        /// <returns><p>If this function succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee719770</doc-id>
        /// <unmanaged>HRESULT IWICPixelFormatInfo::GetChannelCount([Out] unsigned int* puiChannelCount)</unmanaged>
        /// <unmanaged-short>IWICPixelFormatInfo::GetChannelCount</unmanaged-short>
        internal unsafe void GetChannelCount(out System.Int32 channelCountRef)
        {
            SharpDX.Result __result__;
            fixed (void *channelCountRef_ = &channelCountRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, channelCountRef_, (*(void ***)this._nativePointer)[14]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the pixel format's channel mask.</p>
        /// </summary>
        /// <param name = "channelIndex"><dd>  <p>The index to the channel mask to retrieve.</p> </dd></param>
        /// <param name = "maskBuffer"><dd>  <p>The size of the <em>pbMaskBuffer</em> buffer.</p> </dd></param>
        /// <param name = "maskBufferRef"><dd>  <p>Pointer to the mask buffer.</p> </dd></param>
        /// <param name = "actualRef"><dd>  <p>The actual buffer size needed to obtain the channel mask.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>If 0 and <c>null</c> are passed in for <em>cbMaskBuffer</em> and <em>pbMaskBuffer</em>, respectively, the required buffer size will be returned through <em>pcbActual</em>.
        /// </p>
        /// </remarks>
        /// <doc-id>ee719771</doc-id>
        /// <unmanaged>HRESULT IWICPixelFormatInfo::GetChannelMask([In] unsigned int uiChannelIndex,[In] unsigned int cbMaskBuffer,[Out, Buffer, Optional] unsigned char* pbMaskBuffer,[Out] unsigned int* pcbActual)</unmanaged>
        /// <unmanaged-short>IWICPixelFormatInfo::GetChannelMask</unmanaged-short>
        internal unsafe void GetChannelMask(System.Int32 channelIndex, System.Int32 maskBuffer, System.Byte[] maskBufferRef, out System.Int32 actualRef)
        {
            SharpDX.Result __result__;
            fixed (void *actualRef_ = &actualRef)
                fixed (void *maskBufferRef_ = maskBufferRef)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, channelIndex, maskBuffer, maskBufferRef_, actualRef_, (*(void ***)this._nativePointer)[15]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("A9DB33A2-AF5F-43C7-B679-74F5984B5AA4")]
    public partial class PixelFormatInfo2 : SharpDX.WIC.PixelFormatInfo
    {
        public PixelFormatInfo2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator PixelFormatInfo2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new PixelFormatInfo2(nativePtr);
        /// <summary>
        /// <p>Returns whether the format supports transparent pixels.</p>
        /// </summary>
        /// <remarks>
        /// <p> An indexed pixel format will not return <strong>TRUE</strong> even though it may have some transparency support.
        /// </p>
        /// </remarks>
        /// <doc-id>ee719766</doc-id>
        /// <unmanaged>SupportsTransparency</unmanaged>
        /// <unmanaged-short>SupportsTransparency</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsSupportingTransparency
        {
            get
            {
                IsSupportingTransparency_(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ee719765</doc-id>
        /// <unmanaged>GetNumericRepresentation</unmanaged>
        /// <unmanaged-short>GetNumericRepresentation</unmanaged-short>
        public SharpDX.WIC.PixelFormatNumericRepresentation NumericRepresentation
        {
            get
            {
                GetNumericRepresentation(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Returns whether the format supports transparent pixels.</p>
        /// </summary>
        /// <param name = "fSupportsTransparencyRef"><dd>  <p>Returns <strong>TRUE</strong> if the pixel format supports transparency; otherwise, <strong><see cref = "SharpDX.Result.False"/></strong>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p> An indexed pixel format will not return <strong>TRUE</strong> even though it may have some transparency support.
        /// </p>
        /// </remarks>
        /// <doc-id>ee719766</doc-id>
        /// <unmanaged>HRESULT IWICPixelFormatInfo2::SupportsTransparency([Out] BOOL* pfSupportsTransparency)</unmanaged>
        /// <unmanaged-short>IWICPixelFormatInfo2::SupportsTransparency</unmanaged-short>
        internal unsafe void IsSupportingTransparency_(out SharpDX.Mathematics.Interop.RawBool fSupportsTransparencyRef)
        {
            fSupportsTransparencyRef = default (SharpDX.Mathematics.Interop.RawBool);
            SharpDX.Result __result__;
            fixed (void *fSupportsTransparencyRef_ = &fSupportsTransparencyRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, fSupportsTransparencyRef_, (*(void ***)this._nativePointer)[16]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "numericRepresentationRef"><dd>  <p>Returns the <strong><see cref = "SharpDX.WIC.PixelFormatNumericRepresentation"/></strong> of the pixel format.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee719765</doc-id>
        /// <unmanaged>HRESULT IWICPixelFormatInfo2::GetNumericRepresentation([Out] WICPixelFormatNumericRepresentation* pNumericRepresentation)</unmanaged>
        /// <unmanaged-short>IWICPixelFormatInfo2::GetNumericRepresentation</unmanaged-short>
        internal unsafe void GetNumericRepresentation(out SharpDX.WIC.PixelFormatNumericRepresentation numericRepresentationRef)
        {
            SharpDX.Result __result__;
            fixed (void *numericRepresentationRef_ = &numericRepresentationRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, numericRepresentationRef_, (*(void ***)this._nativePointer)[17]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("F928B7B8-2221-40C1-B72E-7E82F1974D1A")]
    public partial class PlanarBitmapFrameEncode : SharpDX.ComObject
    {
        public PlanarBitmapFrameEncode(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator PlanarBitmapFrameEncode(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new PlanarBitmapFrameEncode(nativePtr);
        /// <summary>
        /// <p>Writes lines from the source planes to the encoded format.</p>
        /// </summary>
        /// <param name = "lineCount"><dd>  <p>The number of lines to encode.  See the Remarks section for WIC Jpeg specific line count restrictions.</p> </dd></param>
        /// <param name = "planesRef"><dd>  <p>Specifies the source buffers for each component plane encoded.  </p> </dd></param>
        /// <param name = "planes"><dd>  <p>The number of component planes specified by the <em>pPlanes</em> parameter.</p> </dd></param>
        /// <returns><p>If the planes and source rectangle do not meet the requirements, this method fails with <strong><see cref = "Imagesizeoutofrange"/></strong>. If the <strong><see cref = "SharpDX.WIC.BitmapSource"/></strong> format does not meet the encoder requirements, this method fails with <strong><see cref = "UnsupportedPixelFormat"/></strong>.</p></returns>
        /// <remarks>
        /// <p>Successive <strong>WritePixels</strong> calls are assumed sequentially add scanlines to the output image.  <strong>IWICBitmapFrameEncode::Initialize</strong>, <strong>IWICBitmapFrameEncode::SetSize</strong> and <strong>IWICBitmapFrameEncode::SetPixelFormat</strong> must be called before this method or it will fail.</p><p>The interleaved pixel format set via <strong>IWICBitmapFrameEncode::SetPixelFormat</strong> and the codec specific encode parameters determine the supported planar formats.
        /// </p><p>WIC JPEG Encoder:
        /// QueryInterface can be used to obtain this interface from the WIC JPEG <strong><see cref = "SharpDX.WIC.BitmapFrameEncode"/></strong> implementation.  When using this method to encode Y?CbCr data with the WIC JPEG encoder, chroma subsampling can be configured with encoder options during frame creation.  See the Encoding Overview and <strong>IWICBitmapEncoder::CreateNewFrame</strong> for more details.   </p><p>Depending upon the configured chroma subsampling, the lineCount parameter has the following restrictions:
        /// </p><table> <tr><th>Chroma Subsampling</th><th>Line Count Restriction</th><th>Chroma Plane Width</th><th>Chroma  Plane Height</th></tr> <tr><td>4:2:0</td><td>Multiple of 2, unless the call covers the last scanline of the image</td><td>lumaWidth / 2 Rounded up to the nearest integer.</td><td>lumaHeight / 2 Rounded up to the nearest integer.</td></tr> <tr><td>4:2:2</td><td>Any</td><td>lumaWidth / 2 Rounded up to the nearest integer.</td><td>Any</td></tr> <tr><td>4:4:4</td><td>Any</td><td>Any</td><td>Any</td></tr> <tr><td>4:4:0</td><td>Multiple of 2, unless the call covers the last scanline of the image</td><td>Any</td><td>llumaHeight / 2 Rounded up to the nearest integer.</td></tr> </table><p>?</p><p>The full scanline width must be encoded, and the width of the bitmap sources must match their planar configuration.</p><p>Additionally, if a pixel format is set via <strong>IWICBitmapFrameEncode::SetPixelFormat</strong>, it must be <see cref = "Format24bppBGR"/>.   </p><p>The supported pixel formats of the bitmap sources passed into this method are as follows:
        /// </p><table> <tr><th>Plane Count</th><th>Plane 1</th><th>Plane 2</th><th>Plane 3</th></tr> <tr><td>3</td><td><see cref = "Format8bppY"/></td><td><see cref = "Format8bppCb"/></td><td><see cref = "Format8bppCr"/></td></tr> <tr><td>2</td><td><see cref = "Format8bppY"/></td><td><see cref = "Format16bppCbCr"/></td><td>N/A</td></tr> </table><p>?</p>
        /// </remarks>
        /// <doc-id>dn302091</doc-id>
        /// <unmanaged>HRESULT IWICPlanarBitmapFrameEncode::WritePixels([In] unsigned int lineCount,[In, Buffer] WICBitmapPlane* pPlanes,[In] unsigned int cPlanes)</unmanaged>
        /// <unmanaged-short>IWICPlanarBitmapFrameEncode::WritePixels</unmanaged-short>
        public unsafe void WritePixels(System.Int32 lineCount, SharpDX.WIC.BitmapPlane[] planesRef, System.Int32 planes)
        {
            SharpDX.Result __result__;
            fixed (void *planesRef_ = planesRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, lineCount, planesRef_, planes, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Writes lines from the source planes to the encoded format.</p>
        /// </summary>
        /// <param name = "planesOut"><dd>  <p>Specifies an array of <strong><see cref = "SharpDX.WIC.BitmapSource"/></strong> that represent image planes.</p> </dd></param>
        /// <param name = "planes"><dd>  <p>The number of component planes specified by the planes parameter.</p> </dd></param>
        /// <param name = "rcSourceRef"><dd>  <p>The source rectangle of pixels to encode from the <strong><see cref = "SharpDX.WIC.BitmapSource"/></strong> planes.  Null indicates the entire source.  The source rect width must match the width set through <strong>SetSize</strong>. Repeated <strong>WriteSource</strong> calls can be made as long as the total accumulated source rect height is the same as set through <strong>SetSize</strong>.  </p> </dd></param>
        /// <returns><p>If the planes and source rectangle do not meet the requirements, this method fails with <strong><see cref = "Imagesizeoutofrange"/></strong>. </p><p>If the <strong><see cref = "SharpDX.WIC.BitmapSource"/></strong> format does not meet the encoder requirements, this method fails with <strong><see cref = "UnsupportedPixelFormat"/></strong>.</p></returns>
        /// <remarks>
        /// <p>Successive <strong>WriteSource</strong> calls are assumed sequentially add scanlines to the output image.  <strong>IWICBitmapFrameEncode::Initialize</strong>, <strong>IWICBitmapFrameEncode::SetSize</strong> and <strong>IWICBitmapFrameEncode::SetPixelFormat</strong> must be called before this method or it will fail.</p><p>The interleaved pixel format set via <strong>IWICBitmapFrameEncode::SetPixelFormat</strong> and the codec specific encode parameters determine the supported planar formats.
        /// </p><p>WIC JPEG Encoder:
        /// QueryInterface can be used to obtain this interface from the WIC JPEG <strong><see cref = "SharpDX.WIC.BitmapFrameEncode"/></strong> implementation.  When using this method to encode Y?CbCr data with the WIC JPEG encoder, chroma subsampling can be configured with encoder options during frame creation.  See the Encoding Overview and <strong>IWICBitmapEncoder::CreateNewFrame</strong> for more details.   </p><p>Depending upon the configured chroma subsampling, the lineCount parameter has the following restrictions:
        /// </p><table> <tr><th>Chroma Subsampling</th><th>X Coordinate</th><th>Y Coordinate</th><th>Chroma Width</th><th>Chroma Height</th></tr> <tr><td>4:2:0</td><td>Multiple of 2</td><td>Multiple of 2</td><td>lumaWidth / 2 Rounded up to the nearest integer.</td><td>lumaHeight / 2 Rounded up to the nearest integer.</td></tr> <tr><td>4:2:2</td><td>Multiple of 2</td><td>Any</td><td>lumaWidth / 2 Rounded up to the nearest integer.</td><td>Any</td></tr> <tr><td>4:4:4</td><td>Any</td><td>Any</td><td>Any</td><td>Any</td></tr> <tr><td>4:4:0</td><td>Any</td><td>Multiple of 2</td><td>lumaWidth</td><td>llumaHeight / 2 Rounded up to the nearest integer.</td></tr> </table><p>?</p><p>The full scanline width must be encoded, and the width of the bitmap sources must match their planar configuration.</p><p>Additionally, if a pixel format is set via <strong>IWICBitmapFrameEncode::SetPixelFormat</strong>, it must be <see cref = "Format24bppBGR"/>.   </p><p>The supported pixel formats of the bitmap sources passed into this method are as follows:
        /// </p><table> <tr><th>Plane Count</th><th>Plane 1</th><th>Plane 2</th><th>Plane 3</th></tr> <tr><td>3</td><td><see cref = "Format8bppY"/></td><td><see cref = "Format8bppCb"/></td><td><see cref = "Format8bppCr"/></td></tr> <tr><td>2</td><td><see cref = "Format8bppY"/></td><td><see cref = "Format16bppCbCr"/></td><td>N/A</td></tr> </table><p>?</p>
        /// </remarks>
        /// <doc-id>dn302092</doc-id>
        /// <unmanaged>HRESULT IWICPlanarBitmapFrameEncode::WriteSource([In, Buffer] IWICBitmapSource** ppPlanes,[In] unsigned int cPlanes,[In, Optional] WICRect* prcSource)</unmanaged>
        /// <unmanaged-short>IWICPlanarBitmapFrameEncode::WriteSource</unmanaged-short>
        public unsafe void WriteSource(SharpDX.WIC.BitmapSource[] planesOut, System.Int32 planes, SharpDX.Mathematics.Interop.RawBox? rcSourceRef)
        {
            System.IntPtr*planesOut_;
            planesOut_ = (System.IntPtr*)0;
            if (planesOut != null)
            {
                System.IntPtr*_planesOut = stackalloc System.IntPtr[planesOut.Length];
                planesOut_ = _planesOut;
            }

            SharpDX.Mathematics.Interop.RawBox rcSourceRef_;
            SharpDX.Result __result__;
            if (planesOut != null)
                for (int i = 0; i < planesOut.Length; ++i)
                    (planesOut_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.BitmapSource>(planesOut[i]);
            if (rcSourceRef != null)
                rcSourceRef_ = rcSourceRef.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)planesOut_, planes, rcSourceRef == null ? (void *)0 : &rcSourceRef_, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Writes lines from the source planes to the encoded format.</p>
        /// </summary>
        /// <param name = "planesOut"><dd>  <p>Specifies an array of <strong><see cref = "SharpDX.WIC.BitmapSource"/></strong> that represent image planes.</p> </dd></param>
        /// <param name = "planes"><dd>  <p>The number of component planes specified by the planes parameter.</p> </dd></param>
        /// <param name = "rcSourceRef"><dd>  <p>The source rectangle of pixels to encode from the <strong><see cref = "SharpDX.WIC.BitmapSource"/></strong> planes.  Null indicates the entire source.  The source rect width must match the width set through <strong>SetSize</strong>. Repeated <strong>WriteSource</strong> calls can be made as long as the total accumulated source rect height is the same as set through <strong>SetSize</strong>.  </p> </dd></param>
        /// <returns><p>If the planes and source rectangle do not meet the requirements, this method fails with <strong><see cref = "Imagesizeoutofrange"/></strong>. </p><p>If the <strong><see cref = "SharpDX.WIC.BitmapSource"/></strong> format does not meet the encoder requirements, this method fails with <strong><see cref = "UnsupportedPixelFormat"/></strong>.</p></returns>
        /// <remarks>
        /// <p>Successive <strong>WriteSource</strong> calls are assumed sequentially add scanlines to the output image.  <strong>IWICBitmapFrameEncode::Initialize</strong>, <strong>IWICBitmapFrameEncode::SetSize</strong> and <strong>IWICBitmapFrameEncode::SetPixelFormat</strong> must be called before this method or it will fail.</p><p>The interleaved pixel format set via <strong>IWICBitmapFrameEncode::SetPixelFormat</strong> and the codec specific encode parameters determine the supported planar formats.
        /// </p><p>WIC JPEG Encoder:
        /// QueryInterface can be used to obtain this interface from the WIC JPEG <strong><see cref = "SharpDX.WIC.BitmapFrameEncode"/></strong> implementation.  When using this method to encode Y?CbCr data with the WIC JPEG encoder, chroma subsampling can be configured with encoder options during frame creation.  See the Encoding Overview and <strong>IWICBitmapEncoder::CreateNewFrame</strong> for more details.   </p><p>Depending upon the configured chroma subsampling, the lineCount parameter has the following restrictions:
        /// </p><table> <tr><th>Chroma Subsampling</th><th>X Coordinate</th><th>Y Coordinate</th><th>Chroma Width</th><th>Chroma Height</th></tr> <tr><td>4:2:0</td><td>Multiple of 2</td><td>Multiple of 2</td><td>lumaWidth / 2 Rounded up to the nearest integer.</td><td>lumaHeight / 2 Rounded up to the nearest integer.</td></tr> <tr><td>4:2:2</td><td>Multiple of 2</td><td>Any</td><td>lumaWidth / 2 Rounded up to the nearest integer.</td><td>Any</td></tr> <tr><td>4:4:4</td><td>Any</td><td>Any</td><td>Any</td><td>Any</td></tr> <tr><td>4:4:0</td><td>Any</td><td>Multiple of 2</td><td>lumaWidth</td><td>llumaHeight / 2 Rounded up to the nearest integer.</td></tr> </table><p>?</p><p>The full scanline width must be encoded, and the width of the bitmap sources must match their planar configuration.</p><p>Additionally, if a pixel format is set via <strong>IWICBitmapFrameEncode::SetPixelFormat</strong>, it must be <see cref = "Format24bppBGR"/>.   </p><p>The supported pixel formats of the bitmap sources passed into this method are as follows:
        /// </p><table> <tr><th>Plane Count</th><th>Plane 1</th><th>Plane 2</th><th>Plane 3</th></tr> <tr><td>3</td><td><see cref = "Format8bppY"/></td><td><see cref = "Format8bppCb"/></td><td><see cref = "Format8bppCr"/></td></tr> <tr><td>2</td><td><see cref = "Format8bppY"/></td><td><see cref = "Format16bppCbCr"/></td><td>N/A</td></tr> </table><p>?</p>
        /// </remarks>
        /// <doc-id>dn302092</doc-id>
        /// <unmanaged>HRESULT IWICPlanarBitmapFrameEncode::WriteSource([In, Buffer] IWICBitmapSource** ppPlanes,[In] unsigned int cPlanes,[In, Optional] WICRect* prcSource)</unmanaged>
        /// <unmanaged-short>IWICPlanarBitmapFrameEncode::WriteSource</unmanaged-short>
        public unsafe void WriteSource(SharpDX.ComArray<SharpDX.WIC.BitmapSource> planesOut, System.Int32 planes, SharpDX.Mathematics.Interop.RawBox? rcSourceRef)
        {
            SharpDX.Mathematics.Interop.RawBox rcSourceRef_;
            SharpDX.Result __result__;
            if (rcSourceRef != null)
                rcSourceRef_ = rcSourceRef.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)(planesOut?.NativePointer ?? System.IntPtr.Zero), planes, rcSourceRef == null ? (void *)0 : &rcSourceRef_, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Writes lines from the source planes to the encoded format.</p>
        /// </summary>
        /// <param name = "planesOut"><dd>  <p>Specifies an array of <strong><see cref = "SharpDX.WIC.BitmapSource"/></strong> that represent image planes.</p> </dd></param>
        /// <param name = "planes"><dd>  <p>The number of component planes specified by the planes parameter.</p> </dd></param>
        /// <param name = "rcSourceRef"><dd>  <p>The source rectangle of pixels to encode from the <strong><see cref = "SharpDX.WIC.BitmapSource"/></strong> planes.  Null indicates the entire source.  The source rect width must match the width set through <strong>SetSize</strong>. Repeated <strong>WriteSource</strong> calls can be made as long as the total accumulated source rect height is the same as set through <strong>SetSize</strong>.  </p> </dd></param>
        /// <returns><p>If the planes and source rectangle do not meet the requirements, this method fails with <strong><see cref = "Imagesizeoutofrange"/></strong>. </p><p>If the <strong><see cref = "SharpDX.WIC.BitmapSource"/></strong> format does not meet the encoder requirements, this method fails with <strong><see cref = "UnsupportedPixelFormat"/></strong>.</p></returns>
        /// <remarks>
        /// <p>Successive <strong>WriteSource</strong> calls are assumed sequentially add scanlines to the output image.  <strong>IWICBitmapFrameEncode::Initialize</strong>, <strong>IWICBitmapFrameEncode::SetSize</strong> and <strong>IWICBitmapFrameEncode::SetPixelFormat</strong> must be called before this method or it will fail.</p><p>The interleaved pixel format set via <strong>IWICBitmapFrameEncode::SetPixelFormat</strong> and the codec specific encode parameters determine the supported planar formats.
        /// </p><p>WIC JPEG Encoder:
        /// QueryInterface can be used to obtain this interface from the WIC JPEG <strong><see cref = "SharpDX.WIC.BitmapFrameEncode"/></strong> implementation.  When using this method to encode Y?CbCr data with the WIC JPEG encoder, chroma subsampling can be configured with encoder options during frame creation.  See the Encoding Overview and <strong>IWICBitmapEncoder::CreateNewFrame</strong> for more details.   </p><p>Depending upon the configured chroma subsampling, the lineCount parameter has the following restrictions:
        /// </p><table> <tr><th>Chroma Subsampling</th><th>X Coordinate</th><th>Y Coordinate</th><th>Chroma Width</th><th>Chroma Height</th></tr> <tr><td>4:2:0</td><td>Multiple of 2</td><td>Multiple of 2</td><td>lumaWidth / 2 Rounded up to the nearest integer.</td><td>lumaHeight / 2 Rounded up to the nearest integer.</td></tr> <tr><td>4:2:2</td><td>Multiple of 2</td><td>Any</td><td>lumaWidth / 2 Rounded up to the nearest integer.</td><td>Any</td></tr> <tr><td>4:4:4</td><td>Any</td><td>Any</td><td>Any</td><td>Any</td></tr> <tr><td>4:4:0</td><td>Any</td><td>Multiple of 2</td><td>lumaWidth</td><td>llumaHeight / 2 Rounded up to the nearest integer.</td></tr> </table><p>?</p><p>The full scanline width must be encoded, and the width of the bitmap sources must match their planar configuration.</p><p>Additionally, if a pixel format is set via <strong>IWICBitmapFrameEncode::SetPixelFormat</strong>, it must be <see cref = "Format24bppBGR"/>.   </p><p>The supported pixel formats of the bitmap sources passed into this method are as follows:
        /// </p><table> <tr><th>Plane Count</th><th>Plane 1</th><th>Plane 2</th><th>Plane 3</th></tr> <tr><td>3</td><td><see cref = "Format8bppY"/></td><td><see cref = "Format8bppCb"/></td><td><see cref = "Format8bppCr"/></td></tr> <tr><td>2</td><td><see cref = "Format8bppY"/></td><td><see cref = "Format16bppCbCr"/></td><td>N/A</td></tr> </table><p>?</p>
        /// </remarks>
        /// <doc-id>dn302092</doc-id>
        /// <unmanaged>HRESULT IWICPlanarBitmapFrameEncode::WriteSource([In, Buffer] IWICBitmapSource** ppPlanes,[In] unsigned int cPlanes,[In, Optional] WICRect* prcSource)</unmanaged>
        /// <unmanaged-short>IWICPlanarBitmapFrameEncode::WriteSource</unmanaged-short>
        private unsafe void WriteSource(System.IntPtr planesOut, System.Int32 planes, System.IntPtr rcSourceRef)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)planesOut, planes, (void *)rcSourceRef, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("3AFF9CCE-BE95-4303-B927-E7D16FF4A613")]
    public partial class PlanarBitmapSourceTransform : SharpDX.ComObject
    {
        public PlanarBitmapSourceTransform(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator PlanarBitmapSourceTransform(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new PlanarBitmapSourceTransform(nativePtr);
        /// <summary>
        /// <p>Use this method to determine if a desired planar output is supported and allow the caller to choose an optimized code path if it is.   Otherwise, callers should fall back to <strong><see cref = "SharpDX.WIC.BitmapSourceTransform"/></strong> or <strong><see cref = "SharpDX.WIC.BitmapSource"/></strong> and retrieve interleaved pixels.</p><p> The following transforms can be checked:</p><ul> <li> Determine if the flip/rotate option specified via <strong><see cref = "SharpDX.WIC.BitmapTransformOptions"/></strong> is supported.</li> <li>Determine if the requested planar pixel format configuration is supported.</li> <li>Determine the closest dimensions the implementation can natively scale to given the desired dimensions. 
        /// </li> </ul><p>When a transform is supported, this method returns the description of the resulting planes in the <em>pPlaneDescriptions</em> parameter.
        /// </p>
        /// </summary>
        /// <param name = "widthRef">No documentation.</param>
        /// <param name = "heightRef">No documentation.</param>
        /// <param name = "dstTransform">No documentation.</param>
        /// <param name = "dstPlanarOptions">No documentation.</param>
        /// <param name = "guidDstFormatsRef">No documentation.</param>
        /// <param name = "planeDescriptionsRef">No documentation.</param>
        /// <param name = "planes">No documentation.</param>
        /// <param name = "fIsSupportedRef">No documentation.</param>
        /// <returns><p>Check the value of <em>pfIsSupported</em> to determine if the transform is supported via <strong>IWICPlanarBitmapSourceTransform::CopyPixels</strong>.  If this method fails, the output parameters for width, height, and plane descriptions are zero initialized.Other return values indicate failure. </p></returns>
        /// <doc-id>dn302095</doc-id>
        /// <unmanaged>HRESULT IWICPlanarBitmapSourceTransform::DoesSupportTransform([InOut] unsigned int* puiWidth,[InOut] unsigned int* puiHeight,[In] WICBitmapTransformOptions dstTransform,[In] WICPlanarOptions dstPlanarOptions,[In, Buffer] const GUID* pguidDstFormats,[Out, Buffer] WICBitmapPlaneDescription* pPlaneDescriptions,[In] unsigned int cPlanes,[Out] BOOL* pfIsSupported)</unmanaged>
        /// <unmanaged-short>IWICPlanarBitmapSourceTransform::DoesSupportTransform</unmanaged-short>
        public unsafe void DoesSupportTransform(ref System.Int32 widthRef, ref System.Int32 heightRef, SharpDX.WIC.BitmapTransformOptions dstTransform, SharpDX.WIC.PlanarOptions dstPlanarOptions, System.Guid[] guidDstFormatsRef, SharpDX.WIC.BitmapPlaneDescription[] planeDescriptionsRef, System.Int32 planes, out SharpDX.Mathematics.Interop.RawBool fIsSupportedRef)
        {
            fIsSupportedRef = default (SharpDX.Mathematics.Interop.RawBool);
            SharpDX.Result __result__;
            fixed (void *fIsSupportedRef_ = &fIsSupportedRef)
                fixed (void *planeDescriptionsRef_ = planeDescriptionsRef)
                    fixed (void *guidDstFormatsRef_ = guidDstFormatsRef)
                        fixed (void *heightRef_ = &heightRef)
                            fixed (void *widthRef_ = &widthRef)
                                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, widthRef_, heightRef_, unchecked ((System.Int32)dstTransform), unchecked ((System.Int32)dstPlanarOptions), guidDstFormatsRef_, planeDescriptionsRef_, planes, fIsSupportedRef_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Copies pixels into the destination planes.  Configured by the supplied input parameters.  </p><p>If a <em>dstTransform</em>, scale, or format conversion is specified, <em>cbStride</em> is the transformed stride and is based on the destination pixel format of the <em>pDstPlanes</em> parameter, not the original source's pixel format.</p>
        /// </summary>
        /// <param name = "rcSourceRef"><dd>  <p>The source rectangle of pixels to copy.  </p> </dd></param>
        /// <param name = "width"><dd>  <p>The width to scale the source bitmap.  This parameter must be equal to a value obtainable through <strong>IWICPlanarBitmapSourceTransform:: DoesSupportTransform</strong>.</p> </dd></param>
        /// <param name = "height"><dd>  <p>The height to scale the source bitmap.  This parameter must be equal to a value obtainable through <strong>IWICPlanarBitmapSourceTransform:: DoesSupportTransform</strong>.</p> </dd></param>
        /// <param name = "dstTransform"><dd>  <p>The desired rotation or flip to perform prior to the pixel copy.  A rotate can be combined with a flip horizontal or a flip vertical, see <strong><see cref = "SharpDX.WIC.BitmapTransformOptions"/></strong>.</p> </dd></param>
        /// <param name = "dstPlanarOptions"><dd>  <p>Used to specify additional configuration options for the transform.  See <strong><see cref = "SharpDX.WIC.PlanarOptions"/></strong> for more detail.</p> <p>WIC JPEG Decoder:<strong>WICPlanarOptionsPreserveSubsampling</strong> can be specified to retain the subsampling ratios when downscaling.  By default, the JPEG decoder attempts to preserve quality by downscaling only the Y plane in some cases, changing the image to 4:4:4 chroma subsampling.</p> </dd></param>
        /// <param name = "dstPlanesRef"><dd>  <p>Specifies the pixel format and output buffer for each component plane.  The number of planes and pixel format of each plane must match values obtainable through  <strong>IWICPlanarBitmapSourceTransform::DoesSupportTransform</strong>.</p> </dd></param>
        /// <param name = "planes"><dd>  <p>The number of component planes specified by the <em>pDstPlanes</em> parameter.</p> </dd></param>
        /// <returns><p>If the specified scale, flip/rotate, and planar format configuration is not supported this method fails with <strong><see cref = "InvalidParameter"/></strong>.  You can check if a transform is supported by calling <strong>IWICPlanarBitmapSourceTransform::DoesSupportTransform</strong>.</p></returns>
        /// <remarks>
        /// <p>WIC JPEG Decoder:
        /// Depending on the configured chroma subsampling of the image, the source rectangle has the following restrictions:
        /// </p><table> <tr><th>Chroma Subsampling</th><th>X Coordinate</th><th>Y Coordinate</th><th>Chroma Width</th><th>Chroma Height</th></tr> <tr><td>4:2:0</td><td>Multiple of 2</td><td>Multiple of 2</td><td>lumaWidth / 2 Rounded up to the nearest integer.</td><td>lumaHeight / 2 Rounded up to the nearest integer.</td></tr> <tr><td>4:2:2</td><td>Multiple of 2</td><td>Any</td><td>lumaWidth / 2 Rounded up to the nearest integer.</td><td>lumaHeight</td></tr> <tr><td>4:4:4</td><td>Any</td><td>Any</td><td>llumaWidth</td><td>llumaHeight</td></tr> <tr><td>4:4:0</td><td>Any</td><td>Multiple of 2</td><td>lumaWidth</td><td>llumaHeight / 2 Rounded up to the nearest integer.</td></tr> </table><p>?</p><p>The <em>pDstPlanes</em> parameter supports the following pixel formats.</p><table> <tr><th>Plane Count</th><th>Plane 1</th><th>Plane 2</th><th>Plane 3</th></tr> <tr><td>3</td><td><see cref = "Format8bppY"/></td><td><see cref = "Format8bppCb"/></td><td><see cref = "Format8bppCr"/></td></tr> <tr><td>2</td><td><see cref = "Format8bppY"/></td><td><see cref = "Format16bppCbCr"/></td><td>N/A</td></tr> </table><p>?</p>
        /// </remarks>
        /// <doc-id>dn302094</doc-id>
        /// <unmanaged>HRESULT IWICPlanarBitmapSourceTransform::CopyPixels([In, Optional] const WICRect* prcSource,[In] unsigned int uiWidth,[In] unsigned int uiHeight,[In] WICBitmapTransformOptions dstTransform,[In] WICPlanarOptions dstPlanarOptions,[In, Buffer] const WICBitmapPlane* pDstPlanes,[In] unsigned int cPlanes)</unmanaged>
        /// <unmanaged-short>IWICPlanarBitmapSourceTransform::CopyPixels</unmanaged-short>
        public unsafe void CopyPixels(SharpDX.Mathematics.Interop.RawBox? rcSourceRef, System.Int32 width, System.Int32 height, SharpDX.WIC.BitmapTransformOptions dstTransform, SharpDX.WIC.PlanarOptions dstPlanarOptions, SharpDX.WIC.BitmapPlane[] dstPlanesRef, System.Int32 planes)
        {
            SharpDX.Mathematics.Interop.RawBox rcSourceRef_;
            SharpDX.Result __result__;
            if (rcSourceRef != null)
                rcSourceRef_ = rcSourceRef.Value;
            fixed (void *dstPlanesRef_ = dstPlanesRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, rcSourceRef == null ? (void *)0 : &rcSourceRef_, width, height, unchecked ((System.Int32)dstTransform), unchecked ((System.Int32)dstPlanarOptions), dstPlanesRef_, planes, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("BEBEE9CB-83B0-4DCC-8132-B0AAA55EAC96")]
    public partial class PlanarFormatConverter : SharpDX.WIC.BitmapSource
    {
        public PlanarFormatConverter(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator PlanarFormatConverter(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new PlanarFormatConverter(nativePtr);
        /// <summary>
        /// <p>Initializes a format converter with a planar source, and specifies the interleaved output pixel format.</p>
        /// </summary>
        /// <param name = "planesOut"><dd>  <p>An array of <strong><see cref = "SharpDX.WIC.BitmapSource"/></strong> that represents image planes.</p> </dd></param>
        /// <param name = "planes"><dd>  <p>The number of component planes specified by the planes parameter.</p> </dd></param>
        /// <param name = "dstFormat"><dd>  <p>The destination interleaved pixel format.</p> </dd></param>
        /// <param name = "dither"><dd>  <p>The <strong><see cref = "SharpDX.WIC.BitmapDitherType"/></strong> used for conversion.</p> </dd></param>
        /// <param name = "paletteRef"><dd>  <p>The palette to use for conversion.</p> </dd></param>
        /// <param name = "alphaThresholdPercent"><dd>  <p>The alpha threshold to use for conversion.</p> </dd></param>
        /// <param name = "paletteTranslate"><dd>  <p>The palette translation type to use for conversion.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn302098</doc-id>
        /// <unmanaged>HRESULT IWICPlanarFormatConverter::Initialize([In, Buffer] IWICBitmapSource** ppPlanes,[In] unsigned int cPlanes,[In] const GUID&amp; dstFormat,[In] WICBitmapDitherType dither,[In, Optional] IWICPalette* pIPalette,[In] double alphaThresholdPercent,[In] WICBitmapPaletteType paletteTranslate)</unmanaged>
        /// <unmanaged-short>IWICPlanarFormatConverter::Initialize</unmanaged-short>
        public unsafe void Initialize(SharpDX.WIC.BitmapSource[] planesOut, System.Int32 planes, System.Guid dstFormat, SharpDX.WIC.BitmapDitherType dither, SharpDX.WIC.Palette paletteRef, System.Double alphaThresholdPercent, SharpDX.WIC.BitmapPaletteType paletteTranslate)
        {
            System.IntPtr*planesOut_;
            planesOut_ = (System.IntPtr*)0;
            if (planesOut != null)
            {
                System.IntPtr*_planesOut = stackalloc System.IntPtr[planesOut.Length];
                planesOut_ = _planesOut;
            }

            System.IntPtr paletteRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            if (planesOut != null)
                for (int i = 0; i < planesOut.Length; ++i)
                    (planesOut_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.BitmapSource>(planesOut[i]);
            paletteRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.Palette>(paletteRef);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)planesOut_, planes, &dstFormat, unchecked ((System.Int32)dither), (void *)paletteRef_, alphaThresholdPercent, unchecked ((System.Int32)paletteTranslate), (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Query if the format converter can convert from one format to another.</p>
        /// </summary>
        /// <param name = "srcPixelFormatsRef"><dd> <p>An array of WIC pixel formats that represents source image planes.</p> </dd></param>
        /// <param name = "srcPlanes"><dd> <p>The number of source pixel formats specified by the <em>pSrcFormats</em> parameter.</p> </dd></param>
        /// <param name = "dstPixelFormat"><dd> <p>The destination interleaved pixel format.</p> </dd></param>
        /// <param name = "fCanConvertRef"><dd> <p>True if the conversion is supported.</p> </dd></param>
        /// <returns><p>If the conversion is not supported, this method returns <see cref = "SharpDX.Result.Ok"/>, but *<em>pfCanConvert</em> is set to <see cref = "SharpDX.Result.False"/>. </p><p>If this method fails, the out parameter <em>pfCanConvert</em> is invalid.</p></returns>
        /// <remarks>
        /// <p>To specify an interleaved input pixel format, provide a length 1 array to <em>pSrcPixelFormats</em>.</p>
        /// </remarks>
        /// <doc-id>dn302097</doc-id>
        /// <unmanaged>HRESULT IWICPlanarFormatConverter::CanConvert([In, Buffer] const GUID* pSrcPixelFormats,[In] unsigned int cSrcPlanes,[In] const GUID&amp; dstPixelFormat,[Out] BOOL* pfCanConvert)</unmanaged>
        /// <unmanaged-short>IWICPlanarFormatConverter::CanConvert</unmanaged-short>
        public unsafe void CanConvert(System.Guid[] srcPixelFormatsRef, System.Int32 srcPlanes, System.Guid dstPixelFormat, out SharpDX.Mathematics.Interop.RawBool fCanConvertRef)
        {
            fCanConvertRef = default (SharpDX.Mathematics.Interop.RawBool);
            SharpDX.Result __result__;
            fixed (void *fCanConvertRef_ = &fCanConvertRef)
                fixed (void *srcPixelFormatsRef_ = srcPixelFormatsRef)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, srcPixelFormatsRef_, srcPlanes, &dstPixelFormat, fCanConvertRef_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Initializes a format converter with a planar source, and specifies the interleaved output pixel format.</p>
        /// </summary>
        /// <param name = "planesOut"><dd>  <p>An array of <strong><see cref = "SharpDX.WIC.BitmapSource"/></strong> that represents image planes.</p> </dd></param>
        /// <param name = "planes"><dd>  <p>The number of component planes specified by the planes parameter.</p> </dd></param>
        /// <param name = "dstFormat"><dd>  <p>The destination interleaved pixel format.</p> </dd></param>
        /// <param name = "dither"><dd>  <p>The <strong><see cref = "SharpDX.WIC.BitmapDitherType"/></strong> used for conversion.</p> </dd></param>
        /// <param name = "paletteRef"><dd>  <p>The palette to use for conversion.</p> </dd></param>
        /// <param name = "alphaThresholdPercent"><dd>  <p>The alpha threshold to use for conversion.</p> </dd></param>
        /// <param name = "paletteTranslate"><dd>  <p>The palette translation type to use for conversion.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn302098</doc-id>
        /// <unmanaged>HRESULT IWICPlanarFormatConverter::Initialize([In, Buffer] IWICBitmapSource** ppPlanes,[In] unsigned int cPlanes,[In] const GUID&amp; dstFormat,[In] WICBitmapDitherType dither,[In, Optional] IWICPalette* pIPalette,[In] double alphaThresholdPercent,[In] WICBitmapPaletteType paletteTranslate)</unmanaged>
        /// <unmanaged-short>IWICPlanarFormatConverter::Initialize</unmanaged-short>
        public unsafe void Initialize(SharpDX.ComArray<SharpDX.WIC.BitmapSource> planesOut, System.Int32 planes, System.Guid dstFormat, SharpDX.WIC.BitmapDitherType dither, SharpDX.WIC.Palette paletteRef, System.Double alphaThresholdPercent, SharpDX.WIC.BitmapPaletteType paletteTranslate)
        {
            System.IntPtr paletteRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            paletteRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.Palette>(paletteRef);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)(planesOut?.NativePointer ?? System.IntPtr.Zero), planes, &dstFormat, unchecked ((System.Int32)dither), (void *)paletteRef_, alphaThresholdPercent, unchecked ((System.Int32)paletteTranslate), (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Initializes a format converter with a planar source, and specifies the interleaved output pixel format.</p>
        /// </summary>
        /// <param name = "planesOut"><dd>  <p>An array of <strong><see cref = "SharpDX.WIC.BitmapSource"/></strong> that represents image planes.</p> </dd></param>
        /// <param name = "planes"><dd>  <p>The number of component planes specified by the planes parameter.</p> </dd></param>
        /// <param name = "dstFormat"><dd>  <p>The destination interleaved pixel format.</p> </dd></param>
        /// <param name = "dither"><dd>  <p>The <strong><see cref = "SharpDX.WIC.BitmapDitherType"/></strong> used for conversion.</p> </dd></param>
        /// <param name = "paletteRef"><dd>  <p>The palette to use for conversion.</p> </dd></param>
        /// <param name = "alphaThresholdPercent"><dd>  <p>The alpha threshold to use for conversion.</p> </dd></param>
        /// <param name = "paletteTranslate"><dd>  <p>The palette translation type to use for conversion.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn302098</doc-id>
        /// <unmanaged>HRESULT IWICPlanarFormatConverter::Initialize([In, Buffer] IWICBitmapSource** ppPlanes,[In] unsigned int cPlanes,[In] const GUID&amp; dstFormat,[In] WICBitmapDitherType dither,[In, Optional] IWICPalette* pIPalette,[In] double alphaThresholdPercent,[In] WICBitmapPaletteType paletteTranslate)</unmanaged>
        /// <unmanaged-short>IWICPlanarFormatConverter::Initialize</unmanaged-short>
        private unsafe void Initialize(System.IntPtr planesOut, System.Int32 planes, System.IntPtr dstFormat, SharpDX.WIC.BitmapDitherType dither, System.IntPtr paletteRef, System.Double alphaThresholdPercent, SharpDX.WIC.BitmapPaletteType paletteTranslate)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)planesOut, planes, (void *)dstFormat, unchecked ((System.Int32)dither), (void *)paletteRef, alphaThresholdPercent, unchecked ((System.Int32)paletteTranslate), (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("4776F9CD-9517-45FA-BF24-E89C5EC5C60C")]
    internal partial class ProgressCallback : SharpDX.ComObject
    {
        public ProgressCallback(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ProgressCallback(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ProgressCallback(nativePtr);
        /// <summary>
        /// <p><strong>Notify</strong> method is documented only for compliance; its use is not recommended and may be altered or unavailable in the future. Instead, and use <strong>RegisterProgressNotification</strong>. 
        /// </p>
        /// </summary>
        /// <param name = "frameNum">No documentation.</param>
        /// <param name = "operation">No documentation.</param>
        /// <param name = "dblProgress">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee719776</doc-id>
        /// <unmanaged>HRESULT IWICProgressCallback::Notify([In] ULONG uFrameNum,[In] WICProgressOperation operation,[In] double dblProgress)</unmanaged>
        /// <unmanaged-short>IWICProgressCallback::Notify</unmanaged-short>
        public unsafe void Notify(System.Int32 frameNum, SharpDX.WIC.ProgressOperation operation, System.Double dblProgress)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, frameNum, unchecked ((System.Int32)operation), dblProgress, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("DAAC296F-7AA5-4dbf-8D15-225C5976F891")]
    public partial class ProgressiveLevelControl : SharpDX.ComObject
    {
        public ProgressiveLevelControl(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ProgressiveLevelControl(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ProgressiveLevelControl(nativePtr);
        /// <summary>
        /// <p>Gets the number of levels of progressive decoding supported by the CODEC.</p>
        /// </summary>
        /// <remarks>
        /// <p>Users should not use this function to iterate through the progressive levels of a progressive JPEG image. JPEG progressive levels are determined by the image and do not have a fixed level count. Using this method will force the application to wait for all progressive levels to be downloaded before it can return. Instead, applications should use the following code to iterate through the progressive levels of a progressive JPEG image.</p>
        /// </remarks>
        /// <doc-id>ee719780</doc-id>
        /// <unmanaged>GetLevelCount</unmanaged>
        /// <unmanaged-short>GetLevelCount</unmanaged-short>
        public System.Int32 LevelCount
        {
            get
            {
                GetLevelCount(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets or sets the decoder's current progressive level.</p>
        /// </summary>
        /// <remarks>
        /// <p>The level always defaults to the highest progressive level. In order to decode a lower progressive level, <strong>SetCurrentLevel</strong> must first be called.</p>
        /// </remarks>
        /// <doc-id>ee719779</doc-id>
        /// <unmanaged>GetCurrentLevel / SetCurrentLevel</unmanaged>
        /// <unmanaged-short>GetCurrentLevel</unmanaged-short>
        public System.Int32 CurrentLevel
        {
            get
            {
                GetCurrentLevel(out var __output__);
                return __output__;
            }

            set => SetCurrentLevel(value);
        }

        /// <summary>
        /// <p>Gets the number of levels of progressive decoding supported by the CODEC.</p>
        /// </summary>
        /// <param name = "levelsRef"><dd>  <p>Indicates the number of levels supported by the CODEC.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Users should not use this function to iterate through the progressive levels of a progressive JPEG image. JPEG progressive levels are determined by the image and do not have a fixed level count. Using this method will force the application to wait for all progressive levels to be downloaded before it can return. Instead, applications should use the following code to iterate through the progressive levels of a progressive JPEG image.</p>
        /// </remarks>
        /// <doc-id>ee719780</doc-id>
        /// <unmanaged>HRESULT IWICProgressiveLevelControl::GetLevelCount([Out] unsigned int* pcLevels)</unmanaged>
        /// <unmanaged-short>IWICProgressiveLevelControl::GetLevelCount</unmanaged-short>
        internal unsafe void GetLevelCount(out System.Int32 levelsRef)
        {
            SharpDX.Result __result__;
            fixed (void *levelsRef_ = &levelsRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, levelsRef_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the decoder's current progressive level.</p>
        /// </summary>
        /// <param name = "nLevelRef"><dd>  <p>Indicates the current level specified.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The level always defaults to the highest progressive level. In order to decode a lower progressive level, <strong>SetCurrentLevel</strong> must first be called.</p>
        /// </remarks>
        /// <doc-id>ee719779</doc-id>
        /// <unmanaged>HRESULT IWICProgressiveLevelControl::GetCurrentLevel([Out] unsigned int* pnLevel)</unmanaged>
        /// <unmanaged-short>IWICProgressiveLevelControl::GetCurrentLevel</unmanaged-short>
        internal unsafe void GetCurrentLevel(out System.Int32 nLevelRef)
        {
            SharpDX.Result __result__;
            fixed (void *nLevelRef_ = &nLevelRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, nLevelRef_, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Specifies the level to retrieve on the next call to <strong>CopyPixels</strong>.</p>
        /// </summary>
        /// <param name = "nLevel">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p> A call does not have to request every level supported. If a caller requests level 1, without having previously requested level 0, the bits returned by the next call to <strong>CopyPixels</strong> will include both levels. </p><p> If the requested level is invalid, the error returned is <see cref = "InvalidProgressivelevel"/>.</p>
        /// </remarks>
        /// <doc-id>ee719781</doc-id>
        /// <unmanaged>HRESULT IWICProgressiveLevelControl::SetCurrentLevel([In] unsigned int nLevel)</unmanaged>
        /// <unmanaged-short>IWICProgressiveLevelControl::SetCurrentLevel</unmanaged-short>
        internal unsafe void SetCurrentLevel(System.Int32 nLevel)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, nLevel, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("135FF860-22B7-4ddf-B0F6-218F4F299A43")]
    public partial class WICStream : SharpDX.Win32.ComStream
    {
        public WICStream(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator WICStream(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new WICStream(nativePtr);
        /// <summary>
        /// <p>Initializes a stream from another stream. Access rights are inherited from the underlying stream.</p>
        /// </summary>
        /// <param name = "streamRef"><dd>  <p>The initialize stream.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>ee719789</doc-id>
        /// <unmanaged>HRESULT IWICStream::InitializeFromIStream([In, Optional] IStream* pIStream)</unmanaged>
        /// <unmanaged-short>IWICStream::InitializeFromIStream</unmanaged-short>
        internal unsafe void InitializeFromIStream(SharpDX.Win32.IStream streamRef)
        {
            System.IntPtr streamRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            streamRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Win32.IStream>(streamRef);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)streamRef_, (*(void ***)this._nativePointer)[14]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Initializes a stream from a particular file.</p>
        /// </summary>
        /// <param name = "fileName"><dd>  <p>The file used to initialize the stream.</p> </dd></param>
        /// <param name = "desiredAccess"><dd>  <p>The desired file access mode.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>GENERIC_READ</strong></dt> </dl> </td><td> <p>Read access.</p> </td></tr> <tr><td><dl> <dt><strong>GENERIC_WRITE</strong></dt> </dl> </td><td> <p>Write access.</p> </td></tr> </table> <p>?</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p> The <strong><see cref = "SharpDX.WIC.WICStream"/></strong> interface methods do not enable you to provide a file sharing option. To create a shared file stream for an image, use the SHCreateStreamOnFileEx function. This stream can then be used to create an <strong><see cref = "SharpDX.WIC.BitmapDecoder"/></strong> using the <strong>CreateDecoderFromStream</strong> method. </p>
        /// </remarks>
        /// <doc-id>ee719788</doc-id>
        /// <unmanaged>HRESULT IWICStream::InitializeFromFilename([In] const wchar_t* wzFileName,[In] DWORD dwDesiredAccess)</unmanaged>
        /// <unmanaged-short>IWICStream::InitializeFromFilename</unmanaged-short>
        internal unsafe void InitializeFromFilename(System.String fileName, System.Int32 desiredAccess)
        {
            SharpDX.Result __result__;
            fixed (char *fileName_ = fileName)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)fileName_, desiredAccess, (*(void ***)this._nativePointer)[15]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Initializes a stream to treat a block of memory as a stream. The stream cannot grow beyond the buffer size. </p>
        /// </summary>
        /// <param name = "bufferRef"><dd>  <p>Pointer to the buffer used to initialize the stream.</p> </dd></param>
        /// <param name = "bufferSize"><dd>  <p>The size of buffer.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>This method should be avoided whenever possible. The caller is responsible for ensuring the memory block is valid for the lifetime of the stream when using <strong>InitializeFromMemory</strong>.  A workaround for this behavior is to create an <strong><see cref = "SharpDX.Win32.IStream"/></strong> and use <strong>InitializeFromIStream</strong> to create the <strong><see cref = "SharpDX.WIC.WICStream"/></strong>.</p><p>If you require a growable memory stream, use <strong>CreateStreamOnHGlobal</strong>.</p>
        /// </remarks>
        /// <doc-id>ee719792</doc-id>
        /// <unmanaged>HRESULT IWICStream::InitializeFromMemory([In] unsigned char* pbBuffer,[In] DWORD cbBufferSize)</unmanaged>
        /// <unmanaged-short>IWICStream::InitializeFromMemory</unmanaged-short>
        internal unsafe void InitializeFromMemory(System.IntPtr bufferRef, System.Int32 bufferSize)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)bufferRef, bufferSize, (*(void ***)this._nativePointer)[16]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Initializes the stream as a substream of another stream.</p>
        /// </summary>
        /// <param name = "streamRef"><dd>  <p>Pointer to the input stream.</p> </dd></param>
        /// <param name = "ulOffset"><dd>  <p>The stream offset used to create the new stream.</p> </dd></param>
        /// <param name = "ulMaxSize"><dd>  <p>The maximum size of the stream.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The stream functions with its own stream position, independent of the underlying stream but restricted to a region.  All seek positions are relative to the sub region.  It is allowed, though not recommended, to have multiple writable sub streams overlapping the same range.</p>
        /// </remarks>
        /// <doc-id>ee719790</doc-id>
        /// <unmanaged>HRESULT IWICStream::InitializeFromIStreamRegion([In, Optional] IStream* pIStream,[In] ULARGE_INTEGER ulOffset,[In] ULARGE_INTEGER ulMaxSize)</unmanaged>
        /// <unmanaged-short>IWICStream::InitializeFromIStreamRegion</unmanaged-short>
        internal unsafe void InitializeFromIStreamRegion(SharpDX.Win32.IStream streamRef, System.Int64 ulOffset, System.Int64 ulMaxSize)
        {
            System.IntPtr streamRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            streamRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Win32.IStream>(streamRef);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)streamRef_, ulOffset, ulMaxSize, (*(void ***)this._nativePointer)[17]);
            __result__.CheckError();
        }
    }
}
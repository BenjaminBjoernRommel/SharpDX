// <auto-generated/>

namespace SharpDX.DirectWrite
{
    [System.Runtime.InteropServices.GuidAttribute("CE25F8FD-863B-4D13-9651-C1F88DC73FE2")]
    public partial class AsyncResult : SharpDX.ComObject
    {
        public AsyncResult(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator AsyncResult(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new AsyncResult(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>GetWaitHandle</unmanaged>
        /// <unmanaged-short>GetWaitHandle</unmanaged-short>
        public System.IntPtr WaitHandle
        {
            get => GetWaitHandle();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>GetResult</unmanaged>
        /// <unmanaged-short>GetResult</unmanaged-short>
        public SharpDX.Result Result
        {
            get => GetResult();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <returns>No documentation.</returns>
        /// <unmanaged>void* IDWriteAsyncResult::GetWaitHandle()</unmanaged>
        /// <unmanaged-short>IDWriteAsyncResult::GetWaitHandle</unmanaged-short>
        internal unsafe System.IntPtr GetWaitHandle()
        {
            System.IntPtr __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSystemIntPtr(this._nativePointer, (*(void ***)this._nativePointer)[3]);
            return __result__;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT IDWriteAsyncResult::GetResult()</unmanaged>
        /// <unmanaged-short>IDWriteAsyncResult::GetResult</unmanaged-short>
        internal unsafe SharpDX.Result GetResult()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[4]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("5e5a32a3-8dff-4773-9ff6-0696eab77267")]
    public partial class BitmapRenderTarget : SharpDX.ComObject
    {
        public BitmapRenderTarget(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator BitmapRenderTarget(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new BitmapRenderTarget(nativePtr);
        /// <summary>
        /// <p> Gets a handle to the memory device context. </p>
        /// </summary>
        /// <remarks>
        /// <p> An application can use the device context to draw using GDI functions. An application can obtain the bitmap handle (<see cref = "System.IntPtr"/>) by calling <strong>GetCurrentObject</strong>. An application that wants information about the underlying bitmap, including a reference to the pixel data, can call <strong>GetObject</strong> to fill in a <strong>DIBSECTION</strong> structure. The bitmap is always a 32-bit  top-down DIB. </p><p>Note that this method takes no parameters and returns an <see cref = "System.IntPtr"/> variable, not an <see cref = "SharpDX.Result"/>.</p><pre>memoryHdc = g_pBitmapRenderTarget-&gt;GetMemoryDC();
        /// </pre><p>The <see cref = "System.IntPtr"/> returned here is still owned by the bitmap render targer object and should not be released or deleted by the client.</p>
        /// </remarks>
        /// <doc-id>dd368171</doc-id>
        /// <unmanaged>GetMemoryDC</unmanaged>
        /// <unmanaged-short>GetMemoryDC</unmanaged-short>
        public System.IntPtr MemoryDC
        {
            get => GetMemoryDC();
        }

        /// <summary>
        /// <p>Gets or sets the number of bitmap pixels per DIP.  </p>
        /// </summary>
        /// <remarks>
        /// <p>A DIP (device-independent pixel) is 1/96 inch. Therefore, this value is the number if pixels per inch divided by 96.</p>
        /// </remarks>
        /// <doc-id>dd368173</doc-id>
        /// <unmanaged>GetPixelsPerDip / SetPixelsPerDip</unmanaged>
        /// <unmanaged-short>GetPixelsPerDip</unmanaged-short>
        public System.Single PixelsPerDip
        {
            get => GetPixelsPerDip();
            set => SetPixelsPerDip(value);
        }

        /// <summary>
        /// <p>Gets or sets the transform that maps abstract coordinates to DIPs. By default this is the identity  transform. Note that this is unrelated to the world transform of the underlying device context. </p>
        /// </summary>
        /// <doc-id>dd368169</doc-id>
        /// <unmanaged>GetCurrentTransform / SetCurrentTransform</unmanaged>
        /// <unmanaged-short>GetCurrentTransform</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawMatrix3x2 CurrentTransform
        {
            get
            {
                GetCurrentTransform(out var __output__);
                return __output__;
            }

            set => SetCurrentTransform(value);
        }

        /// <summary>
        /// <p> Gets the dimensions of the target bitmap. </p>
        /// </summary>
        /// <doc-id>dd368176</doc-id>
        /// <unmanaged>GetSize</unmanaged>
        /// <unmanaged-short>GetSize</unmanaged-short>
        public SharpDX.Size2 Size
        {
            get
            {
                GetSize(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p> Draws a run of glyphs to a bitmap target at the specified position.</p>
        /// </summary>
        /// <param name = "baselineOriginX"><dd>  <p> The horizontal position of the baseline origin, in DIPs, relative to the upper-left corner of the DIB.</p> </dd></param>
        /// <param name = "baselineOriginY"><dd>  <p> The vertical position of the baseline origin, in DIPs, relative to the upper-left corner of the DIB.</p> </dd></param>
        /// <param name = "measuringMode"><dd>  <p> The measuring method for glyphs in the run, used with the other properties to determine the rendering mode.</p> </dd></param>
        /// <param name = "glyphRun"><dd>  <p> The structure containing the properties of the glyph run.</p> </dd></param>
        /// <param name = "renderingParams"><dd>  <p> The object that controls rendering behavior.</p> </dd></param>
        /// <param name = "textColor"><dd>  <p> The foreground color of the text.</p> </dd></param>
        /// <param name = "blackBoxRect"><dd>  <p> The optional rectangle that receives the bounding box (in pixels not DIPs) of all the pixels affected by  drawing the glyph run. The black box rectangle may extend beyond the dimensions of the bitmap.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>You can use the <strong>IDWriteBitmapRenderTarget::DrawGlyphRun</strong> to render to a bitmap from a custom text renderer that you implement.  The custom text renderer should call this method from within the <strong>IDWriteTextRenderer::DrawGlyphRun</strong> callback method as shown in the following code.</p><pre>STDMETHODIMP GdiTextRenderer::DrawGlyphRun( __maybenull void* clientDrawingContext, FLOAT baselineOriginX, FLOAT baselineOriginY, <see cref = "SharpDX.Direct2D1.MeasuringMode"/> measuringMode, __in <see cref = "SharpDX.DirectWrite.GlyphRun"/> const* glyphRun, __in <see cref = "SharpDX.DirectWrite.GlyphRunDescription"/> const* glyphRunDescription, <see cref = "SharpDX.IUnknown"/>* clientDrawingEffect )
        /// { <see cref = "SharpDX.Result"/> hr = <see cref = "SharpDX.Result.Ok"/>; // Pass on the drawing call to the render target to do the real work. <see cref = "SharpDX.Mathematics.Interop.RawRectangle"/> dirtyRect = {0}; hr = pRenderTarget_-&gt;DrawGlyphRun( baselineOriginX, baselineOriginY, measuringMode, glyphRun, pRenderingParams_, RGB(0,200,255), &amp;dirtyRect ); return hr;
        /// }
        /// </pre><p>The <em>baselineOriginX</em>, <em>baslineOriginY</em>, <em>measuringMethod</em>, and <em>glyphRun</em> parameters are provided (as arguments) when the callback method is invoked.  The <em>renderingParams</em>, <em>textColor</em> and <em>blackBoxRect</em> are not.</p><p>Default rendering params can be retrieved by using the <strong>IDWriteFactory::CreateMonitorRenderingParams</strong> method.</p><p></p>
        /// </remarks>
        /// <doc-id>dd368167</doc-id>
        /// <unmanaged>HRESULT IDWriteBitmapRenderTarget::DrawGlyphRun([In] float baselineOriginX,[In] float baselineOriginY,[In] DWRITE_MEASURING_MODE measuringMode,[In] const DWRITE_GLYPH_RUN* glyphRun,[In] IDWriteRenderingParams* renderingParams,[In] COLORREF textColor,[Out, Optional] RECT* blackBoxRect)</unmanaged>
        /// <unmanaged-short>IDWriteBitmapRenderTarget::DrawGlyphRun</unmanaged-short>
        private unsafe void DrawGlyphRun(System.Single baselineOriginX, System.Single baselineOriginY, SharpDX.Direct2D1.MeasuringMode measuringMode, SharpDX.DirectWrite.GlyphRun glyphRun, SharpDX.DirectWrite.RenderingParams renderingParams, System.Int32 textColor, out SharpDX.Mathematics.Interop.RawRectangle blackBoxRect)
        {
            SharpDX.DirectWrite.GlyphRun.__Native glyphRun_ = default (SharpDX.DirectWrite.GlyphRun.__Native);
            System.IntPtr renderingParams_ = System.IntPtr.Zero;
            blackBoxRect = default (SharpDX.Mathematics.Interop.RawRectangle);
            SharpDX.Result __result__;
            glyphRun.__MarshalTo(ref glyphRun_);
            renderingParams_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.RenderingParams>(renderingParams);
            fixed (void *blackBoxRect_ = &blackBoxRect)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, baselineOriginX, baselineOriginY, unchecked ((System.Int32)measuringMode), &glyphRun_, (void *)renderingParams_, textColor, blackBoxRect_, (*(void ***)this._nativePointer)[3]);
            glyphRun.__MarshalFree(ref glyphRun_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Gets a handle to the memory device context. </p>
        /// </summary>
        /// <returns><p>Returns a device context handle to the memory device context.</p></returns>
        /// <remarks>
        /// <p> An application can use the device context to draw using GDI functions. An application can obtain the bitmap handle (<see cref = "System.IntPtr"/>) by calling <strong>GetCurrentObject</strong>. An application that wants information about the underlying bitmap, including a reference to the pixel data, can call <strong>GetObject</strong> to fill in a <strong>DIBSECTION</strong> structure. The bitmap is always a 32-bit  top-down DIB. </p><p>Note that this method takes no parameters and returns an <see cref = "System.IntPtr"/> variable, not an <see cref = "SharpDX.Result"/>.</p><pre>memoryHdc = g_pBitmapRenderTarget-&gt;GetMemoryDC();
        /// </pre><p>The <see cref = "System.IntPtr"/> returned here is still owned by the bitmap render targer object and should not be released or deleted by the client.</p>
        /// </remarks>
        /// <doc-id>dd368171</doc-id>
        /// <unmanaged>HDC IDWriteBitmapRenderTarget::GetMemoryDC()</unmanaged>
        /// <unmanaged-short>IDWriteBitmapRenderTarget::GetMemoryDC</unmanaged-short>
        internal unsafe System.IntPtr GetMemoryDC()
        {
            System.IntPtr __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSystemIntPtr(this._nativePointer, (*(void ***)this._nativePointer)[4]);
            return __result__;
        }

        /// <summary>
        /// <p> Gets the number of bitmap pixels per DIP.  </p>
        /// </summary>
        /// <returns><p>The number of bitmap pixels per DIP.</p></returns>
        /// <remarks>
        /// <p>A DIP (device-independent pixel) is 1/96 inch. Therefore, this value is the number if pixels per inch divided by 96.</p>
        /// </remarks>
        /// <doc-id>dd368173</doc-id>
        /// <unmanaged>float IDWriteBitmapRenderTarget::GetPixelsPerDip()</unmanaged>
        /// <unmanaged-short>IDWriteBitmapRenderTarget::GetPixelsPerDip</unmanaged-short>
        internal unsafe System.Single GetPixelsPerDip()
        {
            System.Single __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallfloat(this._nativePointer, (*(void ***)this._nativePointer)[5]);
            return __result__;
        }

        /// <summary>
        /// <p> Sets the number of bitmap pixels per DIP (device-independent pixel). A DIP is 1/96 inch, so this value is the number if pixels per inch divided by 96. </p>
        /// </summary>
        /// <param name = "pixelsPerDip"><dd>  <p>A value that specifies the number of pixels per DIP.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd368182</doc-id>
        /// <unmanaged>HRESULT IDWriteBitmapRenderTarget::SetPixelsPerDip([In] float pixelsPerDip)</unmanaged>
        /// <unmanaged-short>IDWriteBitmapRenderTarget::SetPixelsPerDip</unmanaged-short>
        internal unsafe void SetPixelsPerDip(System.Single pixelsPerDip)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, pixelsPerDip, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Gets the transform that maps abstract coordinates to DIPs. By default this is the identity  transform. Note that this is unrelated to the world transform of the underlying device context. </p>
        /// </summary>
        /// <param name = "transform"><dd>  <p>When this method returns, contains a transform matrix.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd368169</doc-id>
        /// <unmanaged>HRESULT IDWriteBitmapRenderTarget::GetCurrentTransform([Out] DWRITE_MATRIX* transform)</unmanaged>
        /// <unmanaged-short>IDWriteBitmapRenderTarget::GetCurrentTransform</unmanaged-short>
        internal unsafe void GetCurrentTransform(out SharpDX.Mathematics.Interop.RawMatrix3x2 transform)
        {
            transform = default (SharpDX.Mathematics.Interop.RawMatrix3x2);
            SharpDX.Result __result__;
            fixed (void *transform_ = &transform)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, transform_, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Sets the transform that maps abstract coordinate to DIPs (device-independent pixel). This does not affect the world transform of the underlying device context. </p>
        /// </summary>
        /// <param name = "transform"><dd>  <p> Specifies the new transform. This parameter can be <strong><c>null</c></strong>, in which case the identity transform is implied.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd368179</doc-id>
        /// <unmanaged>HRESULT IDWriteBitmapRenderTarget::SetCurrentTransform([In, Optional] const DWRITE_MATRIX* transform)</unmanaged>
        /// <unmanaged-short>IDWriteBitmapRenderTarget::SetCurrentTransform</unmanaged-short>
        internal unsafe void SetCurrentTransform(SharpDX.Mathematics.Interop.RawMatrix3x2? transform)
        {
            SharpDX.Mathematics.Interop.RawMatrix3x2 transform_;
            SharpDX.Result __result__;
            if (transform != null)
                transform_ = transform.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, transform == null ? (void *)0 : &transform_, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Gets the dimensions of the target bitmap. </p>
        /// </summary>
        /// <param name = "size"><dd>  <p>Returns  the width and height of the bitmap in pixels.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd368176</doc-id>
        /// <unmanaged>HRESULT IDWriteBitmapRenderTarget::GetSize([Out] SIZE* size)</unmanaged>
        /// <unmanaged-short>IDWriteBitmapRenderTarget::GetSize</unmanaged-short>
        internal unsafe void GetSize(out SharpDX.Size2 size)
        {
            size = default (SharpDX.Size2);
            SharpDX.Result __result__;
            fixed (void *size_ = &size)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, size_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Resizes the bitmap. </p>
        /// </summary>
        /// <param name = "width"><dd>  <p>The new bitmap width, in pixels.</p> </dd></param>
        /// <param name = "height"><dd>  <p>The new bitmap height, in pixels.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd368177</doc-id>
        /// <unmanaged>HRESULT IDWriteBitmapRenderTarget::Resize([In] unsigned int width,[In] unsigned int height)</unmanaged>
        /// <unmanaged-short>IDWriteBitmapRenderTarget::Resize</unmanaged-short>
        public unsafe void Resize(System.Int32 width, System.Int32 height)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, width, height, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("791e8298-3ef3-4230-9880-c9bdecc42064")]
    public partial class BitmapRenderTarget1 : SharpDX.DirectWrite.BitmapRenderTarget
    {
        public BitmapRenderTarget1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator BitmapRenderTarget1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new BitmapRenderTarget1(nativePtr);
        /// <summary>
        /// <p>Gets or sets the current text antialiasing mode of the bitmap render target.</p>
        /// </summary>
        /// <doc-id>hh780399</doc-id>
        /// <unmanaged>GetTextAntialiasMode / SetTextAntialiasMode</unmanaged>
        /// <unmanaged-short>GetTextAntialiasMode</unmanaged-short>
        public SharpDX.DirectWrite.TextAntialiasMode TextAntialiasMode
        {
            get => GetTextAntialiasMode();
            set => SetTextAntialiasMode(value);
        }

        /// <summary>
        /// <p>Gets the current text antialiasing mode of the bitmap render target.</p>
        /// </summary>
        /// <returns><p>Returns a <strong><see cref = "SharpDX.DirectWrite.TextAntialiasMode"/></strong>-typed value that specifies the antialiasing mode.</p></returns>
        /// <doc-id>hh780399</doc-id>
        /// <unmanaged>DWRITE_TEXT_ANTIALIAS_MODE IDWriteBitmapRenderTarget1::GetTextAntialiasMode()</unmanaged>
        /// <unmanaged-short>IDWriteBitmapRenderTarget1::GetTextAntialiasMode</unmanaged-short>
        internal unsafe SharpDX.DirectWrite.TextAntialiasMode GetTextAntialiasMode()
        {
            SharpDX.DirectWrite.TextAntialiasMode __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirectWriteTextAntialiasMode(this._nativePointer, (*(void ***)this._nativePointer)[11]);
            return __result__;
        }

        /// <summary>
        /// <p>Sets the current text antialiasing mode of the bitmap render target.</p>
        /// </summary>
        /// <param name = "antialiasMode"><dd>  <p>A <strong><see cref = "SharpDX.DirectWrite.TextAntialiasMode"/></strong>-typed value that specifies the antialiasing mode.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful, or E_INVALIDARG if the argument is not valid.</p></returns>
        /// <remarks>
        /// <p>The antialiasing mode of a newly-created bitmap render target defaults to  <strong>DWRITE_TEXT_ANTIALIAS_MODE_CLEARTYPE</strong>. An app can change the antialiasing mode by calling <strong>SetTextAntialiasMode</strong>. For example, an app might specify <strong>DWRITE_TEXT_ANTIALIAS_MODE_GRAYSCALE</strong> for grayscale antialiasing when it renders text onto a transparent bitmap.</p>
        /// </remarks>
        /// <doc-id>hh780400</doc-id>
        /// <unmanaged>HRESULT IDWriteBitmapRenderTarget1::SetTextAntialiasMode([In] DWRITE_TEXT_ANTIALIAS_MODE antialiasMode)</unmanaged>
        /// <unmanaged-short>IDWriteBitmapRenderTarget1::SetTextAntialiasMode</unmanaged-short>
        internal unsafe void SetTextAntialiasMode(SharpDX.DirectWrite.TextAntialiasMode antialiasMode)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)antialiasMode), (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("d31fbe17-f157-41a2-8d24-cb779e0560e8")]
    public partial class ColorGlyphRunEnumerator : SharpDX.ComObject
    {
        public ColorGlyphRunEnumerator(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ColorGlyphRunEnumerator(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ColorGlyphRunEnumerator(nativePtr);
        /// <summary>
        /// <p>Move to the next glyph run in the enumerator.</p>
        /// </summary>
        /// <param name = "hasRun"><dd>  <p>Returns <strong>TRUE</strong> if there is a next glyph run.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn280447</doc-id>
        /// <unmanaged>HRESULT IDWriteColorGlyphRunEnumerator::MoveNext([Out] BOOL* hasRun)</unmanaged>
        /// <unmanaged-short>IDWriteColorGlyphRunEnumerator::MoveNext</unmanaged-short>
        public unsafe void MoveNext(out SharpDX.Mathematics.Interop.RawBool hasRun)
        {
            hasRun = default (SharpDX.Mathematics.Interop.RawBool);
            SharpDX.Result __result__;
            fixed (void *hasRun_ = &hasRun)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, hasRun_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Returns the current glyph run of the enumerator.</p>
        /// </summary>
        /// <param name = "colorGlyphRun"><dd>  <p>A reference to the current glyph run.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn280446</doc-id>
        /// <unmanaged>HRESULT IDWriteColorGlyphRunEnumerator::GetCurrentRun([Out] const void** colorGlyphRun)</unmanaged>
        /// <unmanaged-short>IDWriteColorGlyphRunEnumerator::GetCurrentRun</unmanaged-short>
        internal unsafe void GetCurrentRun(out System.IntPtr colorGlyphRun)
        {
            SharpDX.Result __result__;
            fixed (void *colorGlyphRun_ = &colorGlyphRun)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, colorGlyphRun_, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("7C5F86DA-C7A1-4F05-B8E1-55A179FE5A35")]
    public partial class ColorGlyphRunEnumerator1 : SharpDX.DirectWrite.ColorGlyphRunEnumerator
    {
        public ColorGlyphRunEnumerator1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ColorGlyphRunEnumerator1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ColorGlyphRunEnumerator1(nativePtr);
        /// <summary>
        /// <p>Gets the current color glyph run.</p>
        /// </summary>
        /// <param name = "colorGlyphRun"><dd>  <p>Receives a reference to the color glyph run. The reference remains valid until the next call to MoveNext or until the interface is released.</p> </dd></param>
        /// <returns><p>Standard <see cref = "SharpDX.Result"/> error code. An error is returned if there is no current glyph run, i.e., if MoveNext has not yet been called or if the end of the sequence has been reached.</p></returns>
        /// <doc-id>mt761991</doc-id>
        /// <unmanaged>HRESULT IDWriteColorGlyphRunEnumerator1::GetCurrentRun([Out] const void** colorGlyphRun)</unmanaged>
        /// <unmanaged-short>IDWriteColorGlyphRunEnumerator1::GetCurrentRun</unmanaged-short>
        internal unsafe void GetCurrentRun(out System.IntPtr colorGlyphRun)
        {
            SharpDX.Result __result__;
            fixed (void *colorGlyphRun_ = &colorGlyphRun)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, colorGlyphRun_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("b859ee5a-d838-4b5b-a2e8-1adc7d93db48")]
    public partial class Factory : SharpDX.ComObject
    {
        public Factory(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Factory(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Factory(nativePtr);
        /// <summary>
        /// <p> Creates an object that is used for interoperability with GDI. </p>
        /// </summary>
        /// <doc-id>dd368207</doc-id>
        /// <unmanaged>GetGdiInterop</unmanaged>
        /// <unmanaged-short>GetGdiInterop</unmanaged-short>
        public SharpDX.DirectWrite.GdiInterop GdiInterop
        {
            get
            {
                GetGdiInterop(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p> Gets an object which represents the set of installed fonts. </p>
        /// </summary>
        /// <param name = "checkForUpdates"><dd>  <p>If this parameter is nonzero, the function performs an immediate check for changes to the set of installed fonts. If this parameter is <strong><see cref = "SharpDX.Result.False"/></strong>, the function will still detect changes if the font cache service is running, but there may be some latency. For example, an application might specify <strong>TRUE</strong> if it has itself just installed a font and wants to  be sure the font collection contains that font.</p> </dd></param>
        /// <returns><dd>  <p>When this method returns, contains the address of a reference to the system font collection object, or <strong><c>null</c></strong> in case of failure.</p> </dd></returns>
        /// <doc-id>dd368208</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory::GetSystemFontCollection([Out] IDWriteFontCollection** fontCollection,[In] BOOL checkForUpdates)</unmanaged>
        /// <unmanaged-short>IDWriteFactory::GetSystemFontCollection</unmanaged-short>
        public unsafe SharpDX.DirectWrite.FontCollection GetSystemFontCollection(SharpDX.Mathematics.Interop.RawBool checkForUpdates)
        {
            SharpDX.DirectWrite.FontCollection fontCollection;
            System.IntPtr fontCollection_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, &fontCollection_, checkForUpdates, (*(void ***)this._nativePointer)[3]);
            if (fontCollection_ != System.IntPtr.Zero)
                fontCollection = new SharpDX.DirectWrite.FontCollection(fontCollection_);
            else
                fontCollection = null;
            __result__.CheckError();
            return fontCollection;
        }

        /// <summary>
        /// <p> Creates a font collection using a custom font collection loader. </p>
        /// </summary>
        /// <param name = "collectionLoader"><dd>  <p>An application-defined font collection loader, which must have been previously registered using <strong>RegisterFontCollectionLoader</strong>.</p> </dd></param>
        /// <param name = "collectionKey"><dd>  <p>The key used by the loader to identify a collection of font files.  The buffer allocated for this key should at least be the size of <em>collectionKeySize</em>.</p> </dd></param>
        /// <param name = "collectionKeySize"><dd>  <p>The size, in bytes, of the collection key.</p> </dd></param>
        /// <param name = "fontCollection"><dd>  <p>Contains  an address of a reference to the system font collection object if the method succeeds, or <strong><c>null</c></strong> in case of failure.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd368186</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory::CreateCustomFontCollection([In] IDWriteFontCollectionLoader* collectionLoader,[In, Buffer] const void* collectionKey,[In] unsigned int collectionKeySize,[Out, Fast] IDWriteFontCollection** fontCollection)</unmanaged>
        /// <unmanaged-short>IDWriteFactory::CreateCustomFontCollection</unmanaged-short>
        internal unsafe void CreateCustomFontCollection(SharpDX.DirectWrite.FontCollectionLoader collectionLoader, System.IntPtr collectionKey, System.Int32 collectionKeySize, SharpDX.DirectWrite.FontCollection fontCollection)
        {
            System.IntPtr collectionLoader_ = System.IntPtr.Zero;
            System.IntPtr fontCollection_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            collectionLoader_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.FontCollectionLoader>(collectionLoader);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)collectionLoader_, (void *)collectionKey, collectionKeySize, &fontCollection_, (*(void ***)this._nativePointer)[4]);
            (fontCollection).NativePointer = fontCollection_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Registers a custom font collection loader with the factory object. </p>
        /// </summary>
        /// <param name = "fontCollectionLoader"><dd>  <p>Pointer to a <strong><see cref = "SharpDX.DirectWrite.FontCollectionLoader"/></strong> object to be registered.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>This function registers a font collection loader with DirectWrite. The font collection loader interface, which should be implemented by a singleton object,  handles enumerating font files in a font collection given a particular type of key. A given instance can only be registered once. Succeeding attempts will return an error,  indicating that it has already been registered. Note that font file loader implementations must not register themselves with DirectWrite inside their constructors,  and must not unregister themselves inside their destructors, because registration and unregistraton operations increment and decrement the object reference count respectively.  Instead, registration and unregistration with DirectWrite of font file loaders should be performed outside of the font file loader implementation.</p>
        /// </remarks>
        /// <doc-id>dd368209</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory::RegisterFontCollectionLoader([In] IDWriteFontCollectionLoader* fontCollectionLoader)</unmanaged>
        /// <unmanaged-short>IDWriteFactory::RegisterFontCollectionLoader</unmanaged-short>
        internal unsafe void RegisterFontCollectionLoader_(SharpDX.DirectWrite.FontCollectionLoader fontCollectionLoader)
        {
            System.IntPtr fontCollectionLoader_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fontCollectionLoader_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.FontCollectionLoader>(fontCollectionLoader);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)fontCollectionLoader_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Unregisters a custom font collection loader that was previously registered using <strong>RegisterFontCollectionLoader</strong>. </p>
        /// </summary>
        /// <param name = "fontCollectionLoader">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd368211</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory::UnregisterFontCollectionLoader([In] IDWriteFontCollectionLoader* fontCollectionLoader)</unmanaged>
        /// <unmanaged-short>IDWriteFactory::UnregisterFontCollectionLoader</unmanaged-short>
        internal unsafe void UnregisterFontCollectionLoader_(SharpDX.DirectWrite.FontCollectionLoader fontCollectionLoader)
        {
            System.IntPtr fontCollectionLoader_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fontCollectionLoader_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.FontCollectionLoader>(fontCollectionLoader);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)fontCollectionLoader_, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates a font file reference object from a local font file. </p>
        /// </summary>
        /// <param name = "filePath"><dd>  <p>An array of characters that contains the absolute file path for the font file. Subsequent operations on the constructed object may fail if the user provided <em>filePath</em> doesn't correspond to a valid file on the disk.</p> </dd></param>
        /// <param name = "lastWriteTime"><dd>  <p>The last modified time of the input file path. If the parameter is omitted, the function will access the font file to obtain its last write time. You should specify this value to avoid extra disk access. Subsequent operations on the constructed object may fail if the user provided <em>lastWriteTime</em> doesn't match the file on the disk.</p> </dd></param>
        /// <param name = "fontFile"><dd>  <p>When this method returns, contains an address of a reference to the newly created font file reference object, or <strong><c>null</c></strong> in case of failure.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd368197</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory::CreateFontFileReference([In] const wchar_t* filePath,[In, Optional] const FILETIME* lastWriteTime,[Out, Fast] IDWriteFontFile** fontFile)</unmanaged>
        /// <unmanaged-short>IDWriteFactory::CreateFontFileReference</unmanaged-short>
        internal unsafe void CreateFontFileReference(System.String filePath, System.Int64? lastWriteTime, SharpDX.DirectWrite.FontFile fontFile)
        {
            System.Int64 lastWriteTime_;
            System.IntPtr fontFile_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            if (lastWriteTime != null)
                lastWriteTime_ = lastWriteTime.Value;
            fixed (char *filePath_ = filePath)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)filePath_, lastWriteTime == null ? (void *)0 : &lastWriteTime_, &fontFile_, (*(void ***)this._nativePointer)[7]);
            (fontFile).NativePointer = fontFile_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates a reference to an application-specific font file resource. </p>
        /// </summary>
        /// <param name = "fontFileReferenceKey"><dd>  <p>A font file reference key that uniquely identifies the font file resource during the lifetime of <em>fontFileLoader</em>.</p> </dd></param>
        /// <param name = "fontFileReferenceKeySize"><dd>  <p>The size of the font file reference key in bytes.</p> </dd></param>
        /// <param name = "fontFileLoader"><dd>  <p>The font file loader that will be used by the font system to load data from the file identified by <em>fontFileReferenceKey</em>.</p> </dd></param>
        /// <param name = "fontFile"><dd>  <p>Contains an address of a reference to the newly created font file object when this method succeeds, or <strong><c>null</c></strong> in case of failure.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p> This function is provided for cases when an application or a document needs to use a private font without having to install it on the system. <em>fontFileReferenceKey</em> has to be unique only in the scope of the <em>fontFileLoader</em> used in this call. </p>
        /// </remarks>
        /// <doc-id>dd368188</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory::CreateCustomFontFileReference([In, Buffer] const void* fontFileReferenceKey,[In] unsigned int fontFileReferenceKeySize,[In] IDWriteFontFileLoader* fontFileLoader,[Out, Fast] IDWriteFontFile** fontFile)</unmanaged>
        /// <unmanaged-short>IDWriteFactory::CreateCustomFontFileReference</unmanaged-short>
        internal unsafe void CreateCustomFontFileReference(System.IntPtr fontFileReferenceKey, System.Int32 fontFileReferenceKeySize, SharpDX.DirectWrite.FontFileLoader fontFileLoader, SharpDX.DirectWrite.FontFile fontFile)
        {
            System.IntPtr fontFileLoader_ = System.IntPtr.Zero;
            System.IntPtr fontFile_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fontFileLoader_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.FontFileLoader>(fontFileLoader);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)fontFileReferenceKey, fontFileReferenceKeySize, (void *)fontFileLoader_, &fontFile_, (*(void ***)this._nativePointer)[8]);
            (fontFile).NativePointer = fontFile_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates an object that represents a font face. </p>
        /// </summary>
        /// <param name = "fontFaceType"><dd>  <p>A value that indicates the type of file format of the font face.</p> </dd></param>
        /// <param name = "numberOfFiles"><dd>  <p>The number of font files, in element count, required to represent the font face.</p> </dd></param>
        /// <param name = "fontFiles"><dd>  <p>A font file object representing the font face.  Because <strong><see cref = "SharpDX.DirectWrite.FontFace"/></strong> maintains its own references to the input font file objects, you may release them after this call.</p> </dd></param>
        /// <param name = "faceIndex"><dd>  <p>The zero-based index of a font face, in cases when the font files contain a collection of font faces. If the font files contain a single face, this value should be zero.</p> </dd></param>
        /// <param name = "fontFaceSimulationFlags"><dd>  <p>A value that indicates which, if any, font face simulation flags for algorithmic means of making text bold or italic are applied to the current font face.</p> </dd></param>
        /// <param name = "fontFace"><dd>  <p>When this method returns, contains an address of a reference to the newly created font face object, or <strong><c>null</c></strong> in case of failure.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd368196</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory::CreateFontFace([In] DWRITE_FONT_FACE_TYPE fontFaceType,[In] unsigned int numberOfFiles,[In, Buffer] const IDWriteFontFile** fontFiles,[In] unsigned int faceIndex,[In] DWRITE_FONT_SIMULATIONS fontFaceSimulationFlags,[Out, Fast] IDWriteFontFace** fontFace)</unmanaged>
        /// <unmanaged-short>IDWriteFactory::CreateFontFace</unmanaged-short>
        internal unsafe void CreateFontFace(SharpDX.DirectWrite.FontFaceType fontFaceType, System.Int32 numberOfFiles, SharpDX.DirectWrite.FontFile[] fontFiles, System.Int32 faceIndex, SharpDX.DirectWrite.FontSimulations fontFaceSimulationFlags, SharpDX.DirectWrite.FontFace fontFace)
        {
            System.IntPtr*fontFiles_;
            fontFiles_ = (System.IntPtr*)0;
            if (fontFiles != null)
            {
                System.IntPtr*_fontFiles = stackalloc System.IntPtr[fontFiles.Length];
                fontFiles_ = _fontFiles;
            }

            System.IntPtr fontFace_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            if (fontFiles != null)
                for (int i = 0; i < fontFiles.Length; ++i)
                    (fontFiles_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.FontFile>(fontFiles[i]);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)fontFaceType), numberOfFiles, (void *)fontFiles_, faceIndex, unchecked ((System.Int32)fontFaceSimulationFlags), &fontFace_, (*(void ***)this._nativePointer)[9]);
            (fontFace).NativePointer = fontFace_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates a rendering parameters object with default settings for the primary monitor. Different monitors may have different rendering parameters, for more information see the How to Add Support for Multiple Monitors topic.</p>
        /// </summary>
        /// <param name = "renderingParams">No documentation.</param>
        /// <returns><p>Standard <see cref = "SharpDX.Result"/> error code.</p></returns>
        /// <doc-id>dd368201</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory::CreateRenderingParams([Out, Fast] IDWriteRenderingParams** renderingParams)</unmanaged>
        /// <unmanaged-short>IDWriteFactory::CreateRenderingParams</unmanaged-short>
        internal unsafe void CreateRenderingParams(SharpDX.DirectWrite.RenderingParams renderingParams)
        {
            System.IntPtr renderingParams_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &renderingParams_, (*(void ***)this._nativePointer)[10]);
            (renderingParams).NativePointer = renderingParams_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates a rendering parameters object with default settings for the specified monitor. In most cases, this is the preferred way to create a rendering parameters object.</p>
        /// </summary>
        /// <param name = "monitor"><dd>  <p>A handle for the specified monitor.</p> </dd></param>
        /// <param name = "renderingParams"><dd>  <p>When this method returns, contains an address of a reference to the rendering parameters object created by this method.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd368199</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory::CreateMonitorRenderingParams([In] HMONITOR monitor,[Out, Fast] IDWriteRenderingParams** renderingParams)</unmanaged>
        /// <unmanaged-short>IDWriteFactory::CreateMonitorRenderingParams</unmanaged-short>
        internal unsafe void CreateMonitorRenderingParams(System.IntPtr monitor, SharpDX.DirectWrite.RenderingParams renderingParams)
        {
            System.IntPtr renderingParams_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)monitor, &renderingParams_, (*(void ***)this._nativePointer)[11]);
            (renderingParams).NativePointer = renderingParams_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a rendering parameters object with the specified properties.</p>
        /// </summary>
        /// <param name = "gamma"><dd>  <p>The gamma level to be set for the new rendering parameters object.</p> </dd></param>
        /// <param name = "enhancedContrast"><dd>  <p>The enhanced contrast level to be set for the new rendering parameters object.</p> </dd></param>
        /// <param name = "clearTypeLevel"><dd>  <p>The ClearType level to be set for the new rendering parameters object.</p> </dd></param>
        /// <param name = "pixelGeometry"><dd>  <p>Represents the internal structure of a device pixel (that is, the physical arrangement of red, green, and blue color components) that is assumed for purposes of rendering text.</p> </dd></param>
        /// <param name = "renderingMode"><dd>  <p>A value that represents the method (for example, ClearType natural quality) for rendering glyphs.</p> </dd></param>
        /// <param name = "renderingParams"><dd>  <p>When this method returns, contains an address of a reference to the newly created rendering parameters object.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd368190</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory::CreateCustomRenderingParams([In] float gamma,[In] float enhancedContrast,[In] float clearTypeLevel,[In] DWRITE_PIXEL_GEOMETRY pixelGeometry,[In] DWRITE_RENDERING_MODE renderingMode,[Out, Fast] IDWriteRenderingParams** renderingParams)</unmanaged>
        /// <unmanaged-short>IDWriteFactory::CreateCustomRenderingParams</unmanaged-short>
        internal unsafe void CreateCustomRenderingParams(System.Single gamma, System.Single enhancedContrast, System.Single clearTypeLevel, SharpDX.DirectWrite.PixelGeometry pixelGeometry, SharpDX.DirectWrite.RenderingMode renderingMode, SharpDX.DirectWrite.RenderingParams renderingParams)
        {
            System.IntPtr renderingParams_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, gamma, enhancedContrast, clearTypeLevel, unchecked ((System.Int32)pixelGeometry), unchecked ((System.Int32)renderingMode), &renderingParams_, (*(void ***)this._nativePointer)[12]);
            (renderingParams).NativePointer = renderingParams_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Registers a font file loader with DirectWrite. </p>
        /// </summary>
        /// <param name = "fontFileLoader"><dd>  <p>Pointer to a <strong><see cref = "SharpDX.DirectWrite.FontFileLoader"/></strong> object for a particular file resource type.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p> This function registers a font file loader with DirectWrite. The font file loader interface, which should be implemented   by a singleton object, handles loading font file resources of a particular type from a key. A given instance can only be registered once. Succeeding attempts will return an error, indicating that it has already been registered. Note that font file loader implementations must not register themselves with DirectWrite inside their constructors, and must not unregister themselves inside their destructors, because registration and unregistraton operations increment and decrement the object reference count respectively. Instead, registration and unregistration with DirectWrite of font file loaders should be performed outside of the font file loader implementation. </p>
        /// </remarks>
        /// <doc-id>dd368210</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory::RegisterFontFileLoader([In] IDWriteFontFileLoader* fontFileLoader)</unmanaged>
        /// <unmanaged-short>IDWriteFactory::RegisterFontFileLoader</unmanaged-short>
        internal unsafe void RegisterFontFileLoader_(SharpDX.DirectWrite.FontFileLoader fontFileLoader)
        {
            System.IntPtr fontFileLoader_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fontFileLoader_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.FontFileLoader>(fontFileLoader);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)fontFileLoader_, (*(void ***)this._nativePointer)[13]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Unregisters a font file loader that was previously registered with the DirectWrite font system using <strong>RegisterFontFileLoader</strong>. </p>
        /// </summary>
        /// <param name = "fontFileLoader">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p> This function unregisters font file loader callbacks with the DirectWrite font system. You should implement the font file loader interface by a singleton object. Note that font file loader implementations must not register themselves with DirectWrite inside their constructors and must not unregister themselves in their destructors, because registration and unregistraton operations increment and decrement the object reference count respectively. Instead, registration and unregistration of font file loaders with DirectWrite should be performed outside of the font file loader implementation. </p>
        /// </remarks>
        /// <doc-id>dd368212</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory::UnregisterFontFileLoader([In] IDWriteFontFileLoader* fontFileLoader)</unmanaged>
        /// <unmanaged-short>IDWriteFactory::UnregisterFontFileLoader</unmanaged-short>
        internal unsafe void UnregisterFontFileLoader_(SharpDX.DirectWrite.FontFileLoader fontFileLoader)
        {
            System.IntPtr fontFileLoader_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fontFileLoader_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.FontFileLoader>(fontFileLoader);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)fontFileLoader_, (*(void ***)this._nativePointer)[14]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates a text format object used for text layout. </p>
        /// </summary>
        /// <param name = "fontFamilyName"><dd>  <p>An array of characters that contains the name of the font family</p> </dd></param>
        /// <param name = "fontCollection"><dd>  <p>A reference to a font collection object. When this is <strong><c>null</c></strong>, indicates the system font collection.</p> </dd></param>
        /// <param name = "fontWeight"><dd>  <p>A value that indicates the font weight for the text object created by this method.</p> </dd></param>
        /// <param name = "fontStyle"><dd>  <p>A value that indicates the font style for the text object created by this method.</p> </dd></param>
        /// <param name = "fontStretch"><dd>  <p>A value that indicates the font stretch for the text object created by this method.</p> </dd></param>
        /// <param name = "fontSize"><dd>  <p>The logical size of the font in DIP ("device-independent pixel") units. A DIP equals 1/96 inch.</p> </dd></param>
        /// <param name = "localeName"><dd>  <p>An array of characters that contains the locale name.</p> </dd></param>
        /// <param name = "textFormat"><dd>  <p>When this method returns, contains an address of a reference to a  newly created text format object, or <strong><c>null</c></strong> in case of failure.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd368203</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory::CreateTextFormat([In] const wchar_t* fontFamilyName,[In, Optional] IDWriteFontCollection* fontCollection,[In] DWRITE_FONT_WEIGHT fontWeight,[In] DWRITE_FONT_STYLE fontStyle,[In] DWRITE_FONT_STRETCH fontStretch,[In] float fontSize,[In] const wchar_t* localeName,[Out, Fast] IDWriteTextFormat** textFormat)</unmanaged>
        /// <unmanaged-short>IDWriteFactory::CreateTextFormat</unmanaged-short>
        internal unsafe void CreateTextFormat(System.String fontFamilyName, SharpDX.DirectWrite.FontCollection fontCollection, SharpDX.DirectWrite.FontWeight fontWeight, SharpDX.DirectWrite.FontStyle fontStyle, SharpDX.DirectWrite.FontStretch fontStretch, System.Single fontSize, System.String localeName, SharpDX.DirectWrite.TextFormat textFormat)
        {
            System.IntPtr fontCollection_ = System.IntPtr.Zero;
            System.IntPtr textFormat_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fontCollection_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.FontCollection>(fontCollection);
            fixed (char *localeName_ = localeName)
                fixed (char *fontFamilyName_ = fontFamilyName)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)fontFamilyName_, (void *)fontCollection_, unchecked ((System.Int32)fontWeight), unchecked ((System.Int32)fontStyle), unchecked ((System.Int32)fontStretch), fontSize, (void *)localeName_, &textFormat_, (*(void ***)this._nativePointer)[15]);
            (textFormat).NativePointer = textFormat_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates a typography object for use in a text layout. </p>
        /// </summary>
        /// <param name = "typography"><dd>  <p>When this method returns, contains the address of  a reference to a newly created typography object, or <strong><c>null</c></strong> in case of failure.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd368206</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory::CreateTypography([Out, Fast] IDWriteTypography** typography)</unmanaged>
        /// <unmanaged-short>IDWriteFactory::CreateTypography</unmanaged-short>
        internal unsafe void CreateTypography(SharpDX.DirectWrite.Typography typography)
        {
            System.IntPtr typography_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &typography_, (*(void ***)this._nativePointer)[16]);
            (typography).NativePointer = typography_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates an object that is used for interoperability with GDI. </p>
        /// </summary>
        /// <param name = "gdiInterop"><dd>  <p>When this method returns, contains an address of a reference to a GDI interop object if successful, or <strong><c>null</c></strong> in case of failure.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd368207</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory::GetGdiInterop([Out] IDWriteGdiInterop** gdiInterop)</unmanaged>
        /// <unmanaged-short>IDWriteFactory::GetGdiInterop</unmanaged-short>
        internal unsafe void GetGdiInterop(out SharpDX.DirectWrite.GdiInterop gdiInterop)
        {
            System.IntPtr gdiInterop_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &gdiInterop_, (*(void ***)this._nativePointer)[17]);
            if (gdiInterop_ != System.IntPtr.Zero)
                gdiInterop = new SharpDX.DirectWrite.GdiInterop(gdiInterop_);
            else
                gdiInterop = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Takes a string, text format, and associated constraints, and produces an object that represents the fully analyzed and formatted result. </p>
        /// </summary>
        /// <param name = "text"><dd>  <p>An array of characters that contains the string to create a new <strong><see cref = "SharpDX.DirectWrite.TextLayout"/></strong> object from. This array must be of length <em>stringLength</em> and can contain embedded <strong><c>null</c></strong> characters.</p> </dd></param>
        /// <param name = "stringLength"><dd>  <p>The number of characters in  the string.</p> </dd></param>
        /// <param name = "textFormat"><dd>  <p>A reference to an object that indicates the format to apply to the string.</p> </dd></param>
        /// <param name = "maxWidth"><dd>  <p>The width of the layout box.</p> </dd></param>
        /// <param name = "maxHeight"><dd>  <p>The height of the layout box.</p> </dd></param>
        /// <param name = "textLayout"><dd>  <p>When this method returns, contains an address of a reference to the resultant text layout object.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd368205</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory::CreateTextLayout([In, Buffer] const wchar_t* string,[In] unsigned int stringLength,[In] IDWriteTextFormat* textFormat,[In] float maxWidth,[In] float maxHeight,[Out, Fast] IDWriteTextLayout** textLayout)</unmanaged>
        /// <unmanaged-short>IDWriteFactory::CreateTextLayout</unmanaged-short>
        internal unsafe void CreateTextLayout(System.String text, System.Int32 stringLength, SharpDX.DirectWrite.TextFormat textFormat, System.Single maxWidth, System.Single maxHeight, SharpDX.DirectWrite.TextLayout textLayout)
        {
            System.IntPtr textFormat_ = System.IntPtr.Zero;
            System.IntPtr textLayout_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            textFormat_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.TextFormat>(textFormat);
            fixed (char *text_ = text)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)text_, stringLength, (void *)textFormat_, maxWidth, maxHeight, &textLayout_, (*(void ***)this._nativePointer)[18]);
            (textLayout).NativePointer = textLayout_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Takes a string, format, and associated constraints, and produces an object representing the result, formatted for a particular display resolution and measuring mode.  </p>
        /// </summary>
        /// <param name = "text"><dd>  <p>An array of characters that contains the string to create a new <strong><see cref = "SharpDX.DirectWrite.TextLayout"/></strong> object from. This array must be of length <em>stringLength</em> and can contain embedded <strong><c>null</c></strong> characters.</p> </dd></param>
        /// <param name = "stringLength"><dd>  <p>The length of the string, in character count.</p> </dd></param>
        /// <param name = "textFormat"><dd>  <p>The text formatting object to apply to the string.</p> </dd></param>
        /// <param name = "layoutWidth"><dd>  <p>The width of the layout box.</p> </dd></param>
        /// <param name = "layoutHeight"><dd>  <p>The height of the layout box.</p> </dd></param>
        /// <param name = "pixelsPerDip"><dd>  <p>The number of physical pixels per DIP (device independent pixel). For example, if rendering onto a 96 DPI device <em>pixelsPerDip</em> is 1. If rendering onto a 120 DPI device <em>pixelsPerDip</em> is 1.25 (120/96).</p> </dd></param>
        /// <param name = "transform"><dd>  <p>An optional transform applied to the glyphs and their positions. This transform is applied after the scaling specifies the font size and pixels per DIP.</p> </dd></param>
        /// <param name = "useGdiNatural"><dd>  <p> Instructs the text layout to use the same metrics as GDI bi-level text when set to <strong><see cref = "SharpDX.Result.False"/></strong>. When set to <strong>TRUE</strong>, instructs the text layout to use the same metrics as text measured by GDI using a font created with <strong>CLEARTYPE_NATURAL_QUALITY</strong>. </p> </dd></param>
        /// <param name = "textLayout"><dd>  <p>When this method returns, contains an address to the reference of the resultant text layout object.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The resulting text layout should only be used for the intended resolution, and for cases where text scalability is desired <strong>CreateTextLayout</strong> should be used instead.</p>
        /// </remarks>
        /// <doc-id>dd368192</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory::CreateGdiCompatibleTextLayout([In, Buffer] const wchar_t* string,[In] unsigned int stringLength,[In] IDWriteTextFormat* textFormat,[In] float layoutWidth,[In] float layoutHeight,[In] float pixelsPerDip,[In, Optional] const DWRITE_MATRIX* transform,[In] BOOL useGdiNatural,[Out, Fast] IDWriteTextLayout** textLayout)</unmanaged>
        /// <unmanaged-short>IDWriteFactory::CreateGdiCompatibleTextLayout</unmanaged-short>
        internal unsafe void CreateGdiCompatibleTextLayout(System.String text, System.Int32 stringLength, SharpDX.DirectWrite.TextFormat textFormat, System.Single layoutWidth, System.Single layoutHeight, System.Single pixelsPerDip, SharpDX.Mathematics.Interop.RawMatrix3x2? transform, SharpDX.Mathematics.Interop.RawBool useGdiNatural, SharpDX.DirectWrite.TextLayout textLayout)
        {
            System.IntPtr textFormat_ = System.IntPtr.Zero;
            SharpDX.Mathematics.Interop.RawMatrix3x2 transform_;
            System.IntPtr textLayout_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            textFormat_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.TextFormat>(textFormat);
            if (transform != null)
                transform_ = transform.Value;
            fixed (char *text_ = text)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, (void *)text_, stringLength, (void *)textFormat_, layoutWidth, layoutHeight, pixelsPerDip, transform == null ? (void *)0 : &transform_, useGdiNatural, &textLayout_, (*(void ***)this._nativePointer)[19]);
            (textLayout).NativePointer = textLayout_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates an inline object for trimming, using an ellipsis as the omission sign. </p>
        /// </summary>
        /// <param name = "textFormat"><dd>  <p>A text format object, created with <strong>CreateTextFormat</strong>, used for text layout.</p> </dd></param>
        /// <param name = "trimmingSign"><dd>  <p>When this method returns, contains an address of a reference to the omission (that is, ellipsis trimming) sign created by this method.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The ellipsis will be created using the current settings of the format, including base font, style, and any effects. Alternate omission signs can be created by the application by implementing <strong><see cref = "SharpDX.DirectWrite.InlineObject"/></strong>. </p>
        /// </remarks>
        /// <doc-id>dd368194</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory::CreateEllipsisTrimmingSign([In] IDWriteTextFormat* textFormat,[Out, Fast] IDWriteInlineObject** trimmingSign)</unmanaged>
        /// <unmanaged-short>IDWriteFactory::CreateEllipsisTrimmingSign</unmanaged-short>
        internal unsafe void CreateEllipsisTrimmingSign(SharpDX.DirectWrite.TextFormat textFormat, SharpDX.DirectWrite.InlineObjectNative trimmingSign)
        {
            System.IntPtr textFormat_ = System.IntPtr.Zero;
            System.IntPtr trimmingSign_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            textFormat_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.TextFormat>(textFormat);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)textFormat_, &trimmingSign_, (*(void ***)this._nativePointer)[20]);
            (trimmingSign).NativePointer = trimmingSign_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Returns an interface for performing text analysis. </p>
        /// </summary>
        /// <param name = "textAnalyzer"><dd>  <p>When this method returns, contains an address of  a reference to the newly created text analyzer object.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd368202</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory::CreateTextAnalyzer([Out, Fast] IDWriteTextAnalyzer** textAnalyzer)</unmanaged>
        /// <unmanaged-short>IDWriteFactory::CreateTextAnalyzer</unmanaged-short>
        internal unsafe void CreateTextAnalyzer(SharpDX.DirectWrite.TextAnalyzer textAnalyzer)
        {
            System.IntPtr textAnalyzer_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &textAnalyzer_, (*(void ***)this._nativePointer)[21]);
            (textAnalyzer).NativePointer = textAnalyzer_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates a number substitution object using a locale name, substitution method, and an indicator  whether to ignore user overrides (use NLS defaults for the given culture instead). </p>
        /// </summary>
        /// <param name = "substitutionMethod"><dd>  <p>A value that specifies how to apply number substitution on digits and related punctuation.</p> </dd></param>
        /// <param name = "localeName"><dd>  <p>The name of the locale to be used in the <em>numberSubstitution</em> object.</p> </dd></param>
        /// <param name = "ignoreUserOverride"><dd>  <p>A Boolean flag that indicates whether to ignore user overrides.</p> </dd></param>
        /// <param name = "numberSubstitution"><dd>  <p>When this method returns, contains an address to  a reference to the number substitution object created by this method.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd368200</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory::CreateNumberSubstitution([In] DWRITE_NUMBER_SUBSTITUTION_METHOD substitutionMethod,[In] const wchar_t* localeName,[In] BOOL ignoreUserOverride,[Out, Fast] IDWriteNumberSubstitution** numberSubstitution)</unmanaged>
        /// <unmanaged-short>IDWriteFactory::CreateNumberSubstitution</unmanaged-short>
        internal unsafe void CreateNumberSubstitution(SharpDX.DirectWrite.NumberSubstitutionMethod substitutionMethod, System.String localeName, SharpDX.Mathematics.Interop.RawBool ignoreUserOverride, SharpDX.DirectWrite.NumberSubstitution numberSubstitution)
        {
            System.IntPtr numberSubstitution_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (char *localeName_ = localeName)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, unchecked ((System.Int32)substitutionMethod), (void *)localeName_, ignoreUserOverride, &numberSubstitution_, (*(void ***)this._nativePointer)[22]);
            (numberSubstitution).NativePointer = numberSubstitution_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates a glyph run analysis object, which encapsulates information used to render a glyph run. </p>
        /// </summary>
        /// <param name = "glyphRun"><dd>  <p>A structure that contains the properties of the glyph run (font face, advances, and so on).</p> </dd></param>
        /// <param name = "pixelsPerDip"><dd>  <p>Number of physical pixels per DIP (device independent pixel). For example, if rendering onto a 96 DPI bitmap then <em>pixelsPerDip</em> is 1. If rendering onto a 120 DPI bitmap then <em>pixelsPerDip</em> is 1.25.</p> </dd></param>
        /// <param name = "transform"><dd>  <p>Optional transform applied to the glyphs and their positions. This transform is applied after the scaling specified the <em>emSize</em> and <em>pixelsPerDip</em>.</p> </dd></param>
        /// <param name = "renderingMode"><dd>  <p>A value that specifies the rendering mode, which must be one of the raster rendering modes (that is, not default and not outline).</p> </dd></param>
        /// <param name = "measuringMode"><dd>  <p>Specifies the measuring mode to use with glyphs.</p> </dd></param>
        /// <param name = "baselineOriginX"><dd>  <p>The horizontal position (X-coordinate) of the baseline origin, in DIPs.</p> </dd></param>
        /// <param name = "baselineOriginY"><dd>  <p>Vertical position (Y-coordinate) of the baseline origin, in DIPs.</p> </dd></param>
        /// <param name = "glyphRunAnalysis"><dd>  <p>When this method returns, contains an address of a reference to the newly created glyph run analysis object.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The glyph run analysis object contains the results of analyzing the glyph run, including the positions of all the glyphs and references to all of the rasterized glyphs in the font cache. </p>
        /// </remarks>
        /// <doc-id>dd368198</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory::CreateGlyphRunAnalysis([In] const DWRITE_GLYPH_RUN* glyphRun,[In] float pixelsPerDip,[In, Optional] const DWRITE_MATRIX* transform,[In] DWRITE_RENDERING_MODE renderingMode,[In] DWRITE_MEASURING_MODE measuringMode,[In] float baselineOriginX,[In] float baselineOriginY,[Out, Fast] IDWriteGlyphRunAnalysis** glyphRunAnalysis)</unmanaged>
        /// <unmanaged-short>IDWriteFactory::CreateGlyphRunAnalysis</unmanaged-short>
        internal unsafe void CreateGlyphRunAnalysis(SharpDX.DirectWrite.GlyphRun glyphRun, System.Single pixelsPerDip, SharpDX.Mathematics.Interop.RawMatrix3x2? transform, SharpDX.DirectWrite.RenderingMode renderingMode, SharpDX.Direct2D1.MeasuringMode measuringMode, System.Single baselineOriginX, System.Single baselineOriginY, SharpDX.DirectWrite.GlyphRunAnalysis glyphRunAnalysis)
        {
            SharpDX.DirectWrite.GlyphRun.__Native glyphRun_ = default (SharpDX.DirectWrite.GlyphRun.__Native);
            SharpDX.Mathematics.Interop.RawMatrix3x2 transform_;
            System.IntPtr glyphRunAnalysis_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            glyphRun.__MarshalTo(ref glyphRun_);
            if (transform != null)
                transform_ = transform.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &glyphRun_, pixelsPerDip, transform == null ? (void *)0 : &transform_, unchecked ((System.Int32)renderingMode), unchecked ((System.Int32)measuringMode), baselineOriginX, baselineOriginY, &glyphRunAnalysis_, (*(void ***)this._nativePointer)[23]);
            (glyphRunAnalysis).NativePointer = glyphRunAnalysis_;
            glyphRun.__MarshalFree(ref glyphRun_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates an object that represents a font face. </p>
        /// </summary>
        /// <param name = "fontFaceType"><dd>  <p>A value that indicates the type of file format of the font face.</p> </dd></param>
        /// <param name = "numberOfFiles"><dd>  <p>The number of font files, in element count, required to represent the font face.</p> </dd></param>
        /// <param name = "fontFiles"><dd>  <p>A font file object representing the font face.  Because <strong><see cref = "SharpDX.DirectWrite.FontFace"/></strong> maintains its own references to the input font file objects, you may release them after this call.</p> </dd></param>
        /// <param name = "faceIndex"><dd>  <p>The zero-based index of a font face, in cases when the font files contain a collection of font faces. If the font files contain a single face, this value should be zero.</p> </dd></param>
        /// <param name = "fontFaceSimulationFlags"><dd>  <p>A value that indicates which, if any, font face simulation flags for algorithmic means of making text bold or italic are applied to the current font face.</p> </dd></param>
        /// <param name = "fontFace"><dd>  <p>When this method returns, contains an address of a reference to the newly created font face object, or <strong><c>null</c></strong> in case of failure.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd368196</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory::CreateFontFace([In] DWRITE_FONT_FACE_TYPE fontFaceType,[In] unsigned int numberOfFiles,[In, Buffer] const IDWriteFontFile** fontFiles,[In] unsigned int faceIndex,[In] DWRITE_FONT_SIMULATIONS fontFaceSimulationFlags,[Out, Fast] IDWriteFontFace** fontFace)</unmanaged>
        /// <unmanaged-short>IDWriteFactory::CreateFontFace</unmanaged-short>
        internal unsafe void CreateFontFace(SharpDX.DirectWrite.FontFaceType fontFaceType, System.Int32 numberOfFiles, SharpDX.ComArray<SharpDX.DirectWrite.FontFile> fontFiles, System.Int32 faceIndex, SharpDX.DirectWrite.FontSimulations fontFaceSimulationFlags, SharpDX.DirectWrite.FontFace fontFace)
        {
            System.IntPtr fontFace_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)fontFaceType), numberOfFiles, (void *)(fontFiles?.NativePointer ?? System.IntPtr.Zero), faceIndex, unchecked ((System.Int32)fontFaceSimulationFlags), &fontFace_, (*(void ***)this._nativePointer)[9]);
            (fontFace).NativePointer = fontFace_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates an object that represents a font face. </p>
        /// </summary>
        /// <param name = "fontFaceType"><dd>  <p>A value that indicates the type of file format of the font face.</p> </dd></param>
        /// <param name = "numberOfFiles"><dd>  <p>The number of font files, in element count, required to represent the font face.</p> </dd></param>
        /// <param name = "fontFiles"><dd>  <p>A font file object representing the font face.  Because <strong><see cref = "SharpDX.DirectWrite.FontFace"/></strong> maintains its own references to the input font file objects, you may release them after this call.</p> </dd></param>
        /// <param name = "faceIndex"><dd>  <p>The zero-based index of a font face, in cases when the font files contain a collection of font faces. If the font files contain a single face, this value should be zero.</p> </dd></param>
        /// <param name = "fontFaceSimulationFlags"><dd>  <p>A value that indicates which, if any, font face simulation flags for algorithmic means of making text bold or italic are applied to the current font face.</p> </dd></param>
        /// <param name = "fontFace"><dd>  <p>When this method returns, contains an address of a reference to the newly created font face object, or <strong><c>null</c></strong> in case of failure.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd368196</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory::CreateFontFace([In] DWRITE_FONT_FACE_TYPE fontFaceType,[In] unsigned int numberOfFiles,[In, Buffer] const IDWriteFontFile** fontFiles,[In] unsigned int faceIndex,[In] DWRITE_FONT_SIMULATIONS fontFaceSimulationFlags,[Out, Fast] IDWriteFontFace** fontFace)</unmanaged>
        /// <unmanaged-short>IDWriteFactory::CreateFontFace</unmanaged-short>
        private unsafe void CreateFontFace(SharpDX.DirectWrite.FontFaceType fontFaceType, System.Int32 numberOfFiles, System.IntPtr fontFiles, System.Int32 faceIndex, SharpDX.DirectWrite.FontSimulations fontFaceSimulationFlags, System.IntPtr fontFace)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)fontFaceType), numberOfFiles, (void *)fontFiles, faceIndex, unchecked ((System.Int32)fontFaceSimulationFlags), (void *)fontFace, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("30572f99-dac6-41db-a16e-0486307e606a")]
    public partial class Factory1 : SharpDX.DirectWrite.Factory
    {
        public Factory1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Factory1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Factory1(nativePtr);
        /// <summary>
        /// <p>Gets a font collection representing the set of EUDC (end-user defined characters) fonts.</p>
        /// </summary>
        /// <param name = "fontCollection"><dd>  <p>The font collection to fill.</p> </dd></param>
        /// <param name = "checkForUpdates"><dd>  <p>Whether to check for updates.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Note that if no EUDC is set on the system, the returned collection will be empty, meaning it will return success but GetFontFamilyCount will be zero.</p>
        /// </remarks>
        /// <doc-id>hh780403</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory1::GetEudcFontCollection([Out] IDWriteFontCollection** fontCollection,[In] BOOL checkForUpdates)</unmanaged>
        /// <unmanaged-short>IDWriteFactory1::GetEudcFontCollection</unmanaged-short>
        public unsafe void GetEudcFontCollection(out SharpDX.DirectWrite.FontCollection fontCollection, SharpDX.Mathematics.Interop.RawBool checkForUpdates)
        {
            System.IntPtr fontCollection_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, &fontCollection_, checkForUpdates, (*(void ***)this._nativePointer)[24]);
            if (fontCollection_ != System.IntPtr.Zero)
                fontCollection = new SharpDX.DirectWrite.FontCollection(fontCollection_);
            else
                fontCollection = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a rendering parameters object with the specified properties.</p>
        /// </summary>
        /// <param name = "gamma"><dd>  <p>The gamma level to be set for the new rendering parameters object.</p> </dd></param>
        /// <param name = "enhancedContrast"><dd>  <p>The enhanced contrast level to be set for the new rendering parameters object.</p> </dd></param>
        /// <param name = "enhancedContrastGrayscale"><dd>  <p>The amount of contrast enhancement to use for grayscale antialiasing, zero or greater.</p> </dd></param>
        /// <param name = "clearTypeLevel"><dd>  <p>The ClearType level to be set for the new rendering parameters object.</p> </dd></param>
        /// <param name = "pixelGeometry"><dd>  <p>Represents the internal structure of a device pixel (that is, the physical arrangement of red, green, and blue color components) that is assumed for purposes of rendering text.</p> </dd></param>
        /// <param name = "renderingMode"><dd>  <p>A value that represents the method (for example, ClearType natural quality) for rendering glyphs.</p> </dd></param>
        /// <param name = "renderingParams"><dd>  <p>When this method returns, contains an address of a reference to the newly created rendering parameters object.</p> </dd></param>
        /// <returns><p>Standard <see cref = "SharpDX.Result"/> error code.</p></returns>
        /// <doc-id>hh780402</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory1::CreateCustomRenderingParams([In] float gamma,[In] float enhancedContrast,[In] float enhancedContrastGrayscale,[In] float clearTypeLevel,[In] DWRITE_PIXEL_GEOMETRY pixelGeometry,[In] DWRITE_RENDERING_MODE renderingMode,[Out] IDWriteRenderingParams1** renderingParams)</unmanaged>
        /// <unmanaged-short>IDWriteFactory1::CreateCustomRenderingParams</unmanaged-short>
        public unsafe void CreateCustomRenderingParams(System.Single gamma, System.Single enhancedContrast, System.Single enhancedContrastGrayscale, System.Single clearTypeLevel, SharpDX.DirectWrite.PixelGeometry pixelGeometry, SharpDX.DirectWrite.RenderingMode renderingMode, out SharpDX.DirectWrite.RenderingParams1 renderingParams)
        {
            System.IntPtr renderingParams_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, gamma, enhancedContrast, enhancedContrastGrayscale, clearTypeLevel, unchecked ((System.Int32)pixelGeometry), unchecked ((System.Int32)renderingMode), &renderingParams_, (*(void ***)this._nativePointer)[25]);
            if (renderingParams_ != System.IntPtr.Zero)
                renderingParams = new SharpDX.DirectWrite.RenderingParams1(renderingParams_);
            else
                renderingParams = null;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("0439fc60-ca44-4994-8dee-3a9af7b732ec")]
    public partial class Factory2 : SharpDX.DirectWrite.Factory1
    {
        public Factory2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Factory2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Factory2(nativePtr);
        /// <summary>
        /// <p>Creates a font fallback object from the system font fallback list.</p>
        /// </summary>
        /// <doc-id>dn280450</doc-id>
        /// <unmanaged>GetSystemFontFallback</unmanaged>
        /// <unmanaged-short>GetSystemFontFallback</unmanaged-short>
        public SharpDX.DirectWrite.FontFallback SystemFontFallback
        {
            get
            {
                GetSystemFontFallback(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Creates a font fallback object from the system font fallback list.</p>
        /// </summary>
        /// <param name = "fontFallback"><dd>  <p>Contains an address of a reference to the newly created font fallback object.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn280450</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory2::GetSystemFontFallback([Out] IDWriteFontFallback** fontFallback)</unmanaged>
        /// <unmanaged-short>IDWriteFactory2::GetSystemFontFallback</unmanaged-short>
        internal unsafe void GetSystemFontFallback(out SharpDX.DirectWrite.FontFallback fontFallback)
        {
            System.IntPtr fontFallback_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &fontFallback_, (*(void ***)this._nativePointer)[26]);
            if (fontFallback_ != System.IntPtr.Zero)
                fontFallback = new SharpDX.DirectWrite.FontFallback(fontFallback_);
            else
                fontFallback = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a font fallback builder object.</p><p>A font fall back builder allows you to create Unicode font fallback mappings and create a font fall back object from those mappings.</p>
        /// </summary>
        /// <param name = "fontFallbackBuilder"><dd>  <p>Contains an address of a reference to the newly created font fallback builder object.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn280449</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory2::CreateFontFallbackBuilder([Out] IDWriteFontFallbackBuilder** fontFallbackBuilder)</unmanaged>
        /// <unmanaged-short>IDWriteFactory2::CreateFontFallbackBuilder</unmanaged-short>
        public unsafe void CreateFontFallbackBuilder(out SharpDX.DirectWrite.FontFallbackBuilder fontFallbackBuilder)
        {
            System.IntPtr fontFallbackBuilder_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &fontFallbackBuilder_, (*(void ***)this._nativePointer)[27]);
            if (fontFallbackBuilder_ != System.IntPtr.Zero)
                fontFallbackBuilder = new SharpDX.DirectWrite.FontFallbackBuilder(fontFallbackBuilder_);
            else
                fontFallbackBuilder = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>This method is called on a glyph run to translate it in to multiple color glyph runs.</p>
        /// </summary>
        /// <param name = "baselineOriginX"><dd>  <p>The horizontal baseline origin of the original glyph run.</p> </dd></param>
        /// <param name = "baselineOriginY"><dd>  <p>The vertical baseline origin of the original glyph run.</p> </dd></param>
        /// <param name = "glyphRun"><dd>  <p>Original glyph run containing monochrome glyph IDs.</p> </dd></param>
        /// <param name = "glyphRunDescription"><dd>  <p>Optional glyph run description.</p> </dd></param>
        /// <param name = "measuringMode"><dd>  <p>Measuring mode used to compute glyph positions if the run contains color glyphs.</p> </dd></param>
        /// <param name = "worldToDeviceTransform"><dd>  <p> World transform multiplied by any DPI scaling. This is needed to compute glyph positions if the run contains color glyphs and the  measuring mode is not <strong>DWRITE_MEASURING_MODE_NATURAL</strong>.  If this parameter is <strong><c>null</c></strong>, and identity transform is assumed. </p> </dd></param>
        /// <param name = "colorPaletteIndex"><dd>  <p> Zero-based index of the color palette to use. Valid indices are less than the number of palettes in the font, as  returned by <strong>IDWriteFontFace2::GetColorPaletteCount</strong>. </p> </dd></param>
        /// <param name = "colorLayers"><dd>  <p> If the original glyph run contains color glyphs, this parameter receives a reference to  an <strong><see cref = "SharpDX.DirectWrite.ColorGlyphRunEnumerator"/></strong> interface.  The client uses the returned interface to get information about glyph runs and associated colors to render instead of the original glyph run.  If the original glyph run does not contain color glyphs, this method returns <strong>DWRITE_E_NOCOLOR</strong> and the output reference is <strong><c>null</c></strong>. </p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p> If the code calls this method with a glyph run that contains no color information, the method returns <strong>DWRITE_E_NOCOLOR</strong> to  let the application know that it can just draw the original glyph run. If the glyph run contains color information, the function returns an object that can be enumerated through to expose runs and associated colors. The application then  calls <strong>DrawGlyphRun</strong> with each of the returned glyph runs and foreground colors. </p>
        /// </remarks>
        /// <doc-id>dn280451</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory2::TranslateColorGlyphRun([In] float baselineOriginX,[In] float baselineOriginY,[In] const DWRITE_GLYPH_RUN* glyphRun,[In, Optional] const DWRITE_GLYPH_RUN_DESCRIPTION* glyphRunDescription,[In] DWRITE_MEASURING_MODE measuringMode,[In, Optional] const DWRITE_MATRIX* worldToDeviceTransform,[In] unsigned int colorPaletteIndex,[Out] IDWriteColorGlyphRunEnumerator** colorLayers)</unmanaged>
        /// <unmanaged-short>IDWriteFactory2::TranslateColorGlyphRun</unmanaged-short>
        public unsafe SharpDX.Result TryTranslateColorGlyphRun(System.Single baselineOriginX, System.Single baselineOriginY, SharpDX.DirectWrite.GlyphRun glyphRun, SharpDX.DirectWrite.GlyphRunDescription glyphRunDescription, SharpDX.Direct2D1.MeasuringMode measuringMode, SharpDX.Mathematics.Interop.RawMatrix3x2? worldToDeviceTransform, System.Int32 colorPaletteIndex, out SharpDX.DirectWrite.ColorGlyphRunEnumerator colorLayers)
        {
            SharpDX.DirectWrite.GlyphRun.__Native glyphRun_ = default (SharpDX.DirectWrite.GlyphRun.__Native);
            SharpDX.DirectWrite.GlyphRunDescription.__Native glyphRunDescription_ = default (SharpDX.DirectWrite.GlyphRunDescription.__Native);
            SharpDX.Mathematics.Interop.RawMatrix3x2 worldToDeviceTransform_;
            System.IntPtr colorLayers_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            glyphRun.__MarshalTo(ref glyphRun_);
            if (glyphRunDescription != null)
                glyphRunDescription.__MarshalTo(ref glyphRunDescription_);
            if (worldToDeviceTransform != null)
                worldToDeviceTransform_ = worldToDeviceTransform.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, baselineOriginX, baselineOriginY, &glyphRun_, glyphRunDescription == null ? (void *)0 : &glyphRunDescription_, unchecked ((System.Int32)measuringMode), worldToDeviceTransform == null ? (void *)0 : &worldToDeviceTransform_, colorPaletteIndex, &colorLayers_, (*(void ***)this._nativePointer)[28]);
            if (colorLayers_ != System.IntPtr.Zero)
                colorLayers = new SharpDX.DirectWrite.ColorGlyphRunEnumerator(colorLayers_);
            else
                colorLayers = null;
            glyphRun.__MarshalFree(ref glyphRun_);
            if (glyphRunDescription != null)
                glyphRunDescription.__MarshalFree(ref glyphRunDescription_);
            return __result__;
        }

        /// <summary>
        /// <p>Creates a rendering parameters object with the specified properties.</p>
        /// </summary>
        /// <param name = "gamma"><dd>  <p>The gamma value used for gamma correction, which must be greater than zero and cannot exceed 256.</p> </dd></param>
        /// <param name = "enhancedContrast"><dd>  <p>The amount of contrast enhancement, zero or greater.</p> </dd></param>
        /// <param name = "grayscaleEnhancedContrast"><dd>  <p>The amount of contrast enhancement, zero or greater.</p> </dd></param>
        /// <param name = "clearTypeLevel"><dd>  <p>The degree of ClearType level, from 0.0f (no ClearType) to 1.0f (full ClearType).</p> </dd></param>
        /// <param name = "pixelGeometry"><dd>  <p>The geometry of a device pixel.</p> </dd></param>
        /// <param name = "renderingMode"><dd>  <p>Method of rendering glyphs. In most cases, this should be DWRITE_RENDERING_MODE_DEFAULT to automatically use an appropriate mode.</p> </dd></param>
        /// <param name = "gridFitMode"><dd>  <p>How to grid fit glyph outlines. In most cases, this should be DWRITE_GRID_FIT_DEFAULT to automatically choose an appropriate mode.</p> </dd></param>
        /// <param name = "renderingParams"><dd>  <p>Holds the newly created rendering parameters object, or <c>null</c> in case of failure.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn894552</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory2::CreateCustomRenderingParams([In] float gamma,[In] float enhancedContrast,[In] float grayscaleEnhancedContrast,[In] float clearTypeLevel,[In] DWRITE_PIXEL_GEOMETRY pixelGeometry,[In] DWRITE_RENDERING_MODE renderingMode,[In] DWRITE_GRID_FIT_MODE gridFitMode,[Out] IDWriteRenderingParams2** renderingParams)</unmanaged>
        /// <unmanaged-short>IDWriteFactory2::CreateCustomRenderingParams</unmanaged-short>
        public unsafe void CreateCustomRenderingParams(System.Single gamma, System.Single enhancedContrast, System.Single grayscaleEnhancedContrast, System.Single clearTypeLevel, SharpDX.DirectWrite.PixelGeometry pixelGeometry, SharpDX.DirectWrite.RenderingMode renderingMode, SharpDX.DirectWrite.GridFitMode gridFitMode, out SharpDX.DirectWrite.RenderingParams2 renderingParams)
        {
            System.IntPtr renderingParams_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, gamma, enhancedContrast, grayscaleEnhancedContrast, clearTypeLevel, unchecked ((System.Int32)pixelGeometry), unchecked ((System.Int32)renderingMode), unchecked ((System.Int32)gridFitMode), &renderingParams_, (*(void ***)this._nativePointer)[29]);
            if (renderingParams_ != System.IntPtr.Zero)
                renderingParams = new SharpDX.DirectWrite.RenderingParams2(renderingParams_);
            else
                renderingParams = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a glyph run analysis object, which encapsulates information used to render a glyph run.</p>
        /// </summary>
        /// <param name = "glyphRun"><dd>  <p>Structure specifying the properties of the glyph run.</p> </dd></param>
        /// <param name = "transform"><dd>  <p>Optional transform applied to the glyphs and their positions. This transform is applied after the scaling specified by the emSize and pixelsPerDip.</p> </dd></param>
        /// <param name = "renderingMode"><dd>  <p>Specifies the rendering mode, which must be one of the raster rendering modes (i.e., not default and not outline).</p> </dd></param>
        /// <param name = "measuringMode"><dd>  <p>Specifies the method to measure glyphs.</p> </dd></param>
        /// <param name = "gridFitMode"><dd>  <p>How to grid-fit glyph outlines. This must be non-default.</p> </dd></param>
        /// <param name = "antialiasMode"><dd>  <p>Specifies the antialias mode.</p> </dd></param>
        /// <param name = "baselineOriginX"><dd>  <p>Horizontal position of the baseline origin, in DIPs.</p> </dd></param>
        /// <param name = "baselineOriginY"><dd>  <p>Vertical position of the baseline origin, in DIPs.</p> </dd></param>
        /// <param name = "glyphRunAnalysis"><dd>  <p>Receives a reference to the newly created object.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn894553</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory2::CreateGlyphRunAnalysis([In] const DWRITE_GLYPH_RUN* glyphRun,[In, Optional] const DWRITE_MATRIX* transform,[In] DWRITE_RENDERING_MODE renderingMode,[In] DWRITE_MEASURING_MODE measuringMode,[In] DWRITE_GRID_FIT_MODE gridFitMode,[In] DWRITE_TEXT_ANTIALIAS_MODE antialiasMode,[In] float baselineOriginX,[In] float baselineOriginY,[Out] IDWriteGlyphRunAnalysis** glyphRunAnalysis)</unmanaged>
        /// <unmanaged-short>IDWriteFactory2::CreateGlyphRunAnalysis</unmanaged-short>
        public unsafe void CreateGlyphRunAnalysis(SharpDX.DirectWrite.GlyphRun glyphRun, SharpDX.Mathematics.Interop.RawMatrix3x2? transform, SharpDX.DirectWrite.RenderingMode renderingMode, SharpDX.Direct2D1.MeasuringMode measuringMode, SharpDX.DirectWrite.GridFitMode gridFitMode, SharpDX.DirectWrite.TextAntialiasMode antialiasMode, System.Single baselineOriginX, System.Single baselineOriginY, out SharpDX.DirectWrite.GlyphRunAnalysis glyphRunAnalysis)
        {
            SharpDX.DirectWrite.GlyphRun.__Native glyphRun_ = default (SharpDX.DirectWrite.GlyphRun.__Native);
            SharpDX.Mathematics.Interop.RawMatrix3x2 transform_;
            System.IntPtr glyphRunAnalysis_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            glyphRun.__MarshalTo(ref glyphRun_);
            if (transform != null)
                transform_ = transform.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &glyphRun_, transform == null ? (void *)0 : &transform_, unchecked ((System.Int32)renderingMode), unchecked ((System.Int32)measuringMode), unchecked ((System.Int32)gridFitMode), unchecked ((System.Int32)antialiasMode), baselineOriginX, baselineOriginY, &glyphRunAnalysis_, (*(void ***)this._nativePointer)[30]);
            if (glyphRunAnalysis_ != System.IntPtr.Zero)
                glyphRunAnalysis = new SharpDX.DirectWrite.GlyphRunAnalysis(glyphRunAnalysis_);
            else
                glyphRunAnalysis = null;
            glyphRun.__MarshalFree(ref glyphRun_);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("9A1B41C3-D3BB-466A-87FC-FE67556A3B65")]
    public partial class Factory3 : SharpDX.DirectWrite.Factory2
    {
        public Factory3(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Factory3(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Factory3(nativePtr);
        /// <summary>
        /// <p>Retrieves the list of system fonts.</p>
        /// </summary>
        /// <doc-id>dn890764</doc-id>
        /// <unmanaged>GetSystemFontSet</unmanaged>
        /// <unmanaged-short>GetSystemFontSet</unmanaged-short>
        public SharpDX.DirectWrite.FontSet SystemFontSet
        {
            get
            {
                GetSystemFontSet(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the font download queue associated with this factory object.</p>
        /// </summary>
        /// <doc-id>dn890762</doc-id>
        /// <unmanaged>GetFontDownloadQueue</unmanaged>
        /// <unmanaged-short>GetFontDownloadQueue</unmanaged-short>
        public SharpDX.DirectWrite.FontDownloadQueue FontDownloadQueue
        {
            get
            {
                GetFontDownloadQueue(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p> Creates a glyph-run-analysis object that encapsulates info that DirectWrite uses to render a glyph run. </p>
        /// </summary>
        /// <param name = "glyphRun">No documentation.</param>
        /// <param name = "transform">No documentation.</param>
        /// <param name = "renderingMode">No documentation.</param>
        /// <param name = "measuringMode">No documentation.</param>
        /// <param name = "gridFitMode">No documentation.</param>
        /// <param name = "antialiasMode">No documentation.</param>
        /// <param name = "baselineOriginX">No documentation.</param>
        /// <param name = "baselineOriginY">No documentation.</param>
        /// <param name = "glyphRunAnalysis">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn890760</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory3::CreateGlyphRunAnalysis([In] const DWRITE_GLYPH_RUN* glyphRun,[In, Optional] const DWRITE_MATRIX* transform,[In] DWRITE_RENDERING_MODE1 renderingMode,[In] DWRITE_MEASURING_MODE measuringMode,[In] DWRITE_GRID_FIT_MODE gridFitMode,[In] DWRITE_TEXT_ANTIALIAS_MODE antialiasMode,[In] float baselineOriginX,[In] float baselineOriginY,[Out] IDWriteGlyphRunAnalysis** glyphRunAnalysis)</unmanaged>
        /// <unmanaged-short>IDWriteFactory3::CreateGlyphRunAnalysis</unmanaged-short>
        public unsafe void CreateGlyphRunAnalysis(SharpDX.DirectWrite.GlyphRun glyphRun, SharpDX.Mathematics.Interop.RawMatrix3x2? transform, SharpDX.DirectWrite.RenderingMode1 renderingMode, SharpDX.Direct2D1.MeasuringMode measuringMode, SharpDX.DirectWrite.GridFitMode gridFitMode, SharpDX.DirectWrite.TextAntialiasMode antialiasMode, System.Single baselineOriginX, System.Single baselineOriginY, out SharpDX.DirectWrite.GlyphRunAnalysis glyphRunAnalysis)
        {
            SharpDX.DirectWrite.GlyphRun.__Native glyphRun_ = default (SharpDX.DirectWrite.GlyphRun.__Native);
            SharpDX.Mathematics.Interop.RawMatrix3x2 transform_;
            System.IntPtr glyphRunAnalysis_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            glyphRun.__MarshalTo(ref glyphRun_);
            if (transform != null)
                transform_ = transform.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &glyphRun_, transform == null ? (void *)0 : &transform_, unchecked ((System.Int32)renderingMode), unchecked ((System.Int32)measuringMode), unchecked ((System.Int32)gridFitMode), unchecked ((System.Int32)antialiasMode), baselineOriginX, baselineOriginY, &glyphRunAnalysis_, (*(void ***)this._nativePointer)[31]);
            if (glyphRunAnalysis_ != System.IntPtr.Zero)
                glyphRunAnalysis = new SharpDX.DirectWrite.GlyphRunAnalysis(glyphRunAnalysis_);
            else
                glyphRunAnalysis = null;
            glyphRun.__MarshalFree(ref glyphRun_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a rendering parameters object with the specified properties.</p>
        /// </summary>
        /// <param name = "gamma"><dd>  <p>The gamma value used for gamma correction, which must be greater than zero and cannot exceed 256.</p> </dd></param>
        /// <param name = "enhancedContrast"><dd>  <p> The amount of contrast enhancement, zero or greater. </p> </dd></param>
        /// <param name = "grayscaleEnhancedContrast"><dd>  <p>The amount of contrast enhancement to use for grayscale antialiasing, zero or greater.</p> </dd></param>
        /// <param name = "clearTypeLevel"><dd>  <p>The degree of ClearType level, from 0.0f (no ClearType) to 1.0f (full ClearType).</p> </dd></param>
        /// <param name = "pixelGeometry"><dd>  <p> A <strong><see cref = "SharpDX.DirectWrite.PixelGeometry"/></strong>-typed value that specifies the internal structure of a device pixel (that is, the physical arrangement of red, green, and blue color components) that is assumed for purposes of rendering text. </p> </dd></param>
        /// <param name = "renderingMode"><dd>  <p> A <strong><see cref = "SharpDX.DirectWrite.RenderingMode1"/></strong>-typed value that specifies the method (for example, ClearType natural quality) for rendering glyphs. In most cases, specify <strong>DWRITE_RENDERING_MODE1_DEFAULT</strong> to automatically use an appropriate mode. </p> </dd></param>
        /// <param name = "gridFitMode"><dd>  <p> A <strong><see cref = "SharpDX.DirectWrite.GridFitMode"/></strong>-typed value that specifies how to grid-fit glyph outlines. In most cases, specify <strong>DWRITE_GRID_FIT_DEFAULT</strong> to automatically choose an appropriate mode. </p> </dd></param>
        /// <param name = "renderingParams"><dd>  <p> A reference to a memory block that receives a reference to a <strong><see cref = "SharpDX.DirectWrite.RenderingParams3"/></strong> interface for the newly created rendering parameters object, or <strong><c>null</c></strong> in case of failure. </p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn890754</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory3::CreateCustomRenderingParams([In] float gamma,[In] float enhancedContrast,[In] float grayscaleEnhancedContrast,[In] float clearTypeLevel,[In] DWRITE_PIXEL_GEOMETRY pixelGeometry,[In] DWRITE_RENDERING_MODE1 renderingMode,[In] DWRITE_GRID_FIT_MODE gridFitMode,[Out] IDWriteRenderingParams3** renderingParams)</unmanaged>
        /// <unmanaged-short>IDWriteFactory3::CreateCustomRenderingParams</unmanaged-short>
        public unsafe void CreateCustomRenderingParams(System.Single gamma, System.Single enhancedContrast, System.Single grayscaleEnhancedContrast, System.Single clearTypeLevel, SharpDX.DirectWrite.PixelGeometry pixelGeometry, SharpDX.DirectWrite.RenderingMode1 renderingMode, SharpDX.DirectWrite.GridFitMode gridFitMode, out SharpDX.DirectWrite.RenderingParams3 renderingParams)
        {
            System.IntPtr renderingParams_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, gamma, enhancedContrast, grayscaleEnhancedContrast, clearTypeLevel, unchecked ((System.Int32)pixelGeometry), unchecked ((System.Int32)renderingMode), unchecked ((System.Int32)gridFitMode), &renderingParams_, (*(void ***)this._nativePointer)[32]);
            if (renderingParams_ != System.IntPtr.Zero)
                renderingParams = new SharpDX.DirectWrite.RenderingParams3(renderingParams_);
            else
                renderingParams = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a reference to a font given a full path. </p>
        /// </summary>
        /// <param name = "fontFile"><dd>  <p>Absolute file path. Subsequent operations on the constructed object may fail       if the user provided filePath doesn't correspond to a valid file on the disk.</p> </dd></param>
        /// <param name = "faceIndex"><dd>  <p>The zero based index of a font face in cases when the font files contain a collection of font faces.       If the font files contain a single face, this value should be zero.</p> </dd></param>
        /// <param name = "fontSimulations"><dd>  <p>Font face simulation flags for algorithmic emboldening and italicization.</p> </dd></param>
        /// <param name = "fontFaceReference"><dd>  <p>Contains newly created font face reference object, or nullptr in case of failure.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn890756</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory3::CreateFontFaceReference([In] IDWriteFontFile* fontFile,[In] unsigned int faceIndex,[In] DWRITE_FONT_SIMULATIONS fontSimulations,[Out] IDWriteFontFaceReference** fontFaceReference)</unmanaged>
        /// <unmanaged-short>IDWriteFactory3::CreateFontFaceReference</unmanaged-short>
        public unsafe void CreateFontFaceReference(SharpDX.DirectWrite.FontFile fontFile, System.Int32 faceIndex, SharpDX.DirectWrite.FontSimulations fontSimulations, out SharpDX.DirectWrite.FontFaceReference fontFaceReference)
        {
            System.IntPtr fontFile_ = System.IntPtr.Zero;
            System.IntPtr fontFaceReference_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fontFile_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.FontFile>(fontFile);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)fontFile_, faceIndex, unchecked ((System.Int32)fontSimulations), &fontFaceReference_, (*(void ***)this._nativePointer)[33]);
            if (fontFaceReference_ != System.IntPtr.Zero)
                fontFaceReference = new SharpDX.DirectWrite.FontFaceReference(fontFaceReference_);
            else
                fontFaceReference = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a reference to a font given a full path. </p>
        /// </summary>
        /// <param name = "filePath"><dd>  <p>Absolute file path. Subsequent operations on the constructed object may fail       if the user provided filePath doesn't correspond to a valid file on the disk.</p> </dd></param>
        /// <param name = "lastWriteTime"><dd>  <p>Last modified time of the input file path. If the parameter is omitted,       the function will access the font file to obtain its last write time, so the clients are encouraged to specify this value       to avoid extra disk access. Subsequent operations on the constructed object may fail       if the user provided lastWriteTime doesn't match the file on the disk.</p> </dd></param>
        /// <param name = "faceIndex"><dd>  <p>The zero based index of a font face in cases when the font files contain a collection of font faces.       If the font files contain a single face, this value should be zero.</p> </dd></param>
        /// <param name = "fontSimulations"><dd>  <p>Font face simulation flags for algorithmic emboldening and italicization.</p> </dd></param>
        /// <param name = "fontFaceReference"><dd>  <p>Contains newly created font face reference object, or nullptr in case of failure.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn890756</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory3::CreateFontFaceReference([In] const wchar_t* filePath,[In, Optional] const FILETIME* lastWriteTime,[In] unsigned int faceIndex,[In] DWRITE_FONT_SIMULATIONS fontSimulations,[Out] IDWriteFontFaceReference** fontFaceReference)</unmanaged>
        /// <unmanaged-short>IDWriteFactory3::CreateFontFaceReference</unmanaged-short>
        public unsafe void CreateFontFaceReference(System.String filePath, System.Int64? lastWriteTime, System.Int32 faceIndex, SharpDX.DirectWrite.FontSimulations fontSimulations, out SharpDX.DirectWrite.FontFaceReference fontFaceReference)
        {
            System.Int64 lastWriteTime_;
            System.IntPtr fontFaceReference_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            if (lastWriteTime != null)
                lastWriteTime_ = lastWriteTime.Value;
            fixed (char *filePath_ = filePath)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)filePath_, lastWriteTime == null ? (void *)0 : &lastWriteTime_, faceIndex, unchecked ((System.Int32)fontSimulations), &fontFaceReference_, (*(void ***)this._nativePointer)[34]);
            if (fontFaceReference_ != System.IntPtr.Zero)
                fontFaceReference = new SharpDX.DirectWrite.FontFaceReference(fontFaceReference_);
            else
                fontFaceReference = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the list of system fonts.</p>
        /// </summary>
        /// <param name = "fontSet"><dd>  <p>Holds the newly created font set object, or <c>null</c> in case of failure.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn890764</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory3::GetSystemFontSet([Out] IDWriteFontSet** fontSet)</unmanaged>
        /// <unmanaged-short>IDWriteFactory3::GetSystemFontSet</unmanaged-short>
        internal unsafe void GetSystemFontSet(out SharpDX.DirectWrite.FontSet fontSet)
        {
            System.IntPtr fontSet_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &fontSet_, (*(void ***)this._nativePointer)[35]);
            if (fontSet_ != System.IntPtr.Zero)
                fontSet = new SharpDX.DirectWrite.FontSet(fontSet_);
            else
                fontSet = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates an empty font set builder to add font face references      and create a custom font set. </p>
        /// </summary>
        /// <param name = "fontSetBuilder"><dd>  <p>Holds the newly created font set builder object, or <c>null</c> in case of failure.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn890759</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory3::CreateFontSetBuilder([Out] IDWriteFontSetBuilder** fontSetBuilder)</unmanaged>
        /// <unmanaged-short>IDWriteFactory3::CreateFontSetBuilder</unmanaged-short>
        public unsafe void CreateFontSetBuilder(out SharpDX.DirectWrite.FontSetBuilder fontSetBuilder)
        {
            System.IntPtr fontSetBuilder_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &fontSetBuilder_, (*(void ***)this._nativePointer)[36]);
            if (fontSetBuilder_ != System.IntPtr.Zero)
                fontSetBuilder = new SharpDX.DirectWrite.FontSetBuilder(fontSetBuilder_);
            else
                fontSetBuilder = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Create a weight/width/slope tree from a set of fonts.</p>
        /// </summary>
        /// <param name = "fontSet"><dd>  <p>A set of fonts to use to build the collection.</p> </dd></param>
        /// <param name = "fontCollection"><dd>  <p>Holds the newly created font collection object, or <c>null</c> in case of failure.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn890755</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory3::CreateFontCollectionFromFontSet([In] IDWriteFontSet* fontSet,[Out] IDWriteFontCollection1** fontCollection)</unmanaged>
        /// <unmanaged-short>IDWriteFactory3::CreateFontCollectionFromFontSet</unmanaged-short>
        public unsafe void CreateFontCollectionFromFontSet(SharpDX.DirectWrite.FontSet fontSet, out SharpDX.DirectWrite.FontCollection1 fontCollection)
        {
            System.IntPtr fontSet_ = System.IntPtr.Zero;
            System.IntPtr fontCollection_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fontSet_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.FontSet>(fontSet);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)fontSet_, &fontCollection_, (*(void ***)this._nativePointer)[37]);
            if (fontCollection_ != System.IntPtr.Zero)
                fontCollection = new SharpDX.DirectWrite.FontCollection1(fontCollection_);
            else
                fontCollection = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves a weight/width/slope tree of system fonts.</p>
        /// </summary>
        /// <param name = "includeDownloadableFonts"><dd>  <p>If this parameter is TRUE, the function performs an immediate check for changes        to the set of system fonts. If this parameter is <see cref = "SharpDX.Result.False"/>, the function will still detect changes if the font       cache service is running, but there may be some latency. For example, an application might specify TRUE if       it has just installed a font and wants to be sure the font collection contains that font.</p> </dd></param>
        /// <param name = "fontCollection"><dd>  <p>Holds the newly created font collection object, or <c>null</c> in case of failure.</p> </dd></param>
        /// <param name = "checkForUpdates"><dd>  <p>If this parameter is TRUE, the function performs an immediate check for changes        to the set of system fonts. If this parameter is <see cref = "SharpDX.Result.False"/>, the function will still detect changes if the font       cache service is running, but there may be some latency. For example, an application might specify TRUE if       it has just installed a font and wants to be sure the font collection contains that font.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn890761</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory3::GetSystemFontCollection([In] BOOL includeDownloadableFonts,[Out] IDWriteFontCollection1** fontCollection,[In] BOOL checkForUpdates)</unmanaged>
        /// <unmanaged-short>IDWriteFactory3::GetSystemFontCollection</unmanaged-short>
        public unsafe void GetSystemFontCollection(SharpDX.Mathematics.Interop.RawBool includeDownloadableFonts, out SharpDX.DirectWrite.FontCollection1 fontCollection, SharpDX.Mathematics.Interop.RawBool checkForUpdates)
        {
            System.IntPtr fontCollection_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, includeDownloadableFonts, &fontCollection_, checkForUpdates, (*(void ***)this._nativePointer)[38]);
            if (fontCollection_ != System.IntPtr.Zero)
                fontCollection = new SharpDX.DirectWrite.FontCollection1(fontCollection_);
            else
                fontCollection = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the font download queue associated with this factory object.</p>
        /// </summary>
        /// <param name = "fontDownloadQueue"><dd>  <p>Receives a reference to the font download queue interface.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn890762</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory3::GetFontDownloadQueue([Out] IDWriteFontDownloadQueue** fontDownloadQueue)</unmanaged>
        /// <unmanaged-short>IDWriteFactory3::GetFontDownloadQueue</unmanaged-short>
        internal unsafe void GetFontDownloadQueue(out SharpDX.DirectWrite.FontDownloadQueue fontDownloadQueue)
        {
            System.IntPtr fontDownloadQueue_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &fontDownloadQueue_, (*(void ***)this._nativePointer)[39]);
            if (fontDownloadQueue_ != System.IntPtr.Zero)
                fontDownloadQueue = new SharpDX.DirectWrite.FontDownloadQueue(fontDownloadQueue_);
            else
                fontDownloadQueue = null;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("4B0B5BD3-0797-4549-8AC5-FE915CC53856")]
    public partial class Factory4 : SharpDX.DirectWrite.Factory3
    {
        public Factory4(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Factory4(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Factory4(nativePtr);
        /// <summary>
        /// <p>Translates a glyph run to a sequence of color glyph runs, which can be rendered to produce a color representation of the original "base" run.</p>
        /// </summary>
        /// <param name = "baselineOrigin"><dd>  <p>Horizontal and vertical origin of the base glyph run in pre-transform coordinates.</p> </dd></param>
        /// <param name = "glyphRun"><dd>  <p>Pointer to the original "base" glyph run.</p> </dd></param>
        /// <param name = "glyphRunDescription"><dd>  <p>Optional glyph run description.</p> </dd></param>
        /// <param name = "desiredGlyphImageFormats"><dd>  <p>Which data formats the runs should be split into.</p> </dd></param>
        /// <param name = "measuringMode"><dd>  <p>Measuring mode, needed to compute the origins of each glyph.</p> </dd></param>
        /// <param name = "worldAndDpiTransform"><dd>  <p>Matrix converting from the client's coordinate space to device coordinates (pixels), i.e., the world transform multiplied by any DPI scaling.</p> </dd></param>
        /// <param name = "colorPaletteIndex"><dd>  <p>Zero-based index of the color palette to use. Valid indices are less than the number of palettes in the font, as returned by <strong>IDWriteFontFace2::GetColorPaletteCount</strong>.</p> </dd></param>
        /// <param name = "colorLayers"><dd>  <p>If the function succeeds, receives a reference to an enumerator object that can be used to obtain the color glyph runs. If the base run has no color glyphs, then the output reference is <c>null</c> and the method returns DWRITE_E_NOCOLOR.</p> </dd></param>
        /// <returns><p>Returns DWRITE_E_NOCOLOR if the font has no color information, the glyph run does not contain any color glyphs, or the specified color palette index is out of range. In this case, the client should render the original glyph  run. Otherwise, returns a standard <see cref = "SharpDX.Result"/> error code.</p></returns>
        /// <remarks>
        /// <p>Calling <strong>IDWriteFactory2::TranslateColorGlyphRun</strong> is equivalent  to calling <strong>IDWriteFactory4::TranslateColorGlyph</strong> run with the following formats specified: DWRITE_GLYPH_IMAGE_FORMATS_TRUETYPE|DWRITE_GLYPH_IMAGE_FORMATS_CFF|DWRITE_GLYPH_IMAGE_FORMATS_COLR.</p>
        /// </remarks>
        /// <doc-id>mt761992</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory4::TranslateColorGlyphRun([In] D2D_POINT_2F baselineOrigin,[In] const DWRITE_GLYPH_RUN* glyphRun,[In, Optional] const DWRITE_GLYPH_RUN_DESCRIPTION* glyphRunDescription,[In] DWRITE_GLYPH_IMAGE_FORMATS desiredGlyphImageFormats,[In] DWRITE_MEASURING_MODE measuringMode,[In, Optional] const DWRITE_MATRIX* worldAndDpiTransform,[In] unsigned int colorPaletteIndex,[Out] IDWriteColorGlyphRunEnumerator1** colorLayers)</unmanaged>
        /// <unmanaged-short>IDWriteFactory4::TranslateColorGlyphRun</unmanaged-short>
        public unsafe void TranslateColorGlyphRun(SharpDX.Mathematics.Interop.RawVector2 baselineOrigin, SharpDX.DirectWrite.GlyphRun glyphRun, SharpDX.DirectWrite.GlyphRunDescription glyphRunDescription, SharpDX.Direct2D1.GlyphImageFormatS desiredGlyphImageFormats, SharpDX.Direct2D1.MeasuringMode measuringMode, SharpDX.Mathematics.Interop.RawMatrix3x2? worldAndDpiTransform, System.Int32 colorPaletteIndex, out SharpDX.DirectWrite.ColorGlyphRunEnumerator1 colorLayers)
        {
            SharpDX.DirectWrite.GlyphRun.__Native glyphRun_ = default (SharpDX.DirectWrite.GlyphRun.__Native);
            SharpDX.DirectWrite.GlyphRunDescription.__Native glyphRunDescription_ = default (SharpDX.DirectWrite.GlyphRunDescription.__Native);
            SharpDX.Mathematics.Interop.RawMatrix3x2 worldAndDpiTransform_;
            System.IntPtr colorLayers_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            glyphRun.__MarshalTo(ref glyphRun_);
            if (glyphRunDescription != null)
                glyphRunDescription.__MarshalTo(ref glyphRunDescription_);
            if (worldAndDpiTransform != null)
                worldAndDpiTransform_ = worldAndDpiTransform.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, baselineOrigin, &glyphRun_, glyphRunDescription == null ? (void *)0 : &glyphRunDescription_, unchecked ((System.Int32)desiredGlyphImageFormats), unchecked ((System.Int32)measuringMode), worldAndDpiTransform == null ? (void *)0 : &worldAndDpiTransform_, colorPaletteIndex, &colorLayers_, (*(void ***)this._nativePointer)[40]);
            if (colorLayers_ != System.IntPtr.Zero)
                colorLayers = new SharpDX.DirectWrite.ColorGlyphRunEnumerator1(colorLayers_);
            else
                colorLayers = null;
            glyphRun.__MarshalFree(ref glyphRun_);
            if (glyphRunDescription != null)
                glyphRunDescription.__MarshalFree(ref glyphRunDescription_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Converts glyph run placements to glyph origins.</p>
        /// </summary>
        /// <param name = "glyphRun"><dd>  <p>Structure containing the properties of the glyph run.</p> </dd></param>
        /// <param name = "baselineOrigin"><dd>  <p>The position of the baseline origin, in DIPs, relative to the upper-left corner of the DIB.</p> </dd></param>
        /// <param name = "glyphOrigins"><dd>  <p>On return contains the glyph origins for the glyphrun.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <see cref = "SharpDX.Result"/> error code.</p></returns>
        /// <remarks>
        /// <p>The transform and DPI have no effect on the origin scaling. They are solely used to compute glyph advances when not supplied and align glyphs in pixel aligned measuring modes.</p>
        /// </remarks>
        /// <doc-id>mt725316</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory4::ComputeGlyphOrigins([In] const DWRITE_GLYPH_RUN* glyphRun,[In] D2D_POINT_2F baselineOrigin,[Out, Buffer] D2D_POINT_2F* glyphOrigins)</unmanaged>
        /// <unmanaged-short>IDWriteFactory4::ComputeGlyphOrigins</unmanaged-short>
        public unsafe void ComputeGlyphOrigins(SharpDX.DirectWrite.GlyphRun glyphRun, SharpDX.Mathematics.Interop.RawVector2 baselineOrigin, SharpDX.Mathematics.Interop.RawVector2[] glyphOrigins)
        {
            SharpDX.DirectWrite.GlyphRun.__Native glyphRun_ = default (SharpDX.DirectWrite.GlyphRun.__Native);
            SharpDX.Result __result__;
            glyphRun.__MarshalTo(ref glyphRun_);
            fixed (void *glyphOrigins_ = glyphOrigins)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, &glyphRun_, baselineOrigin, glyphOrigins_, (*(void ***)this._nativePointer)[41]);
            glyphRun.__MarshalFree(ref glyphRun_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Converts glyph run placements to glyph origins.</p>
        /// </summary>
        /// <param name = "glyphRun"><dd>  <p>Structure containing the properties of the glyph run.</p> </dd></param>
        /// <param name = "measuringMode"><dd>  <p>The measuring method for glyphs in the run, used with the other properties to determine the rendering mode.</p> </dd></param>
        /// <param name = "baselineOrigin"><dd>  <p>The position of the baseline origin, in DIPs, relative to the upper-left corner of the DIB.</p> </dd></param>
        /// <param name = "worldAndDpiTransform"><dd>  <p>World transform multiplied by any DPI scaling.  This is needed to compute glyph positions if the run contains color glyphs and the measuring mode is not <strong>DWRITE_MEASURING_MODE_NATURAL</strong>.  If this parameter is <c>null</c>, and identity transform is assumed. </p> </dd></param>
        /// <param name = "glyphOrigins"><dd>  <p>On return contains the glyph origins for the glyphrun.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <see cref = "SharpDX.Result"/> error code.</p></returns>
        /// <remarks>
        /// <p>The transform and DPI have no effect on the origin scaling. They are solely used to compute glyph advances when not supplied and align glyphs in pixel aligned measuring modes.</p>
        /// </remarks>
        /// <doc-id>mt725316</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory4::ComputeGlyphOrigins([In] const DWRITE_GLYPH_RUN* glyphRun,[In] DWRITE_MEASURING_MODE measuringMode,[In] D2D_POINT_2F baselineOrigin,[In, Optional] const DWRITE_MATRIX* worldAndDpiTransform,[Out, Buffer] D2D_POINT_2F* glyphOrigins)</unmanaged>
        /// <unmanaged-short>IDWriteFactory4::ComputeGlyphOrigins</unmanaged-short>
        public unsafe void ComputeGlyphOrigins(SharpDX.DirectWrite.GlyphRun glyphRun, SharpDX.Direct2D1.MeasuringMode measuringMode, SharpDX.Mathematics.Interop.RawVector2 baselineOrigin, SharpDX.Mathematics.Interop.RawMatrix3x2? worldAndDpiTransform, SharpDX.Mathematics.Interop.RawVector2[] glyphOrigins)
        {
            SharpDX.DirectWrite.GlyphRun.__Native glyphRun_ = default (SharpDX.DirectWrite.GlyphRun.__Native);
            SharpDX.Mathematics.Interop.RawMatrix3x2 worldAndDpiTransform_;
            SharpDX.Result __result__;
            glyphRun.__MarshalTo(ref glyphRun_);
            if (worldAndDpiTransform != null)
                worldAndDpiTransform_ = worldAndDpiTransform.Value;
            fixed (void *glyphOrigins_ = glyphOrigins)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, &glyphRun_, unchecked ((System.Int32)measuringMode), baselineOrigin, worldAndDpiTransform == null ? (void *)0 : &worldAndDpiTransform_, glyphOrigins_, (*(void ***)this._nativePointer)[42]);
            glyphRun.__MarshalFree(ref glyphRun_);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("958DB99A-BE2A-4F09-AF7D-65189803D1D3")]
    public partial class Factory5 : SharpDX.DirectWrite.Factory4
    {
        public Factory5(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Factory5(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Factory5(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "fontSetBuilder">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT IDWriteFactory5::CreateFontSetBuilder([Out] IDWriteFontSetBuilder1** fontSetBuilder)</unmanaged>
        /// <unmanaged-short>IDWriteFactory5::CreateFontSetBuilder</unmanaged-short>
        public unsafe void CreateFontSetBuilder(out SharpDX.DirectWrite.FontSetBuilder1 fontSetBuilder)
        {
            System.IntPtr fontSetBuilder_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &fontSetBuilder_, (*(void ***)this._nativePointer)[43]);
            if (fontSetBuilder_ != System.IntPtr.Zero)
                fontSetBuilder = new SharpDX.DirectWrite.FontSetBuilder1(fontSetBuilder_);
            else
                fontSetBuilder = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> </p><p>This topic describes various ways in which you can use custom fonts in your app.</p><p> </p><ul> <li>Introduction?</li> <li>Summary</li> <li>Key</li> <li>Fonts</li> <li>Font</li> <li>Common<ul> <li>Creating</li> <li>Creating</li> <li>Creating</li> <li>Creating</li> </ul> </li> <li>Advanced<ul> <li>Combining</li> <li>Using</li> <li>Using</li> <li>Supporting</li> </ul> </li> </ul>
        /// </summary>
        /// <param name = "newLoader">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <doc-id>mt492448</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory5::CreateInMemoryFontFileLoader([Out] IDWriteInMemoryFontFileLoader** newLoader)</unmanaged>
        /// <unmanaged-short>IDWriteFactory5::CreateInMemoryFontFileLoader</unmanaged-short>
        public unsafe void CreateInMemoryFontFileLoader(out SharpDX.DirectWrite.InMemoryFontFileLoader newLoader)
        {
            System.IntPtr newLoader_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &newLoader_, (*(void ***)this._nativePointer)[44]);
            if (newLoader_ != System.IntPtr.Zero)
                newLoader = new SharpDX.DirectWrite.InMemoryFontFileLoader(newLoader_);
            else
                newLoader = null;
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "referrerUrl">No documentation.</param>
        /// <param name = "extraHeaders">No documentation.</param>
        /// <param name = "newLoader">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT IDWriteFactory5::CreateHttpFontFileLoader([In, Optional] const wchar_t* referrerUrl,[In, Optional] const wchar_t* extraHeaders,[Out] IDWriteRemoteFontFileLoader** newLoader)</unmanaged>
        /// <unmanaged-short>IDWriteFactory5::CreateHttpFontFileLoader</unmanaged-short>
        public unsafe void CreateHttpFontFileLoader(System.String referrerUrl, System.String extraHeaders, out SharpDX.DirectWrite.RemoteFontFileLoader newLoader)
        {
            System.IntPtr newLoader_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (char *extraHeaders_ = extraHeaders)
                fixed (char *referrerUrl_ = referrerUrl)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)referrerUrl_, (void *)extraHeaders_, &newLoader_, (*(void ***)this._nativePointer)[45]);
            if (newLoader_ != System.IntPtr.Zero)
                newLoader = new SharpDX.DirectWrite.RemoteFontFileLoader(newLoader_);
            else
                newLoader = null;
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "fileData">No documentation.</param>
        /// <param name = "fileDataSize">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>DWRITE_CONTAINER_TYPE IDWriteFactory5::AnalyzeContainerType([In, Buffer] const void* fileData,[In] unsigned int fileDataSize)</unmanaged>
        /// <unmanaged-short>IDWriteFactory5::AnalyzeContainerType</unmanaged-short>
        public unsafe SharpDX.DirectWrite.ContainerType AnalyzeContainerType(System.IntPtr fileData, System.Int32 fileDataSize)
        {
            SharpDX.DirectWrite.ContainerType __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirectWriteContainerType(this._nativePointer, (void *)fileData, fileDataSize, (*(void ***)this._nativePointer)[46]);
            return __result__;
        }

        /// <summary>
        /// <p> </p><p>This topic describes various ways in which you can use custom fonts in your app.</p><p> </p><ul> <li>Introduction?</li> <li>Summary</li> <li>Key</li> <li>Fonts</li> <li>Font</li> <li>Common<ul> <li>Creating</li> <li>Creating</li> <li>Creating</li> <li>Creating</li> </ul> </li> <li>Advanced<ul> <li>Combining</li> <li>Using</li> <li>Using</li> <li>Supporting</li> </ul> </li> </ul>
        /// </summary>
        /// <param name = "containerType">No documentation.</param>
        /// <param name = "fileData">No documentation.</param>
        /// <param name = "fileDataSize">No documentation.</param>
        /// <param name = "unpackedFontStream">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <doc-id>mt492448</doc-id>
        /// <unmanaged>HRESULT IDWriteFactory5::UnpackFontFile([In] DWRITE_CONTAINER_TYPE containerType,[In, Buffer] const void* fileData,[In] unsigned int fileDataSize,[Out] IDWriteFontFileStream** unpackedFontStream)</unmanaged>
        /// <unmanaged-short>IDWriteFactory5::UnpackFontFile</unmanaged-short>
        public unsafe void UnpackFontFile(SharpDX.DirectWrite.ContainerType containerType, System.IntPtr fileData, System.Int32 fileDataSize, out SharpDX.DirectWrite.FontFileStream unpackedFontStream)
        {
            System.IntPtr unpackedFontStream_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)containerType), (void *)fileData, fileDataSize, &unpackedFontStream_, (*(void ***)this._nativePointer)[47]);
            if (unpackedFontStream_ != System.IntPtr.Zero)
                unpackedFontStream = new SharpDX.DirectWrite.FontFileStreamNative(unpackedFontStream_);
            else
                unpackedFontStream = null;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("acd16696-8c14-4f5d-877e-fe3fc1d32737")]
    public partial class Font : SharpDX.ComObject
    {
        public Font(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Font(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Font(nativePtr);
        /// <summary>
        /// <p> Gets the font family to which the specified font belongs. </p>
        /// </summary>
        /// <doc-id>dd371143</doc-id>
        /// <unmanaged>GetFontFamily</unmanaged>
        /// <unmanaged-short>GetFontFamily</unmanaged-short>
        public SharpDX.DirectWrite.FontFamily FontFamily
        {
            get
            {
                GetFontFamily(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p> Gets the weight, or stroke thickness, of the specified font. </p>
        /// </summary>
        /// <doc-id>dd371162</doc-id>
        /// <unmanaged>GetWeight</unmanaged>
        /// <unmanaged-short>GetWeight</unmanaged-short>
        public SharpDX.DirectWrite.FontWeight Weight
        {
            get => GetWeight();
        }

        /// <summary>
        /// <p> Gets the stretch, or width, of the specified font. </p>
        /// </summary>
        /// <doc-id>dd371156</doc-id>
        /// <unmanaged>GetStretch</unmanaged>
        /// <unmanaged-short>GetStretch</unmanaged-short>
        public SharpDX.DirectWrite.FontStretch Stretch
        {
            get => GetStretch();
        }

        /// <summary>
        /// <p> Gets the style, or slope, of the specified font. </p>
        /// </summary>
        /// <doc-id>dd371159</doc-id>
        /// <unmanaged>GetStyle</unmanaged>
        /// <unmanaged-short>GetStyle</unmanaged-short>
        public SharpDX.DirectWrite.FontStyle Style
        {
            get => GetStyle();
        }

        /// <summary>
        /// <p> Determines whether the font is a symbol font. </p>
        /// </summary>
        /// <doc-id>dd371168</doc-id>
        /// <unmanaged>IsSymbolFont</unmanaged>
        /// <unmanaged-short>IsSymbolFont</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsSymbolFont
        {
            get => IsSymbolFont_();
        }

        /// <summary>
        /// <p> Gets a localized strings collection containing the face names for the font (such as Regular or Bold), indexed by locale name. </p>
        /// </summary>
        /// <doc-id>dd371140</doc-id>
        /// <unmanaged>GetFaceNames</unmanaged>
        /// <unmanaged-short>GetFaceNames</unmanaged-short>
        public SharpDX.DirectWrite.LocalizedStrings FaceNames
        {
            get
            {
                GetFaceNames(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p> Gets a value that indicates what simulations are applied to the specified font. </p>
        /// </summary>
        /// <doc-id>dd371153</doc-id>
        /// <unmanaged>GetSimulations</unmanaged>
        /// <unmanaged-short>GetSimulations</unmanaged-short>
        public SharpDX.DirectWrite.FontSimulations Simulations
        {
            get => GetSimulations();
        }

        /// <summary>
        /// <p> Obtains design units and common metrics for the font face. These metrics are applicable to all the glyphs within a font face and are used by applications for layout calculations. </p>
        /// </summary>
        /// <doc-id>dd371149</doc-id>
        /// <unmanaged>GetMetrics</unmanaged>
        /// <unmanaged-short>GetMetrics</unmanaged-short>
        public SharpDX.DirectWrite.FontMetrics Metrics
        {
            get
            {
                GetMetrics(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p> Gets the font family to which the specified font belongs. </p>
        /// </summary>
        /// <param name = "fontFamily"><dd>  <p>When this method returns, contains an address of a reference to the font family object to which the specified font belongs.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371143</doc-id>
        /// <unmanaged>HRESULT IDWriteFont::GetFontFamily([Out] IDWriteFontFamily** fontFamily)</unmanaged>
        /// <unmanaged-short>IDWriteFont::GetFontFamily</unmanaged-short>
        internal unsafe void GetFontFamily(out SharpDX.DirectWrite.FontFamily fontFamily)
        {
            System.IntPtr fontFamily_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &fontFamily_, (*(void ***)this._nativePointer)[3]);
            if (fontFamily_ != System.IntPtr.Zero)
                fontFamily = new SharpDX.DirectWrite.FontFamily(fontFamily_);
            else
                fontFamily = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Gets the weight, or stroke thickness, of the specified font. </p>
        /// </summary>
        /// <returns><p>A value that indicates the weight for the specified font.</p></returns>
        /// <doc-id>dd371162</doc-id>
        /// <unmanaged>DWRITE_FONT_WEIGHT IDWriteFont::GetWeight()</unmanaged>
        /// <unmanaged-short>IDWriteFont::GetWeight</unmanaged-short>
        internal unsafe SharpDX.DirectWrite.FontWeight GetWeight()
        {
            SharpDX.DirectWrite.FontWeight __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirectWriteFontWeight(this._nativePointer, (*(void ***)this._nativePointer)[4]);
            return __result__;
        }

        /// <summary>
        /// <p> Gets the stretch, or width, of the specified font. </p>
        /// </summary>
        /// <returns><p>A value that indicates the type of stretch, or width, applied to the specified font.</p></returns>
        /// <doc-id>dd371156</doc-id>
        /// <unmanaged>DWRITE_FONT_STRETCH IDWriteFont::GetStretch()</unmanaged>
        /// <unmanaged-short>IDWriteFont::GetStretch</unmanaged-short>
        internal unsafe SharpDX.DirectWrite.FontStretch GetStretch()
        {
            SharpDX.DirectWrite.FontStretch __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirectWriteFontStretch(this._nativePointer, (*(void ***)this._nativePointer)[5]);
            return __result__;
        }

        /// <summary>
        /// <p> Gets the style, or slope, of the specified font. </p>
        /// </summary>
        /// <returns><p>A value that indicates the type of style, or slope, of the specified font.</p></returns>
        /// <doc-id>dd371159</doc-id>
        /// <unmanaged>DWRITE_FONT_STYLE IDWriteFont::GetStyle()</unmanaged>
        /// <unmanaged-short>IDWriteFont::GetStyle</unmanaged-short>
        internal unsafe SharpDX.DirectWrite.FontStyle GetStyle()
        {
            SharpDX.DirectWrite.FontStyle __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirectWriteFontStyle(this._nativePointer, (*(void ***)this._nativePointer)[6]);
            return __result__;
        }

        /// <summary>
        /// <p> Determines whether the font is a symbol font. </p>
        /// </summary>
        /// <returns><p><strong>TRUE</strong> if the font is a symbol font; otherwise, <strong><see cref = "SharpDX.Result.False"/></strong>.</p></returns>
        /// <doc-id>dd371168</doc-id>
        /// <unmanaged>BOOL IDWriteFont::IsSymbolFont()</unmanaged>
        /// <unmanaged-short>IDWriteFont::IsSymbolFont</unmanaged-short>
        internal unsafe SharpDX.Mathematics.Interop.RawBool IsSymbolFont_()
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, (*(void ***)this._nativePointer)[7]);
            return __result__;
        }

        /// <summary>
        /// <p> Gets a localized strings collection containing the face names for the font (such as Regular or Bold), indexed by locale name. </p>
        /// </summary>
        /// <param name = "names"><dd>  <p>When this method returns, contains an address to a  reference to the newly created localized strings object.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371140</doc-id>
        /// <unmanaged>HRESULT IDWriteFont::GetFaceNames([Out] IDWriteLocalizedStrings** names)</unmanaged>
        /// <unmanaged-short>IDWriteFont::GetFaceNames</unmanaged-short>
        internal unsafe void GetFaceNames(out SharpDX.DirectWrite.LocalizedStrings names)
        {
            System.IntPtr names_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &names_, (*(void ***)this._nativePointer)[8]);
            if (names_ != System.IntPtr.Zero)
                names = new SharpDX.DirectWrite.LocalizedStrings(names_);
            else
                names = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Gets a localized strings collection containing the specified informational strings, indexed by locale name. </p>
        /// </summary>
        /// <param name = "informationalStringID"><dd>  <p>A value that identifies the  informational string to get. For example, <strong>DWRITE_INFORMATIONAL_STRING_DESCRIPTION</strong> specifies a string that contains a description of the font. </p> </dd></param>
        /// <param name = "informationalStrings"><dd>  <p>When this method returns, contains an address of a reference to the newly created localized strings object.</p> </dd></param>
        /// <returns><dd>  <p>When this method returns, <strong>TRUE</strong> if the font contains the specified string ID; otherwise, <strong><see cref = "SharpDX.Result.False"/></strong>.</p> </dd></returns>
        /// <remarks>
        /// <p> If the font does not contain the string specified by <em>informationalStringID</em>, the return value is <strong><see cref = "SharpDX.Result.Ok"/></strong> but  <em>informationalStrings</em> receives a <strong><c>null</c></strong> reference and <em>exists</em> receives the value <strong><see cref = "SharpDX.Result.False"/></strong>.</p>
        /// </remarks>
        /// <doc-id>dd371147</doc-id>
        /// <unmanaged>HRESULT IDWriteFont::GetInformationalStrings([In] DWRITE_INFORMATIONAL_STRING_ID informationalStringID,[Out, Optional] IDWriteLocalizedStrings** informationalStrings,[Out] BOOL* exists)</unmanaged>
        /// <unmanaged-short>IDWriteFont::GetInformationalStrings</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool GetInformationalStrings(SharpDX.DirectWrite.InformationalStringId informationalStringID, out SharpDX.DirectWrite.LocalizedStrings informationalStrings)
        {
            System.IntPtr informationalStrings_ = System.IntPtr.Zero;
            SharpDX.Mathematics.Interop.RawBool exists;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)informationalStringID), &informationalStrings_, &exists, (*(void ***)this._nativePointer)[9]);
            if (informationalStrings_ != System.IntPtr.Zero)
                informationalStrings = new SharpDX.DirectWrite.LocalizedStrings(informationalStrings_);
            else
                informationalStrings = null;
            __result__.CheckError();
            return exists;
        }

        /// <summary>
        /// <p> Gets a value that indicates what simulations are applied to the specified font. </p>
        /// </summary>
        /// <returns><p> A value that indicates one or more of the  types of simulations (none, bold, or oblique)  applied to the specified font.</p></returns>
        /// <doc-id>dd371153</doc-id>
        /// <unmanaged>DWRITE_FONT_SIMULATIONS IDWriteFont::GetSimulations()</unmanaged>
        /// <unmanaged-short>IDWriteFont::GetSimulations</unmanaged-short>
        internal unsafe SharpDX.DirectWrite.FontSimulations GetSimulations()
        {
            SharpDX.DirectWrite.FontSimulations __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirectWriteFontSimulations(this._nativePointer, (*(void ***)this._nativePointer)[10]);
            return __result__;
        }

        /// <summary>
        /// <p> Obtains design units and common metrics for the font face. These metrics are applicable to all the glyphs within a font face and are used by applications for layout calculations. </p>
        /// </summary>
        /// <param name = "fontMetrics"><dd>  <p>When this method returns, contains a structure that has font metrics for the current font face. The metrics returned by this function are in font design units.</p> </dd></param>
        /// <doc-id>dd371149</doc-id>
        /// <unmanaged>void IDWriteFont::GetMetrics([Out] DWRITE_FONT_METRICS* fontMetrics)</unmanaged>
        /// <unmanaged-short>IDWriteFont::GetMetrics</unmanaged-short>
        internal unsafe void GetMetrics(out SharpDX.DirectWrite.FontMetrics fontMetrics)
        {
            fontMetrics = default (SharpDX.DirectWrite.FontMetrics);
            fixed (void *fontMetrics_ = &fontMetrics)
                SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, fontMetrics_, (*(void ***)this._nativePointer)[11]);
        }

        /// <summary>
        /// <p> Determines whether the font supports a specified character. </p>
        /// </summary>
        /// <param name = "unicodeValue"><dd>  <p>A Unicode (UCS-4) character value for the method to inspect.</p> </dd></param>
        /// <returns><dd>  <p>When this method returns, <strong>TRUE</strong> if the font supports the specified character; otherwise, <strong><see cref = "SharpDX.Result.False"/></strong>.</p> </dd></returns>
        /// <doc-id>dd371165</doc-id>
        /// <unmanaged>HRESULT IDWriteFont::HasCharacter([In] unsigned int unicodeValue,[Out] BOOL* exists)</unmanaged>
        /// <unmanaged-short>IDWriteFont::HasCharacter</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool HasCharacter(System.Int32 unicodeValue)
        {
            SharpDX.Mathematics.Interop.RawBool exists;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unicodeValue, &exists, (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
            return exists;
        }

        /// <summary>
        /// <p> Creates a font face object for the font. </p>
        /// </summary>
        /// <param name = "fontFace"><dd>  <p>When this method returns, contains an address of a reference to the newly created font face object.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371137</doc-id>
        /// <unmanaged>HRESULT IDWriteFont::CreateFontFace([Out, Fast] IDWriteFontFace** fontFace)</unmanaged>
        /// <unmanaged-short>IDWriteFont::CreateFontFace</unmanaged-short>
        internal unsafe void CreateFontFace(SharpDX.DirectWrite.FontFace fontFace)
        {
            System.IntPtr fontFace_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &fontFace_, (*(void ***)this._nativePointer)[13]);
            (fontFace).NativePointer = fontFace_;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("acd16696-8c14-4f5d-877e-fe3fc1d32738")]
    public partial class Font1 : SharpDX.DirectWrite.Font
    {
        public Font1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Font1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Font1(nativePtr);
        /// <summary>
        /// <p> Obtains design units and common metrics for the font face. These metrics are applicable to all the glyphs within a font face and are used by applications for layout calculations. </p>
        /// </summary>
        /// <doc-id>hh780405</doc-id>
        /// <unmanaged>GetMetrics</unmanaged>
        /// <unmanaged-short>GetMetrics</unmanaged-short>
        public SharpDX.DirectWrite.FontMetrics1 Metrics
        {
            get
            {
                GetMetrics(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the PANOSE values from the font and is used for font selection and matching.</p>
        /// </summary>
        /// <remarks>
        /// <p>If the font has no PANOSE values, they are set to 'any' (0) and DirectWrite doesn't simulate those values.</p>
        /// </remarks>
        /// <doc-id>hh780406</doc-id>
        /// <unmanaged>GetPanose</unmanaged>
        /// <unmanaged-short>GetPanose</unmanaged-short>
        public SharpDX.DirectWrite.Panose Panose
        {
            get
            {
                GetPanose(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Determines if the font is monospaced, that is, the characters are the same fixed-pitch width (non-proportional).</p>
        /// </summary>
        /// <doc-id>hh780408</doc-id>
        /// <unmanaged>IsMonospacedFont</unmanaged>
        /// <unmanaged-short>IsMonospacedFont</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsMonospacedFont
        {
            get => IsMonospacedFont_();
        }

        /// <summary>
        /// <p> Obtains design units and common metrics for the font face. These metrics are applicable to all the glyphs within a font face and are used by applications for layout calculations. </p>
        /// </summary>
        /// <param name = "fontMetrics"><dd>  <p> A filled  <strong><see cref = "SharpDX.DirectWrite.FontMetrics1"/></strong> structure that has font metrics for the current font face. The metrics returned by this method are in font design units.</p> </dd></param>
        /// <doc-id>hh780405</doc-id>
        /// <unmanaged>void IDWriteFont1::GetMetrics([Out] DWRITE_FONT_METRICS1* fontMetrics)</unmanaged>
        /// <unmanaged-short>IDWriteFont1::GetMetrics</unmanaged-short>
        internal unsafe void GetMetrics(out SharpDX.DirectWrite.FontMetrics1 fontMetrics)
        {
            fontMetrics = default (SharpDX.DirectWrite.FontMetrics1);
            fixed (void *fontMetrics_ = &fontMetrics)
                SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, fontMetrics_, (*(void ***)this._nativePointer)[14]);
        }

        /// <summary>
        /// <p>Gets the PANOSE values from the font and is used for font selection and matching.</p>
        /// </summary>
        /// <param name = "anoseRef"><dd>  <p>A reference to the <strong><see cref = "SharpDX.DirectWrite.Panose"/></strong> structure to fill in.</p> </dd></param>
        /// <remarks>
        /// <p>If the font has no PANOSE values, they are set to 'any' (0) and DirectWrite doesn't simulate those values.</p>
        /// </remarks>
        /// <doc-id>hh780406</doc-id>
        /// <unmanaged>void IDWriteFont1::GetPanose([Out] DWRITE_PANOSE* panose)</unmanaged>
        /// <unmanaged-short>IDWriteFont1::GetPanose</unmanaged-short>
        internal unsafe void GetPanose(out SharpDX.DirectWrite.Panose anoseRef)
        {
            SharpDX.DirectWrite.Panose.__Native anoseRef_ = default (SharpDX.DirectWrite.Panose.__Native);
            anoseRef = default (SharpDX.DirectWrite.Panose);
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, &anoseRef_, (*(void ***)this._nativePointer)[15]);
            anoseRef.__MarshalFrom(ref anoseRef_);
        }

        /// <summary>
        /// <p>Retrieves the list of character ranges supported by a font.</p>
        /// </summary>
        /// <param name = "maxRangeCount"><dd>  <p>The maximum number of character ranges passed in from the client.</p> </dd></param>
        /// <param name = "unicodeRanges"><dd>  <p>An array of <strong><see cref = "SharpDX.DirectWrite.UnicodeRange"/></strong> structures that are filled with the character ranges.</p> </dd></param>
        /// <param name = "actualRangeCount"><dd>  <p>A reference to the actual number of character ranges, regardless of the maximum count.</p> </dd></param>
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return value</th><th>Description</th></tr> <tr><td> <dl> <dt><see cref = "SharpDX.Result.Ok"/></dt> </dl> </td><td> <p>The method executed successfully.</p> </td></tr> <tr><td> <dl> <dt>E_NOT_SUFFICIENT_BUFFER</dt> </dl> </td><td> <p>The buffer is too small.  The <em>actualRangeCount</em> was more than the <em>maxRangeCount</em>.</p> </td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>The list of character ranges supported by a font, is useful for scenarios like character picking, glyph display, and efficient font selection lookup. GetUnicodeRanges is similar to GDI's GetFontUnicodeRanges, except that it returns the full Unicode range, not just 16-bit UCS-2.</p><p>These ranges are from the cmap, not the OS/2::ulCodePageRange1.</p><p>If this method is unavailable, you can use the <strong>IDWriteFontFace::GetGlyphIndices</strong> method to check for missing glyphs.  The method returns the 0 index for glyphs that aren't present in the font.</p><p> The <strong>IDWriteFont::HasCharacter</strong> method is often simpler in cases where you need to check a single character or a series of single characters in succession, such as in font fallback.</p>
        /// </remarks>
        /// <doc-id>hh780407</doc-id>
        /// <unmanaged>HRESULT IDWriteFont1::GetUnicodeRanges([In] unsigned int maxRangeCount,[Out, Buffer, Optional] DWRITE_UNICODE_RANGE* unicodeRanges,[Out] unsigned int* actualRangeCount)</unmanaged>
        /// <unmanaged-short>IDWriteFont1::GetUnicodeRanges</unmanaged-short>
        public unsafe void GetUnicodeRanges(System.Int32 maxRangeCount, SharpDX.DirectWrite.UnicodeRange[] unicodeRanges, out System.Int32 actualRangeCount)
        {
            SharpDX.Result __result__;
            fixed (void *actualRangeCount_ = &actualRangeCount)
                fixed (void *unicodeRanges_ = unicodeRanges)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, maxRangeCount, unicodeRanges_, actualRangeCount_, (*(void ***)this._nativePointer)[16]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Determines if the font is monospaced, that is, the characters are the same fixed-pitch width (non-proportional).</p>
        /// </summary>
        /// <returns><p>Returns true if the font is monospaced, else it returns false.</p></returns>
        /// <doc-id>hh780408</doc-id>
        /// <unmanaged>BOOL IDWriteFont1::IsMonospacedFont()</unmanaged>
        /// <unmanaged-short>IDWriteFont1::IsMonospacedFont</unmanaged-short>
        internal unsafe SharpDX.Mathematics.Interop.RawBool IsMonospacedFont_()
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, (*(void ***)this._nativePointer)[17]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("29748ed6-8c9c-4a6a-be0b-d912e8538944")]
    public partial class Font2 : SharpDX.DirectWrite.Font1
    {
        public Font2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Font2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Font2(nativePtr);
        /// <summary>
        /// <p>Enables determining if a color rendering path is potentially necessary.</p>
        /// </summary>
        /// <doc-id>dn280453</doc-id>
        /// <unmanaged>IsColorFont</unmanaged>
        /// <unmanaged-short>IsColorFont</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsColorFont
        {
            get => IsColorFont_();
        }

        /// <summary>
        /// <p>Enables determining if a color rendering path is potentially necessary.</p>
        /// </summary>
        /// <returns><p>Returns <strong>TRUE</strong> if the font has color information (COLR and CPAL tables); otherwise <strong><see cref = "SharpDX.Result.False"/></strong>.</p></returns>
        /// <doc-id>dn280453</doc-id>
        /// <unmanaged>BOOL IDWriteFont2::IsColorFont()</unmanaged>
        /// <unmanaged-short>IDWriteFont2::IsColorFont</unmanaged-short>
        internal unsafe SharpDX.Mathematics.Interop.RawBool IsColorFont_()
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, (*(void ***)this._nativePointer)[18]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("29748ED6-8C9C-4A6A-BE0B-D912E8538944")]
    public partial class Font3 : SharpDX.DirectWrite.Font2
    {
        public Font3(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Font3(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Font3(nativePtr);
        /// <summary>
        /// <p>Gets a font face reference that identifies this font.</p>
        /// </summary>
        /// <doc-id>dn890771</doc-id>
        /// <unmanaged>GetFontFaceReference</unmanaged>
        /// <unmanaged-short>GetFontFaceReference</unmanaged-short>
        public SharpDX.DirectWrite.FontFaceReference FontFaceReference
        {
            get
            {
                GetFontFaceReference(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the current locality of the font.</p>
        /// </summary>
        /// <remarks>
        /// <p>For fully local files, the result will always  be DWRITE_LOCALITY_LOCAL. A downloadable file may be any of the states, and this function may change between calls.</p>
        /// </remarks>
        /// <doc-id>mt725319</doc-id>
        /// <unmanaged>GetLocality</unmanaged>
        /// <unmanaged-short>GetLocality</unmanaged-short>
        public SharpDX.DirectWrite.Locality Locality
        {
            get => GetLocality();
        }

        /// <summary>
        /// <p>Creates a font face object for the font.</p>
        /// </summary>
        /// <param name = "fontFace"><dd>  <p>A reference to a memory block that receives a reference to a <strong><see cref = "SharpDX.DirectWrite.FontFace3"/></strong> interface for the newly created font face object.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. </p><p>This method returns <strong>DWRITE_E_REMOTEFONT</strong> if it could not construct a remote font.</p></returns>
        /// <doc-id>dn890767</doc-id>
        /// <unmanaged>HRESULT IDWriteFont3::CreateFontFace([Out] IDWriteFontFace3** fontFace)</unmanaged>
        /// <unmanaged-short>IDWriteFont3::CreateFontFace</unmanaged-short>
        public unsafe void CreateFontFace(out SharpDX.DirectWrite.FontFace3 fontFace)
        {
            System.IntPtr fontFace_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &fontFace_, (*(void ***)this._nativePointer)[19]);
            if (fontFace_ != System.IntPtr.Zero)
                fontFace = new SharpDX.DirectWrite.FontFace3(fontFace_);
            else
                fontFace = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Compares two instances of font references for equality.</p>
        /// </summary>
        /// <param name = "font"><dd>  <p>A reference to a <strong><see cref = "SharpDX.DirectWrite.Font"/></strong> interface for the other font instance to compare to this font instance.</p> </dd></param>
        /// <returns><p>Returns whether the two instances of font references are equal. Returns <strong>TRUE</strong> if the two instances are equal; otherwise, <strong><see cref = "SharpDX.Result.False"/></strong>. </p></returns>
        /// <doc-id>dn890769</doc-id>
        /// <unmanaged>BOOL IDWriteFont3::Equals([In] IDWriteFont* font)</unmanaged>
        /// <unmanaged-short>IDWriteFont3::Equals</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool Equals(SharpDX.DirectWrite.Font font)
        {
            System.IntPtr font_ = System.IntPtr.Zero;
            SharpDX.Mathematics.Interop.RawBool __result__;
            font_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.Font>(font);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, (void *)font_, (*(void ***)this._nativePointer)[20]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets a font face reference that identifies this font.</p>
        /// </summary>
        /// <param name = "fontFaceReference"><dd>  <p>A reference to a memory block that receives a reference to a <strong><see cref = "SharpDX.DirectWrite.FontFaceReference"/></strong> interface for the newly created font face reference object.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn890771</doc-id>
        /// <unmanaged>HRESULT IDWriteFont3::GetFontFaceReference([Out] IDWriteFontFaceReference** fontFaceReference)</unmanaged>
        /// <unmanaged-short>IDWriteFont3::GetFontFaceReference</unmanaged-short>
        internal unsafe void GetFontFaceReference(out SharpDX.DirectWrite.FontFaceReference fontFaceReference)
        {
            System.IntPtr fontFaceReference_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &fontFaceReference_, (*(void ***)this._nativePointer)[21]);
            if (fontFaceReference_ != System.IntPtr.Zero)
                fontFaceReference = new SharpDX.DirectWrite.FontFaceReference(fontFaceReference_);
            else
                fontFaceReference = null;
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "unicodeValue">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>BOOL IDWriteFont3::HasCharacter([In] unsigned int unicodeValue)</unmanaged>
        /// <unmanaged-short>IDWriteFont3::HasCharacter</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool HasCharacter(System.Int32 unicodeValue)
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, unicodeValue, (*(void ***)this._nativePointer)[22]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets the current locality of the font.</p>
        /// </summary>
        /// <returns><p>Returns the current locality of the font.</p></returns>
        /// <remarks>
        /// <p>For fully local files, the result will always  be DWRITE_LOCALITY_LOCAL. A downloadable file may be any of the states, and this function may change between calls.</p>
        /// </remarks>
        /// <doc-id>mt725319</doc-id>
        /// <unmanaged>DWRITE_LOCALITY IDWriteFont3::GetLocality()</unmanaged>
        /// <unmanaged-short>IDWriteFont3::GetLocality</unmanaged-short>
        internal unsafe SharpDX.DirectWrite.Locality GetLocality()
        {
            SharpDX.DirectWrite.Locality __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirectWriteLocality(this._nativePointer, (*(void ***)this._nativePointer)[23]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("a84cee02-3eea-4eee-a827-87c1a02a0fcc")]
    public partial class FontCollection : SharpDX.ComObject
    {
        public FontCollection(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator FontCollection(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new FontCollection(nativePtr);
        /// <summary>
        /// <p> Gets the number of font families in the collection. </p>
        /// </summary>
        /// <doc-id>dd370974</doc-id>
        /// <unmanaged>GetFontFamilyCount</unmanaged>
        /// <unmanaged-short>GetFontFamilyCount</unmanaged-short>
        public System.Int32 FontFamilyCount
        {
            get => GetFontFamilyCount();
        }

        /// <summary>
        /// <p> Gets the number of font families in the collection. </p>
        /// </summary>
        /// <returns><p>The number of font families in the collection.</p></returns>
        /// <doc-id>dd370974</doc-id>
        /// <unmanaged>unsigned int IDWriteFontCollection::GetFontFamilyCount()</unmanaged>
        /// <unmanaged-short>IDWriteFontCollection::GetFontFamilyCount</unmanaged-short>
        internal unsafe System.Int32 GetFontFamilyCount()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[3]);
            return __result__;
        }

        /// <summary>
        /// <p> Creates a font family object given a zero-based font family index. </p>
        /// </summary>
        /// <param name = "index"><dd>  <p>Zero-based index of the font family.</p> </dd></param>
        /// <returns><dd>  <p>When this method returns, contains the address of   a reference to the newly created font family object.</p> </dd></returns>
        /// <doc-id>dd370970</doc-id>
        /// <unmanaged>HRESULT IDWriteFontCollection::GetFontFamily([In] unsigned int index,[Out] IDWriteFontFamily** fontFamily)</unmanaged>
        /// <unmanaged-short>IDWriteFontCollection::GetFontFamily</unmanaged-short>
        public unsafe SharpDX.DirectWrite.FontFamily GetFontFamily(System.Int32 index)
        {
            SharpDX.DirectWrite.FontFamily fontFamily;
            System.IntPtr fontFamily_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, index, &fontFamily_, (*(void ***)this._nativePointer)[4]);
            if (fontFamily_ != System.IntPtr.Zero)
                fontFamily = new SharpDX.DirectWrite.FontFamily(fontFamily_);
            else
                fontFamily = null;
            __result__.CheckError();
            return fontFamily;
        }

        /// <summary>
        /// <p> Finds the font family with the specified family name. </p>
        /// </summary>
        /// <param name = "familyName"><dd>  <p>An array of characters, which is null-terminated, containing the name of the font family. The name is not case-sensitive but must otherwise exactly match a family name in the collection.</p> </dd></param>
        /// <param name = "index"><dd>  <p>When this method returns, contains the zero-based index of the matching font family if the family name was found; otherwise, <strong>UINT_MAX</strong>.</p> </dd></param>
        /// <returns><dd>  <p>When this method returns, <strong>TRUE</strong> if the family name exists; otherwise, <strong><see cref = "SharpDX.Result.False"/></strong>.</p> </dd></returns>
        /// <doc-id>dd368217</doc-id>
        /// <unmanaged>HRESULT IDWriteFontCollection::FindFamilyName([In] const wchar_t* familyName,[Out] unsigned int* index,[Out] BOOL* exists)</unmanaged>
        /// <unmanaged-short>IDWriteFontCollection::FindFamilyName</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool FindFamilyName(System.String familyName, out System.Int32 index)
        {
            SharpDX.Mathematics.Interop.RawBool exists;
            SharpDX.Result __result__;
            fixed (void *index_ = &index)
                fixed (char *familyName_ = familyName)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)familyName_, index_, &exists, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
            return exists;
        }

        /// <summary>
        /// <p> Gets the font object that corresponds to the same physical font as the specified font face object. The specified physical font must belong  to the font collection. </p>
        /// </summary>
        /// <param name = "fontFace"><dd>  <p>A font face object that specifies the physical font.</p> </dd></param>
        /// <returns><dd>  <p>When this method returns, contains the address of a reference to the newly created font object if successful; otherwise, <strong><c>null</c></strong>.</p> </dd></returns>
        /// <doc-id>dd370978</doc-id>
        /// <unmanaged>HRESULT IDWriteFontCollection::GetFontFromFontFace([In] IDWriteFontFace* fontFace,[Out] IDWriteFont** font)</unmanaged>
        /// <unmanaged-short>IDWriteFontCollection::GetFontFromFontFace</unmanaged-short>
        public unsafe SharpDX.DirectWrite.Font GetFontFromFontFace(SharpDX.DirectWrite.FontFace fontFace)
        {
            System.IntPtr fontFace_ = System.IntPtr.Zero;
            SharpDX.DirectWrite.Font font;
            System.IntPtr font_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fontFace_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.FontFace>(fontFace);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)fontFace_, &font_, (*(void ***)this._nativePointer)[6]);
            if (font_ != System.IntPtr.Zero)
                font = new SharpDX.DirectWrite.Font(font_);
            else
                font = null;
            __result__.CheckError();
            return font;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("53585141-D9F8-4095-8321-D73CF6BD116C")]
    public partial class FontCollection1 : SharpDX.DirectWrite.FontCollection
    {
        public FontCollection1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator FontCollection1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new FontCollection1(nativePtr);
        /// <summary>
        /// <p>Gets the underlying font set used by this collection.</p>
        /// </summary>
        /// <doc-id>dn933225</doc-id>
        /// <unmanaged>GetFontSet</unmanaged>
        /// <unmanaged-short>GetFontSet</unmanaged-short>
        public SharpDX.DirectWrite.FontSet FontSet
        {
            get
            {
                GetFontSet(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the underlying font set used by this collection.</p>
        /// </summary>
        /// <param name = "fontSet"><dd>  <p>Returns the font set used by the collection.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn933225</doc-id>
        /// <unmanaged>HRESULT IDWriteFontCollection1::GetFontSet([Out] IDWriteFontSet** fontSet)</unmanaged>
        /// <unmanaged-short>IDWriteFontCollection1::GetFontSet</unmanaged-short>
        internal unsafe void GetFontSet(out SharpDX.DirectWrite.FontSet fontSet)
        {
            System.IntPtr fontSet_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &fontSet_, (*(void ***)this._nativePointer)[7]);
            if (fontSet_ != System.IntPtr.Zero)
                fontSet = new SharpDX.DirectWrite.FontSet(fontSet_);
            else
                fontSet = null;
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "index">No documentation.</param>
        /// <param name = "fontFamily">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT IDWriteFontCollection1::GetFontFamily([In] unsigned int index,[Out] IDWriteFontFamily1** fontFamily)</unmanaged>
        /// <unmanaged-short>IDWriteFontCollection1::GetFontFamily</unmanaged-short>
        public unsafe void GetFontFamily(System.Int32 index, out SharpDX.DirectWrite.FontFamily1 fontFamily)
        {
            System.IntPtr fontFamily_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, index, &fontFamily_, (*(void ***)this._nativePointer)[8]);
            if (fontFamily_ != System.IntPtr.Zero)
                fontFamily = new SharpDX.DirectWrite.FontFamily1(fontFamily_);
            else
                fontFamily = null;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("cca920e4-52f0-492b-bfa8-29c72ee0a468")]
    public partial interface FontCollectionLoader : SharpDX.IUnknown
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("B06FE5B9-43EC-4393-881B-DBE4DC72FDA7")]
    public partial class FontDownloadListener : SharpDX.ComObject
    {
        public FontDownloadListener(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator FontDownloadListener(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new FontDownloadListener(nativePtr);
        /// <summary>
        /// <p>The DownloadCompleted method is called back on an arbitrary thread when a     download operation ends. </p>
        /// </summary>
        /// <param name = "downloadQueue"><dd>  <p>Pointer to the download queue interface on which      the BeginDownload method was called.</p> </dd></param>
        /// <param name = "context"><dd>  <p>Optional context object that was passed to BeginDownload.     AddRef is called on the context object by BeginDownload and Release is called   after the DownloadCompleted method returns.</p> </dd></param>
        /// <param name = "downloadResult"><dd>  <p>Result of the download operation.</p> </dd></param>
        /// <doc-id>dn890776</doc-id>
        /// <unmanaged>void IDWriteFontDownloadListener::DownloadCompleted([In] IDWriteFontDownloadQueue* downloadQueue,[In, Optional] IUnknown* context,[In] HRESULT downloadResult)</unmanaged>
        /// <unmanaged-short>IDWriteFontDownloadListener::DownloadCompleted</unmanaged-short>
        public unsafe void DownloadCompleted(SharpDX.DirectWrite.FontDownloadQueue downloadQueue, SharpDX.IUnknown context, SharpDX.Result downloadResult)
        {
            System.IntPtr downloadQueue_ = System.IntPtr.Zero;
            System.IntPtr context_ = System.IntPtr.Zero;
            downloadQueue_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.FontDownloadQueue>(downloadQueue);
            context_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(context);
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid0(this._nativePointer, (void *)downloadQueue_, (void *)context_, downloadResult, (*(void ***)this._nativePointer)[3]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("B71E6052-5AEA-4FA3-832E-F60D431F7E91")]
    public partial class FontDownloadQueue : SharpDX.ComObject
    {
        public FontDownloadQueue(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator FontDownloadQueue(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new FontDownloadQueue(nativePtr);
        /// <summary>
        /// <p>Determines whether the download queue is empty. Note that the queue does not     include requests that are already being downloaded. Calling <strong>BeginDownload</strong> clears the queue.</p>
        /// </summary>
        /// <doc-id>dn894558</doc-id>
        /// <unmanaged>IsEmpty</unmanaged>
        /// <unmanaged-short>IsEmpty</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsEmpty
        {
            get => IsEmpty_();
        }

        /// <summary>
        /// <p>Gets the current generation number of the download queue, which is incremented    every time after a download completes, whether failed or successful. This cookie   value can be compared against cached data to determine if it is stale.</p>
        /// </summary>
        /// <doc-id>dn894557</doc-id>
        /// <unmanaged>GetGenerationCount</unmanaged>
        /// <unmanaged-short>GetGenerationCount</unmanaged-short>
        public System.Int64 GenerationCount
        {
            get => GetGenerationCount();
        }

        /// <summary>
        /// <p>Registers a client-defined listener object that receives download notifications.   All registered listener's DownloadCompleted will be called after <strong>BeginDownload</strong> completes. </p>
        /// </summary>
        /// <param name = "listener">No documentation.</param>
        /// <param name = "token">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>An <strong><see cref = "SharpDX.DirectWrite.FontDownloadListener"/></strong> can also be passed to <strong>BeginDownload</strong> using the context parameter, rather than globally registered to the queue.</p>
        /// </remarks>
        /// <doc-id>dn890779</doc-id>
        /// <unmanaged>HRESULT IDWriteFontDownloadQueue::AddListener([In] IDWriteFontDownloadListener* listener,[Out] unsigned int* token)</unmanaged>
        /// <unmanaged-short>IDWriteFontDownloadQueue::AddListener</unmanaged-short>
        public unsafe void AddListener(SharpDX.DirectWrite.FontDownloadListener listener, out System.Int32 token)
        {
            System.IntPtr listener_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            listener_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.FontDownloadListener>(listener);
            fixed (void *token_ = &token)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)listener_, token_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Unregisters a notification handler that was previously registered using <strong>AddListener</strong>.</p>
        /// </summary>
        /// <param name = "token">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn894559</doc-id>
        /// <unmanaged>HRESULT IDWriteFontDownloadQueue::RemoveListener([In] unsigned int token)</unmanaged>
        /// <unmanaged-short>IDWriteFontDownloadQueue::RemoveListener</unmanaged-short>
        public unsafe void RemoveListener(System.Int32 token)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, token, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Determines whether the download queue is empty. Note that the queue does not     include requests that are already being downloaded. Calling <strong>BeginDownload</strong> clears the queue.</p>
        /// </summary>
        /// <returns><p>TRUE if the queue is empty, <see cref = "SharpDX.Result.False"/> if there are requests pending for <strong>BeginDownload</strong>.</p></returns>
        /// <doc-id>dn894558</doc-id>
        /// <unmanaged>BOOL IDWriteFontDownloadQueue::IsEmpty()</unmanaged>
        /// <unmanaged-short>IDWriteFontDownloadQueue::IsEmpty</unmanaged-short>
        internal unsafe SharpDX.Mathematics.Interop.RawBool IsEmpty_()
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, (*(void ***)this._nativePointer)[5]);
            return __result__;
        }

        /// <summary>
        /// <p>Begins an asynchronous download operation. The download operation executes    in the background until it completes or is cancelled by a <strong>CancelDownload</strong> call.</p>
        /// </summary>
        /// <param name = "context">No documentation.</param>
        /// <returns><p> Returns <see cref = "SharpDX.Result.Ok"/> if a download was successfully begun, S_FALSE if the queue was  empty, or a standard <see cref = "SharpDX.Result"/> error code.</p></returns>
        /// <remarks>
        /// <p>BeginDownload removes all download requests from the queue, transferring them    to a background download operation. If any previous downloads are still ongoing      when BeginDownload is called again, the new download does not complete until      the previous downloads have finished. If the queue is empty and no active    downloads are pending, the <strong>DownloadCompleted</strong> callback is called immediately with     DWRITE_DOWNLOAD_RESULT_NONE.</p>
        /// </remarks>
        /// <doc-id>dn894554</doc-id>
        /// <unmanaged>HRESULT IDWriteFontDownloadQueue::BeginDownload([In, Optional] IUnknown* context)</unmanaged>
        /// <unmanaged-short>IDWriteFontDownloadQueue::BeginDownload</unmanaged-short>
        public unsafe void BeginDownload(SharpDX.IUnknown context)
        {
            System.IntPtr context_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            context_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(context);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)context_, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Removes all download requests from the queue and cancels any active download     operations.</p>
        /// </summary>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn894556</doc-id>
        /// <unmanaged>HRESULT IDWriteFontDownloadQueue::CancelDownload()</unmanaged>
        /// <unmanaged-short>IDWriteFontDownloadQueue::CancelDownload</unmanaged-short>
        public unsafe void CancelDownload()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the current generation number of the download queue, which is incremented    every time after a download completes, whether failed or successful. This cookie   value can be compared against cached data to determine if it is stale.</p>
        /// </summary>
        /// <returns><p>The current generation number of the download queue.</p></returns>
        /// <doc-id>dn894557</doc-id>
        /// <unmanaged>unsigned longlong IDWriteFontDownloadQueue::GetGenerationCount()</unmanaged>
        /// <unmanaged-short>IDWriteFontDownloadQueue::GetGenerationCount</unmanaged-short>
        internal unsafe System.Int64 GetGenerationCount()
        {
            System.Int64 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCalllong(this._nativePointer, (*(void ***)this._nativePointer)[8]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("5f49804d-7024-4d43-bfa9-d25984f53849")]
    public partial class FontFace : SharpDX.ComObject
    {
        public FontFace(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator FontFace(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new FontFace(nativePtr);
        /// <summary>
        /// <p> Obtains the file format type of a font face. </p>
        /// </summary>
        /// <doc-id>dd371031</doc-id>
        /// <unmanaged>GetType</unmanaged>
        /// <unmanaged-short>GetType</unmanaged-short>
        public SharpDX.DirectWrite.FontFaceType FaceType
        {
            get => GetFaceType();
        }

        /// <summary>
        /// <p> Obtains the index of a font face in the context of its font files. </p>
        /// </summary>
        /// <doc-id>dd371007</doc-id>
        /// <unmanaged>GetIndex</unmanaged>
        /// <unmanaged-short>GetIndex</unmanaged-short>
        public System.Int32 Index
        {
            get => GetIndex();
        }

        /// <summary>
        /// <p> Obtains the algorithmic style simulation flags of a font face. </p>
        /// </summary>
        /// <doc-id>dd371018</doc-id>
        /// <unmanaged>GetSimulations</unmanaged>
        /// <unmanaged-short>GetSimulations</unmanaged-short>
        public SharpDX.DirectWrite.FontSimulations Simulations
        {
            get => GetSimulations();
        }

        /// <summary>
        /// <p> Determines whether the font is a symbol font. </p>
        /// </summary>
        /// <doc-id>dd371034</doc-id>
        /// <unmanaged>IsSymbolFont</unmanaged>
        /// <unmanaged-short>IsSymbolFont</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsSymbolFont
        {
            get => IsSymbolFont_();
        }

        /// <summary>
        /// <p> Obtains design units and common metrics for the font face. These metrics are applicable to all the glyphs within a font face and are used by applications for layout calculations. </p>
        /// </summary>
        /// <doc-id>dd371011</doc-id>
        /// <unmanaged>GetMetrics</unmanaged>
        /// <unmanaged-short>GetMetrics</unmanaged-short>
        public SharpDX.DirectWrite.FontMetrics Metrics
        {
            get
            {
                GetMetrics(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p> Obtains the number of glyphs in the font face. </p>
        /// </summary>
        /// <doc-id>dd370993</doc-id>
        /// <unmanaged>GetGlyphCount</unmanaged>
        /// <unmanaged-short>GetGlyphCount</unmanaged-short>
        public System.Int16 GlyphCount
        {
            get => GetGlyphCount();
        }

        /// <summary>
        /// <p> Obtains the file format type of a font face. </p>
        /// </summary>
        /// <returns><p>A value that indicates the type of format for the font face (such as Type 1, TrueType, vector, or bitmap).</p></returns>
        /// <doc-id>dd371031</doc-id>
        /// <unmanaged>DWRITE_FONT_FACE_TYPE IDWriteFontFace::GetType()</unmanaged>
        /// <unmanaged-short>IDWriteFontFace::GetType</unmanaged-short>
        internal unsafe SharpDX.DirectWrite.FontFaceType GetFaceType()
        {
            SharpDX.DirectWrite.FontFaceType __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirectWriteFontFaceType(this._nativePointer, (*(void ***)this._nativePointer)[3]);
            return __result__;
        }

        /// <summary>
        /// <p> Obtains the font files representing a font face. </p>
        /// </summary>
        /// <param name = "numberOfFiles"><dd>  <p>If <em>fontFiles</em> is <strong><c>null</c></strong>, receives the number of files representing the font face.  Otherwise, the number of font files being requested should be passed.  See the Remarks section below for more information.</p> </dd></param>
        /// <param name = "fontFiles"><dd>  <p>When this method returns, contains a reference to a user-provided array that stores references to font files representing the font face. This parameter can be <strong><c>null</c></strong> if the user wants only the number of files representing the font face. This API increments reference count of the font file references returned according to COM conventions, and the client should release them when finished.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The <strong>IDWriteFontFace::GetFiles</strong> method should be called twice.  The first time you call <strong>GetFiles</strong><em>fontFiles</em> should be <strong><c>null</c></strong>. When the method returns, <em>numberOfFiles</em> receives the number of font files that represent the font face.</p><p>Then, call the method a second time, passing the <em>numberOfFiles</em> value that was output the first call, and a non-null buffer of the correct size to store the <strong><see cref = "SharpDX.DirectWrite.FontFile"/></strong> references.</p>
        /// </remarks>
        /// <doc-id>dd370989</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFace::GetFiles([InOut] unsigned int* numberOfFiles,[Out, Buffer, Optional] IDWriteFontFile** fontFiles)</unmanaged>
        /// <unmanaged-short>IDWriteFontFace::GetFiles</unmanaged-short>
        internal unsafe void GetFiles(ref System.Int32 numberOfFiles, SharpDX.DirectWrite.FontFile[] fontFiles)
        {
            System.IntPtr*fontFiles_;
            fontFiles_ = (System.IntPtr*)0;
            if (fontFiles != null)
            {
                System.IntPtr*_fontFiles = stackalloc System.IntPtr[fontFiles.Length];
                fontFiles_ = _fontFiles;
            }

            SharpDX.Result __result__;
            fixed (void *numberOfFiles_ = &numberOfFiles)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, numberOfFiles_, (void *)fontFiles_, (*(void ***)this._nativePointer)[4]);
            if (fontFiles != null)
                for (int i = 0; i < fontFiles.Length; ++i)
                    if ((fontFiles_)[i] != System.IntPtr.Zero)
                        fontFiles[i] = new SharpDX.DirectWrite.FontFile((fontFiles_)[i]);
                    else
                        fontFiles[i] = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Obtains the index of a font face in the context of its font files. </p>
        /// </summary>
        /// <returns><p>The zero-based index of a font face in cases when the font files contain a collection of font faces. If the font files contain a single face, this value is zero.</p></returns>
        /// <doc-id>dd371007</doc-id>
        /// <unmanaged>unsigned int IDWriteFontFace::GetIndex()</unmanaged>
        /// <unmanaged-short>IDWriteFontFace::GetIndex</unmanaged-short>
        internal unsafe System.Int32 GetIndex()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[5]);
            return __result__;
        }

        /// <summary>
        /// <p> Obtains the algorithmic style simulation flags of a font face. </p>
        /// </summary>
        /// <returns><p>Font face simulation flags for algorithmic means of making text bold or italic.</p></returns>
        /// <doc-id>dd371018</doc-id>
        /// <unmanaged>DWRITE_FONT_SIMULATIONS IDWriteFontFace::GetSimulations()</unmanaged>
        /// <unmanaged-short>IDWriteFontFace::GetSimulations</unmanaged-short>
        internal unsafe SharpDX.DirectWrite.FontSimulations GetSimulations()
        {
            SharpDX.DirectWrite.FontSimulations __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirectWriteFontSimulations(this._nativePointer, (*(void ***)this._nativePointer)[6]);
            return __result__;
        }

        /// <summary>
        /// <p> Determines whether the font is a symbol font. </p>
        /// </summary>
        /// <returns><p>Returns <strong>TRUE</strong> if the font is a symbol font, otherwise <strong><see cref = "SharpDX.Result.False"/></strong>.</p></returns>
        /// <doc-id>dd371034</doc-id>
        /// <unmanaged>BOOL IDWriteFontFace::IsSymbolFont()</unmanaged>
        /// <unmanaged-short>IDWriteFontFace::IsSymbolFont</unmanaged-short>
        internal unsafe SharpDX.Mathematics.Interop.RawBool IsSymbolFont_()
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, (*(void ***)this._nativePointer)[7]);
            return __result__;
        }

        /// <summary>
        /// <p> Obtains design units and common metrics for the font face. These metrics are applicable to all the glyphs within a font face and are used by applications for layout calculations. </p>
        /// </summary>
        /// <param name = "fontFaceMetrics"><dd>  <p>When this method returns, a?<strong><see cref = "SharpDX.DirectWrite.FontMetrics"/></strong> structure that holds metrics (such as ascent, descent, or cap height) for the current font face element. The metrics returned by this function are in font design units.</p> </dd></param>
        /// <doc-id>dd371011</doc-id>
        /// <unmanaged>void IDWriteFontFace::GetMetrics([Out] DWRITE_FONT_METRICS* fontFaceMetrics)</unmanaged>
        /// <unmanaged-short>IDWriteFontFace::GetMetrics</unmanaged-short>
        internal unsafe void GetMetrics(out SharpDX.DirectWrite.FontMetrics fontFaceMetrics)
        {
            fontFaceMetrics = default (SharpDX.DirectWrite.FontMetrics);
            fixed (void *fontFaceMetrics_ = &fontFaceMetrics)
                SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, fontFaceMetrics_, (*(void ***)this._nativePointer)[8]);
        }

        /// <summary>
        /// <p> Obtains the number of glyphs in the font face. </p>
        /// </summary>
        /// <returns><p>The number of glyphs in the font face.</p></returns>
        /// <doc-id>dd370993</doc-id>
        /// <unmanaged>unsigned short IDWriteFontFace::GetGlyphCount()</unmanaged>
        /// <unmanaged-short>IDWriteFontFace::GetGlyphCount</unmanaged-short>
        internal unsafe System.Int16 GetGlyphCount()
        {
            System.Int16 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallshort(this._nativePointer, (*(void ***)this._nativePointer)[9]);
            return __result__;
        }

        /// <summary>
        /// <p> Obtains ideal (resolution-independent) glyph metrics in font design units.  </p>
        /// </summary>
        /// <param name = "glyphIndices"><dd>  <p> An array of glyph indices for which to compute  metrics. The array must contain at least as many elements as specified by <em>glyphCount</em>.</p> </dd></param>
        /// <param name = "glyphCount"><dd>  <p>The number of elements in the <em>glyphIndices</em> array.</p> </dd></param>
        /// <param name = "glyphMetrics"><dd>  <p>When this method returns, contains an array of <see cref = "SharpDX.DirectWrite.GlyphMetrics"/> structures.  <em>glyphMetrics</em> must be initialized with an empty buffer that contains at least as many elements as <em>glyphCount</em>. The metrics returned by this function are in font design units.</p> </dd></param>
        /// <param name = "isSideways"><dd>  <p>Indicates whether the font is being used in a sideways run. This can affect the glyph metrics if the font has oblique simulation because sideways oblique simulation differs from non-sideways oblique simulation</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Design glyph metrics are used for glyph positioning.</p>
        /// </remarks>
        /// <doc-id>dd370986</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFace::GetDesignGlyphMetrics([In, Buffer] const unsigned short* glyphIndices,[In] unsigned int glyphCount,[Out, Buffer] DWRITE_GLYPH_METRICS* glyphMetrics,[In] BOOL isSideways)</unmanaged>
        /// <unmanaged-short>IDWriteFontFace::GetDesignGlyphMetrics</unmanaged-short>
        internal unsafe void GetDesignGlyphMetrics(System.Int16[] glyphIndices, System.Int32 glyphCount, SharpDX.DirectWrite.GlyphMetrics[] glyphMetrics, SharpDX.Mathematics.Interop.RawBool isSideways)
        {
            SharpDX.Result __result__;
            fixed (void *glyphMetrics_ = glyphMetrics)
                fixed (void *glyphIndices_ = glyphIndices)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, glyphIndices_, glyphCount, glyphMetrics_, isSideways, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Returns the nominal mapping of UCS4 Unicode code points to glyph indices as defined by the font 'CMAP' table. </p>
        /// </summary>
        /// <param name = "codePoints"><dd>  <p>An array of USC4 code points from which to obtain nominal glyph indices. The array must be allocated and be able to contain the number of elements specified by <em>codePointCount</em>.</p> </dd></param>
        /// <param name = "codePointCount"><dd>  <p>The number of elements in the <em>codePoints</em> array.</p> </dd></param>
        /// <param name = "glyphIndices"><dd>  <p>When this method returns, contains a reference to an array of nominal glyph indices filled by this function.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Note that this mapping is primarily provided for line layout engines built on top of the physical font API. Because of OpenType glyph substitution and line layout character substitution, the nominal conversion does not always correspond to how a Unicode string will map to glyph indices when rendering using a particular font face. Also, note that Unicode variant selectors provide for alternate mappings for character to glyph. This call will always return the default variant.</p><p> When characters are not present in the font this method returns the index 0, which is the undefined glyph or ".notdef" glyph.  If a character isn't in a font, IDWriteFont::HasCharacter returns false and GetUnicodeRanges doesn't return it in the range.</p>
        /// </remarks>
        /// <doc-id>dd370998</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFace::GetGlyphIndicesW([In, Buffer] const unsigned int* codePoints,[In] unsigned int codePointCount,[Out, Buffer] unsigned short* glyphIndices)</unmanaged>
        /// <unmanaged-short>IDWriteFontFace::GetGlyphIndicesW</unmanaged-short>
        internal unsafe void GetGlyphIndices(System.Int32[] codePoints, System.Int32 codePointCount, System.Int16[] glyphIndices)
        {
            SharpDX.Result __result__;
            fixed (void *glyphIndices_ = glyphIndices)
                fixed (void *codePoints_ = codePoints)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, codePoints_, codePointCount, glyphIndices_, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Finds the specified OpenType font table if it exists and returns a reference to it. The function accesses the underlying font data through the <strong><see cref = "SharpDX.DirectWrite.FontFileStream"/></strong> interface implemented by the font file loader. </p>
        /// </summary>
        /// <param name = "openTypeTableTag">No documentation.</param>
        /// <param name = "tableData">No documentation.</param>
        /// <param name = "tableSize">No documentation.</param>
        /// <param name = "tableContext">No documentation.</param>
        /// <param name = "exists">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p> The context for the same tag may be different for each call, so each one must be held and released separately. </p>
        /// </remarks>
        /// <doc-id>dd371039</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFace::TryGetFontTable([In] unsigned int openTypeTableTag,[Out, Buffer] const void** tableData,[Out] unsigned int* tableSize,[Out] void** tableContext,[Out] BOOL* exists)</unmanaged>
        /// <unmanaged-short>IDWriteFontFace::TryGetFontTable</unmanaged-short>
        internal unsafe void TryGetFontTable(System.Int32 openTypeTableTag, System.IntPtr tableData, out System.Int32 tableSize, out System.IntPtr tableContext, out SharpDX.Mathematics.Interop.RawBool exists)
        {
            exists = default (SharpDX.Mathematics.Interop.RawBool);
            SharpDX.Result __result__;
            fixed (void *exists_ = &exists)
                fixed (void *tableContext_ = &tableContext)
                    fixed (void *tableSize_ = &tableSize)
                        __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, openTypeTableTag, (void *)tableData, tableSize_, tableContext_, exists_, (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Releases the table obtained earlier from <strong>TryGetFontTable</strong>. </p>
        /// </summary>
        /// <param name = "tableContext">No documentation.</param>
        /// <doc-id>dd371036</doc-id>
        /// <unmanaged>void IDWriteFontFace::ReleaseFontTable([In] void* tableContext)</unmanaged>
        /// <unmanaged-short>IDWriteFontFace::ReleaseFontTable</unmanaged-short>
        public unsafe void ReleaseFontTable(System.IntPtr tableContext)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)tableContext, (*(void ***)this._nativePointer)[13]);
        }

        /// <summary>
        /// <p> Computes the outline of a run of glyphs by calling back to the outline sink interface. </p>
        /// </summary>
        /// <param name = "emSize"><dd>  <p>The logical size of the font in DIP units. A DIP ("device-independent pixel") equals 1/96 inch.</p> </dd></param>
        /// <param name = "glyphIndices"><dd>  <p>An array of glyph indices. The glyphs are in logical order and the advance direction depends on the <em>isRightToLeft</em> parameter. The array must be allocated and be able to contain the number of elements specified by <em>glyphCount</em>.</p> </dd></param>
        /// <param name = "glyphAdvances"><dd>  <p>An optional array of glyph advances in DIPs. The advance of a glyph is the amount to advance the position (in the direction of the baseline) after drawing the glyph. <em>glyphAdvances</em> contains the number of elements specified by <em>glyphCount</em>.</p> </dd></param>
        /// <param name = "glyphOffsets"><dd>  <p>An optional array of glyph offsets, each of which specifies the offset along the baseline and offset perpendicular to the baseline of a glyph relative to the current pen position.   <em>glyphOffsets</em> contains the number of elements specified by <em>glyphCount</em>.</p> </dd></param>
        /// <param name = "glyphCount"><dd>  <p>The number of glyphs in the run.</p> </dd></param>
        /// <param name = "isSideways"><dd>  <p>If <strong>TRUE</strong>, the ascender of the glyph runs alongside the baseline. If <strong><see cref = "SharpDX.Result.False"/></strong>, the glyph ascender runs perpendicular to the baseline. For example, an English alphabet on a vertical baseline would have <em>isSideways</em> set to <strong><see cref = "SharpDX.Result.False"/></strong>.</p> <p>A client can render a vertical run by setting <em>isSideways</em> to <strong>TRUE</strong> and rotating the resulting geometry 90 degrees to the right using a transform. The <em>isSideways</em> and <em>isRightToLeft</em> parameters cannot both be true.</p> </dd></param>
        /// <param name = "isRightToLeft"><dd>  <p>The visual order of the glyphs. If this parameter is <strong><see cref = "SharpDX.Result.False"/></strong>, then glyph advances are from left to right. If <strong>TRUE</strong>, the advance direction is right to left. By default, the advance direction is left to right.</p> </dd></param>
        /// <param name = "geometrySink"><dd>  <p>A reference to the interface that is called back to perform outline drawing operations.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371003</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFace::GetGlyphRunOutline([In] float emSize,[In, Buffer] const unsigned short* glyphIndices,[In, Buffer, Optional] const float* glyphAdvances,[In, Buffer, Optional] const DWRITE_GLYPH_OFFSET* glyphOffsets,[In] unsigned int glyphCount,[In] BOOL isSideways,[In] BOOL isRightToLeft,[In] ID2D1SimplifiedGeometrySink* geometrySink)</unmanaged>
        /// <unmanaged-short>IDWriteFontFace::GetGlyphRunOutline</unmanaged-short>
        public unsafe void GetGlyphRunOutline(System.Single emSize, System.Int16[] glyphIndices, System.Single[] glyphAdvances, SharpDX.DirectWrite.GlyphOffset[] glyphOffsets, System.Int32 glyphCount, SharpDX.Mathematics.Interop.RawBool isSideways, SharpDX.Mathematics.Interop.RawBool isRightToLeft, SharpDX.Direct2D1.SimplifiedGeometrySink geometrySink)
        {
            System.IntPtr geometrySink_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            geometrySink_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.SimplifiedGeometrySink>(geometrySink);
            fixed (void *glyphOffsets_ = glyphOffsets)
                fixed (void *glyphAdvances_ = glyphAdvances)
                    fixed (void *glyphIndices_ = glyphIndices)
                        __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, emSize, glyphIndices_, glyphAdvances_, glyphOffsets_, glyphCount, isSideways, isRightToLeft, (void *)geometrySink_, (*(void ***)this._nativePointer)[14]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Determines the recommended rendering mode for the font, using the specified size and rendering parameters. </p>
        /// </summary>
        /// <param name = "emSize"><dd>  <p>The logical size of the font in DIP units. A DIP ("device-independent pixel") equals 1/96 inch.</p> </dd></param>
        /// <param name = "pixelsPerDip"><dd>  <p>The number of physical pixels per DIP. For example, if the DPI of the rendering surface is 96, this  value is 1.0f. If the DPI is 120, this value is 120.0f/96.</p> </dd></param>
        /// <param name = "measuringMode"><dd>  <p>The measuring method that will be used for glyphs in the font. Renderer implementations may choose different rendering modes for different measuring methods, for example: </p> <ul> <li>DWRITE_RENDERING_MODE_CLEARTYPE_NATURAL for <strong>DWRITE_MEASURING_MODE_NATURAL</strong> </li> <li> DWRITE_RENDERING_MODE_CLEARTYPE_GDI_CLASSIC for <strong>DWRITE_MEASURING_MODE_GDI_CLASSIC</strong> </li> <li> DWRITE_RENDERING_MODE_CLEARTYPE_GDI_NATURAL for <strong>DWRITE_MEASURING_MODE_GDI_NATURAL</strong> </li> </ul> </dd></param>
        /// <param name = "renderingParams"><dd>  <p>A reference to an object that contains rendering settings such as gamma level, enhanced contrast, and ClearType level. This parameter is necessary in case the rendering parameters  object overrides the rendering mode.</p> </dd></param>
        /// <returns><dd>  <p>When this method returns, contains a value that indicates the recommended rendering mode to use.</p> </dd></returns>
        /// <doc-id>dd371015</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFace::GetRecommendedRenderingMode([In] float emSize,[In] float pixelsPerDip,[In] DWRITE_MEASURING_MODE measuringMode,[In] IDWriteRenderingParams* renderingParams,[Out] DWRITE_RENDERING_MODE* renderingMode)</unmanaged>
        /// <unmanaged-short>IDWriteFontFace::GetRecommendedRenderingMode</unmanaged-short>
        public unsafe SharpDX.DirectWrite.RenderingMode GetRecommendedRenderingMode(System.Single emSize, System.Single pixelsPerDip, SharpDX.Direct2D1.MeasuringMode measuringMode, SharpDX.DirectWrite.RenderingParams renderingParams)
        {
            System.IntPtr renderingParams_ = System.IntPtr.Zero;
            SharpDX.DirectWrite.RenderingMode renderingMode;
            SharpDX.Result __result__;
            renderingParams_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.RenderingParams>(renderingParams);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, emSize, pixelsPerDip, unchecked ((System.Int32)measuringMode), (void *)renderingParams_, &renderingMode, (*(void ***)this._nativePointer)[15]);
            __result__.CheckError();
            return renderingMode;
        }

        /// <summary>
        /// <p>Obtains design units and common metrics for the font face. These metrics are applicable to all the glyphs within a fontface and are used by applications for layout calculations.</p>
        /// </summary>
        /// <param name = "emSize"><dd>  <p>The logical size of the font in DIP units.</p> </dd></param>
        /// <param name = "pixelsPerDip"><dd>  <p>The number of physical pixels per DIP.</p> </dd></param>
        /// <param name = "transform"><dd>  <p>An optional transform applied to the glyphs and their positions. This transform is applied after the scaling specified by the font size and <em>pixelsPerDip</em>.</p> </dd></param>
        /// <returns><dd>  <p>A reference to a <strong>DWRITE_FONT_METRIC</strong>S structure to fill in. The metrics returned by this function are in font design units.</p> </dd></returns>
        /// <doc-id>dd941789</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFace::GetGdiCompatibleMetrics([In] float emSize,[In] float pixelsPerDip,[In, Optional] const DWRITE_MATRIX* transform,[Out] DWRITE_FONT_METRICS* fontFaceMetrics)</unmanaged>
        /// <unmanaged-short>IDWriteFontFace::GetGdiCompatibleMetrics</unmanaged-short>
        public unsafe SharpDX.DirectWrite.FontMetrics GetGdiCompatibleMetrics(System.Single emSize, System.Single pixelsPerDip, SharpDX.Mathematics.Interop.RawMatrix3x2? transform)
        {
            SharpDX.Mathematics.Interop.RawMatrix3x2 transform_;
            SharpDX.DirectWrite.FontMetrics fontFaceMetrics;
            SharpDX.Result __result__;
            if (transform != null)
                transform_ = transform.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, emSize, pixelsPerDip, transform == null ? (void *)0 : &transform_, &fontFaceMetrics, (*(void ***)this._nativePointer)[16]);
            __result__.CheckError();
            return fontFaceMetrics;
        }

        /// <summary>
        /// <p>Obtains glyph metrics in font design units with the return values compatible with what GDI would produce.</p>
        /// </summary>
        /// <param name = "emSize"><dd>  <p>The ogical size of the font in DIP units.</p> </dd></param>
        /// <param name = "pixelsPerDip"><dd>  <p>The number of physical pixels per DIP.</p> </dd></param>
        /// <param name = "transform"><dd>  <p>An optional transform applied to the glyphs and their positions. This transform is applied after the scaling specified by the font size and <em>pixelsPerDip</em>.</p> </dd></param>
        /// <param name = "useGdiNatural"><dd>  <p>When set to <strong><see cref = "SharpDX.Result.False"/></strong>, the metrics are the same as the metrics of GDI aliased text.  When set to <strong>TRUE</strong>, the metrics are the same as the metrics of text measured by GDI using a font created with <strong>CLEARTYPE_NATURAL_QUALITY</strong>.</p> </dd></param>
        /// <param name = "glyphIndices"><dd>  <p>An array of glyph indices for which to compute the metrics.</p> </dd></param>
        /// <param name = "glyphCount"><dd>  <p>The number of elements in the <em>glyphIndices</em> array.</p> </dd></param>
        /// <param name = "glyphMetrics"><dd>  <p>An array of <strong><see cref = "SharpDX.DirectWrite.GlyphMetrics"/></strong> structures filled by this function. The metrics are in font design units.</p> </dd></param>
        /// <param name = "isSideways"><dd>  <p>A <see cref = "SharpDX.Mathematics.Interop.RawBool"/> value that indicates whether the font is being used in a sideways run.  This can affect the glyph metrics if the font has oblique simulation because sideways oblique simulation differs from non-sideways oblique simulation.</p> </dd></param>
        /// <returns><p>Standard <strong><see cref = "SharpDX.Result"/></strong> error code. If any of the input glyph indices are outside of the valid glyph index range for the current font face, <strong>E_INVALIDARG</strong> will be returned.</p></returns>
        /// <doc-id>dd941788</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFace::GetGdiCompatibleGlyphMetrics([In] float emSize,[In] float pixelsPerDip,[In, Optional] const DWRITE_MATRIX* transform,[In] BOOL useGdiNatural,[In, Buffer] const unsigned short* glyphIndices,[In] unsigned int glyphCount,[Out, Buffer] DWRITE_GLYPH_METRICS* glyphMetrics,[In] BOOL isSideways)</unmanaged>
        /// <unmanaged-short>IDWriteFontFace::GetGdiCompatibleGlyphMetrics</unmanaged-short>
        internal unsafe void GetGdiCompatibleGlyphMetrics(System.Single emSize, System.Single pixelsPerDip, SharpDX.Mathematics.Interop.RawMatrix3x2? transform, SharpDX.Mathematics.Interop.RawBool useGdiNatural, System.Int16[] glyphIndices, System.Int32 glyphCount, SharpDX.DirectWrite.GlyphMetrics[] glyphMetrics, SharpDX.Mathematics.Interop.RawBool isSideways)
        {
            SharpDX.Mathematics.Interop.RawMatrix3x2 transform_;
            SharpDX.Result __result__;
            if (transform != null)
                transform_ = transform.Value;
            fixed (void *glyphMetrics_ = glyphMetrics)
                fixed (void *glyphIndices_ = glyphIndices)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, emSize, pixelsPerDip, transform == null ? (void *)0 : &transform_, useGdiNatural, glyphIndices_, glyphCount, glyphMetrics_, isSideways, (*(void ***)this._nativePointer)[17]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("a71efdb4-9fdb-4838-ad90-cfc3be8c3daf")]
    public partial class FontFace1 : SharpDX.DirectWrite.FontFace
    {
        public FontFace1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator FontFace1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new FontFace1(nativePtr);
        /// <summary>
        /// <p> Obtains design units and common metrics for the font face. These metrics are applicable to all the glyphs within a font face and are used by applications for layout calculations. </p>
        /// </summary>
        /// <doc-id>hh780415</doc-id>
        /// <unmanaged>GetMetrics</unmanaged>
        /// <unmanaged-short>GetMetrics</unmanaged-short>
        public SharpDX.DirectWrite.FontMetrics1 Metrics
        {
            get
            {
                GetMetrics(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets caret metrics for the font in design units.</p>
        /// </summary>
        /// <remarks>
        /// <p>Caret metrics are used by text editors for drawing the correct caret placement and slant.</p>
        /// </remarks>
        /// <doc-id>hh780410</doc-id>
        /// <unmanaged>GetCaretMetrics</unmanaged>
        /// <unmanaged-short>GetCaretMetrics</unmanaged-short>
        public SharpDX.DirectWrite.CaretMetrics CaretMetrics
        {
            get
            {
                GetCaretMetrics(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Determines whether the font of a text range is monospaced, that is, the font characters are the same fixed-pitch width.</p>
        /// </summary>
        /// <doc-id>hh780421</doc-id>
        /// <unmanaged>IsMonospacedFont</unmanaged>
        /// <unmanaged-short>IsMonospacedFont</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsMonospacedFont
        {
            get => IsMonospacedFont_();
        }

        /// <summary>
        /// <p> Obtains design units and common metrics for the font face. These metrics are applicable to all the glyphs within a font face and are used by applications for layout calculations. </p>
        /// </summary>
        /// <param name = "fontMetrics"><dd>  <p>A filled <strong><see cref = "SharpDX.DirectWrite.FontMetrics1"/></strong> structure that holds metrics for the current font face element. The metrics returned by this method are in font design units.</p> </dd></param>
        /// <doc-id>hh780415</doc-id>
        /// <unmanaged>void IDWriteFontFace1::GetMetrics([Out] DWRITE_FONT_METRICS1* fontMetrics)</unmanaged>
        /// <unmanaged-short>IDWriteFontFace1::GetMetrics</unmanaged-short>
        internal unsafe void GetMetrics(out SharpDX.DirectWrite.FontMetrics1 fontMetrics)
        {
            fontMetrics = default (SharpDX.DirectWrite.FontMetrics1);
            fixed (void *fontMetrics_ = &fontMetrics)
                SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, fontMetrics_, (*(void ***)this._nativePointer)[18]);
        }

        /// <summary>
        /// <p>Obtains design units and common metrics for the font face. These metrics are applicable to all the glyphs within a fontface and are used by applications for layout calculations.</p>
        /// </summary>
        /// <param name = "emSize"><dd>  <p>The logical size of the font in DIP units.</p> </dd></param>
        /// <param name = "pixelsPerDip"><dd>  <p>The number of physical pixels per DIP.</p> </dd></param>
        /// <param name = "transform"><dd>  <p>An optional transform applied to the glyphs and their positions. This transform is applied after the scaling specified by the font size and <em>pixelsPerDip</em>.</p> </dd></param>
        /// <param name = "fontMetrics"><dd>  <p>A reference to a <strong><see cref = "SharpDX.DirectWrite.FontMetrics1"/></strong> structure to fill in. The metrics returned by this function are in font design units.</p> </dd></param>
        /// <returns><p>Standard <see cref = "SharpDX.Result"/> error code.</p></returns>
        /// <doc-id>hh780413</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFace1::GetGdiCompatibleMetrics([In] float emSize,[In] float pixelsPerDip,[In, Optional] const DWRITE_MATRIX* transform,[Out] DWRITE_FONT_METRICS1* fontMetrics)</unmanaged>
        /// <unmanaged-short>IDWriteFontFace1::GetGdiCompatibleMetrics</unmanaged-short>
        public unsafe void GetGdiCompatibleMetrics(System.Single emSize, System.Single pixelsPerDip, SharpDX.Mathematics.Interop.RawMatrix3x2? transform, out SharpDX.DirectWrite.FontMetrics1 fontMetrics)
        {
            SharpDX.Mathematics.Interop.RawMatrix3x2 transform_;
            fontMetrics = default (SharpDX.DirectWrite.FontMetrics1);
            SharpDX.Result __result__;
            if (transform != null)
                transform_ = transform.Value;
            fixed (void *fontMetrics_ = &fontMetrics)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, emSize, pixelsPerDip, transform == null ? (void *)0 : &transform_, fontMetrics_, (*(void ***)this._nativePointer)[19]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets caret metrics for the font in design units.</p>
        /// </summary>
        /// <param name = "caretMetrics"><dd>  <p>A reference to the <strong><see cref = "SharpDX.DirectWrite.CaretMetrics"/></strong> structure that is filled.</p> </dd></param>
        /// <remarks>
        /// <p>Caret metrics are used by text editors for drawing the correct caret placement and slant.</p>
        /// </remarks>
        /// <doc-id>hh780410</doc-id>
        /// <unmanaged>void IDWriteFontFace1::GetCaretMetrics([Out] DWRITE_CARET_METRICS* caretMetrics)</unmanaged>
        /// <unmanaged-short>IDWriteFontFace1::GetCaretMetrics</unmanaged-short>
        internal unsafe void GetCaretMetrics(out SharpDX.DirectWrite.CaretMetrics caretMetrics)
        {
            caretMetrics = default (SharpDX.DirectWrite.CaretMetrics);
            fixed (void *caretMetrics_ = &caretMetrics)
                SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, caretMetrics_, (*(void ***)this._nativePointer)[20]);
        }

        /// <summary>
        /// <p>Retrieves a list of character ranges supported by a font.</p>
        /// </summary>
        /// <param name = "maxRangeCount"><dd>  <p>Maximum number of character ranges passed in from the client.</p> </dd></param>
        /// <param name = "unicodeRanges"><dd>  <p>An array of <strong><see cref = "SharpDX.DirectWrite.UnicodeRange"/></strong> structures that are filled with the character ranges.</p> </dd></param>
        /// <param name = "actualRangeCount"><dd>  <p>A reference to the actual number of character ranges, regardless of the maximum count.</p> </dd></param>
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return value</th><th>Description</th></tr> <tr><td> <dl> <dt><see cref = "SharpDX.Result.Ok"/></dt> </dl> </td><td> <p>The method executed successfully.</p> </td></tr> <tr><td> <dl> <dt>E_NOT_SUFFICIENT_BUFFER</dt> </dl> </td><td> <p>The buffer is too small.  The <em>actualRangeCount</em> was more than the <em>maxRangeCount</em>.</p> </td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>A  list of character ranges supported by the font is useful for scenarios like character picking, glyph display, and efficient font selection lookup. This is similar to GDI's <strong>GetFontUnicodeRanges</strong>, except that it returns the full Unicode range, not just 16-bit UCS-2.</p><p>These ranges are from the cmap, not the OS/2::ulCodePageRange1.</p><p>If this method is unavailable, you can use the <strong>IDWriteFontFace::GetGlyphIndices</strong> method to check for missing glyphs.  The method returns the 0 index for glyphs that aren't present in the font.</p><p> The <strong>IDWriteFont::HasCharacter</strong> method is often simpler in cases where you need to check a single character or a series of single characters in succession, such as in font fallback.</p>
        /// </remarks>
        /// <doc-id>hh780417</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFace1::GetUnicodeRanges([In] unsigned int maxRangeCount,[Out, Buffer, Optional] DWRITE_UNICODE_RANGE* unicodeRanges,[Out] unsigned int* actualRangeCount)</unmanaged>
        /// <unmanaged-short>IDWriteFontFace1::GetUnicodeRanges</unmanaged-short>
        public unsafe void GetUnicodeRanges(System.Int32 maxRangeCount, SharpDX.DirectWrite.UnicodeRange[] unicodeRanges, out System.Int32 actualRangeCount)
        {
            SharpDX.Result __result__;
            fixed (void *actualRangeCount_ = &actualRangeCount)
                fixed (void *unicodeRanges_ = unicodeRanges)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, maxRangeCount, unicodeRanges_, actualRangeCount_, (*(void ***)this._nativePointer)[21]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Determines whether the font of a text range is monospaced, that is, the font characters are the same fixed-pitch width.</p>
        /// </summary>
        /// <returns><p>Returns TRUE if the font is monospaced, otherwise it returns <see cref = "SharpDX.Result.False"/>.</p></returns>
        /// <doc-id>hh780421</doc-id>
        /// <unmanaged>BOOL IDWriteFontFace1::IsMonospacedFont()</unmanaged>
        /// <unmanaged-short>IDWriteFontFace1::IsMonospacedFont</unmanaged-short>
        internal unsafe SharpDX.Mathematics.Interop.RawBool IsMonospacedFont_()
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, (*(void ***)this._nativePointer)[22]);
            return __result__;
        }

        /// <summary>
        /// <p>Retrieves the advances in design units for a sequences of glyphs.</p>
        /// </summary>
        /// <param name = "glyphCount"><dd>  <p>The number of glyphs to retrieve advances for.</p> </dd></param>
        /// <param name = "glyphIndices"><dd>  <p>An array of glyph id's to retrieve advances for.</p> </dd></param>
        /// <param name = "glyphAdvances"><dd>  <p>The returned advances in font design units for each glyph.</p> </dd></param>
        /// <param name = "isSideways"><dd>  <p>Retrieve the glyph's vertical advance height rather than horizontal advance widths.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p> This is equivalent to calling GetGlyphMetrics and using only the advance width and height.</p>
        /// </remarks>
        /// <doc-id>hh780411</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFace1::GetDesignGlyphAdvances([In] unsigned int glyphCount,[In, Buffer] const unsigned short* glyphIndices,[Out, Buffer] int* glyphAdvances,[In] BOOL isSideways)</unmanaged>
        /// <unmanaged-short>IDWriteFontFace1::GetDesignGlyphAdvances</unmanaged-short>
        public unsafe void GetDesignGlyphAdvances(System.Int32 glyphCount, System.Int16[] glyphIndices, System.Int32[] glyphAdvances, SharpDX.Mathematics.Interop.RawBool isSideways)
        {
            SharpDX.Result __result__;
            fixed (void *glyphAdvances_ = glyphAdvances)
                fixed (void *glyphIndices_ = glyphIndices)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, glyphCount, glyphIndices_, glyphAdvances_, isSideways, (*(void ***)this._nativePointer)[23]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Returns the pixel-aligned advances for a sequences of glyphs.</p>
        /// </summary>
        /// <param name = "emSize"><dd>  <p>Logical size of the font in DIP units. A DIP ("device-independent pixel") equals 1/96 inch.</p> </dd></param>
        /// <param name = "pixelsPerDip"><dd>  <p>Number of physical pixels per DIP. For example, if the DPI of the rendering surface is 96 this value is 1.0f. If the DPI is 120, this value is 120.0f/96.</p> </dd></param>
        /// <param name = "transform"><dd>  <p>Optional transform applied to the glyphs and their positions. This transform is applied after the scaling specified by the font size and pixelsPerDip.</p> </dd></param>
        /// <param name = "useGdiNatural"><dd>  <p>When <see cref = "SharpDX.Result.False"/>, the metrics are the same as GDI aliased text (DWRITE_MEASURING_MODE_GDI_CLASSIC). When TRUE, the metrics are the same as those measured by GDI using a font using CLEARTYPE_NATURAL_QUALITY (DWRITE_MEASURING_MODE_GDI_NATURAL).</p> </dd></param>
        /// <param name = "isSideways"><dd>  <p>Retrieve the glyph's vertical advances rather than horizontal advances.</p> </dd></param>
        /// <param name = "glyphCount"><dd>  <p>Total glyphs to retrieve adjustments for.</p> </dd></param>
        /// <param name = "glyphIndices"><dd>  <p>An array of glyph id's to retrieve advances.</p> </dd></param>
        /// <param name = "glyphAdvances"><dd>  <p>The returned advances in font design units for each glyph.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>This is equivalent to calling <strong>GetGdiCompatibleGlyphMetrics</strong> and using only the advance width and height. </p><p>Like <strong>GetGdiCompatibleGlyphMetrics</strong>, these are in design units, meaning they must be scaled down by DWRITE_FONT_METRICS::designUnitsPerEm.</p>
        /// </remarks>
        /// <doc-id>hh780412</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFace1::GetGdiCompatibleGlyphAdvances([In] float emSize,[In] float pixelsPerDip,[In, Optional] const DWRITE_MATRIX* transform,[In] BOOL useGdiNatural,[In] BOOL isSideways,[In] unsigned int glyphCount,[In, Buffer] const unsigned short* glyphIndices,[Out, Buffer] int* glyphAdvances)</unmanaged>
        /// <unmanaged-short>IDWriteFontFace1::GetGdiCompatibleGlyphAdvances</unmanaged-short>
        public unsafe void GetGdiCompatibleGlyphAdvances(System.Single emSize, System.Single pixelsPerDip, SharpDX.Mathematics.Interop.RawMatrix3x2? transform, SharpDX.Mathematics.Interop.RawBool useGdiNatural, SharpDX.Mathematics.Interop.RawBool isSideways, System.Int32 glyphCount, System.Int16[] glyphIndices, System.Int32[] glyphAdvances)
        {
            SharpDX.Mathematics.Interop.RawMatrix3x2 transform_;
            SharpDX.Result __result__;
            if (transform != null)
                transform_ = transform.Value;
            fixed (void *glyphAdvances_ = glyphAdvances)
                fixed (void *glyphIndices_ = glyphIndices)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, emSize, pixelsPerDip, transform == null ? (void *)0 : &transform_, useGdiNatural, isSideways, glyphCount, glyphIndices_, glyphAdvances_, (*(void ***)this._nativePointer)[24]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the kerning pair adjustments from the font's kern table.</p>
        /// </summary>
        /// <param name = "glyphCount"><dd>  <p>Number of glyphs to retrieve adjustments for.</p> </dd></param>
        /// <param name = "glyphIndices"><dd>  <p>An array of glyph id's to retrieve adjustments for.</p> </dd></param>
        /// <param name = "glyphAdvanceAdjustments"><dd>  <p>The advances, returned in font design units, for each glyph. The last glyph adjustment is zero.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p><strong>GetKerningPairAdjustments</strong> isn't a direct replacement for GDI's character based <strong>GetKerningPairs</strong>, but it serves the same role, without the client needing to cache them locally. <strong>GetKerningPairAdjustments</strong> also uses glyph id's directly rather than UCS-2 characters (how the kern table actually stores them), which avoids glyph collapse and ambiguity, such as the dash and hyphen, or space and non-breaking space. </p><p>Newer fonts may have only GPOS kerning instead of the legacy pair-table kerning. Such fonts, like Gabriola, will only return 0's for adjustments. <strong>GetKerningPairAdjustments</strong> doesn't virtualize and flatten these GPOS entries into kerning pairs.</p><p>You can realize a performance benefit by calling <strong>IDWriteFontFace1::HasKerningPairs</strong> to determine whether you need to call  <strong>GetKerningPairAdjustments</strong>. If you previously called <strong>IDWriteFontFace1::HasKerningPairs</strong> and it returned <see cref = "SharpDX.Result.False"/>, you can avoid calling <strong>GetKerningPairAdjustments</strong> because the font has no kerning pair-table entries. That is, in this situation, a call to <strong>GetKerningPairAdjustments</strong> would be a no-op.</p>
        /// </remarks>
        /// <doc-id>hh780414</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFace1::GetKerningPairAdjustments([In] unsigned int glyphCount,[In, Buffer] const unsigned short* glyphIndices,[Out, Buffer] int* glyphAdvanceAdjustments)</unmanaged>
        /// <unmanaged-short>IDWriteFontFace1::GetKerningPairAdjustments</unmanaged-short>
        public unsafe void GetKerningPairAdjustments(System.Int32 glyphCount, System.Int16[] glyphIndices, System.Int32[] glyphAdvanceAdjustments)
        {
            SharpDX.Result __result__;
            fixed (void *glyphAdvanceAdjustments_ = glyphAdvanceAdjustments)
                fixed (void *glyphIndices_ = glyphIndices)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, glyphCount, glyphIndices_, glyphAdvanceAdjustments_, (*(void ***)this._nativePointer)[25]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Determines whether the font supports pair-kerning.</p>
        /// </summary>
        /// <returns><p>Returns TRUE if the font supports kerning pairs, otherwise <see cref = "SharpDX.Result.False"/>.</p></returns>
        /// <remarks>
        /// <p>If the font doesn't support pair table kerning, you don't need to call <strong>IDWriteFontFace1::GetKerningPairAdjustments</strong> because it would retrieve all zeroes.</p>
        /// </remarks>
        /// <doc-id>hh780419</doc-id>
        /// <unmanaged>BOOL IDWriteFontFace1::HasKerningPairs()</unmanaged>
        /// <unmanaged-short>IDWriteFontFace1::HasKerningPairs</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool HasKerningPairs()
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, (*(void ***)this._nativePointer)[26]);
            return __result__;
        }

        /// <summary>
        /// <p> Determines the recommended rendering mode for the font, using the specified size and rendering parameters. </p>
        /// </summary>
        /// <param name = "fontEmSize"><dd>  <p>The logical size of the font in DIP units. A DIP ("device-independent pixel") equals 1/96 inch.</p> </dd></param>
        /// <param name = "dpiX"><dd>  <p>The number of physical pixels per DIP in a horizontal position. For example, if the DPI of the rendering surface is 96, this  value is 1.0f. If the DPI is 120, this value is 120.0f/96.</p> </dd></param>
        /// <param name = "dpiY"><dd>  <p>The number of physical pixels per DIP in a vertical position. For example, if the DPI of the rendering surface is 96, this  value is 1.0f. If the DPI is 120, this value is 120.0f/96.</p> </dd></param>
        /// <param name = "transform"><dd>  <p>Specifies the world transform.</p> </dd></param>
        /// <param name = "isSideways"><dd>  <p>Whether the glyphs in the run are sideways or not.</p> </dd></param>
        /// <param name = "outlineThreshold"><dd>  <p>A <strong><see cref = "SharpDX.DirectWrite.OutlineThreshold"/></strong>-typed value that specifies the quality of the graphics system's outline rendering, affects the size threshold above which outline rendering is used.</p> </dd></param>
        /// <param name = "measuringMode"><dd>  <p>The measuring method that will be used for glyphs in the font. Renderer implementations may choose different rendering modes for different measuring methods, for example: </p> <ul> <li>DWRITE_RENDERING_MODE_CLEARTYPE_NATURAL for <strong>DWRITE_MEASURING_MODE_NATURAL</strong> </li> <li> DWRITE_RENDERING_MODE_CLEARTYPE_GDI_CLASSIC for <strong>DWRITE_MEASURING_MODE_GDI_CLASSIC</strong> </li> <li> DWRITE_RENDERING_MODE_CLEARTYPE_GDI_NATURAL for <strong>DWRITE_MEASURING_MODE_GDI_NATURAL</strong> </li> </ul> </dd></param>
        /// <param name = "renderingMode"><dd>  <p>When this method returns, contains a value that indicates the recommended rendering mode to use.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>This method should be used to determine the actual rendering mode in cases where the rendering  mode of the rendering params object is DWRITE_RENDERING_MODE_DEFAULT.</p>
        /// </remarks>
        /// <doc-id>hh780416</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFace1::GetRecommendedRenderingMode([In] float fontEmSize,[In] float dpiX,[In] float dpiY,[In, Optional] const DWRITE_MATRIX* transform,[In] BOOL isSideways,[In] DWRITE_OUTLINE_THRESHOLD outlineThreshold,[In] DWRITE_MEASURING_MODE measuringMode,[Out] DWRITE_RENDERING_MODE* renderingMode)</unmanaged>
        /// <unmanaged-short>IDWriteFontFace1::GetRecommendedRenderingMode</unmanaged-short>
        public unsafe void GetRecommendedRenderingMode(System.Single fontEmSize, System.Single dpiX, System.Single dpiY, SharpDX.Mathematics.Interop.RawMatrix3x2? transform, SharpDX.Mathematics.Interop.RawBool isSideways, SharpDX.DirectWrite.OutlineThreshold outlineThreshold, SharpDX.Direct2D1.MeasuringMode measuringMode, out SharpDX.DirectWrite.RenderingMode renderingMode)
        {
            SharpDX.Mathematics.Interop.RawMatrix3x2 transform_;
            SharpDX.Result __result__;
            if (transform != null)
                transform_ = transform.Value;
            fixed (void *renderingMode_ = &renderingMode)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, fontEmSize, dpiX, dpiY, transform == null ? (void *)0 : &transform_, isSideways, unchecked ((System.Int32)outlineThreshold), unchecked ((System.Int32)measuringMode), renderingMode_, (*(void ***)this._nativePointer)[27]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the vertical forms of the nominal glyphs retrieved from GetGlyphIndices.</p>
        /// </summary>
        /// <param name = "glyphCount"><dd>  <p>The number of glyphs to retrieve.</p> </dd></param>
        /// <param name = "nominalGlyphIndices"><dd>  <p>Original glyph indices from cmap.</p> </dd></param>
        /// <param name = "verticalGlyphIndices"><dd>  <p>The vertical form of glyph indices.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p> The retrieval uses the font's 'vert' table. This is used in CJK vertical layout so the correct characters are shown.</p><p>Call <strong>GetGlyphIndices</strong> to get the nominal glyph indices, followed by calling this to remap the to the substituted forms, when the run is sideways, and the font has vertical glyph variants. See <strong>HasVerticalGlyphVariants</strong> for more info.
        /// </p>
        /// </remarks>
        /// <doc-id>hh780418</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFace1::GetVerticalGlyphVariants([In] unsigned int glyphCount,[In, Buffer] const unsigned short* nominalGlyphIndices,[Out, Buffer] unsigned short* verticalGlyphIndices)</unmanaged>
        /// <unmanaged-short>IDWriteFontFace1::GetVerticalGlyphVariants</unmanaged-short>
        public unsafe void GetVerticalGlyphVariants(System.Int32 glyphCount, System.Int16[] nominalGlyphIndices, System.Int16[] verticalGlyphIndices)
        {
            SharpDX.Result __result__;
            fixed (void *verticalGlyphIndices_ = verticalGlyphIndices)
                fixed (void *nominalGlyphIndices_ = nominalGlyphIndices)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, glyphCount, nominalGlyphIndices_, verticalGlyphIndices_, (*(void ***)this._nativePointer)[28]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Determines whether the font has any vertical glyph variants.</p>
        /// </summary>
        /// <returns><p>Returns TRUE if the font contains vertical glyph variants, otherwise <see cref = "SharpDX.Result.False"/>.</p></returns>
        /// <remarks>
        /// <p>For OpenType fonts, <strong>HasVerticalGlyphVariants</strong> returns TRUE if the font contains a "vert" feature. </p><p> <strong>IDWriteFontFace1::GetVerticalGlyphVariants</strong> retrieves the vertical forms of the nominal glyphs that are retrieved from <strong>IDWriteFontFace::GetGlyphIndices</strong>. </p>
        /// </remarks>
        /// <doc-id>hh780420</doc-id>
        /// <unmanaged>BOOL IDWriteFontFace1::HasVerticalGlyphVariants()</unmanaged>
        /// <unmanaged-short>IDWriteFontFace1::HasVerticalGlyphVariants</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool HasVerticalGlyphVariants()
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, (*(void ***)this._nativePointer)[29]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("d8b768ff-64bc-4e66-982b-ec8e87f693f7")]
    public partial class FontFace2 : SharpDX.DirectWrite.FontFace1
    {
        public FontFace2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator FontFace2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new FontFace2(nativePtr);
        /// <summary>
        /// <p>Allows you to determine if a color rendering path is potentially necessary.</p>
        /// </summary>
        /// <doc-id>dn280457</doc-id>
        /// <unmanaged>IsColorFont</unmanaged>
        /// <unmanaged-short>IsColorFont</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsColorFont
        {
            get => IsColorFont_();
        }

        /// <summary>
        /// <p>Gets the number of color palettes defined by the font. </p>
        /// </summary>
        /// <doc-id>dn312080</doc-id>
        /// <unmanaged>GetColorPaletteCount</unmanaged>
        /// <unmanaged-short>GetColorPaletteCount</unmanaged-short>
        public System.Int32 ColorPaletteCount
        {
            get => GetColorPaletteCount();
        }

        /// <summary>
        /// <p>Get the number of entries in each color palette.</p>
        /// </summary>
        /// <doc-id>dn312082</doc-id>
        /// <unmanaged>GetPaletteEntryCount</unmanaged>
        /// <unmanaged-short>GetPaletteEntryCount</unmanaged-short>
        public System.Int32 PaletteEntryCount
        {
            get => GetPaletteEntryCount();
        }

        /// <summary>
        /// <p>Allows you to determine if a color rendering path is potentially necessary.</p>
        /// </summary>
        /// <returns><p>Returns <strong>TRUE</strong> if a color rendering path is potentially necessary.</p></returns>
        /// <doc-id>dn280457</doc-id>
        /// <unmanaged>BOOL IDWriteFontFace2::IsColorFont()</unmanaged>
        /// <unmanaged-short>IDWriteFontFace2::IsColorFont</unmanaged-short>
        internal unsafe SharpDX.Mathematics.Interop.RawBool IsColorFont_()
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, (*(void ***)this._nativePointer)[30]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets the number of color palettes defined by the font. </p>
        /// </summary>
        /// <returns><p>The return value is zero if the font has no color information. Color fonts are required to define at least one palette, with palette index zero reserved as the default palette.</p></returns>
        /// <doc-id>dn312080</doc-id>
        /// <unmanaged>unsigned int IDWriteFontFace2::GetColorPaletteCount()</unmanaged>
        /// <unmanaged-short>IDWriteFontFace2::GetColorPaletteCount</unmanaged-short>
        internal unsafe System.Int32 GetColorPaletteCount()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[31]);
            return __result__;
        }

        /// <summary>
        /// <p>Get the number of entries in each color palette.</p>
        /// </summary>
        /// <returns><p>The number of entries in each color palette. All color palettes in a font have the same number of palette entries. The return value is  zero if the font has no color information.</p></returns>
        /// <doc-id>dn312082</doc-id>
        /// <unmanaged>unsigned int IDWriteFontFace2::GetPaletteEntryCount()</unmanaged>
        /// <unmanaged-short>IDWriteFontFace2::GetPaletteEntryCount</unmanaged-short>
        internal unsafe System.Int32 GetPaletteEntryCount()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[32]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets color values from the font's color palette.</p>
        /// </summary>
        /// <param name = "colorPaletteIndex"><dd> <p>Zero-based index of the color palette. If the font does not have a palette with the specified index, the method returns <strong>DWRITE_E_NOCOLOR</strong>.</p> </dd></param>
        /// <param name = "firstEntryIndex"><dd> <p>Zero-based index of the first palette entry to read.</p> </dd></param>
        /// <param name = "entryCount"><dd> <p>Number of palette entries to read.</p> </dd></param>
        /// <param name = "aletteEntriesRef"><dd> <p>Array that receives the color values.</p> </dd></param>
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return value</th><th>Description</th></tr> <tr><td> <dl> <dt>E_INVALIDARG</dt> </dl> </td><td> <p>The sum of <em>firstEntryIndex</em> and <em>entryCount</em> is greater than the actual number of palette entries that's returned by the <strong>GetPaletteEntryCount</strong> method.</p> </td></tr> <tr><td> <dl> <dt>DWRITE_E_NOCOLOR</dt> </dl> </td><td> <p>The font doesn't have a palette with the specified palette index.</p> </td></tr> </table><p>?</p></returns>
        /// <doc-id>dn312081</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFace2::GetPaletteEntries([In] unsigned int colorPaletteIndex,[In] unsigned int firstEntryIndex,[In] unsigned int entryCount,[Out, Buffer] D3DCOLORVALUE* paletteEntries)</unmanaged>
        /// <unmanaged-short>IDWriteFontFace2::GetPaletteEntries</unmanaged-short>
        public unsafe void GetPaletteEntries(System.Int32 colorPaletteIndex, System.Int32 firstEntryIndex, System.Int32 entryCount, SharpDX.Mathematics.Interop.RawColor4[] aletteEntriesRef)
        {
            SharpDX.Result __result__;
            fixed (void *aletteEntriesRef_ = aletteEntriesRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, colorPaletteIndex, firstEntryIndex, entryCount, aletteEntriesRef_, (*(void ***)this._nativePointer)[33]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Determines the recommended text rendering and grid-fit mode to be used based on the font, size, world transform, and measuring mode.</p>
        /// </summary>
        /// <param name = "fontEmSize"><dd>  <p>Logical font size in DIPs.</p> </dd></param>
        /// <param name = "dpiX"><dd>  <p>Number of pixels per logical inch in the horizontal direction.</p> </dd></param>
        /// <param name = "dpiY"><dd>  <p>Number of pixels per logical inch in the vertical direction.</p> </dd></param>
        /// <param name = "transform"><dd>  <p>A <strong><see cref = "SharpDX.Mathematics.Interop.RawMatrix3x2"/></strong> structure that describes the world transform.</p> </dd></param>
        /// <param name = "isSideways"><dd>  <p>Specifies whether the font is sideways. <strong>TRUE</strong> if the font is sideways; otherwise, <strong><see cref = "SharpDX.Result.False"/></strong>. </p> </dd></param>
        /// <param name = "outlineThreshold"><dd>  <p>A <strong><see cref = "SharpDX.DirectWrite.OutlineThreshold"/></strong>-typed value that specifies the quality of the graphics system's outline rendering, affects the size threshold above which outline rendering is used.</p> </dd></param>
        /// <param name = "measuringMode"><dd>  <p>A <strong><see cref = "SharpDX.Direct2D1.MeasuringMode"/></strong>-typed value that specifies  the method used to measure during text layout. For proper glyph spacing, this method returns a rendering mode that is compatible with the specified measuring mode.</p> </dd></param>
        /// <param name = "renderingParams"><dd>  <p>A reference to a <strong><see cref = "SharpDX.DirectWrite.RenderingParams"/></strong> interface for the rendering parameters object. This parameter is necessary in case the rendering parameters object overrides the rendering mode.</p> </dd></param>
        /// <param name = "renderingMode"><dd>  <p>A reference to a variable that receives a <strong><see cref = "SharpDX.DirectWrite.RenderingMode"/></strong>-typed value for the recommended rendering mode.</p> </dd></param>
        /// <param name = "gridFitMode"><dd>  <p>A reference to a variable that receives a <strong><see cref = "SharpDX.DirectWrite.GridFitMode"/></strong>-typed value for the recommended grid-fit mode.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn894560</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFace2::GetRecommendedRenderingMode([In] float fontEmSize,[In] float dpiX,[In] float dpiY,[In, Optional] const DWRITE_MATRIX* transform,[In] BOOL isSideways,[In] DWRITE_OUTLINE_THRESHOLD outlineThreshold,[In] DWRITE_MEASURING_MODE measuringMode,[In, Optional] IDWriteRenderingParams* renderingParams,[Out] DWRITE_RENDERING_MODE* renderingMode,[Out] DWRITE_GRID_FIT_MODE* gridFitMode)</unmanaged>
        /// <unmanaged-short>IDWriteFontFace2::GetRecommendedRenderingMode</unmanaged-short>
        public unsafe void GetRecommendedRenderingMode(System.Single fontEmSize, System.Single dpiX, System.Single dpiY, SharpDX.Mathematics.Interop.RawMatrix3x2? transform, SharpDX.Mathematics.Interop.RawBool isSideways, SharpDX.DirectWrite.OutlineThreshold outlineThreshold, SharpDX.Direct2D1.MeasuringMode measuringMode, SharpDX.DirectWrite.RenderingParams renderingParams, out SharpDX.DirectWrite.RenderingMode renderingMode, out SharpDX.DirectWrite.GridFitMode gridFitMode)
        {
            SharpDX.Mathematics.Interop.RawMatrix3x2 transform_;
            System.IntPtr renderingParams_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            if (transform != null)
                transform_ = transform.Value;
            renderingParams_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.RenderingParams>(renderingParams);
            fixed (void *gridFitMode_ = &gridFitMode)
                fixed (void *renderingMode_ = &renderingMode)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, fontEmSize, dpiX, dpiY, transform == null ? (void *)0 : &transform_, isSideways, unchecked ((System.Int32)outlineThreshold), unchecked ((System.Int32)measuringMode), (void *)renderingParams_, renderingMode_, gridFitMode_, (*(void ***)this._nativePointer)[34]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("D37D7598-09BE-4222-A236-2081341CC1F2")]
    public partial class FontFace3 : SharpDX.DirectWrite.FontFace2
    {
        public FontFace3(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator FontFace3(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new FontFace3(nativePtr);
        /// <summary>
        /// <p>Gets a font face reference that identifies this font.</p>
        /// </summary>
        /// <doc-id>dn894566</doc-id>
        /// <unmanaged>GetFontFaceReference</unmanaged>
        /// <unmanaged-short>GetFontFaceReference</unmanaged-short>
        public SharpDX.DirectWrite.FontFaceReference FontFaceReference
        {
            get
            {
                GetFontFaceReference(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the PANOSE values from the font, used for font selection and matching.</p>
        /// </summary>
        /// <remarks>
        /// <p>This method doesn't simulate these values, such as substituting a weight or proportion inferred on other values. If the font doesn't specify them, they are all set to 'any' (0).</p>
        /// </remarks>
        /// <doc-id>dn894568</doc-id>
        /// <unmanaged>GetPanose</unmanaged>
        /// <unmanaged-short>GetPanose</unmanaged-short>
        public SharpDX.DirectWrite.Panose Panose
        {
            get
            {
                GetPanose(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the weight of this font.</p>
        /// </summary>
        /// <doc-id>dn894572</doc-id>
        /// <unmanaged>GetWeight</unmanaged>
        /// <unmanaged-short>GetWeight</unmanaged-short>
        public SharpDX.DirectWrite.FontWeight Weight
        {
            get => GetWeight();
        }

        /// <summary>
        /// <p>Gets the stretch (also known as width) of this font.</p>
        /// </summary>
        /// <doc-id>dn894570</doc-id>
        /// <unmanaged>GetStretch</unmanaged>
        /// <unmanaged-short>GetStretch</unmanaged-short>
        public SharpDX.DirectWrite.FontStretch Stretch
        {
            get => GetStretch();
        }

        /// <summary>
        /// <p>Gets the style (also known as slope) of this font.</p>
        /// </summary>
        /// <doc-id>dn894571</doc-id>
        /// <unmanaged>GetStyle</unmanaged>
        /// <unmanaged-short>GetStyle</unmanaged-short>
        public SharpDX.DirectWrite.FontStyle Style
        {
            get => GetStyle();
        }

        /// <summary>
        /// <p>Creates a localized strings object that contains the family names for the font family, indexed by locale name.</p>
        /// </summary>
        /// <doc-id>dn894565</doc-id>
        /// <unmanaged>GetFamilyNames</unmanaged>
        /// <unmanaged-short>GetFamilyNames</unmanaged-short>
        public SharpDX.DirectWrite.LocalizedStrings FamilyNames
        {
            get
            {
                GetFamilyNames(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Creates a localized strings object that contains the face names for the font (for example, Regular or Bold), indexed by locale name.</p>
        /// </summary>
        /// <doc-id>dn894564</doc-id>
        /// <unmanaged>GetFaceNames</unmanaged>
        /// <unmanaged-short>GetFaceNames</unmanaged-short>
        public SharpDX.DirectWrite.LocalizedStrings FaceNames
        {
            get
            {
                GetFaceNames(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets a font face reference that identifies this font.</p>
        /// </summary>
        /// <param name = "fontFaceReference"><dd>  <p>A reference to a memory block that receives a reference to a <strong><see cref = "SharpDX.DirectWrite.FontFaceReference"/></strong> interface for the newly created font face reference object.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn894566</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFace3::GetFontFaceReference([Out] IDWriteFontFaceReference** fontFaceReference)</unmanaged>
        /// <unmanaged-short>IDWriteFontFace3::GetFontFaceReference</unmanaged-short>
        internal unsafe void GetFontFaceReference(out SharpDX.DirectWrite.FontFaceReference fontFaceReference)
        {
            System.IntPtr fontFaceReference_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &fontFaceReference_, (*(void ***)this._nativePointer)[35]);
            if (fontFaceReference_ != System.IntPtr.Zero)
                fontFaceReference = new SharpDX.DirectWrite.FontFaceReference(fontFaceReference_);
            else
                fontFaceReference = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the PANOSE values from the font, used for font selection and matching.</p>
        /// </summary>
        /// <param name = "anoseRef"><dd>  <p>A reference to a <strong><see cref = "SharpDX.DirectWrite.Panose"/></strong> structure that receives the PANOSE values from the font.</p> </dd></param>
        /// <remarks>
        /// <p>This method doesn't simulate these values, such as substituting a weight or proportion inferred on other values. If the font doesn't specify them, they are all set to 'any' (0).</p>
        /// </remarks>
        /// <doc-id>dn894568</doc-id>
        /// <unmanaged>void IDWriteFontFace3::GetPanose([Out] DWRITE_PANOSE* panose)</unmanaged>
        /// <unmanaged-short>IDWriteFontFace3::GetPanose</unmanaged-short>
        internal unsafe void GetPanose(out SharpDX.DirectWrite.Panose anoseRef)
        {
            SharpDX.DirectWrite.Panose.__Native anoseRef_ = default (SharpDX.DirectWrite.Panose.__Native);
            anoseRef = default (SharpDX.DirectWrite.Panose);
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, &anoseRef_, (*(void ***)this._nativePointer)[36]);
            anoseRef.__MarshalFrom(ref anoseRef_);
        }

        /// <summary>
        /// <p>Gets the weight of this font.</p>
        /// </summary>
        /// <returns><p>Returns a <strong><see cref = "SharpDX.DirectWrite.FontWeight"/></strong>-typed value that specifies the density of a typeface, in terms of the lightness or heaviness of the strokes. </p></returns>
        /// <doc-id>dn894572</doc-id>
        /// <unmanaged>DWRITE_FONT_WEIGHT IDWriteFontFace3::GetWeight()</unmanaged>
        /// <unmanaged-short>IDWriteFontFace3::GetWeight</unmanaged-short>
        internal unsafe SharpDX.DirectWrite.FontWeight GetWeight()
        {
            SharpDX.DirectWrite.FontWeight __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirectWriteFontWeight(this._nativePointer, (*(void ***)this._nativePointer)[37]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets the stretch (also known as width) of this font.</p>
        /// </summary>
        /// <returns><p>Returns a <strong><see cref = "SharpDX.DirectWrite.FontStretch"/></strong>-typed value that specifies the degree to which a font has been stretched compared to a font's normal aspect ratio. </p></returns>
        /// <doc-id>dn894570</doc-id>
        /// <unmanaged>DWRITE_FONT_STRETCH IDWriteFontFace3::GetStretch()</unmanaged>
        /// <unmanaged-short>IDWriteFontFace3::GetStretch</unmanaged-short>
        internal unsafe SharpDX.DirectWrite.FontStretch GetStretch()
        {
            SharpDX.DirectWrite.FontStretch __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirectWriteFontStretch(this._nativePointer, (*(void ***)this._nativePointer)[38]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets the style (also known as slope) of this font.</p>
        /// </summary>
        /// <returns><p>Returns a <strong><see cref = "SharpDX.DirectWrite.FontStyle"/></strong>-typed value that specifies the style of the font. </p></returns>
        /// <doc-id>dn894571</doc-id>
        /// <unmanaged>DWRITE_FONT_STYLE IDWriteFontFace3::GetStyle()</unmanaged>
        /// <unmanaged-short>IDWriteFontFace3::GetStyle</unmanaged-short>
        internal unsafe SharpDX.DirectWrite.FontStyle GetStyle()
        {
            SharpDX.DirectWrite.FontStyle __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirectWriteFontStyle(this._nativePointer, (*(void ***)this._nativePointer)[39]);
            return __result__;
        }

        /// <summary>
        /// <p>Creates a localized strings object that contains the family names for the font family, indexed by locale name.</p>
        /// </summary>
        /// <param name = "names"><dd>  <p>A reference to a memory block that receives a reference to a <strong><see cref = "SharpDX.DirectWrite.LocalizedStrings"/></strong> interface for the newly created localized strings object.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn894565</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFace3::GetFamilyNames([Out] IDWriteLocalizedStrings** names)</unmanaged>
        /// <unmanaged-short>IDWriteFontFace3::GetFamilyNames</unmanaged-short>
        internal unsafe void GetFamilyNames(out SharpDX.DirectWrite.LocalizedStrings names)
        {
            System.IntPtr names_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &names_, (*(void ***)this._nativePointer)[40]);
            if (names_ != System.IntPtr.Zero)
                names = new SharpDX.DirectWrite.LocalizedStrings(names_);
            else
                names = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a localized strings object that contains the face names for the font (for example, Regular or Bold), indexed by locale name.</p>
        /// </summary>
        /// <param name = "names"><dd>  <p>A reference to a memory block that receives a reference to a <strong><see cref = "SharpDX.DirectWrite.LocalizedStrings"/></strong> interface for the newly created localized strings object.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn894564</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFace3::GetFaceNames([Out] IDWriteLocalizedStrings** names)</unmanaged>
        /// <unmanaged-short>IDWriteFontFace3::GetFaceNames</unmanaged-short>
        internal unsafe void GetFaceNames(out SharpDX.DirectWrite.LocalizedStrings names)
        {
            System.IntPtr names_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &names_, (*(void ***)this._nativePointer)[41]);
            if (names_ != System.IntPtr.Zero)
                names = new SharpDX.DirectWrite.LocalizedStrings(names_);
            else
                names = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets a localized strings collection that contains the specified informational strings, indexed by locale name.</p>
        /// </summary>
        /// <param name = "informationalStringID"><dd>  <p>A <strong><see cref = "SharpDX.DirectWrite.InformationalStringId"/></strong>-typed value that identifies the strings to get.</p> </dd></param>
        /// <param name = "informationalStrings"><dd>  <p>A reference to a memory block that receives a reference to a <strong><see cref = "SharpDX.DirectWrite.LocalizedStrings"/></strong> interface for the newly created localized strings object.</p> </dd></param>
        /// <param name = "exists"><dd>  <p>A reference to a variable that receives whether the font contains the specified string ID. <strong>TRUE</strong> if the font contains the specified string ID; otherwise, <strong><see cref = "SharpDX.Result.False"/></strong>.</p> </dd></param>
        /// <returns><p>If the font doesn't contain the specified string, the return value is <see cref = "SharpDX.Result.Ok"/>, but <em>informationalStrings</em> receives a <strong><c>null</c></strong> reference and <em>exists</em> receives the value <strong><see cref = "SharpDX.Result.False"/></strong>.</p></returns>
        /// <doc-id>dn894567</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFace3::GetInformationalStrings([In] DWRITE_INFORMATIONAL_STRING_ID informationalStringID,[Out, Optional] IDWriteLocalizedStrings** informationalStrings,[Out] BOOL* exists)</unmanaged>
        /// <unmanaged-short>IDWriteFontFace3::GetInformationalStrings</unmanaged-short>
        public unsafe void GetInformationalStrings(SharpDX.DirectWrite.InformationalStringId informationalStringID, out SharpDX.DirectWrite.LocalizedStrings informationalStrings, out SharpDX.Mathematics.Interop.RawBool exists)
        {
            System.IntPtr informationalStrings_ = System.IntPtr.Zero;
            exists = default (SharpDX.Mathematics.Interop.RawBool);
            SharpDX.Result __result__;
            fixed (void *exists_ = &exists)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)informationalStringID), &informationalStrings_, exists_, (*(void ***)this._nativePointer)[42]);
            if (informationalStrings_ != System.IntPtr.Zero)
                informationalStrings = new SharpDX.DirectWrite.LocalizedStrings(informationalStrings_);
            else
                informationalStrings = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Determines whether the font supports the specified character.</p>
        /// </summary>
        /// <param name = "unicodeValue"><dd>  <p>A Unicode (UCS-4) character value.</p> </dd></param>
        /// <returns><p>Returns whether the font supports the specified character. Returns <strong>TRUE</strong> if the font has the specified character; otherwise, <strong><see cref = "SharpDX.Result.False"/></strong>. </p></returns>
        /// <doc-id>dn894573</doc-id>
        /// <unmanaged>BOOL IDWriteFontFace3::HasCharacter([In] unsigned int unicodeValue)</unmanaged>
        /// <unmanaged-short>IDWriteFontFace3::HasCharacter</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool HasCharacter(System.Int32 unicodeValue)
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, unicodeValue, (*(void ***)this._nativePointer)[43]);
            return __result__;
        }

        /// <summary>
        /// <p>Determines the recommended text rendering and grid-fit mode to be used based on the font, size, world transform, and measuring mode.</p>
        /// </summary>
        /// <param name = "fontEmSize"><dd>  <p>Logical font size in DIPs.</p> </dd></param>
        /// <param name = "dpiX"><dd>  <p>Number of pixels per logical inch in the horizontal direction.</p> </dd></param>
        /// <param name = "dpiY"><dd>  <p>Number of pixels per logical inch in the vertical direction.</p> </dd></param>
        /// <param name = "transform"><dd>  <p>A <strong><see cref = "SharpDX.Mathematics.Interop.RawMatrix3x2"/></strong> structure that describes the world transform.</p> </dd></param>
        /// <param name = "isSideways"><dd>  <p>Specifies whether the font is sideways. <strong>TRUE</strong> if the font is sideways; otherwise, <strong><see cref = "SharpDX.Result.False"/></strong>. </p> </dd></param>
        /// <param name = "outlineThreshold"><dd>  <p>A <strong><see cref = "SharpDX.DirectWrite.OutlineThreshold"/></strong>-typed value that specifies the quality of the graphics system's outline rendering, affects the size threshold above which outline rendering is used.</p> </dd></param>
        /// <param name = "measuringMode"><dd>  <p>A <strong><see cref = "SharpDX.Direct2D1.MeasuringMode"/></strong>-typed value that specifies  the method used to measure during text layout. For proper glyph spacing, this method returns a rendering mode that is compatible with the specified measuring mode.</p> </dd></param>
        /// <param name = "renderingParams"><dd>  <p>A reference to a <strong><see cref = "SharpDX.DirectWrite.RenderingParams"/></strong> interface for the rendering parameters object. This parameter is necessary in case the rendering parameters object overrides the rendering mode.</p> </dd></param>
        /// <param name = "renderingMode"><dd>  <p>A reference to a variable that receives a <strong><see cref = "SharpDX.DirectWrite.RenderingMode1"/></strong>-typed value for the recommended rendering mode.</p> </dd></param>
        /// <param name = "gridFitMode"><dd>  <p>A reference to a variable that receives a <strong><see cref = "SharpDX.DirectWrite.GridFitMode"/></strong>-typed value for the recommended grid-fit mode.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn894569</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFace3::GetRecommendedRenderingMode([In] float fontEmSize,[In] float dpiX,[In] float dpiY,[In, Optional] const DWRITE_MATRIX* transform,[In] BOOL isSideways,[In] DWRITE_OUTLINE_THRESHOLD outlineThreshold,[In] DWRITE_MEASURING_MODE measuringMode,[In, Optional] IDWriteRenderingParams* renderingParams,[Out] DWRITE_RENDERING_MODE1* renderingMode,[Out] DWRITE_GRID_FIT_MODE* gridFitMode)</unmanaged>
        /// <unmanaged-short>IDWriteFontFace3::GetRecommendedRenderingMode</unmanaged-short>
        public unsafe void GetRecommendedRenderingMode(System.Single fontEmSize, System.Single dpiX, System.Single dpiY, SharpDX.Mathematics.Interop.RawMatrix3x2? transform, SharpDX.Mathematics.Interop.RawBool isSideways, SharpDX.DirectWrite.OutlineThreshold outlineThreshold, SharpDX.Direct2D1.MeasuringMode measuringMode, SharpDX.DirectWrite.RenderingParams renderingParams, out SharpDX.DirectWrite.RenderingMode1 renderingMode, out SharpDX.DirectWrite.GridFitMode gridFitMode)
        {
            SharpDX.Mathematics.Interop.RawMatrix3x2 transform_;
            System.IntPtr renderingParams_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            if (transform != null)
                transform_ = transform.Value;
            renderingParams_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.RenderingParams>(renderingParams);
            fixed (void *gridFitMode_ = &gridFitMode)
                fixed (void *renderingMode_ = &renderingMode)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, fontEmSize, dpiX, dpiY, transform == null ? (void *)0 : &transform_, isSideways, unchecked ((System.Int32)outlineThreshold), unchecked ((System.Int32)measuringMode), (void *)renderingParams_, renderingMode_, gridFitMode_, (*(void ***)this._nativePointer)[44]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Determines whether the character is locally downloaded from the font.</p>
        /// </summary>
        /// <param name = "unicodeValue"><dd>  <p>A Unicode (UCS-4) character value.</p> </dd></param>
        /// <returns><p>Returns <strong>TRUE</strong> if the font has the specified character locally available,     <strong><see cref = "SharpDX.Result.False"/></strong> if not or if the font does not support that character. </p></returns>
        /// <doc-id>dn894574</doc-id>
        /// <unmanaged>BOOL IDWriteFontFace3::IsCharacterLocal([In] unsigned int unicodeValue)</unmanaged>
        /// <unmanaged-short>IDWriteFontFace3::IsCharacterLocal</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool IsCharacterLocal(System.Int32 unicodeValue)
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, unicodeValue, (*(void ***)this._nativePointer)[45]);
            return __result__;
        }

        /// <summary>
        /// <p>Determines whether the glyph is locally downloaded from the font.</p>
        /// </summary>
        /// <param name = "glyphId"><dd>  <p>Glyph identifier.</p> </dd></param>
        /// <returns><p>Returns TRUE if the font has the specified glyph locally available.</p></returns>
        /// <doc-id>dn894575</doc-id>
        /// <unmanaged>BOOL IDWriteFontFace3::IsGlyphLocal([In] unsigned short glyphId)</unmanaged>
        /// <unmanaged-short>IDWriteFontFace3::IsGlyphLocal</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool IsGlyphLocal(System.Int16 glyphId)
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, glyphId, (*(void ***)this._nativePointer)[46]);
            return __result__;
        }

        /// <summary>
        /// <p>Determines whether the specified characters are local.</p>
        /// </summary>
        /// <param name = "characters"><dd>  <p>Array of characters.</p> </dd></param>
        /// <param name = "characterCount"><dd>  <p>The number of elements in the character array.</p> </dd></param>
        /// <param name = "enqueueIfNotLocal"><dd>  <p>Specifies whether to enqueue a download request     if any of the specified characters are not local.</p> </dd></param>
        /// <param name = "isLocal"><dd>  <p>Receives TRUE if all of the specified characters are local,     <see cref = "SharpDX.Result.False"/> if any of the specified characters are remote.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn894562</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFace3::AreCharactersLocal([In, Buffer] const wchar_t* characters,[In] unsigned int characterCount,[In] BOOL enqueueIfNotLocal,[Out] BOOL* isLocal)</unmanaged>
        /// <unmanaged-short>IDWriteFontFace3::AreCharactersLocal</unmanaged-short>
        public unsafe void AreCharactersLocal(System.String characters, System.Int32 characterCount, SharpDX.Mathematics.Interop.RawBool enqueueIfNotLocal, out SharpDX.Mathematics.Interop.RawBool isLocal)
        {
            isLocal = default (SharpDX.Mathematics.Interop.RawBool);
            SharpDX.Result __result__;
            fixed (void *isLocal_ = &isLocal)
                fixed (char *characters_ = characters)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, (void *)characters_, characterCount, enqueueIfNotLocal, isLocal_, (*(void ***)this._nativePointer)[47]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Determines whether the specified glyphs are local.</p>
        /// </summary>
        /// <param name = "glyphIndices"><dd>  <p>Array of glyph indices.</p> </dd></param>
        /// <param name = "glyphCount"><dd>  <p>The number of elements in the glyph index array.</p> </dd></param>
        /// <param name = "enqueueIfNotLocal"><dd>  <p>Specifies whether to enqueue a download request     if any of the specified glyphs are not local.</p> </dd></param>
        /// <param name = "isLocal"><dd>  <p>Receives TRUE if all of the specified glyphs are local,     <see cref = "SharpDX.Result.False"/> if any of the specified glyphs are remote.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn894563</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFace3::AreGlyphsLocal([In, Buffer] const unsigned short* glyphIndices,[In] unsigned int glyphCount,[In] BOOL enqueueIfNotLocal,[Out] BOOL* isLocal)</unmanaged>
        /// <unmanaged-short>IDWriteFontFace3::AreGlyphsLocal</unmanaged-short>
        public unsafe void AreGlyphsLocal(System.Int16[] glyphIndices, System.Int32 glyphCount, SharpDX.Mathematics.Interop.RawBool enqueueIfNotLocal, out SharpDX.Mathematics.Interop.RawBool isLocal)
        {
            isLocal = default (SharpDX.Mathematics.Interop.RawBool);
            SharpDX.Result __result__;
            fixed (void *isLocal_ = &isLocal)
                fixed (void *glyphIndices_ = glyphIndices)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, glyphIndices_, glyphCount, enqueueIfNotLocal, isLocal_, (*(void ***)this._nativePointer)[48]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("27F2A904-4EB8-441D-9678-0563F53E3E2F")]
    public partial class FontFace4 : SharpDX.DirectWrite.FontFace3
    {
        public FontFace4(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator FontFace4(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new FontFace4(nativePtr);
        /// <summary>
        /// <p>Gets the available image formats of a specific glyph and ppem. </p>
        /// </summary>
        /// <param name = "glyphId"><dd>  <p>The ID of the glyph.</p> </dd></param>
        /// <param name = "pixelsPerEmFirst"><dd>  </dd></param>
        /// <param name = "pixelsPerEmLast"><dd>  </dd></param>
        /// <param name = "glyphImageFormats"><dd>  <p>Specifies which formats are supported in the font.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <see cref = "SharpDX.Result"/> error code.</p></returns>
        /// <remarks>
        /// <p>Glyphs often have at least TrueType or CFF outlines, but they may also have SVG outlines, or they may have only bitmaps with no TrueType/CFF outlines. Some image formats, notably the PNG/JPEG ones, are size specific and will return no match when there isn't an entry in that size range.</p><p>Glyph ids beyond the glyph count return DWRITE_GLYPH_IMAGE_FORMATS_NONE.</p>
        /// </remarks>
        /// <doc-id>mt725323</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFace4::GetGlyphImageFormats([In] unsigned short glyphId,[In] unsigned int pixelsPerEmFirst,[In] unsigned int pixelsPerEmLast,[Out] DWRITE_GLYPH_IMAGE_FORMATS* glyphImageFormats)</unmanaged>
        /// <unmanaged-short>IDWriteFontFace4::GetGlyphImageFormats</unmanaged-short>
        public unsafe void GetGlyphImageFormats(System.Int16 glyphId, System.Int32 pixelsPerEmFirst, System.Int32 pixelsPerEmLast, out SharpDX.Direct2D1.GlyphImageFormatS glyphImageFormats)
        {
            SharpDX.Result __result__;
            fixed (void *glyphImageFormats_ = &glyphImageFormats)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, glyphId, pixelsPerEmFirst, pixelsPerEmLast, glyphImageFormats_, (*(void ***)this._nativePointer)[49]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the available image formats of a specific glyph and ppem. </p>
        /// </summary>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <see cref = "SharpDX.Result"/> error code.</p></returns>
        /// <remarks>
        /// <p>Glyphs often have at least TrueType or CFF outlines, but they may also have SVG outlines, or they may have only bitmaps with no TrueType/CFF outlines. Some image formats, notably the PNG/JPEG ones, are size specific and will return no match when there isn't an entry in that size range.</p><p>Glyph ids beyond the glyph count return DWRITE_GLYPH_IMAGE_FORMATS_NONE.</p>
        /// </remarks>
        /// <doc-id>mt725323</doc-id>
        /// <unmanaged>DWRITE_GLYPH_IMAGE_FORMATS IDWriteFontFace4::GetGlyphImageFormats()</unmanaged>
        /// <unmanaged-short>IDWriteFontFace4::GetGlyphImageFormats</unmanaged-short>
        public unsafe SharpDX.Direct2D1.GlyphImageFormatS GetGlyphImageFormats()
        {
            SharpDX.Direct2D1.GlyphImageFormatS __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirect2D1GlyphImageFormatS(this._nativePointer, (*(void ***)this._nativePointer)[50]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets a reference to the glyph data based on the desired image format.</p>
        /// </summary>
        /// <param name = "glyphId"><dd>  <p>The ID of the glyph to retrieve image data for.</p> </dd></param>
        /// <param name = "pixelsPerEm"><dd>  <p>Requested pixels per em.</p> </dd></param>
        /// <param name = "glyphImageFormat"><dd>  <p>Specifies which formats are supported in the font.</p> </dd></param>
        /// <param name = "glyphData"><dd>  <p>On return contains data for a glyph.</p> </dd></param>
        /// <param name = "glyphDataContext"><dd>  </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <see cref = "SharpDX.Result"/> error code.</p></returns>
        /// <remarks>
        /// <p> The glyphDataContext must be released via <strong>ReleaseGlyphImageData</strong> when done if the data is not empty, similar to <strong>IDWriteFontFileStream::ReadFileFragment</strong> and <strong>IDWriteFontFileStream::ReleaseFileFragment</strong>. The data reference is valid so long as the <strong><see cref = "SharpDX.DirectWrite.FontFace"/></strong> exists and <strong>ReleaseGlyphImageData</strong> has not been called. </p><p> The <strong>DWRITE_GLYPH_IMAGE_DATA::uniqueDataId</strong> is valuable for caching purposes so that if the same resource is returned more than once, an existing resource can be quickly retrieved rather than needing to reparse or decompress the data. </p><p> The function only returns SVG or raster data - requesting TrueType/CFF/COLR data returns DWRITE_E_INVALIDARG. Those must be drawn via DrawGlyphRun or queried using GetGlyphOutline instead. Exactly one format may be requested or else the function returns DWRITE_E_INVALIDARG. If the glyph does not have that format, the call is not an error, but the function returns empty data.  </p>
        /// </remarks>
        /// <doc-id>mt725321</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFace4::GetGlyphImageData([In] unsigned short glyphId,[In] unsigned int pixelsPerEm,[In] DWRITE_GLYPH_IMAGE_FORMATS glyphImageFormat,[Out] DWRITE_GLYPH_IMAGE_DATA* glyphData,[Out, Optional] void** glyphDataContext)</unmanaged>
        /// <unmanaged-short>IDWriteFontFace4::GetGlyphImageData</unmanaged-short>
        public unsafe void GetGlyphImageData(System.Int16 glyphId, System.Int32 pixelsPerEm, SharpDX.Direct2D1.GlyphImageFormatS glyphImageFormat, out SharpDX.DirectWrite.GlyphImageData glyphData, out System.IntPtr glyphDataContext)
        {
            glyphData = default (SharpDX.DirectWrite.GlyphImageData);
            SharpDX.Result __result__;
            fixed (void *glyphDataContext_ = &glyphDataContext)
                fixed (void *glyphData_ = &glyphData)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, glyphId, pixelsPerEm, unchecked ((System.Int32)glyphImageFormat), glyphData_, glyphDataContext_, (*(void ***)this._nativePointer)[51]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Releases the table data obtained from ReadGlyphData.</p>
        /// </summary>
        /// <param name = "glyphDataContext"><dd>  <p>Opaque context from ReadGlyphData.</p> </dd></param>
        /// <doc-id>mt725325</doc-id>
        /// <unmanaged>void IDWriteFontFace4::ReleaseGlyphImageData([In] void* glyphDataContext)</unmanaged>
        /// <unmanaged-short>IDWriteFontFace4::ReleaseGlyphImageData</unmanaged-short>
        public unsafe void ReleaseGlyphImageData(System.IntPtr glyphDataContext)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)glyphDataContext, (*(void ***)this._nativePointer)[52]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("5E7FA7CA-DDE3-424C-89F0-9FCD6FED58CD")]
    public partial class FontFaceReference : SharpDX.ComObject
    {
        public FontFaceReference(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator FontFaceReference(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new FontFaceReference(nativePtr);
        /// <summary>
        /// <p>Obtains the zero-based index of the font face in its font file or files. If the font files contain a single face,   the return value is zero. </p>
        /// </summary>
        /// <doc-id>dn894585</doc-id>
        /// <unmanaged>GetFontFaceIndex</unmanaged>
        /// <unmanaged-short>GetFontFaceIndex</unmanaged-short>
        public System.Int32 FontFaceIndex
        {
            get => GetFontFaceIndex();
        }

        /// <summary>
        /// <p>Obtains the algorithmic style simulation flags of a font face.</p>
        /// </summary>
        /// <doc-id>dn894589</doc-id>
        /// <unmanaged>GetSimulations</unmanaged>
        /// <unmanaged-short>GetSimulations</unmanaged-short>
        public SharpDX.DirectWrite.FontSimulations Simulations
        {
            get => GetSimulations();
        }

        /// <summary>
        /// <p>Obtains the font file representing a font face.</p>
        /// </summary>
        /// <doc-id>dn894586</doc-id>
        /// <unmanaged>GetFontFile</unmanaged>
        /// <unmanaged-short>GetFontFile</unmanaged-short>
        public SharpDX.DirectWrite.FontFile FontFile
        {
            get
            {
                GetFontFile(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Get the local size of the font face in bytes, which will always be    less than or equal to GetFullSize. If the locality is remote, this      value is zero. If full, this value will equal GetFileSize.</p>
        /// </summary>
        /// <doc-id>dn894587</doc-id>
        /// <unmanaged>GetLocalFileSize</unmanaged>
        /// <unmanaged-short>GetLocalFileSize</unmanaged-short>
        public System.Int64 LocalFileSize
        {
            get => GetLocalFileSize();
        }

        /// <summary>
        /// <p>Get the total size of the font face in bytes.  </p>
        /// </summary>
        /// <doc-id>dn894583</doc-id>
        /// <unmanaged>GetFileSize</unmanaged>
        /// <unmanaged-short>GetFileSize</unmanaged-short>
        public System.Int64 FileSize
        {
            get => GetFileSize();
        }

        /// <summary>
        /// <p>Get the last modified date.</p>
        /// </summary>
        /// <doc-id>dn894584</doc-id>
        /// <unmanaged>GetFileTime</unmanaged>
        /// <unmanaged-short>GetFileTime</unmanaged-short>
        public System.Int64 FileTime
        {
            get
            {
                GetFileTime(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Get the locality of this font face reference.</p>
        /// </summary>
        /// <remarks>
        /// <p>You can always successfully   create a font face from a fully local font. Attempting to create a font      face on a remote or partially local font may fail with DWRITE_E_REMOTEFONT.     This function may change between calls depending on background downloads     and whether cached data expires.</p>
        /// </remarks>
        /// <doc-id>dn894588</doc-id>
        /// <unmanaged>GetLocality</unmanaged>
        /// <unmanaged-short>GetLocality</unmanaged-short>
        public SharpDX.DirectWrite.Locality Locality
        {
            get => GetLocality();
        }

        /// <summary>
        /// <p>Creates a font face from the reference for use with layout, shaping, or rendering.</p>
        /// </summary>
        /// <param name = "fontFace"><dd>  <p>Newly created font face object, or nullptr in the case of failure.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>This function can fail with DWRITE_E_REMOTEFONT if the font is not local.</p>
        /// </remarks>
        /// <doc-id>dn894577</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFaceReference::CreateFontFace([Out] IDWriteFontFace3** fontFace)</unmanaged>
        /// <unmanaged-short>IDWriteFontFaceReference::CreateFontFace</unmanaged-short>
        public unsafe void CreateFontFace(out SharpDX.DirectWrite.FontFace3 fontFace)
        {
            System.IntPtr fontFace_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &fontFace_, (*(void ***)this._nativePointer)[3]);
            if (fontFace_ != System.IntPtr.Zero)
                fontFace = new SharpDX.DirectWrite.FontFace3(fontFace_);
            else
                fontFace = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a font face with alternate font simulations, for example, to explicitly simulate a bold font face out of a regular variant.</p>
        /// </summary>
        /// <param name = "fontFaceSimulationFlags"><dd>  <p>Font face simulation flags for algorithmic emboldening and italicization.</p> </dd></param>
        /// <param name = "fontFace"><dd>  <p>Newly created font face object, or nullptr in the case of failure.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>This function can fail with DWRITE_E_REMOTEFONT if the font is not local.</p>
        /// </remarks>
        /// <doc-id>dn894578</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFaceReference::CreateFontFaceWithSimulations([In] DWRITE_FONT_SIMULATIONS fontFaceSimulationFlags,[Out] IDWriteFontFace3** fontFace)</unmanaged>
        /// <unmanaged-short>IDWriteFontFaceReference::CreateFontFaceWithSimulations</unmanaged-short>
        public unsafe void CreateFontFaceWithSimulations(SharpDX.DirectWrite.FontSimulations fontFaceSimulationFlags, out SharpDX.DirectWrite.FontFace3 fontFace)
        {
            System.IntPtr fontFace_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)fontFaceSimulationFlags), &fontFace_, (*(void ***)this._nativePointer)[4]);
            if (fontFace_ != System.IntPtr.Zero)
                fontFace = new SharpDX.DirectWrite.FontFace3(fontFace_);
            else
                fontFace = null;
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "fontFaceReference">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>BOOL IDWriteFontFaceReference::Equals([In] IDWriteFontFaceReference* fontFaceReference)</unmanaged>
        /// <unmanaged-short>IDWriteFontFaceReference::Equals</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool Equals(SharpDX.DirectWrite.FontFaceReference fontFaceReference)
        {
            System.IntPtr fontFaceReference_ = System.IntPtr.Zero;
            SharpDX.Mathematics.Interop.RawBool __result__;
            fontFaceReference_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.FontFaceReference>(fontFaceReference);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, (void *)fontFaceReference_, (*(void ***)this._nativePointer)[5]);
            return __result__;
        }

        /// <summary>
        /// <p>Obtains the zero-based index of the font face in its font file or files. If the font files contain a single face,   the return value is zero. </p>
        /// </summary>
        /// <returns><p> the zero-based index of the font face in its font file or files. If the font files contain a single face,   the return value is zero.</p></returns>
        /// <doc-id>dn894585</doc-id>
        /// <unmanaged>unsigned int IDWriteFontFaceReference::GetFontFaceIndex()</unmanaged>
        /// <unmanaged-short>IDWriteFontFaceReference::GetFontFaceIndex</unmanaged-short>
        internal unsafe System.Int32 GetFontFaceIndex()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[6]);
            return __result__;
        }

        /// <summary>
        /// <p>Obtains the algorithmic style simulation flags of a font face.</p>
        /// </summary>
        /// <returns><p>Returns the algorithmic style simulation flags of a font face.</p></returns>
        /// <doc-id>dn894589</doc-id>
        /// <unmanaged>DWRITE_FONT_SIMULATIONS IDWriteFontFaceReference::GetSimulations()</unmanaged>
        /// <unmanaged-short>IDWriteFontFaceReference::GetSimulations</unmanaged-short>
        internal unsafe SharpDX.DirectWrite.FontSimulations GetSimulations()
        {
            SharpDX.DirectWrite.FontSimulations __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirectWriteFontSimulations(this._nativePointer, (*(void ***)this._nativePointer)[7]);
            return __result__;
        }

        /// <summary>
        /// <p>Obtains the font file representing a font face.</p>
        /// </summary>
        /// <param name = "fontFile"><dd>  </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn894586</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFaceReference::GetFontFile([Out] IDWriteFontFile** fontFile)</unmanaged>
        /// <unmanaged-short>IDWriteFontFaceReference::GetFontFile</unmanaged-short>
        internal unsafe void GetFontFile(out SharpDX.DirectWrite.FontFile fontFile)
        {
            System.IntPtr fontFile_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &fontFile_, (*(void ***)this._nativePointer)[8]);
            if (fontFile_ != System.IntPtr.Zero)
                fontFile = new SharpDX.DirectWrite.FontFile(fontFile_);
            else
                fontFile = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Get the local size of the font face in bytes, which will always be    less than or equal to GetFullSize. If the locality is remote, this      value is zero. If full, this value will equal GetFileSize.</p>
        /// </summary>
        /// <returns><p>the local size of the font face in bytes, which will always be    less than or equal to GetFullSize. If the locality is remote, this      value is zero. If full, this value will equal <strong>GetFileSize</strong>.</p></returns>
        /// <doc-id>dn894587</doc-id>
        /// <unmanaged>unsigned longlong IDWriteFontFaceReference::GetLocalFileSize()</unmanaged>
        /// <unmanaged-short>IDWriteFontFaceReference::GetLocalFileSize</unmanaged-short>
        internal unsafe System.Int64 GetLocalFileSize()
        {
            System.Int64 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCalllong(this._nativePointer, (*(void ***)this._nativePointer)[9]);
            return __result__;
        }

        /// <summary>
        /// <p>Get the total size of the font face in bytes.  </p>
        /// </summary>
        /// <returns><p>Returns the total size of the font face in bytes. If the locality is remote, this value is unknown and will be zero.</p></returns>
        /// <doc-id>dn894583</doc-id>
        /// <unmanaged>unsigned longlong IDWriteFontFaceReference::GetFileSize()</unmanaged>
        /// <unmanaged-short>IDWriteFontFaceReference::GetFileSize</unmanaged-short>
        internal unsafe System.Int64 GetFileSize()
        {
            System.Int64 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCalllong(this._nativePointer, (*(void ***)this._nativePointer)[10]);
            return __result__;
        }

        /// <summary>
        /// <p>Get the last modified date.</p>
        /// </summary>
        /// <param name = "lastWriteTime"><dd>  <p>Returns the last modified date. The time may be zero if the font file loader does not expose file time.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn894584</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFaceReference::GetFileTime([Out] FILETIME* lastWriteTime)</unmanaged>
        /// <unmanaged-short>IDWriteFontFaceReference::GetFileTime</unmanaged-short>
        internal unsafe void GetFileTime(out System.Int64 lastWriteTime)
        {
            SharpDX.Result __result__;
            fixed (void *lastWriteTime_ = &lastWriteTime)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, lastWriteTime_, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Get the locality of this font face reference.</p>
        /// </summary>
        /// <returns><p>Returns the locality of this font face reference.</p></returns>
        /// <remarks>
        /// <p>You can always successfully   create a font face from a fully local font. Attempting to create a font      face on a remote or partially local font may fail with DWRITE_E_REMOTEFONT.     This function may change between calls depending on background downloads     and whether cached data expires.</p>
        /// </remarks>
        /// <doc-id>dn894588</doc-id>
        /// <unmanaged>DWRITE_LOCALITY IDWriteFontFaceReference::GetLocality()</unmanaged>
        /// <unmanaged-short>IDWriteFontFaceReference::GetLocality</unmanaged-short>
        internal unsafe SharpDX.DirectWrite.Locality GetLocality()
        {
            SharpDX.DirectWrite.Locality __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirectWriteLocality(this._nativePointer, (*(void ***)this._nativePointer)[12]);
            return __result__;
        }

        /// <summary>
        /// <p>Adds a request to the font download queue (<strong><see cref = "SharpDX.DirectWrite.FontDownloadQueue"/></strong>).</p>
        /// </summary>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn894581</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFaceReference::EnqueueFontDownloadRequest()</unmanaged>
        /// <unmanaged-short>IDWriteFontFaceReference::EnqueueFontDownloadRequest</unmanaged-short>
        public unsafe void EnqueueFontDownloadRequest()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[13]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Adds a request to the font download queue (<strong><see cref = "SharpDX.DirectWrite.FontDownloadQueue"/></strong>).</p>
        /// </summary>
        /// <param name = "characters">No documentation.</param>
        /// <param name = "characterCount">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p> Downloading a character involves downloading every glyph it depends on directly or indirectly, via font tables (cmap, GSUB, COLR, glyf).</p>
        /// </remarks>
        /// <doc-id>dn894579</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFaceReference::EnqueueCharacterDownloadRequest([In, Buffer] const wchar_t* characters,[In] unsigned int characterCount)</unmanaged>
        /// <unmanaged-short>IDWriteFontFaceReference::EnqueueCharacterDownloadRequest</unmanaged-short>
        public unsafe void EnqueueCharacterDownloadRequest(System.String characters, System.Int32 characterCount)
        {
            SharpDX.Result __result__;
            fixed (char *characters_ = characters)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)characters_, characterCount, (*(void ***)this._nativePointer)[14]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Adds a request to the font download queue (<strong><see cref = "SharpDX.DirectWrite.FontDownloadQueue"/></strong>).</p>
        /// </summary>
        /// <param name = "glyphIndices">No documentation.</param>
        /// <param name = "glyphCount">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Downloading a glyph involves downloading any other glyphs it depends on from the font tables (GSUB, COLR, glyf).</p>
        /// </remarks>
        /// <doc-id>dn894582</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFaceReference::EnqueueGlyphDownloadRequest([In, Buffer] const unsigned short* glyphIndices,[In] unsigned int glyphCount)</unmanaged>
        /// <unmanaged-short>IDWriteFontFaceReference::EnqueueGlyphDownloadRequest</unmanaged-short>
        public unsafe void EnqueueGlyphDownloadRequest(System.Int16[] glyphIndices, System.Int32 glyphCount)
        {
            SharpDX.Result __result__;
            fixed (void *glyphIndices_ = glyphIndices)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, glyphIndices_, glyphCount, (*(void ***)this._nativePointer)[15]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Adds a request to the font download queue (<strong><see cref = "SharpDX.DirectWrite.FontDownloadQueue"/></strong>).</p>
        /// </summary>
        /// <param name = "fileOffset">No documentation.</param>
        /// <param name = "fragmentSize">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn894580</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFaceReference::EnqueueFileFragmentDownloadRequest([In] unsigned longlong fileOffset,[In] unsigned longlong fragmentSize)</unmanaged>
        /// <unmanaged-short>IDWriteFontFaceReference::EnqueueFileFragmentDownloadRequest</unmanaged-short>
        public unsafe void EnqueueFileFragmentDownloadRequest(System.Int64 fileOffset, System.Int64 fragmentSize)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, fileOffset, fragmentSize, (*(void ***)this._nativePointer)[16]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("EFA008F9-F7A1-48BF-B05C-F224713CC0FF")]
    public partial class FontFallback : SharpDX.ComObject
    {
        public FontFallback(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator FontFallback(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new FontFallback(nativePtr);
        /// <summary>
        /// <p>Determines an appropriate font to use to render the beginning range of text.</p>
        /// </summary>
        /// <param name = "analysisSource"><dd>  <p>The text source implementation holds the text and locale.</p> </dd></param>
        /// <param name = "textPosition"><dd>  <p>Starting position to analyze.</p> </dd></param>
        /// <param name = "textLength"><dd>  <p>Length of the text to analyze.</p> </dd></param>
        /// <param name = "baseFontCollection"><dd>  <p>Default font collection to use.</p> </dd></param>
        /// <param name = "baseFamilyName"><dd>  <p>Family name of the base font. If you pass null, no matching     will be done against the family.</p> </dd></param>
        /// <param name = "baseWeight"><dd>  <p>The desired weight.</p> </dd></param>
        /// <param name = "baseStyle"><dd>  <p>The desired style.</p> </dd></param>
        /// <param name = "baseStretch"><dd>  <p>The desired stretch.</p> </dd></param>
        /// <param name = "mappedLength"><dd>  <p>Length of text mapped to the mapped font. This will always be less than     or equal to the text length and greater than zero (if the text length is non-zero) so     the caller advances at least one character.</p> </dd></param>
        /// <param name = "mappedFont"><dd>  <p>The font that should be used to render the first <em>mappedLength</em> characters of the text. If it returns <c>null</c>, that means that no font can render the     text, and <em>mappedLength</em> is the number of characters to skip (rendered with a missing glyph).</p> </dd></param>
        /// <param name = "scale"><dd>  <p>Scale factor to multiply the em size of the returned font by.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn280480</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFallback::MapCharacters([In] IDWriteTextAnalysisSource* analysisSource,[In] unsigned int textPosition,[In] unsigned int textLength,[In, Optional] IDWriteFontCollection* baseFontCollection,[In, Optional] const wchar_t* baseFamilyName,[In] DWRITE_FONT_WEIGHT baseWeight,[In] DWRITE_FONT_STYLE baseStyle,[In] DWRITE_FONT_STRETCH baseStretch,[Out] unsigned int* mappedLength,[Out, Optional] IDWriteFont** mappedFont,[Out] float* scale)</unmanaged>
        /// <unmanaged-short>IDWriteFontFallback::MapCharacters</unmanaged-short>
        public unsafe void MapCharacters(SharpDX.DirectWrite.TextAnalysisSource analysisSource, System.Int32 textPosition, System.Int32 textLength, SharpDX.DirectWrite.FontCollection baseFontCollection, System.String baseFamilyName, SharpDX.DirectWrite.FontWeight baseWeight, SharpDX.DirectWrite.FontStyle baseStyle, SharpDX.DirectWrite.FontStretch baseStretch, out System.Int32 mappedLength, out SharpDX.DirectWrite.Font mappedFont, out System.Single scale)
        {
            System.IntPtr analysisSource_ = System.IntPtr.Zero;
            System.IntPtr baseFontCollection_ = System.IntPtr.Zero;
            System.IntPtr mappedFont_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            analysisSource_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.TextAnalysisSource>(analysisSource);
            baseFontCollection_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.FontCollection>(baseFontCollection);
            fixed (void *scale_ = &scale)
                fixed (void *mappedLength_ = &mappedLength)
                    fixed (char *baseFamilyName_ = baseFamilyName)
                        __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)analysisSource_, textPosition, textLength, (void *)baseFontCollection_, (void *)baseFamilyName_, unchecked ((System.Int32)baseWeight), unchecked ((System.Int32)baseStyle), unchecked ((System.Int32)baseStretch), mappedLength_, &mappedFont_, scale_, (*(void ***)this._nativePointer)[3]);
            if (mappedFont_ != System.IntPtr.Zero)
                mappedFont = new SharpDX.DirectWrite.Font(mappedFont_);
            else
                mappedFont = null;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("FD882D06-8ABA-4FB8-B849-8BE8B73E14DE")]
    public partial class FontFallbackBuilder : SharpDX.ComObject
    {
        public FontFallbackBuilder(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator FontFallbackBuilder(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new FontFallbackBuilder(nativePtr);
        /// <summary>
        /// <p>Appends a single mapping to the list. Call this once for each additional mapping.</p>
        /// </summary>
        /// <param name = "ranges"><dd>  <p>Unicode ranges that apply to this mapping.</p> </dd></param>
        /// <param name = "rangesCount"><dd>  <p>Number of Unicode ranges.</p> </dd></param>
        /// <param name = "targetFamilyNames"><dd>  <p>List of target family name strings.</p> </dd></param>
        /// <param name = "targetFamilyNamesCount"><dd>  <p>Number of target family names.</p> </dd></param>
        /// <param name = "fontCollection"><dd>  <p>Optional explicit font collection for this mapping.</p> </dd></param>
        /// <param name = "localeName"><dd>  <p>Locale of the context.</p> </dd></param>
        /// <param name = "baseFamilyName"><dd>  <p>Base family name to match against, if applicable.</p> </dd></param>
        /// <param name = "scale"><dd>  <p>Scale factor to multiply the result target font by.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn280477</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFallbackBuilder::AddMapping([In, Buffer] const DWRITE_UNICODE_RANGE* ranges,[In] unsigned int rangesCount,[In, Buffer] const wchar_t** targetFamilyNames,[In] unsigned int targetFamilyNamesCount,[In, Optional] IDWriteFontCollection* fontCollection,[In, Optional] const wchar_t* localeName,[In, Optional] const wchar_t* baseFamilyName,[In] float scale)</unmanaged>
        /// <unmanaged-short>IDWriteFontFallbackBuilder::AddMapping</unmanaged-short>
        public unsafe void AddMapping(SharpDX.DirectWrite.UnicodeRange[] ranges, System.Int32 rangesCount, System.String targetFamilyNames, System.Int32 targetFamilyNamesCount, SharpDX.DirectWrite.FontCollection fontCollection, System.String localeName, System.String baseFamilyName, System.Single scale)
        {
            System.IntPtr fontCollection_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fontCollection_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.FontCollection>(fontCollection);
            fixed (char *baseFamilyName_ = baseFamilyName)
                fixed (char *localeName_ = localeName)
                    fixed (char *targetFamilyNames_ = targetFamilyNames)
                        fixed (void *ranges_ = ranges)
                            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, ranges_, rangesCount, (void *)targetFamilyNames_, targetFamilyNamesCount, (void *)fontCollection_, (void *)localeName_, (void *)baseFamilyName_, scale, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Add all the mappings from an existing font fallback object.</p>
        /// </summary>
        /// <param name = "fontFallback"><dd>  <p>An existing font fallback object.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn280478</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFallbackBuilder::AddMappings([In] IDWriteFontFallback* fontFallback)</unmanaged>
        /// <unmanaged-short>IDWriteFontFallbackBuilder::AddMappings</unmanaged-short>
        public unsafe void AddMappings(SharpDX.DirectWrite.FontFallback fontFallback)
        {
            System.IntPtr fontFallback_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fontFallback_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.FontFallback>(fontFallback);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)fontFallback_, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates the finalized fallback object from the mappings added.</p>
        /// </summary>
        /// <param name = "fontFallback"><dd> <p>Contains an address of a reference to the created fallback list.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn280479</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFallbackBuilder::CreateFontFallback([Out] IDWriteFontFallback** fontFallback)</unmanaged>
        /// <unmanaged-short>IDWriteFontFallbackBuilder::CreateFontFallback</unmanaged-short>
        public unsafe void CreateFontFallback(out SharpDX.DirectWrite.FontFallback fontFallback)
        {
            System.IntPtr fontFallback_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &fontFallback_, (*(void ***)this._nativePointer)[5]);
            if (fontFallback_ != System.IntPtr.Zero)
                fontFallback = new SharpDX.DirectWrite.FontFallback(fontFallback_);
            else
                fontFallback = null;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("da20d8ef-812a-4c43-9802-62ec4abd7add")]
    public partial class FontFamily : SharpDX.DirectWrite.FontList
    {
        public FontFamily(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator FontFamily(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new FontFamily(nativePtr);
        /// <summary>
        /// <p> Creates a localized strings object that contains the family names for the font family, indexed by locale name. </p>
        /// </summary>
        /// <remarks>
        /// <p> The following code example shows how to get the font family name from a <strong><see cref = "SharpDX.DirectWrite.FontFamily"/></strong> object.</p><pre><see cref = "SharpDX.DirectWrite.LocalizedStrings"/>* pFamilyNames = <c>null</c>; // Get a list of localized strings for the family name.
        /// if (SUCCEEDED(hr))
        /// { hr = pFontFamily-&gt;GetFamilyNames(&amp;pFamilyNames);
        /// } UINT32 index = 0;
        /// <see cref = "SharpDX.Mathematics.Interop.RawBool"/> exists = false; wchar_t localeName[LOCALE_NAME_MAX_LENGTH]; if (SUCCEEDED(hr))
        /// { // Get the default locale for this user. int defaultLocaleSuccess = GetUserDefaultLocaleName(localeName, LOCALE_NAME_MAX_LENGTH); // If the default locale is returned, find that locale name, otherwise use "en-us". if (defaultLocaleSuccess) { hr = pFamilyNames-&gt;FindLocaleName(localeName, &amp;index, &amp;exists); } if (SUCCEEDED(hr) &amp; &amp; !exists) // if the above find did not find a match, retry with US English { hr = pFamilyNames-&gt;FindLocaleName(L"en-us", &amp;index, &amp;exists); }
        /// } // If the specified locale doesn't exist, select the first on the list.
        /// if (!exists) index = 0; UINT32 length = 0; // Get the string length.
        /// if (SUCCEEDED(hr))
        /// { hr = pFamilyNames-&gt;GetStringLength(index, &amp;length);
        /// } // Allocate a string big enough to hold the name.
        /// wchar_t* name = new (std::nothrow) wchar_t[length+1];
        /// if (name == <c>null</c>)
        /// { hr = E_OUTOFMEMORY;
        /// } // Get the family name.
        /// if (SUCCEEDED(hr))
        /// { hr = pFamilyNames-&gt;GetString(index, name, length+1);
        /// }
        /// </pre>
        /// </remarks>
        /// <doc-id>dd371047</doc-id>
        /// <unmanaged>GetFamilyNames</unmanaged>
        /// <unmanaged-short>GetFamilyNames</unmanaged-short>
        public SharpDX.DirectWrite.LocalizedStrings FamilyNames
        {
            get
            {
                GetFamilyNames(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p> Creates a localized strings object that contains the family names for the font family, indexed by locale name. </p>
        /// </summary>
        /// <param name = "names"><dd>  <p>The address of a reference to the newly created <strong><see cref = "SharpDX.DirectWrite.LocalizedStrings"/></strong> object.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p> The following code example shows how to get the font family name from a <strong><see cref = "SharpDX.DirectWrite.FontFamily"/></strong> object.</p><pre><see cref = "SharpDX.DirectWrite.LocalizedStrings"/>* pFamilyNames = <c>null</c>; // Get a list of localized strings for the family name.
        /// if (SUCCEEDED(hr))
        /// { hr = pFontFamily-&gt;GetFamilyNames(&amp;pFamilyNames);
        /// } UINT32 index = 0;
        /// <see cref = "SharpDX.Mathematics.Interop.RawBool"/> exists = false; wchar_t localeName[LOCALE_NAME_MAX_LENGTH]; if (SUCCEEDED(hr))
        /// { // Get the default locale for this user. int defaultLocaleSuccess = GetUserDefaultLocaleName(localeName, LOCALE_NAME_MAX_LENGTH); // If the default locale is returned, find that locale name, otherwise use "en-us". if (defaultLocaleSuccess) { hr = pFamilyNames-&gt;FindLocaleName(localeName, &amp;index, &amp;exists); } if (SUCCEEDED(hr) &amp; &amp; !exists) // if the above find did not find a match, retry with US English { hr = pFamilyNames-&gt;FindLocaleName(L"en-us", &amp;index, &amp;exists); }
        /// } // If the specified locale doesn't exist, select the first on the list.
        /// if (!exists) index = 0; UINT32 length = 0; // Get the string length.
        /// if (SUCCEEDED(hr))
        /// { hr = pFamilyNames-&gt;GetStringLength(index, &amp;length);
        /// } // Allocate a string big enough to hold the name.
        /// wchar_t* name = new (std::nothrow) wchar_t[length+1];
        /// if (name == <c>null</c>)
        /// { hr = E_OUTOFMEMORY;
        /// } // Get the family name.
        /// if (SUCCEEDED(hr))
        /// { hr = pFamilyNames-&gt;GetString(index, name, length+1);
        /// }
        /// </pre>
        /// </remarks>
        /// <doc-id>dd371047</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFamily::GetFamilyNames([Out] IDWriteLocalizedStrings** names)</unmanaged>
        /// <unmanaged-short>IDWriteFontFamily::GetFamilyNames</unmanaged-short>
        internal unsafe void GetFamilyNames(out SharpDX.DirectWrite.LocalizedStrings names)
        {
            System.IntPtr names_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &names_, (*(void ***)this._nativePointer)[6]);
            if (names_ != System.IntPtr.Zero)
                names = new SharpDX.DirectWrite.LocalizedStrings(names_);
            else
                names = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Gets the font that best matches the specified properties. </p>
        /// </summary>
        /// <param name = "weight"><dd>  <p>A value that is used to match a requested font weight.</p> </dd></param>
        /// <param name = "stretch"><dd>  <p>A value that is used to match a requested font stretch.</p> </dd></param>
        /// <param name = "style"><dd>  <p>A value that is used to match a requested font style.</p> </dd></param>
        /// <returns><dd>  <p>When this method returns, contains the address of a reference to the newly created <strong><see cref = "SharpDX.DirectWrite.Font"/></strong> object.</p> </dd></returns>
        /// <doc-id>dd371051</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFamily::GetFirstMatchingFont([In] DWRITE_FONT_WEIGHT weight,[In] DWRITE_FONT_STRETCH stretch,[In] DWRITE_FONT_STYLE style,[Out] IDWriteFont** matchingFont)</unmanaged>
        /// <unmanaged-short>IDWriteFontFamily::GetFirstMatchingFont</unmanaged-short>
        public unsafe SharpDX.DirectWrite.Font GetFirstMatchingFont(SharpDX.DirectWrite.FontWeight weight, SharpDX.DirectWrite.FontStretch stretch, SharpDX.DirectWrite.FontStyle style)
        {
            SharpDX.DirectWrite.Font matchingFont;
            System.IntPtr matchingFont_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)weight), unchecked ((System.Int32)stretch), unchecked ((System.Int32)style), &matchingFont_, (*(void ***)this._nativePointer)[7]);
            if (matchingFont_ != System.IntPtr.Zero)
                matchingFont = new SharpDX.DirectWrite.Font(matchingFont_);
            else
                matchingFont = null;
            __result__.CheckError();
            return matchingFont;
        }

        /// <summary>
        /// <p> Gets a list of fonts in the font family ranked in order of how well they match the specified properties. </p>
        /// </summary>
        /// <param name = "weight"><dd>  <p>A value that is used to match a requested font weight.</p> </dd></param>
        /// <param name = "stretch"><dd>  <p>A value that is used to match a requested font stretch.</p> </dd></param>
        /// <param name = "style"><dd>  <p>A value that is used to match a requested font style.</p> </dd></param>
        /// <returns><dd>  <p>An address of a reference to the newly created <strong><see cref = "SharpDX.DirectWrite.FontList"/></strong> object.</p> </dd></returns>
        /// <doc-id>dd371056</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFamily::GetMatchingFonts([In] DWRITE_FONT_WEIGHT weight,[In] DWRITE_FONT_STRETCH stretch,[In] DWRITE_FONT_STYLE style,[Out] IDWriteFontList** matchingFonts)</unmanaged>
        /// <unmanaged-short>IDWriteFontFamily::GetMatchingFonts</unmanaged-short>
        public unsafe SharpDX.DirectWrite.FontList GetMatchingFonts(SharpDX.DirectWrite.FontWeight weight, SharpDX.DirectWrite.FontStretch stretch, SharpDX.DirectWrite.FontStyle style)
        {
            SharpDX.DirectWrite.FontList matchingFonts;
            System.IntPtr matchingFonts_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)weight), unchecked ((System.Int32)stretch), unchecked ((System.Int32)style), &matchingFonts_, (*(void ***)this._nativePointer)[8]);
            if (matchingFonts_ != System.IntPtr.Zero)
                matchingFonts = new SharpDX.DirectWrite.FontList(matchingFonts_);
            else
                matchingFonts = null;
            __result__.CheckError();
            return matchingFonts;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("DA20D8EF-812A-4C43-9802-62EC4ABD7ADF")]
    public partial class FontFamily1 : SharpDX.DirectWrite.FontFamily
    {
        public FontFamily1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator FontFamily1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new FontFamily1(nativePtr);
        /// <summary>
        /// <p>Gets the current location of a font given its zero-based index.</p>
        /// </summary>
        /// <param name = "listIndex"><dd>  <p>Zero-based index of the font in the font list.</p> </dd></param>
        /// <returns><p>Returns a <strong><see cref = "SharpDX.DirectWrite.Locality"/></strong>-typed value that specifies the location of the specified font.</p></returns>
        /// <remarks>
        /// <p>For fully local files, the result will always be <strong>DWRITE_LOCALITY_LOCAL</strong>. For streamed files, the result depends on how much of the file has been downloaded. <strong>GetFont</strong> fails if the locality is <strong>DWRITE_LOCALITY_REMOTE</strong> and potentially fails if <strong>DWRITE_LOCALITY_PARTIAL</strong>. </p>
        /// </remarks>
        /// <doc-id>dn894593</doc-id>
        /// <unmanaged>DWRITE_LOCALITY IDWriteFontFamily1::GetFontLocality([In] unsigned int listIndex)</unmanaged>
        /// <unmanaged-short>IDWriteFontFamily1::GetFontLocality</unmanaged-short>
        public unsafe SharpDX.DirectWrite.Locality GetFontLocality(System.Int32 listIndex)
        {
            SharpDX.DirectWrite.Locality __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirectWriteLocality(this._nativePointer, listIndex, (*(void ***)this._nativePointer)[9]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets a font given its zero-based index.</p>
        /// </summary>
        /// <param name = "listIndex"><dd>  <p>Zero-based index of the font in the font list.</p> </dd></param>
        /// <param name = "font"><dd>  <p>A reference to a memory block that receives a reference to a <strong><see cref = "SharpDX.DirectWrite.Font3"/></strong> interface for the newly created font object.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn894591</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFamily1::GetFont([In] unsigned int listIndex,[Out] IDWriteFont3** font)</unmanaged>
        /// <unmanaged-short>IDWriteFontFamily1::GetFont</unmanaged-short>
        public unsafe void GetFont(System.Int32 listIndex, out SharpDX.DirectWrite.Font3 font)
        {
            System.IntPtr font_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, listIndex, &font_, (*(void ***)this._nativePointer)[10]);
            if (font_ != System.IntPtr.Zero)
                font = new SharpDX.DirectWrite.Font3(font_);
            else
                font = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets a font face reference given its zero-based index.</p>
        /// </summary>
        /// <param name = "listIndex"><dd>  <p>Zero-based index of the font in the font list.</p> </dd></param>
        /// <param name = "fontFaceReference"><dd>  <p>A reference to a memory block that receives a reference to a <strong><see cref = "SharpDX.DirectWrite.FontFaceReference"/></strong> interface for the newly created font face reference object.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn894592</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFamily1::GetFontFaceReference([In] unsigned int listIndex,[Out] IDWriteFontFaceReference** fontFaceReference)</unmanaged>
        /// <unmanaged-short>IDWriteFontFamily1::GetFontFaceReference</unmanaged-short>
        public unsafe void GetFontFaceReference(System.Int32 listIndex, out SharpDX.DirectWrite.FontFaceReference fontFaceReference)
        {
            System.IntPtr fontFaceReference_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, listIndex, &fontFaceReference_, (*(void ***)this._nativePointer)[11]);
            if (fontFaceReference_ != System.IntPtr.Zero)
                fontFaceReference = new SharpDX.DirectWrite.FontFaceReference(fontFaceReference_);
            else
                fontFaceReference = null;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("739d886a-cef5-47dc-8769-1a8b41bebbb0")]
    public partial class FontFile : SharpDX.ComObject
    {
        public FontFile(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator FontFile(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new FontFile(nativePtr);
        /// <summary>
        /// <p> Obtains the reference to the reference key of a font file. The returned reference is valid until the font file object is released.  </p>
        /// </summary>
        /// <param name = "fontFileReferenceKey"><dd>  <p>When this method returns, contains an address of  a reference to the font file reference key. Note that the reference value is only valid until the font file object it is obtained from is released. This parameter is passed uninitialized.</p> </dd></param>
        /// <param name = "fontFileReferenceKeySize"><dd>  <p>When this method returns, contains the size of the font file reference key in bytes. This parameter is passed uninitialized.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371108</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFile::GetReferenceKey([Out, Buffer] const void** fontFileReferenceKey,[Out] unsigned int* fontFileReferenceKeySize)</unmanaged>
        /// <unmanaged-short>IDWriteFontFile::GetReferenceKey</unmanaged-short>
        internal unsafe void GetReferenceKey(System.IntPtr fontFileReferenceKey, out System.Int32 fontFileReferenceKeySize)
        {
            SharpDX.Result __result__;
            fixed (void *fontFileReferenceKeySize_ = &fontFileReferenceKeySize)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)fontFileReferenceKey, fontFileReferenceKeySize_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Obtains the file loader associated with a font file object. </p>
        /// </summary>
        /// <param name = "fontFileLoader"><dd>  <p>When this method returns, contains the address of  a reference to the font file loader associated with the font file object.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371104</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFile::GetLoader([Out] IDWriteFontFileLoader** fontFileLoader)</unmanaged>
        /// <unmanaged-short>IDWriteFontFile::GetLoader</unmanaged-short>
        internal unsafe void GetLoader(out SharpDX.DirectWrite.FontFileLoader fontFileLoader)
        {
            System.IntPtr fontFileLoader_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &fontFileLoader_, (*(void ***)this._nativePointer)[4]);
            if (fontFileLoader_ != System.IntPtr.Zero)
                fontFileLoader = new SharpDX.DirectWrite.FontFileLoaderNative(fontFileLoader_);
            else
                fontFileLoader = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Analyzes a file and returns whether it represents a font, and whether the font type is supported by the font system. </p>
        /// </summary>
        /// <param name = "isSupportedFontType"><dd>  <p><strong>TRUE</strong> if the font type is supported by the font system; otherwise, <strong><see cref = "SharpDX.Result.False"/></strong>.</p> </dd></param>
        /// <param name = "fontFileType"><dd>  <p>When this method returns, contains a value that indicates the type of the font file. Note that even if <em> isSupportedFontType</em> is <strong><see cref = "SharpDX.Result.False"/></strong>, the <em>fontFileType</em> value may be different from <strong>DWRITE_FONT_FILE_TYPE_UNKNOWN</strong>.</p> </dd></param>
        /// <param name = "fontFaceType"><dd>  <p>When this method returns, contains a value that indicates the type of the font face. If <em>fontFileType</em> is not equal to <strong>DWRITE_FONT_FILE_TYPE_UNKNOWN</strong>, then that can be constructed from the font file. </p> </dd></param>
        /// <param name = "numberOfFaces"><dd>  <p>When this method returns, contains the number of font faces contained in the font file.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <strong>Important</strong>??Certain font file types are recognized, but not supported by the font system. For example, the font system will recognize a file as a Type 1 font file but will not be able to construct a font face object from it. In such situations, <strong>Analyze</strong> will set <em>isSupportedFontType</em> output parameter to <strong><see cref = "SharpDX.Result.False"/></strong>.?
        /// </remarks>
        /// <doc-id>dd371099</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFile::Analyze([Out] BOOL* isSupportedFontType,[Out] DWRITE_FONT_FILE_TYPE* fontFileType,[Out, Optional] DWRITE_FONT_FACE_TYPE* fontFaceType,[Out] unsigned int* numberOfFaces)</unmanaged>
        /// <unmanaged-short>IDWriteFontFile::Analyze</unmanaged-short>
        public unsafe void Analyze(out SharpDX.Mathematics.Interop.RawBool isSupportedFontType, out SharpDX.DirectWrite.FontFileType fontFileType, out SharpDX.DirectWrite.FontFaceType fontFaceType, out System.Int32 numberOfFaces)
        {
            isSupportedFontType = default (SharpDX.Mathematics.Interop.RawBool);
            SharpDX.Result __result__;
            fixed (void *numberOfFaces_ = &numberOfFaces)
                fixed (void *fontFaceType_ = &fontFaceType)
                    fixed (void *fontFileType_ = &fontFileType)
                        fixed (void *isSupportedFontType_ = &isSupportedFontType)
                            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, isSupportedFontType_, fontFileType_, fontFaceType_, numberOfFaces_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("72755049-5ff7-435d-8348-4be97cfa6c7c")]
    public partial interface FontFileEnumerator : SharpDX.IUnknown
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("727cad4e-d6af-4c9e-8a08-d695b11caa49")]
    public partial interface FontFileLoader : SharpDX.IUnknown
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("727cad4e-d6af-4c9e-8a08-d695b11caa49")]
    public partial class FontFileLoaderNative : SharpDX.ComObject, SharpDX.DirectWrite.FontFileLoader
    {
        public FontFileLoaderNative(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator FontFileLoaderNative(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new FontFileLoaderNative(nativePtr);
        /// <summary>
        /// <p> Creates a font file stream object that encapsulates an open file resource. </p>
        /// </summary>
        /// <param name = "fontFileReferenceKey"><dd>  <p>A reference to a font file reference key that uniquely identifies the font file resource within the scope of the font loader being used. The buffer allocated for this key must at least be the size, in bytes, specified by <em> fontFileReferenceKeySize</em>.</p> </dd></param>
        /// <param name = "fontFileReferenceKeySize"><dd>  <p>The size of font file reference key, in bytes.</p> </dd></param>
        /// <param name = "fontFileStream"><dd>  <p>When this method returns, contains the address of a reference to the newly created <strong><see cref = "SharpDX.DirectWrite.FontFileStream"/></strong> object.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The resource is closed when the last reference to <em>fontFileStream</em> is released. </p>
        /// </remarks>
        /// <doc-id>dd371077</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFileLoader::CreateStreamFromKey([In, Buffer] const void* fontFileReferenceKey,[In] unsigned int fontFileReferenceKeySize,[Out] IDWriteFontFileStream** fontFileStream)</unmanaged>
        /// <unmanaged-short>IDWriteFontFileLoader::CreateStreamFromKey</unmanaged-short>
        internal unsafe void CreateStreamFromKey_(System.IntPtr fontFileReferenceKey, System.Int32 fontFileReferenceKeySize, out SharpDX.DirectWrite.FontFileStream fontFileStream)
        {
            System.IntPtr fontFileStream_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)fontFileReferenceKey, fontFileReferenceKeySize, &fontFileStream_, (*(void ***)this._nativePointer)[3]);
            if (fontFileStream_ != System.IntPtr.Zero)
                fontFileStream = new SharpDX.DirectWrite.FontFileStreamNative(fontFileStream_);
            else
                fontFileStream = null;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("6d4865fe-0ab8-4d91-8f62-5dd6be34a3e0")]
    public partial interface FontFileStream : SharpDX.IUnknown
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("6d4865fe-0ab8-4d91-8f62-5dd6be34a3e0")]
    public partial class FontFileStreamNative : SharpDX.ComObject, SharpDX.DirectWrite.FontFileStream
    {
        public FontFileStreamNative(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator FontFileStreamNative(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new FontFileStreamNative(nativePtr);
        /// <summary>
        /// <p> Obtains the total size of a file. </p>
        /// </summary>
        /// <remarks>
        /// <p> Implementing <strong>GetFileSize</strong>() for asynchronously loaded font files may require downloading the complete file contents. Therefore, this method should be used only for operations that either require a complete font file to be loaded (for example, copying a font file) or that need to make decisions based on the value of the file size (for example, validation against a persisted file size). </p>
        /// </remarks>
        /// <doc-id>dd371084</doc-id>
        /// <unmanaged>GetFileSize</unmanaged>
        /// <unmanaged-short>GetFileSize</unmanaged-short>
        public System.Int64 FileSize_
        {
            get
            {
                GetFileSize_(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p> Obtains the last modified time of the file.  </p>
        /// </summary>
        /// <remarks>
        /// <p>The "last modified time" is used by DirectWrite font selection algorithms to determine whether one font resource is more up to date than another one.</p>
        /// </remarks>
        /// <doc-id>dd371089</doc-id>
        /// <unmanaged>GetLastWriteTime</unmanaged>
        /// <unmanaged-short>GetLastWriteTime</unmanaged-short>
        public System.Int64 LastWriteTime_
        {
            get
            {
                GetLastWriteTime_(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p> Reads a fragment from a font file. </p>
        /// </summary>
        /// <param name = "fragmentStart"><dd>  <p>When this method returns, contains an address of a  reference to the start of the font file fragment.  This parameter is passed uninitialized.</p> </dd></param>
        /// <param name = "fileOffset"><dd>  <p>The offset of the fragment, in bytes, from the beginning of the font file.</p> </dd></param>
        /// <param name = "fragmentSize"><dd>  <p>The size of the file fragment, in bytes.</p> </dd></param>
        /// <param name = "fragmentContext"><dd>  <p>When this method returns, contains the address of a reference to a reference to the client-defined context to be passed to <strong>ReleaseFileFragment</strong>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p> Note that <strong>ReadFileFragment</strong> implementations must check whether the requested font file fragment is within the file bounds. Otherwise, an error should be returned from <strong>ReadFileFragment</strong>. </p><p> DirectWrite may invoke <strong><see cref = "SharpDX.DirectWrite.FontFileStream"/></strong> methods on the same object from multiple threads simultaneously. Therefore, <strong>ReadFileFragment</strong> implementations that rely on internal mutable state must serialize access to such state across multiple threads. For example, an implementation that uses separate Seek and Read operations to read a file fragment must place the code block containing Seek and Read calls under a lock or a critical section.</p>
        /// </remarks>
        /// <doc-id>dd371091</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFileStream::ReadFileFragment([Out] const void** fragmentStart,[In] unsigned longlong fileOffset,[In] unsigned longlong fragmentSize,[Out] void** fragmentContext)</unmanaged>
        /// <unmanaged-short>IDWriteFontFileStream::ReadFileFragment</unmanaged-short>
        internal unsafe void ReadFileFragment_(out System.IntPtr fragmentStart, System.Int64 fileOffset, System.Int64 fragmentSize, out System.IntPtr fragmentContext)
        {
            SharpDX.Result __result__;
            fixed (void *fragmentContext_ = &fragmentContext)
                fixed (void *fragmentStart_ = &fragmentStart)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, fragmentStart_, fileOffset, fragmentSize, fragmentContext_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Releases a fragment from a file. </p>
        /// </summary>
        /// <param name = "fragmentContext"><dd>  <p>A reference to the client-defined context of a font fragment returned from <strong>ReadFileFragment</strong>.</p> </dd></param>
        /// <doc-id>dd371095</doc-id>
        /// <unmanaged>void IDWriteFontFileStream::ReleaseFileFragment([In] void* fragmentContext)</unmanaged>
        /// <unmanaged-short>IDWriteFontFileStream::ReleaseFileFragment</unmanaged-short>
        internal unsafe void ReleaseFileFragment_(System.IntPtr fragmentContext)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)fragmentContext, (*(void ***)this._nativePointer)[4]);
        }

        /// <summary>
        /// <p> Obtains the total size of a file. </p>
        /// </summary>
        /// <param name = "fileSize"><dd>  <p>When this method returns, contains the total size of the file.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p> Implementing <strong>GetFileSize</strong>() for asynchronously loaded font files may require downloading the complete file contents. Therefore, this method should be used only for operations that either require a complete font file to be loaded (for example, copying a font file) or that need to make decisions based on the value of the file size (for example, validation against a persisted file size). </p>
        /// </remarks>
        /// <doc-id>dd371084</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFileStream::GetFileSize([Out] unsigned longlong* fileSize)</unmanaged>
        /// <unmanaged-short>IDWriteFontFileStream::GetFileSize</unmanaged-short>
        internal unsafe void GetFileSize_(out System.Int64 fileSize)
        {
            SharpDX.Result __result__;
            fixed (void *fileSize_ = &fileSize)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, fileSize_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Obtains the last modified time of the file.  </p>
        /// </summary>
        /// <param name = "lastWriteTime"><dd>  <p>When this method returns, contains  the last modified time of the file in the format that represents the number of 100-nanosecond intervals since January 1, 1601 (UTC).</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The "last modified time" is used by DirectWrite font selection algorithms to determine whether one font resource is more up to date than another one.</p>
        /// </remarks>
        /// <doc-id>dd371089</doc-id>
        /// <unmanaged>HRESULT IDWriteFontFileStream::GetLastWriteTime([Out] unsigned longlong* lastWriteTime)</unmanaged>
        /// <unmanaged-short>IDWriteFontFileStream::GetLastWriteTime</unmanaged-short>
        internal unsafe void GetLastWriteTime_(out System.Int64 lastWriteTime)
        {
            SharpDX.Result __result__;
            fixed (void *lastWriteTime_ = &lastWriteTime)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, lastWriteTime_, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("1a0d8438-1d97-4ec1-aef9-a2fb86ed6acb")]
    public partial class FontList : SharpDX.ComObject
    {
        public FontList(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator FontList(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new FontList(nativePtr);
        /// <summary>
        /// <p> Gets the font collection that contains the fonts in the font list.</p>
        /// </summary>
        /// <doc-id>dd371129</doc-id>
        /// <unmanaged>GetFontCollection</unmanaged>
        /// <unmanaged-short>GetFontCollection</unmanaged-short>
        public SharpDX.DirectWrite.FontCollection FontCollection
        {
            get
            {
                GetFontCollection(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p> Gets the number of fonts in the font list. </p>
        /// </summary>
        /// <doc-id>dd371133</doc-id>
        /// <unmanaged>GetFontCount</unmanaged>
        /// <unmanaged-short>GetFontCount</unmanaged-short>
        public System.Int32 FontCount
        {
            get => GetFontCount();
        }

        /// <summary>
        /// <p> Gets the font collection that contains the fonts in the font list.</p>
        /// </summary>
        /// <param name = "fontCollection"><dd>  <p>When this method returns, contains the address of a reference to the current <strong><see cref = "SharpDX.DirectWrite.FontCollection"/></strong> object.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371129</doc-id>
        /// <unmanaged>HRESULT IDWriteFontList::GetFontCollection([Out] IDWriteFontCollection** fontCollection)</unmanaged>
        /// <unmanaged-short>IDWriteFontList::GetFontCollection</unmanaged-short>
        internal unsafe void GetFontCollection(out SharpDX.DirectWrite.FontCollection fontCollection)
        {
            System.IntPtr fontCollection_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &fontCollection_, (*(void ***)this._nativePointer)[3]);
            if (fontCollection_ != System.IntPtr.Zero)
                fontCollection = new SharpDX.DirectWrite.FontCollection(fontCollection_);
            else
                fontCollection = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Gets the number of fonts in the font list. </p>
        /// </summary>
        /// <returns><p>The number of fonts in the font list.</p></returns>
        /// <doc-id>dd371133</doc-id>
        /// <unmanaged>unsigned int IDWriteFontList::GetFontCount()</unmanaged>
        /// <unmanaged-short>IDWriteFontList::GetFontCount</unmanaged-short>
        internal unsafe System.Int32 GetFontCount()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[4]);
            return __result__;
        }

        /// <summary>
        /// <p> Gets a font given its zero-based index. </p>
        /// </summary>
        /// <param name = "index"><dd>  <p>Zero-based index of the font in the font list.</p> </dd></param>
        /// <returns><dd>  <p>When this method returns, contains the address of a reference to the newly created <strong><see cref = "SharpDX.DirectWrite.Font"/></strong> object.</p> </dd></returns>
        /// <doc-id>dd371125</doc-id>
        /// <unmanaged>HRESULT IDWriteFontList::GetFont([In] unsigned int index,[Out] IDWriteFont** font)</unmanaged>
        /// <unmanaged-short>IDWriteFontList::GetFont</unmanaged-short>
        public unsafe SharpDX.DirectWrite.Font GetFont(System.Int32 index)
        {
            SharpDX.DirectWrite.Font font;
            System.IntPtr font_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, index, &font_, (*(void ***)this._nativePointer)[5]);
            if (font_ != System.IntPtr.Zero)
                font = new SharpDX.DirectWrite.Font(font_);
            else
                font = null;
            __result__.CheckError();
            return font;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("DA20D8EF-812A-4C43-9802-62EC4ABD7ADE")]
    public partial class FontList1 : SharpDX.DirectWrite.FontList
    {
        public FontList1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator FontList1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new FontList1(nativePtr);
        /// <summary>
        /// <p>Gets the current location of a font given its zero-based index.</p>
        /// </summary>
        /// <param name = "listIndex"><dd>  <p>Zero-based index of the font in the font list.</p> </dd></param>
        /// <returns><p>Returns a <strong><see cref = "SharpDX.DirectWrite.Locality"/></strong>-typed value that specifies the location of the specified font.</p></returns>
        /// <remarks>
        /// <p>For fully local files, the result will always be <strong>DWRITE_LOCALITY_LOCAL</strong>. For streamed files, the result depends on how much of the file has been downloaded. <strong>GetFont</strong> fails if the locality is <strong>DWRITE_LOCALITY_REMOTE</strong> and potentially fails if <strong>DWRITE_LOCALITY_PARTIAL</strong>. </p>
        /// </remarks>
        /// <doc-id>dn900386</doc-id>
        /// <unmanaged>DWRITE_LOCALITY IDWriteFontList1::GetFontLocality([In] unsigned int listIndex)</unmanaged>
        /// <unmanaged-short>IDWriteFontList1::GetFontLocality</unmanaged-short>
        public unsafe SharpDX.DirectWrite.Locality GetFontLocality(System.Int32 listIndex)
        {
            SharpDX.DirectWrite.Locality __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirectWriteLocality(this._nativePointer, listIndex, (*(void ***)this._nativePointer)[6]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets a font given its zero-based index.</p>
        /// </summary>
        /// <param name = "listIndex"><dd>  <p>Zero-based index of the font in the font list.</p> </dd></param>
        /// <param name = "font"><dd>  <p>A reference to a memory block that receives a reference to a <strong><see cref = "SharpDX.DirectWrite.Font3"/></strong> interface for the newly created font object.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. </p><p>This method returns <strong>DWRITE_E_REMOTEFONT</strong> if it could not construct a remote font.</p></returns>
        /// <doc-id>dn894595</doc-id>
        /// <unmanaged>HRESULT IDWriteFontList1::GetFont([In] unsigned int listIndex,[Out] IDWriteFont3** font)</unmanaged>
        /// <unmanaged-short>IDWriteFontList1::GetFont</unmanaged-short>
        public unsafe void GetFont(System.Int32 listIndex, out SharpDX.DirectWrite.Font3 font)
        {
            System.IntPtr font_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, listIndex, &font_, (*(void ***)this._nativePointer)[7]);
            if (font_ != System.IntPtr.Zero)
                font = new SharpDX.DirectWrite.Font3(font_);
            else
                font = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets a font face reference given its zero-based index.</p>
        /// </summary>
        /// <param name = "listIndex"><dd>  <p>Zero-based index of the font in the font list.</p> </dd></param>
        /// <param name = "fontFaceReference"><dd>  <p>A reference to a memory block that receives a reference to a <strong><see cref = "SharpDX.DirectWrite.FontFaceReference"/></strong> interface for the newly created font face reference object.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn900385</doc-id>
        /// <unmanaged>HRESULT IDWriteFontList1::GetFontFaceReference([In] unsigned int listIndex,[Out] IDWriteFontFaceReference** fontFaceReference)</unmanaged>
        /// <unmanaged-short>IDWriteFontList1::GetFontFaceReference</unmanaged-short>
        public unsafe void GetFontFaceReference(System.Int32 listIndex, out SharpDX.DirectWrite.FontFaceReference fontFaceReference)
        {
            System.IntPtr fontFaceReference_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, listIndex, &fontFaceReference_, (*(void ***)this._nativePointer)[8]);
            if (fontFaceReference_ != System.IntPtr.Zero)
                fontFaceReference = new SharpDX.DirectWrite.FontFaceReference(fontFaceReference_);
            else
                fontFaceReference = null;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("53585141-D9F8-4095-8321-D73CF6BD116B")]
    public partial class FontSet : SharpDX.ComObject
    {
        public FontSet(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator FontSet(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new FontSet(nativePtr);
        /// <summary>
        /// <p>Get the number of total fonts in the set.</p>
        /// </summary>
        /// <doc-id>dn933243</doc-id>
        /// <unmanaged>GetFontCount</unmanaged>
        /// <unmanaged-short>GetFontCount</unmanaged-short>
        public System.Int32 FontCount
        {
            get => GetFontCount();
        }

        /// <summary>
        /// <p>Get the number of total fonts in the set.</p>
        /// </summary>
        /// <returns><p>Returns the number of total fonts in the set.</p></returns>
        /// <doc-id>dn933243</doc-id>
        /// <unmanaged>unsigned int IDWriteFontSet::GetFontCount()</unmanaged>
        /// <unmanaged-short>IDWriteFontSet::GetFontCount</unmanaged-short>
        internal unsafe System.Int32 GetFontCount()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[3]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets a reference to the font at the specified index, which may be local or remote.</p>
        /// </summary>
        /// <param name = "listIndex"><dd>  <p>Zero-based index of the font.</p> </dd></param>
        /// <param name = "fontFaceReference"><dd>  <p>Receives a reference the font face reference object, or nullptr on failure.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn933244</doc-id>
        /// <unmanaged>HRESULT IDWriteFontSet::GetFontFaceReference([In] unsigned int listIndex,[Out] IDWriteFontFaceReference** fontFaceReference)</unmanaged>
        /// <unmanaged-short>IDWriteFontSet::GetFontFaceReference</unmanaged-short>
        public unsafe void GetFontFaceReference(System.Int32 listIndex, out SharpDX.DirectWrite.FontFaceReference fontFaceReference)
        {
            System.IntPtr fontFaceReference_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, listIndex, &fontFaceReference_, (*(void ***)this._nativePointer)[4]);
            if (fontFaceReference_ != System.IntPtr.Zero)
                fontFaceReference = new SharpDX.DirectWrite.FontFaceReference(fontFaceReference_);
            else
                fontFaceReference = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the index of the matching font face reference in the font set, with the same file, face index, and simulations.</p>
        /// </summary>
        /// <param name = "fontFaceReference"><dd>  <p>Font face object that specifies the physical font.</p> </dd></param>
        /// <param name = "listIndex"><dd>  <p>Receives the zero-based index of the matching font if the font was found, or UINT_MAX otherwise.</p> </dd></param>
        /// <param name = "exists"><dd>  <p>Receives TRUE if the font exists or <see cref = "SharpDX.Result.False"/> otherwise.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn958414</doc-id>
        /// <unmanaged>HRESULT IDWriteFontSet::FindFontFaceReference([In] IDWriteFontFaceReference* fontFaceReference,[Out] unsigned int* listIndex,[Out] BOOL* exists)</unmanaged>
        /// <unmanaged-short>IDWriteFontSet::FindFontFaceReference</unmanaged-short>
        public unsafe void FindFontFaceReference(SharpDX.DirectWrite.FontFaceReference fontFaceReference, out System.Int32 listIndex, out SharpDX.Mathematics.Interop.RawBool exists)
        {
            System.IntPtr fontFaceReference_ = System.IntPtr.Zero;
            exists = default (SharpDX.Mathematics.Interop.RawBool);
            SharpDX.Result __result__;
            fontFaceReference_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.FontFaceReference>(fontFaceReference);
            fixed (void *exists_ = &exists)
                fixed (void *listIndex_ = &listIndex)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)fontFaceReference_, listIndex_, exists_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the index of the matching font face reference in the font set, with the same file, face index, and simulations.</p>
        /// </summary>
        /// <param name = "fontFace"><dd>  <p>Font face object that specifies the physical font.</p> </dd></param>
        /// <param name = "listIndex"><dd>  <p>Receives the zero-based index of the matching font if the font was found, or UINT_MAX otherwise.</p> </dd></param>
        /// <param name = "exists"><dd>  <p>Receives TRUE if the font exists or <see cref = "SharpDX.Result.False"/> otherwise.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn933242</doc-id>
        /// <unmanaged>HRESULT IDWriteFontSet::FindFontFace([In] IDWriteFontFace* fontFace,[Out] unsigned int* listIndex,[Out] BOOL* exists)</unmanaged>
        /// <unmanaged-short>IDWriteFontSet::FindFontFace</unmanaged-short>
        public unsafe void FindFontFace(SharpDX.DirectWrite.FontFace fontFace, out System.Int32 listIndex, out SharpDX.Mathematics.Interop.RawBool exists)
        {
            System.IntPtr fontFace_ = System.IntPtr.Zero;
            exists = default (SharpDX.Mathematics.Interop.RawBool);
            SharpDX.Result __result__;
            fontFace_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.FontFace>(fontFace);
            fixed (void *exists_ = &exists)
                fixed (void *listIndex_ = &listIndex)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)fontFace_, listIndex_, exists_, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Returns all unique property values in the set, which can be used for purposes such as displaying a family list or tag cloud. Values are returned in priority order according to the language list, such that if a font contains more than one localized name, the preferred one will be returned.</p>
        /// </summary>
        /// <param name = "propertyID"><dd>  <p>Font property of interest.</p> </dd></param>
        /// <param name = "values"><dd>  <p>Receives a reference to the newly created strings list.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn933250</doc-id>
        /// <unmanaged>HRESULT IDWriteFontSet::GetPropertyValues([In] DWRITE_FONT_PROPERTY_ID propertyID,[Out] IDWriteStringList** values)</unmanaged>
        /// <unmanaged-short>IDWriteFontSet::GetPropertyValues</unmanaged-short>
        public unsafe void GetPropertyValues(SharpDX.DirectWrite.FontPropertyId propertyID, out SharpDX.DirectWrite.StringList values)
        {
            System.IntPtr values_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)propertyID), &values_, (*(void ***)this._nativePointer)[7]);
            if (values_ != System.IntPtr.Zero)
                values = new SharpDX.DirectWrite.StringList(values_);
            else
                values = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Returns all unique property values in the set, which can be used for purposes such as displaying a family list or tag cloud. Values are returned in priority order according to the language list, such that if a font contains more than one localized name, the preferred one will be returned.</p>
        /// </summary>
        /// <param name = "propertyID"><dd>  <p>Font property of interest.</p> </dd></param>
        /// <param name = "referredLocaleNamesRef"><dd>  <p>List of semicolon delimited language names in preferred order. When a particular string like font family has more than one localized name, the first match is returned. For example, suppose the font set includes the Meiryo family, which has both Japanese and English family names. The returned list of distinct family names would include either the Japanese name (if "ja-jp" was specified as a preferred locale) or the English name (in all other cases). </p> </dd></param>
        /// <param name = "values"><dd>  <p>Receives a reference to the newly created strings list.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn933250</doc-id>
        /// <unmanaged>HRESULT IDWriteFontSet::GetPropertyValues([In] DWRITE_FONT_PROPERTY_ID propertyID,[In] const wchar_t* preferredLocaleNames,[Out] IDWriteStringList** values)</unmanaged>
        /// <unmanaged-short>IDWriteFontSet::GetPropertyValues</unmanaged-short>
        public unsafe void GetPropertyValues(SharpDX.DirectWrite.FontPropertyId propertyID, System.String referredLocaleNamesRef, out SharpDX.DirectWrite.StringList values)
        {
            System.IntPtr values_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (char *referredLocaleNamesRef_ = referredLocaleNamesRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)propertyID), (void *)referredLocaleNamesRef_, &values_, (*(void ***)this._nativePointer)[8]);
            if (values_ != System.IntPtr.Zero)
                values = new SharpDX.DirectWrite.StringList(values_);
            else
                values = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Returns all unique property values in the set, which can be used for purposes such as displaying a family list or tag cloud. Values are returned in priority order according to the language list, such that if a font contains more than one localized name, the preferred one will be returned.</p>
        /// </summary>
        /// <param name = "listIndex"><dd>  <p>Font property of interest.</p> </dd></param>
        /// <param name = "propertyId"><dd>  <p>List of semicolon delimited language names in preferred order. When a particular string like font family has more than one localized name, the first match is returned. For example, suppose the font set includes the Meiryo family, which has both Japanese and English family names. The returned list of distinct family names would include either the Japanese name (if "ja-jp" was specified as a preferred locale) or the English name (in all other cases). </p> </dd></param>
        /// <param name = "exists"><dd>  <p>Receives a reference to the newly created strings list.</p> </dd></param>
        /// <param name = "values"><dd>  <p>Receives a reference to the newly created strings list.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn933250</doc-id>
        /// <unmanaged>HRESULT IDWriteFontSet::GetPropertyValues([In] unsigned int listIndex,[In] DWRITE_FONT_PROPERTY_ID propertyId,[Out] BOOL* exists,[Out, Optional] IDWriteLocalizedStrings** values)</unmanaged>
        /// <unmanaged-short>IDWriteFontSet::GetPropertyValues</unmanaged-short>
        public unsafe void GetPropertyValues(System.Int32 listIndex, SharpDX.DirectWrite.FontPropertyId propertyId, out SharpDX.Mathematics.Interop.RawBool exists, out SharpDX.DirectWrite.LocalizedStrings values)
        {
            exists = default (SharpDX.Mathematics.Interop.RawBool);
            System.IntPtr values_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *exists_ = &exists)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, listIndex, unchecked ((System.Int32)propertyId), exists_, &values_, (*(void ***)this._nativePointer)[9]);
            if (values_ != System.IntPtr.Zero)
                values = new SharpDX.DirectWrite.LocalizedStrings(values_);
            else
                values = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Returns how many times a given property value occurs in the set.</p>
        /// </summary>
        /// <param name = "ropertyRef"><dd>  <p>Font property of interest.</p> </dd></param>
        /// <param name = "ropertyOccurrenceCountRef"><dd>  <p>Receives how many times the property occurs.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn933248</doc-id>
        /// <unmanaged>HRESULT IDWriteFontSet::GetPropertyOccurrenceCount([In] const DWRITE_FONT_PROPERTY* property,[Out] unsigned int* propertyOccurrenceCount)</unmanaged>
        /// <unmanaged-short>IDWriteFontSet::GetPropertyOccurrenceCount</unmanaged-short>
        public unsafe void GetPropertyOccurrenceCount(ref SharpDX.DirectWrite.FontProperty ropertyRef, out System.Int32 ropertyOccurrenceCountRef)
        {
            SharpDX.DirectWrite.FontProperty.__Native ropertyRef_ = default (SharpDX.DirectWrite.FontProperty.__Native);
            SharpDX.Result __result__;
            ropertyRef.__MarshalTo(ref ropertyRef_);
            fixed (void *ropertyOccurrenceCountRef_ = &ropertyOccurrenceCountRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &ropertyRef_, ropertyOccurrenceCountRef_, (*(void ***)this._nativePointer)[10]);
            ropertyRef.__MarshalFree(ref ropertyRef_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Returns a subset of fonts filtered by the given properties.</p>
        /// </summary>
        /// <param name = "familyName"><dd>  <p>List of properties to filter using.</p> </dd></param>
        /// <param name = "fontWeight"><dd>  <p>The number of properties to filter.</p> </dd></param>
        /// <param name = "fontStretch"><dd>  <p>The subset of fonts that match the properties, or nullptr on failure.</p> </dd></param>
        /// <param name = "fontStyle">No documentation.</param>
        /// <param name = "filteredSet"><dd>  <p>The subset of fonts that match the properties, or nullptr on failure.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>If no fonts matched the filter, the subset will be empty (GetFontCount returns 0), but the function does not return an error. The subset will always be equal to or less than the original set. If you only want to filter out remote fonts, you may pass null in properties and zero in propertyCount. </p>
        /// </remarks>
        /// <doc-id>dn933245</doc-id>
        /// <unmanaged>HRESULT IDWriteFontSet::GetMatchingFonts([In] const wchar_t* familyName,[In] DWRITE_FONT_WEIGHT fontWeight,[In] DWRITE_FONT_STRETCH fontStretch,[In] DWRITE_FONT_STYLE fontStyle,[Out] IDWriteFontSet** filteredSet)</unmanaged>
        /// <unmanaged-short>IDWriteFontSet::GetMatchingFonts</unmanaged-short>
        public unsafe void GetMatchingFonts(System.String familyName, SharpDX.DirectWrite.FontWeight fontWeight, SharpDX.DirectWrite.FontStretch fontStretch, SharpDX.DirectWrite.FontStyle fontStyle, out SharpDX.DirectWrite.FontSet filteredSet)
        {
            System.IntPtr filteredSet_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (char *familyName_ = familyName)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)familyName_, unchecked ((System.Int32)fontWeight), unchecked ((System.Int32)fontStretch), unchecked ((System.Int32)fontStyle), &filteredSet_, (*(void ***)this._nativePointer)[11]);
            if (filteredSet_ != System.IntPtr.Zero)
                filteredSet = new SharpDX.DirectWrite.FontSet(filteredSet_);
            else
                filteredSet = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Returns a subset of fonts filtered by the given properties.</p>
        /// </summary>
        /// <param name = "ropertiesRef"><dd>  <p>List of properties to filter using.</p> </dd></param>
        /// <param name = "propertyCount"><dd>  <p>The number of properties to filter.</p> </dd></param>
        /// <param name = "filteredSet"><dd>  <p>The subset of fonts that match the properties, or nullptr on failure.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>If no fonts matched the filter, the subset will be empty (GetFontCount returns 0), but the function does not return an error. The subset will always be equal to or less than the original set. If you only want to filter out remote fonts, you may pass null in properties and zero in propertyCount. </p>
        /// </remarks>
        /// <doc-id>dn933245</doc-id>
        /// <unmanaged>HRESULT IDWriteFontSet::GetMatchingFonts([In, Buffer] const DWRITE_FONT_PROPERTY* properties,[In] unsigned int propertyCount,[Out] IDWriteFontSet** filteredSet)</unmanaged>
        /// <unmanaged-short>IDWriteFontSet::GetMatchingFonts</unmanaged-short>
        public unsafe void GetMatchingFonts(SharpDX.DirectWrite.FontProperty[] ropertiesRef, System.Int32 propertyCount, out SharpDX.DirectWrite.FontSet filteredSet)
        {
            SharpDX.DirectWrite.FontProperty.__Native[] ropertiesRef_ = new SharpDX.DirectWrite.FontProperty.__Native[ropertiesRef.Length];
            System.IntPtr filteredSet_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            for (int i = 0; i < ropertiesRef.Length; ++i)
                ropertiesRef[i].__MarshalTo(ref (ropertiesRef_)[i]);
            fixed (void *_ropertiesRef = ropertiesRef_)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, _ropertiesRef, propertyCount, &filteredSet_, (*(void ***)this._nativePointer)[12]);
            if (filteredSet_ != System.IntPtr.Zero)
                filteredSet = new SharpDX.DirectWrite.FontSet(filteredSet_);
            else
                filteredSet = null;
            for (int i = 0; i < ropertiesRef.Length; ++i)
                ropertiesRef[i].__MarshalFree(ref (ropertiesRef_)[i]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("2F642AFE-9C68-4F40-B8BE-457401AFCB3D")]
    public partial class FontSetBuilder : SharpDX.ComObject
    {
        public FontSetBuilder(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator FontSetBuilder(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new FontSetBuilder(nativePtr);
        /// <summary>
        /// <p>Adds a reference to a font to the set being built. The caller supplies enough information to search on, avoiding the need to open the potentially non-local font. Any properties not supplied by the caller will be missing, and those properties will not be available as filters in GetMatchingFonts. GetPropertyValues for missing properties will return an empty string list. The properties passed should generally be consistent with the actual font contents, but they need not be. You could, for example, alias a font using a different name or unique identifier, or you could set custom tags not present in the actual font.</p>
        /// </summary>
        /// <param name = "fontFaceReference"><dd>  <p>Reference to the font.</p> </dd></param>
        /// <param name = "ropertiesRef"><dd>  <p>List of properties to associate with the reference.</p> </dd></param>
        /// <param name = "propertyCount"><dd>  <p>The number of properties defined.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn933238</doc-id>
        /// <unmanaged>HRESULT IDWriteFontSetBuilder::AddFontFaceReference([In] IDWriteFontFaceReference* fontFaceReference,[In, Buffer] const DWRITE_FONT_PROPERTY* properties,[In] unsigned int propertyCount)</unmanaged>
        /// <unmanaged-short>IDWriteFontSetBuilder::AddFontFaceReference</unmanaged-short>
        public unsafe void AddFontFaceReference(SharpDX.DirectWrite.FontFaceReference fontFaceReference, SharpDX.DirectWrite.FontProperty[] ropertiesRef, System.Int32 propertyCount)
        {
            System.IntPtr fontFaceReference_ = System.IntPtr.Zero;
            SharpDX.DirectWrite.FontProperty.__Native[] ropertiesRef_ = new SharpDX.DirectWrite.FontProperty.__Native[ropertiesRef.Length];
            SharpDX.Result __result__;
            fontFaceReference_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.FontFaceReference>(fontFaceReference);
            for (int i = 0; i < ropertiesRef.Length; ++i)
                ropertiesRef[i].__MarshalTo(ref (ropertiesRef_)[i]);
            fixed (void *_ropertiesRef = ropertiesRef_)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)fontFaceReference_, _ropertiesRef, propertyCount, (*(void ***)this._nativePointer)[3]);
            for (int i = 0; i < ropertiesRef.Length; ++i)
                ropertiesRef[i].__MarshalFree(ref (ropertiesRef_)[i]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Adds a reference to a font to the set being built. The caller supplies enough information to search on, avoiding the need to open the potentially non-local font. Any properties not supplied by the caller will be missing, and those properties will not be available as filters in GetMatchingFonts. GetPropertyValues for missing properties will return an empty string list. The properties passed should generally be consistent with the actual font contents, but they need not be. You could, for example, alias a font using a different name or unique identifier, or you could set custom tags not present in the actual font.</p>
        /// </summary>
        /// <param name = "fontFaceReference"><dd>  <p>Reference to the font.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn933238</doc-id>
        /// <unmanaged>HRESULT IDWriteFontSetBuilder::AddFontFaceReference([In] IDWriteFontFaceReference* fontFaceReference)</unmanaged>
        /// <unmanaged-short>IDWriteFontSetBuilder::AddFontFaceReference</unmanaged-short>
        public unsafe void AddFontFaceReference(SharpDX.DirectWrite.FontFaceReference fontFaceReference)
        {
            System.IntPtr fontFaceReference_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fontFaceReference_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.FontFaceReference>(fontFaceReference);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)fontFaceReference_, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Appends an existing font set to the one being built, allowing one to aggregate two sets or to essentially extend an existing one.</p>
        /// </summary>
        /// <param name = "fontSet"><dd>  <p>Font set to append font face references from.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn933240</doc-id>
        /// <unmanaged>HRESULT IDWriteFontSetBuilder::AddFontSet([In] IDWriteFontSet* fontSet)</unmanaged>
        /// <unmanaged-short>IDWriteFontSetBuilder::AddFontSet</unmanaged-short>
        public unsafe void AddFontSet(SharpDX.DirectWrite.FontSet fontSet)
        {
            System.IntPtr fontSet_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fontSet_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.FontSet>(fontSet);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)fontSet_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a font set from all the font face references added so far with AddFontFaceReference.</p>
        /// </summary>
        /// <param name = "fontSet"><dd>  <p>Contains the newly created font set object, or nullptr in case of failure.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Creating a font set takes less time if the references were added with metadata rather than needing to extract the metadata from the font file.</p>
        /// </remarks>
        /// <doc-id>dn933241</doc-id>
        /// <unmanaged>HRESULT IDWriteFontSetBuilder::CreateFontSet([Out] IDWriteFontSet** fontSet)</unmanaged>
        /// <unmanaged-short>IDWriteFontSetBuilder::CreateFontSet</unmanaged-short>
        public unsafe void CreateFontSet(out SharpDX.DirectWrite.FontSet fontSet)
        {
            System.IntPtr fontSet_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &fontSet_, (*(void ***)this._nativePointer)[6]);
            if (fontSet_ != System.IntPtr.Zero)
                fontSet = new SharpDX.DirectWrite.FontSet(fontSet_);
            else
                fontSet = null;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("3FF7715F-3CDC-4DC6-9B72-EC5621DCCAFD")]
    public partial class FontSetBuilder1 : SharpDX.DirectWrite.FontSetBuilder
    {
        public FontSetBuilder1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator FontSetBuilder1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new FontSetBuilder1(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "fontFile">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT IDWriteFontSetBuilder1::AddFontFile([In] IDWriteFontFile* fontFile)</unmanaged>
        /// <unmanaged-short>IDWriteFontSetBuilder1::AddFontFile</unmanaged-short>
        public unsafe void AddFontFile(SharpDX.DirectWrite.FontFile fontFile)
        {
            System.IntPtr fontFile_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fontFile_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.FontFile>(fontFile);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)fontFile_, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("1edd9491-9853-4299-898f-6432983b6f3a")]
    public partial class GdiInterop : SharpDX.ComObject
    {
        public GdiInterop(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator GdiInterop(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new GdiInterop(nativePtr);
        /// <summary>
        /// <p> Creates a font object that matches the properties specified by the <strong><see cref = "SharpDX.DirectWrite.GdiInterop.LogFont"/></strong> structure. </p>
        /// </summary>
        /// <param name = "logFont"><dd>  <p>A structure containing a GDI-compatible font description.</p> </dd></param>
        /// <param name = "font"><dd>  <p>When this method returns, contains an address of a  reference to a newly created <strong><see cref = "SharpDX.DirectWrite.Font"/></strong> object if successful; otherwise, <strong><c>null</c></strong>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371187</doc-id>
        /// <unmanaged>HRESULT IDWriteGdiInterop::CreateFontFromLOGFONT([In] const void* logFont,[Out] IDWriteFont** font)</unmanaged>
        /// <unmanaged-short>IDWriteGdiInterop::CreateFontFromLOGFONT</unmanaged-short>
        internal unsafe void CreateFontFromLOGFONT(System.IntPtr logFont, out SharpDX.DirectWrite.Font font)
        {
            System.IntPtr font_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)logFont, &font_, (*(void ***)this._nativePointer)[3]);
            if (font_ != System.IntPtr.Zero)
                font = new SharpDX.DirectWrite.Font(font_);
            else
                font = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Initializes a <strong><see cref = "SharpDX.DirectWrite.GdiInterop.LogFont"/></strong> structure based on the GDI-compatible properties of the specified font. </p>
        /// </summary>
        /// <param name = "font"><dd>  <p>An <strong><see cref = "SharpDX.DirectWrite.Font"/></strong> object to be converted into a GDI-compatible <strong><see cref = "SharpDX.DirectWrite.GdiInterop.LogFont"/></strong> structure.</p> </dd></param>
        /// <param name = "logFont"><dd>  <p>When this method returns, contains a structure that receives a GDI-compatible font description.</p> </dd></param>
        /// <param name = "isSystemFont"><dd>  <p>When this method returns, contains <strong>TRUE</strong> if the specified font object is part of the system font collection; otherwise, <strong><see cref = "SharpDX.Result.False"/></strong>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The conversion to a  <strong><see cref = "SharpDX.DirectWrite.GdiInterop.LogFont"/></strong> by using <strong>ConvertFontToLOGFONT</strong> operates at the logical font level and does not guarantee that it will map to a specific physical font. It is not guaranteed that GDI will select the same physical font for displaying  text formatted by a <strong><see cref = "SharpDX.DirectWrite.GdiInterop.LogFont"/></strong> as the <strong><see cref = "SharpDX.DirectWrite.Font"/></strong> object that was converted.</p>
        /// </remarks>
        /// <doc-id>dd371177</doc-id>
        /// <unmanaged>HRESULT IDWriteGdiInterop::ConvertFontToLOGFONT([In] IDWriteFont* font,[In] void* logFont,[Out] BOOL* isSystemFont)</unmanaged>
        /// <unmanaged-short>IDWriteGdiInterop::ConvertFontToLOGFONT</unmanaged-short>
        internal unsafe void ConvertFontToLOGFONT(SharpDX.DirectWrite.Font font, System.IntPtr logFont, out SharpDX.Mathematics.Interop.RawBool isSystemFont)
        {
            System.IntPtr font_ = System.IntPtr.Zero;
            isSystemFont = default (SharpDX.Mathematics.Interop.RawBool);
            SharpDX.Result __result__;
            font_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.Font>(font);
            fixed (void *isSystemFont_ = &isSystemFont)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)font_, (void *)logFont, isSystemFont_, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Initializes a <see cref = "SharpDX.DirectWrite.GdiInterop.LogFont"/> structure based on the GDI-compatible properties of the specified font. </p>
        /// </summary>
        /// <param name = "font"><dd>  <p>An <strong><see cref = "SharpDX.DirectWrite.FontFace"/></strong> object to be converted into a GDI-compatible <see cref = "SharpDX.DirectWrite.GdiInterop.LogFont"/> structure.</p> </dd></param>
        /// <param name = "logFont"><dd>  <p>When this method returns, contains a reference to a structure that receives a GDI-compatible font description.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The conversion to a  <see cref = "SharpDX.DirectWrite.GdiInterop.LogFont"/> by using <strong>ConvertFontFaceToLOGFONT</strong> operates at the logical font level and does not guarantee that it will map to a specific physical font. It is not guaranteed that GDI will select the same physical font for displaying  text formatted by a <see cref = "SharpDX.DirectWrite.GdiInterop.LogFont"/> as the <strong><see cref = "SharpDX.DirectWrite.Font"/></strong> object that was converted.</p>
        /// </remarks>
        /// <doc-id>dd371175</doc-id>
        /// <unmanaged>HRESULT IDWriteGdiInterop::ConvertFontFaceToLOGFONT([In] IDWriteFontFace* font,[In] void* logFont)</unmanaged>
        /// <unmanaged-short>IDWriteGdiInterop::ConvertFontFaceToLOGFONT</unmanaged-short>
        internal unsafe void ConvertFontFaceToLOGFONT(SharpDX.DirectWrite.FontFace font, System.IntPtr logFont)
        {
            System.IntPtr font_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            font_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.FontFace>(font);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)font_, (void *)logFont, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates an <strong><see cref = "SharpDX.DirectWrite.FontFace"/></strong> object that corresponds to the currently selected <strong>HFONT</strong> of the specified <strong><see cref = "System.IntPtr"/></strong>. </p>
        /// </summary>
        /// <param name = "hdc"><dd>  <p>A handle to a device context into which a font has been selected. It is assumed that the client has already performed font mapping and that the font selected into the device context is the actual font to be used  for rendering glyphs.</p> </dd></param>
        /// <returns><dd>  <p>Contains an address of a reference to  the newly created font face object, or <strong><c>null</c></strong> in case of failure. The font face returned is guaranteed to reference the same physical typeface that would be used for drawing glyphs (but not necessarily characters) using ExtTextOut.</p> </dd></returns>
        /// <remarks>
        /// <p>This function is intended for scenarios in which an application wants to use GDI and Uniscribe 1.x for text layout and shaping, but  DirectWrite for final rendering. This function assumes the client is performing text output using glyph indexes.</p>
        /// </remarks>
        /// <doc-id>dd371185</doc-id>
        /// <unmanaged>HRESULT IDWriteGdiInterop::CreateFontFaceFromHdc([In] HDC hdc,[Out] IDWriteFontFace** fontFace)</unmanaged>
        /// <unmanaged-short>IDWriteGdiInterop::CreateFontFaceFromHdc</unmanaged-short>
        public unsafe SharpDX.DirectWrite.FontFace CreateFontFaceFromHdc(System.IntPtr hdc)
        {
            SharpDX.DirectWrite.FontFace fontFace;
            System.IntPtr fontFace_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)hdc, &fontFace_, (*(void ***)this._nativePointer)[6]);
            if (fontFace_ != System.IntPtr.Zero)
                fontFace = new SharpDX.DirectWrite.FontFace(fontFace_);
            else
                fontFace = null;
            __result__.CheckError();
            return fontFace;
        }

        /// <summary>
        /// <p> Creates an object that encapsulates a bitmap and memory DC (device context) which can be used for rendering glyphs. </p>
        /// </summary>
        /// <param name = "hdc"><dd>  <p>A handle to the optional device context used to create a compatible memory DC (device context).</p> </dd></param>
        /// <param name = "width"><dd>  <p>The width of the bitmap render target.</p> </dd></param>
        /// <param name = "height"><dd>  <p>The height of the bitmap render target.</p> </dd></param>
        /// <returns><dd>  <p>When this method returns, contains an address of a reference to the newly created <strong><see cref = "SharpDX.DirectWrite.BitmapRenderTarget"/></strong> object.</p> </dd></returns>
        /// <doc-id>dd371182</doc-id>
        /// <unmanaged>HRESULT IDWriteGdiInterop::CreateBitmapRenderTarget([In, Optional] HDC hdc,[In] unsigned int width,[In] unsigned int height,[Out] IDWriteBitmapRenderTarget** renderTarget)</unmanaged>
        /// <unmanaged-short>IDWriteGdiInterop::CreateBitmapRenderTarget</unmanaged-short>
        public unsafe SharpDX.DirectWrite.BitmapRenderTarget CreateBitmapRenderTarget(System.IntPtr hdc, System.Int32 width, System.Int32 height)
        {
            SharpDX.DirectWrite.BitmapRenderTarget renderTarget;
            System.IntPtr renderTarget_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)hdc, width, height, &renderTarget_, (*(void ***)this._nativePointer)[7]);
            if (renderTarget_ != System.IntPtr.Zero)
                renderTarget = new SharpDX.DirectWrite.BitmapRenderTarget(renderTarget_);
            else
                renderTarget = null;
            __result__.CheckError();
            return renderTarget;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("4556BE70-3ABD-4F70-90BE-421780A6F515")]
    public partial class GdiInterop1 : SharpDX.DirectWrite.GdiInterop
    {
        public GdiInterop1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator GdiInterop1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new GdiInterop1(nativePtr);
        /// <summary>
        /// <p>Creates a font object that matches the properties specified by the <see cref = "SharpDX.DirectWrite.GdiInterop.LogFont"/> structure.</p>
        /// </summary>
        /// <param name = "logFont"><dd>  <p>Structure containing a GDI-compatible font description.</p> </dd></param>
        /// <param name = "fontCollection"><dd>  <p>The font collection to search. If <c>null</c>, the local system font collection is used.</p> </dd></param>
        /// <returns><dd>  <p>Receives a newly created font object if successful, or <c>null</c> in case of error.</p> </dd></returns>
        /// <doc-id>dn958416</doc-id>
        /// <unmanaged>HRESULT IDWriteGdiInterop1::CreateFontFromLOGFONT([In] const void* logFont,[In, Optional] IDWriteFontCollection* fontCollection,[Out] IDWriteFont** font)</unmanaged>
        /// <unmanaged-short>IDWriteGdiInterop1::CreateFontFromLOGFONT</unmanaged-short>
        internal unsafe SharpDX.DirectWrite.Font CreateFontFromLOGFONT(System.IntPtr logFont, SharpDX.DirectWrite.FontCollection fontCollection)
        {
            System.IntPtr fontCollection_ = System.IntPtr.Zero;
            SharpDX.DirectWrite.Font font;
            System.IntPtr font_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fontCollection_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.FontCollection>(fontCollection);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)logFont, (void *)fontCollection_, &font_, (*(void ***)this._nativePointer)[8]);
            if (font_ != System.IntPtr.Zero)
                font = new SharpDX.DirectWrite.Font(font_);
            else
                font = null;
            __result__.CheckError();
            return font;
        }

        /// <summary>
        /// <p>Reads the font signature from the given font face.</p>
        /// </summary>
        /// <param name = "fontFace"><dd>  <p>Font face to read font signature from.</p> </dd></param>
        /// <returns><dd>  <p>Font signature from the OS/2 table, ulUnicodeRange and ulCodePageRange.</p> </dd></returns>
        /// <doc-id>dn958418</doc-id>
        /// <unmanaged>HRESULT IDWriteGdiInterop1::GetFontSignature([In] IDWriteFontFace* fontFace,[Out] FONTSIGNATURE* fontSignature)</unmanaged>
        /// <unmanaged-short>IDWriteGdiInterop1::GetFontSignature</unmanaged-short>
        public unsafe SharpDX.DirectWrite.GdiInterop.FontSignature GetFontSignature(SharpDX.DirectWrite.FontFace fontFace)
        {
            System.IntPtr fontFace_ = System.IntPtr.Zero;
            SharpDX.DirectWrite.GdiInterop.FontSignature fontSignature;
            SharpDX.Result __result__;
            fontFace_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.FontFace>(fontFace);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)fontFace_, &fontSignature, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
            return fontSignature;
        }

        /// <summary>
        /// <p>Reads the font signature from the given font face.</p>
        /// </summary>
        /// <param name = "font"><dd>  <p>Font face to read font signature from.</p> </dd></param>
        /// <returns><dd>  <p>Font signature from the OS/2 table, ulUnicodeRange and ulCodePageRange.</p> </dd></returns>
        /// <doc-id>dn958418</doc-id>
        /// <unmanaged>HRESULT IDWriteGdiInterop1::GetFontSignature([In] IDWriteFont* font,[Out] FONTSIGNATURE* fontSignature)</unmanaged>
        /// <unmanaged-short>IDWriteGdiInterop1::GetFontSignature</unmanaged-short>
        public unsafe SharpDX.DirectWrite.GdiInterop.FontSignature GetFontSignature(SharpDX.DirectWrite.Font font)
        {
            System.IntPtr font_ = System.IntPtr.Zero;
            SharpDX.DirectWrite.GdiInterop.FontSignature fontSignature;
            SharpDX.Result __result__;
            font_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.Font>(font);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)font_, &fontSignature, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
            return fontSignature;
        }

        /// <summary>
        /// <p>Gets a list of matching fonts based on the specified <see cref = "SharpDX.DirectWrite.GdiInterop.LogFont"/> values. Only fonts of that family name will be returned.</p>
        /// </summary>
        /// <param name = "logFont"><dd>  <p>Structure containing a GDI-compatible font description.</p> </dd></param>
        /// <param name = "fontSet"><dd>  <p>The font set to search.</p> </dd></param>
        /// <param name = "filteredSet"><dd>  <p>&gt;Receives the filtered font set if successful.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn958420</doc-id>
        /// <unmanaged>HRESULT IDWriteGdiInterop1::GetMatchingFontsByLOGFONT([In] const void* logFont,[In] IDWriteFontSet* fontSet,[Out] IDWriteFontSet** filteredSet)</unmanaged>
        /// <unmanaged-short>IDWriteGdiInterop1::GetMatchingFontsByLOGFONT</unmanaged-short>
        internal unsafe void GetMatchingFontsByLOGFONT(System.IntPtr logFont, SharpDX.DirectWrite.FontSet fontSet, out SharpDX.DirectWrite.FontSet filteredSet)
        {
            System.IntPtr fontSet_ = System.IntPtr.Zero;
            System.IntPtr filteredSet_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fontSet_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.FontSet>(fontSet);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)logFont, (void *)fontSet_, &filteredSet_, (*(void ***)this._nativePointer)[11]);
            if (filteredSet_ != System.IntPtr.Zero)
                filteredSet = new SharpDX.DirectWrite.FontSet(filteredSet_);
            else
                filteredSet = null;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("7d97dbf7-e085-42d4-81e3-6a883bded118")]
    public partial class GlyphRunAnalysis : SharpDX.ComObject
    {
        public GlyphRunAnalysis(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator GlyphRunAnalysis(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new GlyphRunAnalysis(nativePtr);
        /// <summary>
        /// <p> Gets the bounding rectangle of the physical pixels affected by the glyph run. </p>
        /// </summary>
        /// <param name = "textureType"><dd>  <p>Specifies the type of texture requested. If a bi-level texture is requested, the bounding rectangle includes only bi-level glyphs. Otherwise, the bounding rectangle includes only antialiased glyphs.</p> </dd></param>
        /// <returns><dd>  <p>When this method returns, contains the bounding rectangle of the physical pixels affected by the glyph run, or an empty rectangle if there are no glyphs of the specified texture type.</p> </dd></returns>
        /// <doc-id>dd371215</doc-id>
        /// <unmanaged>HRESULT IDWriteGlyphRunAnalysis::GetAlphaTextureBounds([In] DWRITE_TEXTURE_TYPE textureType,[Out] RECT* textureBounds)</unmanaged>
        /// <unmanaged-short>IDWriteGlyphRunAnalysis::GetAlphaTextureBounds</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawRectangle GetAlphaTextureBounds(SharpDX.DirectWrite.TextureType textureType)
        {
            SharpDX.Mathematics.Interop.RawRectangle textureBounds;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)textureType), &textureBounds, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
            return textureBounds;
        }

        /// <summary>
        /// <p> Creates an alpha texture of the specified type for glyphs within a specified bounding rectangle. </p>
        /// </summary>
        /// <param name = "textureType"><dd>  <p>A value that specifies the type of texture requested. This can be <strong>DWRITE_TEXTURE_BILEVEL_1x1</strong> or <strong>DWRITE_TEXTURE_CLEARTYPE_3x1</strong>. If a bi-level texture is requested, the texture contains only bi-level glyphs. Otherwise, the texture contains only antialiased glyphs.</p> </dd></param>
        /// <param name = "textureBounds"><dd>  <p>The bounding rectangle of the texture, which can be different than the bounding rectangle returned by <strong>GetAlphaTextureBounds</strong>.</p> </dd></param>
        /// <param name = "alphaValues"><dd>  <p>When this method returns, contains  the array of alpha values from the texture. The buffer allocated for this array must be at least the size of <em>bufferSize</em>.</p> </dd></param>
        /// <param name = "bufferSize"><dd>  <p>The size of the <em>alphaValues</em> array, in bytes. The minimum size depends on the dimensions of the rectangle and the type of texture requested.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371189</doc-id>
        /// <unmanaged>HRESULT IDWriteGlyphRunAnalysis::CreateAlphaTexture([In] DWRITE_TEXTURE_TYPE textureType,[In] const RECT* textureBounds,[Out, Buffer] unsigned char* alphaValues,[In] unsigned int bufferSize)</unmanaged>
        /// <unmanaged-short>IDWriteGlyphRunAnalysis::CreateAlphaTexture</unmanaged-short>
        public unsafe void CreateAlphaTexture(SharpDX.DirectWrite.TextureType textureType, SharpDX.Mathematics.Interop.RawRectangle textureBounds, System.Byte[] alphaValues, System.Int32 bufferSize)
        {
            SharpDX.Result __result__;
            fixed (void *alphaValues_ = alphaValues)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)textureType), &textureBounds, alphaValues_, bufferSize, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Gets alpha blending properties required for ClearType blending. </p>
        /// </summary>
        /// <param name = "renderingParams"><dd>  <p>An object that specifies the ClearType level and enhanced contrast, gamma, pixel geometry, and rendering mode. In most cases, the values returned by the output parameters of this method are based on the properties of this object, unless a GDI-compatible rendering mode was specified.</p> </dd></param>
        /// <param name = "blendGamma"><dd>  <p>When this method returns, contains  the gamma value to use for gamma correction.</p> </dd></param>
        /// <param name = "blendEnhancedContrast"><dd>  <p>When this method returns, contains the enhanced contrast value to be used for blending.</p> </dd></param>
        /// <param name = "blendClearTypeLevel"><dd>  <p>When this method returns, contains  the ClearType level used in the alpha blending.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371190</doc-id>
        /// <unmanaged>HRESULT IDWriteGlyphRunAnalysis::GetAlphaBlendParams([In] IDWriteRenderingParams* renderingParams,[Out] float* blendGamma,[Out] float* blendEnhancedContrast,[Out] float* blendClearTypeLevel)</unmanaged>
        /// <unmanaged-short>IDWriteGlyphRunAnalysis::GetAlphaBlendParams</unmanaged-short>
        public unsafe void GetAlphaBlendParams(SharpDX.DirectWrite.RenderingParams renderingParams, out System.Single blendGamma, out System.Single blendEnhancedContrast, out System.Single blendClearTypeLevel)
        {
            System.IntPtr renderingParams_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            renderingParams_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.RenderingParams>(renderingParams);
            fixed (void *blendClearTypeLevel_ = &blendClearTypeLevel)
                fixed (void *blendEnhancedContrast_ = &blendEnhancedContrast)
                    fixed (void *blendGamma_ = &blendGamma)
                        __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)renderingParams_, blendGamma_, blendEnhancedContrast_, blendClearTypeLevel_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("8339FDE3-106F-47ab-8373-1C6295EB10B3")]
    public partial interface InlineObject : SharpDX.IUnknown
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("8339FDE3-106F-47ab-8373-1C6295EB10B3")]
    public partial class InlineObjectNative : SharpDX.ComObject, SharpDX.DirectWrite.InlineObject
    {
        public InlineObjectNative(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator InlineObjectNative(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new InlineObjectNative(nativePtr);
        /// <summary>
        /// <p> <strong><see cref = "SharpDX.DirectWrite.TextLayout"/></strong> calls this callback function to get the measurement of the inline object. </p>
        /// </summary>
        /// <doc-id>dd371232</doc-id>
        /// <unmanaged>GetMetrics</unmanaged>
        /// <unmanaged-short>GetMetrics</unmanaged-short>
        public SharpDX.DirectWrite.InlineObjectMetrics Metrics_
        {
            get
            {
                GetMetrics_(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p> <strong><see cref = "SharpDX.DirectWrite.TextLayout"/></strong> calls this callback function to get the visible extents (in DIPs) of the inline object. In the case of a simple bitmap, with no padding and no overhang, all the overhangs will simply be zeroes.</p><p>The overhangs should be returned relative to the reported size of the object (see <strong><see cref = "SharpDX.DirectWrite.InlineObjectMetrics"/></strong>), and should not be baseline adjusted.</p>
        /// </summary>
        /// <doc-id>dd371235</doc-id>
        /// <unmanaged>GetOverhangMetrics</unmanaged>
        /// <unmanaged-short>GetOverhangMetrics</unmanaged-short>
        public SharpDX.DirectWrite.OverhangMetrics OverhangMetrics_
        {
            get
            {
                GetOverhangMetrics_(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p> The application implemented rendering callback (<strong>IDWriteTextRenderer::DrawInlineObject</strong>) can use this to draw the inline object without needing to cast or query the object type. The text layout does not call this method directly. </p>
        /// </summary>
        /// <param name = "clientDrawingContext">No documentation.</param>
        /// <param name = "renderer">No documentation.</param>
        /// <param name = "originX">No documentation.</param>
        /// <param name = "originY">No documentation.</param>
        /// <param name = "isSideways">No documentation.</param>
        /// <param name = "isRightToLeft">No documentation.</param>
        /// <param name = "clientDrawingEffect">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371225</doc-id>
        /// <unmanaged>HRESULT IDWriteInlineObject::Draw([In, Optional] void* clientDrawingContext,[In] IDWriteTextRenderer* renderer,[In] float originX,[In] float originY,[In] BOOL isSideways,[In] BOOL isRightToLeft,[In, Optional] IUnknown* clientDrawingEffect)</unmanaged>
        /// <unmanaged-short>IDWriteInlineObject::Draw</unmanaged-short>
        internal unsafe void Draw_(System.IntPtr clientDrawingContext, SharpDX.DirectWrite.TextRenderer renderer, System.Single originX, System.Single originY, SharpDX.Mathematics.Interop.RawBool isSideways, SharpDX.Mathematics.Interop.RawBool isRightToLeft, System.IntPtr clientDrawingEffect)
        {
            System.IntPtr renderer_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            renderer_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.TextRenderer>(renderer);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, (void *)clientDrawingContext, (void *)renderer_, originX, originY, isSideways, isRightToLeft, (void *)clientDrawingEffect, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> <strong><see cref = "SharpDX.DirectWrite.TextLayout"/></strong> calls this callback function to get the measurement of the inline object. </p>
        /// </summary>
        /// <param name = "metrics">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371232</doc-id>
        /// <unmanaged>HRESULT IDWriteInlineObject::GetMetrics([Out] DWRITE_INLINE_OBJECT_METRICS* metrics)</unmanaged>
        /// <unmanaged-short>IDWriteInlineObject::GetMetrics</unmanaged-short>
        internal unsafe void GetMetrics_(out SharpDX.DirectWrite.InlineObjectMetrics metrics)
        {
            metrics = default (SharpDX.DirectWrite.InlineObjectMetrics);
            SharpDX.Result __result__;
            fixed (void *metrics_ = &metrics)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, metrics_, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> <strong><see cref = "SharpDX.DirectWrite.TextLayout"/></strong> calls this callback function to get the visible extents (in DIPs) of the inline object. In the case of a simple bitmap, with no padding and no overhang, all the overhangs will simply be zeroes.</p><p>The overhangs should be returned relative to the reported size of the object (see <strong><see cref = "SharpDX.DirectWrite.InlineObjectMetrics"/></strong>), and should not be baseline adjusted.</p>
        /// </summary>
        /// <param name = "overhangs">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371235</doc-id>
        /// <unmanaged>HRESULT IDWriteInlineObject::GetOverhangMetrics([Out] DWRITE_OVERHANG_METRICS* overhangs)</unmanaged>
        /// <unmanaged-short>IDWriteInlineObject::GetOverhangMetrics</unmanaged-short>
        internal unsafe void GetOverhangMetrics_(out SharpDX.DirectWrite.OverhangMetrics overhangs)
        {
            overhangs = default (SharpDX.DirectWrite.OverhangMetrics);
            SharpDX.Result __result__;
            fixed (void *overhangs_ = &overhangs)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, overhangs_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Layout uses this to determine the line-breaking behavior of the inline object among the text. </p>
        /// </summary>
        /// <param name = "breakConditionBefore"><dd>  <p>When this method returns, contains a value which indicates the line-breaking condition between the object and the content immediately preceding it.</p> </dd></param>
        /// <param name = "breakConditionAfter"><dd>  <p>When this method returns, contains a value which indicates the line-breaking condition between the object and the content immediately following it.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371229</doc-id>
        /// <unmanaged>HRESULT IDWriteInlineObject::GetBreakConditions([Out] DWRITE_BREAK_CONDITION* breakConditionBefore,[Out] DWRITE_BREAK_CONDITION* breakConditionAfter)</unmanaged>
        /// <unmanaged-short>IDWriteInlineObject::GetBreakConditions</unmanaged-short>
        internal unsafe void GetBreakConditions_(out SharpDX.DirectWrite.BreakCondition breakConditionBefore, out SharpDX.DirectWrite.BreakCondition breakConditionAfter)
        {
            SharpDX.Result __result__;
            fixed (void *breakConditionAfter_ = &breakConditionAfter)
                fixed (void *breakConditionBefore_ = &breakConditionBefore)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, breakConditionBefore_, breakConditionAfter_, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("DC102F47-A12D-4B1C-822D-9E117E33043F")]
    public partial class InMemoryFontFileLoader : SharpDX.DirectWrite.FontFileLoaderNative
    {
        public InMemoryFontFileLoader(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator InMemoryFontFileLoader(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new InMemoryFontFileLoader(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>GetFileCount</unmanaged>
        /// <unmanaged-short>GetFileCount</unmanaged-short>
        public System.Int32 FileCount
        {
            get => GetFileCount();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "factory">No documentation.</param>
        /// <param name = "fontData">No documentation.</param>
        /// <param name = "fontDataSize">No documentation.</param>
        /// <param name = "ownerObject">No documentation.</param>
        /// <param name = "fontFile">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT IDWriteInMemoryFontFileLoader::CreateInMemoryFontFileReference([In] IDWriteFactory* factory,[In, Buffer] const void* fontData,[In] unsigned int fontDataSize,[In, Optional] IUnknown* ownerObject,[Out] IDWriteFontFile** fontFile)</unmanaged>
        /// <unmanaged-short>IDWriteInMemoryFontFileLoader::CreateInMemoryFontFileReference</unmanaged-short>
        public unsafe void CreateInMemoryFontFileReference(SharpDX.DirectWrite.Factory factory, System.IntPtr fontData, System.Int32 fontDataSize, SharpDX.IUnknown ownerObject, out SharpDX.DirectWrite.FontFile fontFile)
        {
            System.IntPtr factory_ = System.IntPtr.Zero;
            System.IntPtr ownerObject_ = System.IntPtr.Zero;
            System.IntPtr fontFile_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            factory_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.Factory>(factory);
            ownerObject_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(ownerObject);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)factory_, (void *)fontData, fontDataSize, (void *)ownerObject_, &fontFile_, (*(void ***)this._nativePointer)[4]);
            if (fontFile_ != System.IntPtr.Zero)
                fontFile = new SharpDX.DirectWrite.FontFile(fontFile_);
            else
                fontFile = null;
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <returns>No documentation.</returns>
        /// <unmanaged>unsigned int IDWriteInMemoryFontFileLoader::GetFileCount()</unmanaged>
        /// <unmanaged-short>IDWriteInMemoryFontFileLoader::GetFileCount</unmanaged-short>
        internal unsafe System.Int32 GetFileCount()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[5]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("b2d9f3ec-c9fe-4a11-a2ec-d86208f7c0a2")]
    public partial class LocalFontFileLoader : SharpDX.DirectWrite.FontFileLoaderNative
    {
        public LocalFontFileLoader(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator LocalFontFileLoader(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new LocalFontFileLoader(nativePtr);
        /// <summary>
        /// <p>Obtains the length of the absolute file path from the font file reference key.</p>
        /// </summary>
        /// <param name = "fontFileReferenceKey"><dd>  <p>Font file reference key that uniquely identifies the local font file within the scope of the font loader being used.</p> </dd></param>
        /// <param name = "fontFileReferenceKeySize"><dd>  <p>Size of font file reference key in bytes.</p> </dd></param>
        /// <returns><dd>  <p>Length of the file path string, not including the terminated <strong><c>null</c></strong> character.</p> </dd></returns>
        /// <doc-id>dd371244</doc-id>
        /// <unmanaged>HRESULT IDWriteLocalFontFileLoader::GetFilePathLengthFromKey([In, Buffer] const void* fontFileReferenceKey,[In] unsigned int fontFileReferenceKeySize,[Out] unsigned int* filePathLength)</unmanaged>
        /// <unmanaged-short>IDWriteLocalFontFileLoader::GetFilePathLengthFromKey</unmanaged-short>
        internal unsafe System.Int32 GetFilePathLengthFromKey(System.IntPtr fontFileReferenceKey, System.Int32 fontFileReferenceKeySize)
        {
            System.Int32 filePathLength;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)fontFileReferenceKey, fontFileReferenceKeySize, &filePathLength, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
            return filePathLength;
        }

        /// <summary>
        /// <p>Obtains the absolute font file path from the font file reference key.</p>
        /// </summary>
        /// <param name = "fontFileReferenceKey"><dd>  <p>The font file reference key that uniquely identifies the local font file within the scope of the font loader being used.</p> </dd></param>
        /// <param name = "fontFileReferenceKeySize"><dd>  <p>The size of font file reference key in bytes.</p> </dd></param>
        /// <param name = "filePath"><dd>  <p>The character array that receives the local file path.</p> </dd></param>
        /// <param name = "filePathSize"><dd>  <p>The length of the file path character array.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371241</doc-id>
        /// <unmanaged>HRESULT IDWriteLocalFontFileLoader::GetFilePathFromKey([In, Buffer] const void* fontFileReferenceKey,[In] unsigned int fontFileReferenceKeySize,[Out, Buffer] wchar_t* filePath,[In] unsigned int filePathSize)</unmanaged>
        /// <unmanaged-short>IDWriteLocalFontFileLoader::GetFilePathFromKey</unmanaged-short>
        internal unsafe void GetFilePathFromKey(System.IntPtr fontFileReferenceKey, System.Int32 fontFileReferenceKeySize, System.IntPtr filePath, System.Int32 filePathSize)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)fontFileReferenceKey, fontFileReferenceKeySize, (void *)filePath, filePathSize, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Obtains the last write time of the file from the font file reference key.</p>
        /// </summary>
        /// <param name = "fontFileReferenceKey"><dd>  <p>The font file reference key that uniquely identifies the local font file within the scope of the font loader being used.</p> </dd></param>
        /// <param name = "fontFileReferenceKeySize"><dd>  <p>The size of font file reference key in bytes.</p> </dd></param>
        /// <returns><dd>  <p>The time of the last font file modification.</p> </dd></returns>
        /// <doc-id>dd371247</doc-id>
        /// <unmanaged>HRESULT IDWriteLocalFontFileLoader::GetLastWriteTimeFromKey([In, Buffer] const void* fontFileReferenceKey,[In] unsigned int fontFileReferenceKeySize,[Out] FILETIME* lastWriteTime)</unmanaged>
        /// <unmanaged-short>IDWriteLocalFontFileLoader::GetLastWriteTimeFromKey</unmanaged-short>
        internal unsafe System.Int64 GetLastWriteTimeFromKey(System.IntPtr fontFileReferenceKey, System.Int32 fontFileReferenceKeySize)
        {
            System.Int64 lastWriteTime;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)fontFileReferenceKey, fontFileReferenceKeySize, &lastWriteTime, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
            return lastWriteTime;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("08256209-099a-4b34-b86d-c22b110e7771")]
    public partial class LocalizedStrings : SharpDX.ComObject
    {
        public LocalizedStrings(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator LocalizedStrings(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new LocalizedStrings(nativePtr);
        /// <summary>
        /// <p> Gets the number of language/string pairs. </p>
        /// </summary>
        /// <doc-id>dd371256</doc-id>
        /// <unmanaged>GetCount</unmanaged>
        /// <unmanaged-short>GetCount</unmanaged-short>
        public System.Int32 Count
        {
            get => GetCount();
        }

        /// <summary>
        /// <p> Gets the number of language/string pairs. </p>
        /// </summary>
        /// <returns><p>The number of language/string pairs.</p></returns>
        /// <doc-id>dd371256</doc-id>
        /// <unmanaged>unsigned int IDWriteLocalizedStrings::GetCount()</unmanaged>
        /// <unmanaged-short>IDWriteLocalizedStrings::GetCount</unmanaged-short>
        internal unsafe System.Int32 GetCount()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[3]);
            return __result__;
        }

        /// <summary>
        /// <p> Gets the zero-based index of the locale name/string pair with the specified locale name. </p>
        /// </summary>
        /// <param name = "localeName"><dd>  <p>A null-terminated array of characters containing the locale name to look for.</p> </dd></param>
        /// <param name = "index"><dd>  <p>The zero-based index of the locale name/string pair. This method initializes <em>index</em> to <strong>UINT_MAX</strong>.</p> </dd></param>
        /// <returns><dd>  <p>When this method returns, contains <strong>TRUE</strong> if the locale name exists; otherwise, <strong><see cref = "SharpDX.Result.False"/></strong>. This method initializes <em>exists</em> to <strong><see cref = "SharpDX.Result.False"/></strong>.</p> </dd></returns>
        /// <remarks>
        /// <p>Note that if the locale name does not exist, the return value is a success and the <em>exists</em> parameter is <strong><see cref = "SharpDX.Result.False"/></strong>. If you are getting the font family name for a font and the specified locale name does not exist, one option is to set the index to 0 as shown below.  There is always at least one locale for a font family.</p><pre>UINT32 index = 0;
        /// <see cref = "SharpDX.Mathematics.Interop.RawBool"/> exists = false; wchar_t localeName[LOCALE_NAME_MAX_LENGTH]; if (SUCCEEDED(hr))
        /// { // Get the default locale for this user. int defaultLocaleSuccess = GetUserDefaultLocaleName(localeName, LOCALE_NAME_MAX_LENGTH); // If the default locale is returned, find that locale name, otherwise use "en-us". if (defaultLocaleSuccess) { hr = pFamilyNames-&gt;FindLocaleName(localeName, &amp;index, &amp;exists); } if (SUCCEEDED(hr) &amp; &amp; !exists) // if the above find did not find a match, retry with US English { hr = pFamilyNames-&gt;FindLocaleName(L"en-us", &amp;index, &amp;exists); }
        /// } // If the specified locale doesn't exist, select the first on the list.
        /// if (!exists) index = 0;
        /// </pre>
        /// </remarks>
        /// <doc-id>dd371254</doc-id>
        /// <unmanaged>HRESULT IDWriteLocalizedStrings::FindLocaleName([In] const wchar_t* localeName,[Out] unsigned int* index,[Out] BOOL* exists)</unmanaged>
        /// <unmanaged-short>IDWriteLocalizedStrings::FindLocaleName</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool FindLocaleName(System.String localeName, out System.Int32 index)
        {
            SharpDX.Mathematics.Interop.RawBool exists;
            SharpDX.Result __result__;
            fixed (void *index_ = &index)
                fixed (char *localeName_ = localeName)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)localeName_, index_, &exists, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
            return exists;
        }

        /// <summary>
        /// <p> Gets the length in characters (not including the null terminator) of the locale name with the specified index. </p>
        /// </summary>
        /// <param name = "index"><dd>  <p>Zero-based index of the locale name to be retrieved.</p> </dd></param>
        /// <param name = "length"><dd>  <p>When this method returns, contains the length in characters of the locale name, not including the null terminator.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371262</doc-id>
        /// <unmanaged>HRESULT IDWriteLocalizedStrings::GetLocaleNameLength([In] unsigned int index,[Out] unsigned int* length)</unmanaged>
        /// <unmanaged-short>IDWriteLocalizedStrings::GetLocaleNameLength</unmanaged-short>
        internal unsafe void GetLocaleNameLength(System.Int32 index, out System.Int32 length)
        {
            SharpDX.Result __result__;
            fixed (void *length_ = &length)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, index, length_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Copies the locale name with the specified index to the specified array. </p>
        /// </summary>
        /// <param name = "index"><dd>  <p>Zero-based index of the locale name to be retrieved.</p> </dd></param>
        /// <param name = "localeName"><dd>  <p>When this method returns, contains a character array, which is null-terminated, that receives the locale name from the language/string pair.  The buffer allocated for this array must be at least the size of <em>size</em>, in element count.</p> </dd></param>
        /// <param name = "size"><dd>  <p>The size of the array in characters. The size must include space for the terminating null character.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371259</doc-id>
        /// <unmanaged>HRESULT IDWriteLocalizedStrings::GetLocaleName([In] unsigned int index,[Out, Buffer] wchar_t* localeName,[In] unsigned int size)</unmanaged>
        /// <unmanaged-short>IDWriteLocalizedStrings::GetLocaleName</unmanaged-short>
        internal unsafe void GetLocaleName(System.Int32 index, System.IntPtr localeName, System.Int32 size)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, index, (void *)localeName, size, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Gets the length in characters (not including the null terminator) of the string with the specified index. </p>
        /// </summary>
        /// <param name = "index"><dd>  <p>A zero-based index of the language/string pair.</p> </dd></param>
        /// <param name = "length"><dd>  <p>The length in characters of the string, not including the null terminator, from the language/string pair.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Use <strong>GetStringLength</strong> to get the string length before calling the <strong>IDWriteLocalizedStrings::GetString</strong> method, as shown in the following code.</p><pre>UINT32 length = 0; // Get the string length.
        /// if (SUCCEEDED(hr))
        /// { hr = pFamilyNames-&gt;GetStringLength(index, &amp;length);
        /// } // Allocate a string big enough to hold the name.
        /// wchar_t* name = new (std::nothrow) wchar_t[length+1];
        /// if (name == <c>null</c>)
        /// { hr = E_OUTOFMEMORY;
        /// } // Get the family name.
        /// if (SUCCEEDED(hr))
        /// { hr = pFamilyNames-&gt;GetString(index, name, length+1);
        /// }
        /// </pre>
        /// </remarks>
        /// <doc-id>dd371269</doc-id>
        /// <unmanaged>HRESULT IDWriteLocalizedStrings::GetStringLength([In] unsigned int index,[Out] unsigned int* length)</unmanaged>
        /// <unmanaged-short>IDWriteLocalizedStrings::GetStringLength</unmanaged-short>
        internal unsafe void GetStringLength(System.Int32 index, out System.Int32 length)
        {
            SharpDX.Result __result__;
            fixed (void *length_ = &length)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, index, length_, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Copies the string with the specified index to the specified array. </p>
        /// </summary>
        /// <param name = "index"><dd>  <p>The zero-based index of the language/string pair to be examined.</p> </dd></param>
        /// <param name = "stringBuffer"><dd>  <p>The null terminated array of characters that receives the string from the language/string pair.  The buffer allocated for this array should be at least the size of <em>size</em>. <strong>GetStringLength</strong> can be used to get the size of the array before using this method.</p> </dd></param>
        /// <param name = "size"><dd>  <p>The size of the array in characters. The size must include space for the terminating null character. <strong>GetStringLength</strong> can be used to get the size of the array before using this method.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The string returned must be allocated by the caller.  You can get the size of the string by using the <strong>GetStringLength</strong> method prior to calling <strong>GetString</strong>, as shown in the following example.</p><pre>UINT32 length = 0; // Get the string length.
        /// if (SUCCEEDED(hr))
        /// { hr = pFamilyNames-&gt;GetStringLength(index, &amp;length);
        /// } // Allocate a string big enough to hold the name.
        /// wchar_t* name = new (std::nothrow) wchar_t[length+1];
        /// if (name == <c>null</c>)
        /// { hr = E_OUTOFMEMORY;
        /// } // Get the family name.
        /// if (SUCCEEDED(hr))
        /// { hr = pFamilyNames-&gt;GetString(index, name, length+1);
        /// }
        /// </pre>
        /// </remarks>
        /// <doc-id>dd371267</doc-id>
        /// <unmanaged>HRESULT IDWriteLocalizedStrings::GetString([In] unsigned int index,[Out, Buffer] wchar_t* stringBuffer,[In] unsigned int size)</unmanaged>
        /// <unmanaged-short>IDWriteLocalizedStrings::GetString</unmanaged-short>
        internal unsafe void GetString(System.Int32 index, System.IntPtr stringBuffer, System.Int32 size)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, index, (void *)stringBuffer, size, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("14885CC9-BAB0-4f90-B6ED-5C366A2CD03D")]
    public partial class NumberSubstitution : SharpDX.ComObject
    {
        public NumberSubstitution(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator NumberSubstitution(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new NumberSubstitution(nativePtr);
    }

    [System.Runtime.InteropServices.GuidAttribute("eaf3a2da-ecf4-4d24-b644-b34f6842024b")]
    public partial interface PixelSnapping : SharpDX.IUnknown
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("68648C83-6EDE-46C0-AB46-20083A887FDE")]
    public partial class RemoteFontFileLoader : SharpDX.DirectWrite.FontFileLoaderNative
    {
        public RemoteFontFileLoader(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator RemoteFontFileLoader(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new RemoteFontFileLoader(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "fontFileReferenceKey">No documentation.</param>
        /// <param name = "fontFileReferenceKeySize">No documentation.</param>
        /// <param name = "fontFileStream">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT IDWriteRemoteFontFileLoader::CreateRemoteStreamFromKey([In, Buffer] const void* fontFileReferenceKey,[In] unsigned int fontFileReferenceKeySize,[Out] IDWriteRemoteFontFileStream** fontFileStream)</unmanaged>
        /// <unmanaged-short>IDWriteRemoteFontFileLoader::CreateRemoteStreamFromKey</unmanaged-short>
        public unsafe void CreateRemoteStreamFromKey(System.IntPtr fontFileReferenceKey, System.Int32 fontFileReferenceKeySize, out SharpDX.DirectWrite.RemoteFontFileStream fontFileStream)
        {
            System.IntPtr fontFileStream_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)fontFileReferenceKey, fontFileReferenceKeySize, &fontFileStream_, (*(void ***)this._nativePointer)[4]);
            if (fontFileStream_ != System.IntPtr.Zero)
                fontFileStream = new SharpDX.DirectWrite.RemoteFontFileStream(fontFileStream_);
            else
                fontFileStream = null;
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "fontFileReferenceKey">No documentation.</param>
        /// <param name = "fontFileReferenceKeySize">No documentation.</param>
        /// <param name = "locality">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT IDWriteRemoteFontFileLoader::GetLocalityFromKey([In, Buffer] const void* fontFileReferenceKey,[In] unsigned int fontFileReferenceKeySize,[Out] DWRITE_LOCALITY* locality)</unmanaged>
        /// <unmanaged-short>IDWriteRemoteFontFileLoader::GetLocalityFromKey</unmanaged-short>
        public unsafe void GetLocalityFromKey(System.IntPtr fontFileReferenceKey, System.Int32 fontFileReferenceKeySize, out SharpDX.DirectWrite.Locality locality)
        {
            SharpDX.Result __result__;
            fixed (void *locality_ = &locality)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)fontFileReferenceKey, fontFileReferenceKeySize, locality_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "factory">No documentation.</param>
        /// <param name = "baseUrl">No documentation.</param>
        /// <param name = "fontFileUrl">No documentation.</param>
        /// <param name = "fontFile">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT IDWriteRemoteFontFileLoader::CreateFontFileReferenceFromUrl([In] IDWriteFactory* factory,[In, Optional] const wchar_t* baseUrl,[In] const wchar_t* fontFileUrl,[Out] IDWriteFontFile** fontFile)</unmanaged>
        /// <unmanaged-short>IDWriteRemoteFontFileLoader::CreateFontFileReferenceFromUrl</unmanaged-short>
        public unsafe void CreateFontFileReferenceFromUrl(SharpDX.DirectWrite.Factory factory, System.String baseUrl, System.String fontFileUrl, out SharpDX.DirectWrite.FontFile fontFile)
        {
            System.IntPtr factory_ = System.IntPtr.Zero;
            System.IntPtr fontFile_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            factory_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.Factory>(factory);
            fixed (char *fontFileUrl_ = fontFileUrl)
                fixed (char *baseUrl_ = baseUrl)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)factory_, (void *)baseUrl_, (void *)fontFileUrl_, &fontFile_, (*(void ***)this._nativePointer)[6]);
            if (fontFile_ != System.IntPtr.Zero)
                fontFile = new SharpDX.DirectWrite.FontFile(fontFile_);
            else
                fontFile = null;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("4DB3757A-2C72-4ED9-B2B6-1ABABE1AFF9C")]
    public partial class RemoteFontFileStream : SharpDX.DirectWrite.FontFileStreamNative
    {
        public RemoteFontFileStream(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator RemoteFontFileStream(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new RemoteFontFileStream(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>GetLocalFileSize</unmanaged>
        /// <unmanaged-short>GetLocalFileSize</unmanaged-short>
        public System.Int64 LocalFileSize
        {
            get
            {
                GetLocalFileSize(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>GetLocality</unmanaged>
        /// <unmanaged-short>GetLocality</unmanaged-short>
        public SharpDX.DirectWrite.Locality Locality
        {
            get => GetLocality();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "localFileSize">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT IDWriteRemoteFontFileStream::GetLocalFileSize([Out] unsigned longlong* localFileSize)</unmanaged>
        /// <unmanaged-short>IDWriteRemoteFontFileStream::GetLocalFileSize</unmanaged-short>
        internal unsafe void GetLocalFileSize(out System.Int64 localFileSize)
        {
            SharpDX.Result __result__;
            fixed (void *localFileSize_ = &localFileSize)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, localFileSize_, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "fileOffset">No documentation.</param>
        /// <param name = "fragmentSize">No documentation.</param>
        /// <param name = "isLocal">No documentation.</param>
        /// <param name = "artialSizeRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT IDWriteRemoteFontFileStream::GetFileFragmentLocality([In] unsigned longlong fileOffset,[In] unsigned longlong fragmentSize,[Out] BOOL* isLocal,[In] unsigned longlong* partialSize)</unmanaged>
        /// <unmanaged-short>IDWriteRemoteFontFileStream::GetFileFragmentLocality</unmanaged-short>
        public unsafe void GetFileFragmentLocality(System.Int64 fileOffset, System.Int64 fragmentSize, out SharpDX.Mathematics.Interop.RawBool isLocal, System.Int64 artialSizeRef)
        {
            isLocal = default (SharpDX.Mathematics.Interop.RawBool);
            SharpDX.Result __result__;
            fixed (void *isLocal_ = &isLocal)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, fileOffset, fragmentSize, isLocal_, &artialSizeRef, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <returns>No documentation.</returns>
        /// <unmanaged>DWRITE_LOCALITY IDWriteRemoteFontFileStream::GetLocality()</unmanaged>
        /// <unmanaged-short>IDWriteRemoteFontFileStream::GetLocality</unmanaged-short>
        internal unsafe SharpDX.DirectWrite.Locality GetLocality()
        {
            SharpDX.DirectWrite.Locality __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirectWriteLocality(this._nativePointer, (*(void ***)this._nativePointer)[9]);
            return __result__;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "downloadOperationID">No documentation.</param>
        /// <param name = "fileFragments">No documentation.</param>
        /// <param name = "fragmentCount">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT IDWriteRemoteFontFileStream::BeginDownload([In] const GUID* downloadOperationID,[In, Buffer] const DWRITE_FILE_FRAGMENT* fileFragments,[In] unsigned int fragmentCount,[Out, Optional] IDWriteAsyncResult** asyncResult)</unmanaged>
        /// <unmanaged-short>IDWriteRemoteFontFileStream::BeginDownload</unmanaged-short>
        public unsafe SharpDX.DirectWrite.AsyncResult BeginDownload(System.Guid downloadOperationID, SharpDX.DirectWrite.FileFragment[] fileFragments, System.Int32 fragmentCount)
        {
            SharpDX.DirectWrite.AsyncResult asyncResult;
            System.IntPtr asyncResult_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *fileFragments_ = fileFragments)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &downloadOperationID, fileFragments_, fragmentCount, &asyncResult_, (*(void ***)this._nativePointer)[10]);
            if (asyncResult_ != System.IntPtr.Zero)
                asyncResult = new SharpDX.DirectWrite.AsyncResult(asyncResult_);
            else
                asyncResult = null;
            __result__.CheckError();
            return asyncResult;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("2f0da53a-2add-47cd-82ee-d9ec34688e75")]
    public partial class RenderingParams : SharpDX.ComObject
    {
        public RenderingParams(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator RenderingParams(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new RenderingParams(nativePtr);
        /// <summary>
        /// <p>Gets the gamma value used for gamma correction. Valid values must be greater than zero and cannot exceed 256.</p>
        /// </summary>
        /// <remarks>
        /// <p>The gamma value is used for gamma correction, which compensates for the non-linear luminosity response of most monitors.</p>
        /// </remarks>
        /// <doc-id>dd371295</doc-id>
        /// <unmanaged>GetGamma</unmanaged>
        /// <unmanaged-short>GetGamma</unmanaged-short>
        public System.Single Gamma
        {
            get => GetGamma();
        }

        /// <summary>
        /// <p>Gets the enhanced contrast property of the rendering parameters object. Valid values are greater than or equal to zero.</p>
        /// </summary>
        /// <remarks>
        /// <p>Enhanced contrast is the amount to increase the darkness of text, and typically ranges from 0 to 1. Zero means no contrast enhancement.</p>
        /// </remarks>
        /// <doc-id>dd371290</doc-id>
        /// <unmanaged>GetEnhancedContrast</unmanaged>
        /// <unmanaged-short>GetEnhancedContrast</unmanaged-short>
        public System.Single EnhancedContrast
        {
            get => GetEnhancedContrast();
        }

        /// <summary>
        /// <p>Gets the ClearType level of the rendering parameters object. </p>
        /// </summary>
        /// <remarks>
        /// <p>The ClearType level represents the amount of ClearType ? that is, the degree to which the red, green, and blue subpixels of each pixel are treated differently. Valid values range from zero (meaning no ClearType, which is equivalent to grayscale anti-aliasing) to one (meaning full ClearType)</p>
        /// </remarks>
        /// <doc-id>dd371288</doc-id>
        /// <unmanaged>GetClearTypeLevel</unmanaged>
        /// <unmanaged-short>GetClearTypeLevel</unmanaged-short>
        public System.Single ClearTypeLevel
        {
            get => GetClearTypeLevel();
        }

        /// <summary>
        /// <p>Gets the pixel geometry of the rendering parameters object.</p>
        /// </summary>
        /// <doc-id>dd371297</doc-id>
        /// <unmanaged>GetPixelGeometry</unmanaged>
        /// <unmanaged-short>GetPixelGeometry</unmanaged-short>
        public SharpDX.DirectWrite.PixelGeometry PixelGeometry
        {
            get => GetPixelGeometry();
        }

        /// <summary>
        /// <p>Gets the rendering mode of the rendering parameters object.</p>
        /// </summary>
        /// <remarks>
        /// <p>By default, the rendering mode is initialized to DWRITE_RENDERING_MODE_DEFAULT, which means the rendering mode is determined automatically based on the font and size. To determine the recommended rendering mode to use for a given font and size and rendering parameters object, use the <strong>IDWriteFontFace::GetRecommendedRenderingMode</strong> method.</p>
        /// </remarks>
        /// <doc-id>dd371300</doc-id>
        /// <unmanaged>GetRenderingMode</unmanaged>
        /// <unmanaged-short>GetRenderingMode</unmanaged-short>
        public SharpDX.DirectWrite.RenderingMode RenderingMode
        {
            get => GetRenderingMode();
        }

        /// <summary>
        /// <p>Gets the gamma value used for gamma correction. Valid values must be greater than zero and cannot exceed 256.</p>
        /// </summary>
        /// <returns><p>Returns the gamma value used for gamma correction. Valid values must be greater than zero and cannot exceed 256.</p></returns>
        /// <remarks>
        /// <p>The gamma value is used for gamma correction, which compensates for the non-linear luminosity response of most monitors.</p>
        /// </remarks>
        /// <doc-id>dd371295</doc-id>
        /// <unmanaged>float IDWriteRenderingParams::GetGamma()</unmanaged>
        /// <unmanaged-short>IDWriteRenderingParams::GetGamma</unmanaged-short>
        internal unsafe System.Single GetGamma()
        {
            System.Single __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallfloat(this._nativePointer, (*(void ***)this._nativePointer)[3]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets the enhanced contrast property of the rendering parameters object. Valid values are greater than or equal to zero.</p>
        /// </summary>
        /// <returns><p>Returns the amount of contrast enhancement. Valid values are greater than or equal to zero.</p></returns>
        /// <remarks>
        /// <p>Enhanced contrast is the amount to increase the darkness of text, and typically ranges from 0 to 1. Zero means no contrast enhancement.</p>
        /// </remarks>
        /// <doc-id>dd371290</doc-id>
        /// <unmanaged>float IDWriteRenderingParams::GetEnhancedContrast()</unmanaged>
        /// <unmanaged-short>IDWriteRenderingParams::GetEnhancedContrast</unmanaged-short>
        internal unsafe System.Single GetEnhancedContrast()
        {
            System.Single __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallfloat(this._nativePointer, (*(void ***)this._nativePointer)[4]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets the ClearType level of the rendering parameters object. </p>
        /// </summary>
        /// <returns><p>The ClearType level of the rendering parameters object.</p></returns>
        /// <remarks>
        /// <p>The ClearType level represents the amount of ClearType ? that is, the degree to which the red, green, and blue subpixels of each pixel are treated differently. Valid values range from zero (meaning no ClearType, which is equivalent to grayscale anti-aliasing) to one (meaning full ClearType)</p>
        /// </remarks>
        /// <doc-id>dd371288</doc-id>
        /// <unmanaged>float IDWriteRenderingParams::GetClearTypeLevel()</unmanaged>
        /// <unmanaged-short>IDWriteRenderingParams::GetClearTypeLevel</unmanaged-short>
        internal unsafe System.Single GetClearTypeLevel()
        {
            System.Single __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallfloat(this._nativePointer, (*(void ***)this._nativePointer)[5]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets the pixel geometry of the rendering parameters object.</p>
        /// </summary>
        /// <returns><p> A value that indicates the type of  pixel geometry used in the rendering parameters object.</p></returns>
        /// <doc-id>dd371297</doc-id>
        /// <unmanaged>DWRITE_PIXEL_GEOMETRY IDWriteRenderingParams::GetPixelGeometry()</unmanaged>
        /// <unmanaged-short>IDWriteRenderingParams::GetPixelGeometry</unmanaged-short>
        internal unsafe SharpDX.DirectWrite.PixelGeometry GetPixelGeometry()
        {
            SharpDX.DirectWrite.PixelGeometry __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirectWritePixelGeometry(this._nativePointer, (*(void ***)this._nativePointer)[6]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets the rendering mode of the rendering parameters object.</p>
        /// </summary>
        /// <returns><p>A value that indicates the rendering mode of the rendering parameters object.</p></returns>
        /// <remarks>
        /// <p>By default, the rendering mode is initialized to DWRITE_RENDERING_MODE_DEFAULT, which means the rendering mode is determined automatically based on the font and size. To determine the recommended rendering mode to use for a given font and size and rendering parameters object, use the <strong>IDWriteFontFace::GetRecommendedRenderingMode</strong> method.</p>
        /// </remarks>
        /// <doc-id>dd371300</doc-id>
        /// <unmanaged>DWRITE_RENDERING_MODE IDWriteRenderingParams::GetRenderingMode()</unmanaged>
        /// <unmanaged-short>IDWriteRenderingParams::GetRenderingMode</unmanaged-short>
        internal unsafe SharpDX.DirectWrite.RenderingMode GetRenderingMode()
        {
            SharpDX.DirectWrite.RenderingMode __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirectWriteRenderingMode(this._nativePointer, (*(void ***)this._nativePointer)[7]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("94413cf4-a6fc-4248-8b50-6674348fcad3")]
    public partial class RenderingParams1 : SharpDX.DirectWrite.RenderingParams
    {
        public RenderingParams1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator RenderingParams1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new RenderingParams1(nativePtr);
        /// <summary>
        /// <p>Gets the amount of contrast enhancement to use for grayscale antialiasing.</p>
        /// </summary>
        /// <doc-id>hh780423</doc-id>
        /// <unmanaged>GetGrayscaleEnhancedContrast</unmanaged>
        /// <unmanaged-short>GetGrayscaleEnhancedContrast</unmanaged-short>
        public System.Single GrayscaleEnhancedContrast
        {
            get => GetGrayscaleEnhancedContrast();
        }

        /// <summary>
        /// <p>Gets the amount of contrast enhancement to use for grayscale antialiasing.</p>
        /// </summary>
        /// <returns><p>The contrast enhancement value. Valid values are greater than or equal to zero.</p></returns>
        /// <doc-id>hh780423</doc-id>
        /// <unmanaged>float IDWriteRenderingParams1::GetGrayscaleEnhancedContrast()</unmanaged>
        /// <unmanaged-short>IDWriteRenderingParams1::GetGrayscaleEnhancedContrast</unmanaged-short>
        internal unsafe System.Single GetGrayscaleEnhancedContrast()
        {
            System.Single __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallfloat(this._nativePointer, (*(void ***)this._nativePointer)[8]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("F9D711C3-9777-40AE-87E8-3E5AF9BF0948")]
    public partial class RenderingParams2 : SharpDX.DirectWrite.RenderingParams1
    {
        public RenderingParams2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator RenderingParams2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new RenderingParams2(nativePtr);
        /// <summary>
        /// <p>Gets the grid fitting mode.</p>
        /// </summary>
        /// <doc-id>dn900388</doc-id>
        /// <unmanaged>GetGridFitMode</unmanaged>
        /// <unmanaged-short>GetGridFitMode</unmanaged-short>
        public SharpDX.DirectWrite.GridFitMode GridFitMode
        {
            get => GetGridFitMode();
        }

        /// <summary>
        /// <p>Gets the grid fitting mode.</p>
        /// </summary>
        /// <returns><p>Returns a <strong><see cref = "SharpDX.DirectWrite.GridFitMode"/></strong>-typed value for the grid fitting mode.</p></returns>
        /// <doc-id>dn900388</doc-id>
        /// <unmanaged>DWRITE_GRID_FIT_MODE IDWriteRenderingParams2::GetGridFitMode()</unmanaged>
        /// <unmanaged-short>IDWriteRenderingParams2::GetGridFitMode</unmanaged-short>
        internal unsafe SharpDX.DirectWrite.GridFitMode GetGridFitMode()
        {
            SharpDX.DirectWrite.GridFitMode __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirectWriteGridFitMode(this._nativePointer, (*(void ***)this._nativePointer)[9]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("B7924BAA-391B-412A-8C5C-E44CC2D867DC")]
    public partial class RenderingParams3 : SharpDX.DirectWrite.RenderingParams2
    {
        public RenderingParams3(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator RenderingParams3(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new RenderingParams3(nativePtr);
        /// <summary>
        /// <p>Gets the rendering mode.</p>
        /// </summary>
        /// <doc-id>dn900390</doc-id>
        /// <unmanaged>GetRenderingMode1</unmanaged>
        /// <unmanaged-short>GetRenderingMode1</unmanaged-short>
        public SharpDX.DirectWrite.RenderingMode1 RenderingMode1
        {
            get => GetRenderingMode1();
        }

        /// <summary>
        /// <p>Gets the rendering mode.</p>
        /// </summary>
        /// <returns><p>Returns a <strong><see cref = "SharpDX.DirectWrite.RenderingMode1"/></strong>-typed value for the rendering mode.</p></returns>
        /// <doc-id>dn900390</doc-id>
        /// <unmanaged>DWRITE_RENDERING_MODE1 IDWriteRenderingParams3::GetRenderingMode1()</unmanaged>
        /// <unmanaged-short>IDWriteRenderingParams3::GetRenderingMode1</unmanaged-short>
        internal unsafe SharpDX.DirectWrite.RenderingMode1 GetRenderingMode1()
        {
            SharpDX.DirectWrite.RenderingMode1 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirectWriteRenderingMode1(this._nativePointer, (*(void ***)this._nativePointer)[10]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("CFEE3140-1157-47CA-8B85-31BFCF3F2D0E")]
    public partial class StringList : SharpDX.ComObject
    {
        public StringList(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator StringList(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new StringList(nativePtr);
        /// <summary>
        /// <p>Gets the number of strings in the string list.</p>
        /// </summary>
        /// <doc-id>dn958422</doc-id>
        /// <unmanaged>GetCount</unmanaged>
        /// <unmanaged-short>GetCount</unmanaged-short>
        public System.Int32 Count
        {
            get => GetCount();
        }

        /// <summary>
        /// <p>Gets the number of strings in the string list.</p>
        /// </summary>
        /// <returns><p>Returns the number of strings in the string list.</p></returns>
        /// <doc-id>dn958422</doc-id>
        /// <unmanaged>unsigned int IDWriteStringList::GetCount()</unmanaged>
        /// <unmanaged-short>IDWriteStringList::GetCount</unmanaged-short>
        internal unsafe System.Int32 GetCount()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[3]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets the length in characters (not including the null terminator) of the locale name with the specified index.</p>
        /// </summary>
        /// <param name = "listIndex"><dd>  <p>Zero-based index of the locale name.</p> </dd></param>
        /// <param name = "length"><dd>  <p>Receives the length in characters, not including the null terminator.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn958424</doc-id>
        /// <unmanaged>HRESULT IDWriteStringList::GetLocaleNameLength([In] unsigned int listIndex,[Out] unsigned int* length)</unmanaged>
        /// <unmanaged-short>IDWriteStringList::GetLocaleNameLength</unmanaged-short>
        public unsafe void GetLocaleNameLength(System.Int32 listIndex, out System.Int32 length)
        {
            SharpDX.Result __result__;
            fixed (void *length_ = &length)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, listIndex, length_, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Copies the locale name with the specified index to the specified array.</p>
        /// </summary>
        /// <param name = "listIndex"><dd>  <p>Zero-based index of the locale name.</p> </dd></param>
        /// <param name = "localeName"><dd>  <p>Character array that receives the locale name.</p> </dd></param>
        /// <param name = "size"><dd>  <p>Size of the array in characters. The size must include space for the terminating null character.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn958423</doc-id>
        /// <unmanaged>HRESULT IDWriteStringList::GetLocaleName([In] unsigned int listIndex,[Out, Buffer] wchar_t* localeName,[In] unsigned int size)</unmanaged>
        /// <unmanaged-short>IDWriteStringList::GetLocaleName</unmanaged-short>
        public unsafe void GetLocaleName(System.Int32 listIndex, System.IntPtr localeName, System.Int32 size)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, listIndex, (void *)localeName, size, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the length in characters (not including the null terminator) of the string with the specified index.</p>
        /// </summary>
        /// <param name = "listIndex"><dd>  <p>Zero-based index of the string.</p> </dd></param>
        /// <param name = "length"><dd>  <p>Receives the length in characters of the string, not including the null terminator.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn958426</doc-id>
        /// <unmanaged>HRESULT IDWriteStringList::GetStringLength([In] unsigned int listIndex,[Out] unsigned int* length)</unmanaged>
        /// <unmanaged-short>IDWriteStringList::GetStringLength</unmanaged-short>
        public unsafe void GetStringLength(System.Int32 listIndex, out System.Int32 length)
        {
            SharpDX.Result __result__;
            fixed (void *length_ = &length)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, listIndex, length_, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Copies the string with the specified index to the specified array.</p>
        /// </summary>
        /// <param name = "listIndex"><dd>  <p>Zero-based index of the string.</p> </dd></param>
        /// <param name = "stringBuffer"><dd>  <p>Character array that receives the string.</p> </dd></param>
        /// <param name = "stringBufferSize"><dd>  <p>Size of the array in characters. The size must include space for the terminating null character.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn958425</doc-id>
        /// <unmanaged>HRESULT IDWriteStringList::GetString([In] unsigned int listIndex,[Out, Buffer] wchar_t* stringBuffer,[In] unsigned int stringBufferSize)</unmanaged>
        /// <unmanaged-short>IDWriteStringList::GetString</unmanaged-short>
        public unsafe void GetString(System.Int32 listIndex, System.IntPtr stringBuffer, System.Int32 stringBufferSize)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, listIndex, (void *)stringBuffer, stringBufferSize, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("5810cd44-0ca0-4701-b3fa-bec5182ae4f6")]
    public partial interface TextAnalysisSink : SharpDX.IUnknown
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("B0D941A0-85E7-4D8B-9FD3-5CED9934482A")]
    public partial interface TextAnalysisSink1 : SharpDX.DirectWrite.TextAnalysisSink
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("688e1a58-5094-47c8-adc8-fbcea60ae92b")]
    public partial interface TextAnalysisSource : SharpDX.IUnknown
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("639CFAD8-0FB4-4B21-A58A-067920120009")]
    public partial interface TextAnalysisSource1 : SharpDX.DirectWrite.TextAnalysisSource
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("b7e6163e-7f46-43b4-84b3-e4e6249c365d")]
    public partial class TextAnalyzer : SharpDX.ComObject
    {
        public TextAnalyzer(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator TextAnalyzer(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new TextAnalyzer(nativePtr);
        /// <summary>
        /// <p> Analyzes a text range for script boundaries, reading text attributes from the source and reporting the Unicode script ID to the sink  callback <strong>SetScript</strong>. </p>
        /// </summary>
        /// <param name = "analysisSource">No documentation.</param>
        /// <param name = "textPosition">No documentation.</param>
        /// <param name = "textLength">No documentation.</param>
        /// <param name = "analysisSink">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd316620</doc-id>
        /// <unmanaged>HRESULT IDWriteTextAnalyzer::AnalyzeScript([In] IDWriteTextAnalysisSource* analysisSource,[In] unsigned int textPosition,[In] unsigned int textLength,[In] IDWriteTextAnalysisSink* analysisSink)</unmanaged>
        /// <unmanaged-short>IDWriteTextAnalyzer::AnalyzeScript</unmanaged-short>
        public unsafe void AnalyzeScript(SharpDX.DirectWrite.TextAnalysisSource analysisSource, System.Int32 textPosition, System.Int32 textLength, SharpDX.DirectWrite.TextAnalysisSink analysisSink)
        {
            System.IntPtr analysisSource_ = System.IntPtr.Zero;
            System.IntPtr analysisSink_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            analysisSource_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.TextAnalysisSource>(analysisSource);
            analysisSink_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.TextAnalysisSink>(analysisSink);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)analysisSource_, textPosition, textLength, (void *)analysisSink_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Analyzes a text range for script directionality, reading attributes from the source and reporting levels to the sink callback <strong>SetBidiLevel</strong>. </p>
        /// </summary>
        /// <param name = "analysisSource">No documentation.</param>
        /// <param name = "textPosition">No documentation.</param>
        /// <param name = "textLength">No documentation.</param>
        /// <param name = "analysisSink">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p> While the function can handle multiple paragraphs, the text range should not arbitrarily split the middle of paragraphs. Otherwise, the returned levels may be wrong, because the Bidi algorithm is meant to apply to the paragraph as a whole. </p>
        /// </remarks>
        /// <doc-id>dd316610</doc-id>
        /// <unmanaged>HRESULT IDWriteTextAnalyzer::AnalyzeBidi([In] IDWriteTextAnalysisSource* analysisSource,[In] unsigned int textPosition,[In] unsigned int textLength,[In] IDWriteTextAnalysisSink* analysisSink)</unmanaged>
        /// <unmanaged-short>IDWriteTextAnalyzer::AnalyzeBidi</unmanaged-short>
        public unsafe void AnalyzeBidi(SharpDX.DirectWrite.TextAnalysisSource analysisSource, System.Int32 textPosition, System.Int32 textLength, SharpDX.DirectWrite.TextAnalysisSink analysisSink)
        {
            System.IntPtr analysisSource_ = System.IntPtr.Zero;
            System.IntPtr analysisSink_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            analysisSource_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.TextAnalysisSource>(analysisSource);
            analysisSink_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.TextAnalysisSink>(analysisSink);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)analysisSource_, textPosition, textLength, (void *)analysisSink_, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Analyzes a text range for spans where number substitution is applicable, reading attributes from the source and reporting substitutable ranges to the sink callback <strong>SetNumberSubstitution</strong>. </p>
        /// </summary>
        /// <param name = "analysisSource">No documentation.</param>
        /// <param name = "textPosition">No documentation.</param>
        /// <param name = "textLength">No documentation.</param>
        /// <param name = "analysisSink">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p> Although the function can handle multiple ranges of differing number substitutions, the text ranges should not arbitrarily split the middle of numbers. Otherwise, it will treat the numbers separately and will not translate any intervening punctuation. </p>
        /// </remarks>
        /// <doc-id>dd316616</doc-id>
        /// <unmanaged>HRESULT IDWriteTextAnalyzer::AnalyzeNumberSubstitution([In] IDWriteTextAnalysisSource* analysisSource,[In] unsigned int textPosition,[In] unsigned int textLength,[In] IDWriteTextAnalysisSink* analysisSink)</unmanaged>
        /// <unmanaged-short>IDWriteTextAnalyzer::AnalyzeNumberSubstitution</unmanaged-short>
        public unsafe void AnalyzeNumberSubstitution(SharpDX.DirectWrite.TextAnalysisSource analysisSource, System.Int32 textPosition, System.Int32 textLength, SharpDX.DirectWrite.TextAnalysisSink analysisSink)
        {
            System.IntPtr analysisSource_ = System.IntPtr.Zero;
            System.IntPtr analysisSink_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            analysisSource_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.TextAnalysisSource>(analysisSource);
            analysisSink_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.TextAnalysisSink>(analysisSink);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)analysisSource_, textPosition, textLength, (void *)analysisSink_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Analyzes a text range for potential breakpoint opportunities, reading attributes from the source and reporting breakpoint opportunities to the sink callback <strong>SetLineBreakpoints</strong>. </p>
        /// </summary>
        /// <param name = "analysisSource">No documentation.</param>
        /// <param name = "textPosition">No documentation.</param>
        /// <param name = "textLength">No documentation.</param>
        /// <param name = "analysisSink">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p> Although the function can handle multiple paragraphs, the text range should not arbitrarily split the middle of paragraphs, unless the specified text span is considered a whole unit. Otherwise, the returned properties for the first and last characters will inappropriately allow breaks. </p>
        /// </remarks>
        /// <doc-id>dd316613</doc-id>
        /// <unmanaged>HRESULT IDWriteTextAnalyzer::AnalyzeLineBreakpoints([In] IDWriteTextAnalysisSource* analysisSource,[In] unsigned int textPosition,[In] unsigned int textLength,[In] IDWriteTextAnalysisSink* analysisSink)</unmanaged>
        /// <unmanaged-short>IDWriteTextAnalyzer::AnalyzeLineBreakpoints</unmanaged-short>
        public unsafe void AnalyzeLineBreakpoints(SharpDX.DirectWrite.TextAnalysisSource analysisSource, System.Int32 textPosition, System.Int32 textLength, SharpDX.DirectWrite.TextAnalysisSink analysisSink)
        {
            System.IntPtr analysisSource_ = System.IntPtr.Zero;
            System.IntPtr analysisSink_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            analysisSource_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.TextAnalysisSource>(analysisSource);
            analysisSink_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.TextAnalysisSink>(analysisSink);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)analysisSource_, textPosition, textLength, (void *)analysisSink_, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Parses the input text string and maps it to the set of glyphs and associated glyph data according to the font and the writing system's rendering rules. </p>
        /// </summary>
        /// <param name = "textString"><dd>  <p>An array of characters to convert to glyphs.</p> </dd></param>
        /// <param name = "textLength"><dd>  <p>The length of <em>textString</em>.</p> </dd></param>
        /// <param name = "fontFace"><dd>  <p>The font face that is the source of the output glyphs.</p> </dd></param>
        /// <param name = "isSideways"><dd>  <p>A Boolean flag set to <strong>TRUE</strong> if the text is intended to be drawn vertically.</p> </dd></param>
        /// <param name = "isRightToLeft"><dd>  <p>A Boolean flag set to <strong>TRUE</strong> for right-to-left text.</p> </dd></param>
        /// <param name = "scriptAnalysis"><dd>  <p>A reference to a Script analysis result from an <strong>AnalyzeScript</strong> call.</p> </dd></param>
        /// <param name = "localeName"><dd>  <p>The locale to use when selecting glyphs. For example the same character may map to different glyphs for ja-jp versus zh-chs. If this is <strong><c>null</c></strong>, then the default mapping based on the script is used.</p> </dd></param>
        /// <param name = "numberSubstitution"><dd>  <p>A reference to an optional number substitution which selects the appropriate glyphs for digits and related numeric characters, depending on the results obtained from <strong>AnalyzeNumberSubstitution</strong>. Passing <strong><c>null</c></strong> indicates that no substitution is needed and that the digits should receive nominal glyphs.</p> </dd></param>
        /// <param name = "features"><dd>  <p>An array of references to the sets of typographic  features to use in each feature range.</p> </dd></param>
        /// <param name = "featureRangeLengths"><dd>  <p>The length of each feature range, in characters.   The sum of all lengths should be equal to <em>textLength</em>.</p> </dd></param>
        /// <param name = "featureRanges"><dd>  <p>The number of feature ranges.</p> </dd></param>
        /// <param name = "maxGlyphCount"><dd>  <p>The maximum number of glyphs that can be returned.</p> </dd></param>
        /// <param name = "clusterMap"><dd>  <p>When this method returns, contains the mapping from character ranges to glyph  ranges.</p> </dd></param>
        /// <param name = "textProps"><dd>  <p>When this method returns, contains a reference to an array of structures that contains  shaping properties for each character.</p> </dd></param>
        /// <param name = "glyphIndices"><dd>  <p>The output glyph indices.</p> </dd></param>
        /// <param name = "glyphProps"><dd>  <p>When this method returns, contains a reference to an array of structures that contain  shaping properties for each output glyph.</p> </dd></param>
        /// <param name = "actualGlyphCount"><dd>  <p>When this method returns, contains the actual number of glyphs returned if the call succeeds.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p> Note that the mapping from characters to glyphs is, in general, many-to-many.  The recommended estimate for the per-glyph output buffers is (3 * <em>textLength</em> / 2 + 16).  This is not guaranteed to be sufficient. The value of the <em>actualGlyphCount</em> parameter is only valid if the call succeeds.  In the event that <em>maxGlyphCount</em> is not big enough, <strong>HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)</strong> will be returned.  The application should  allocate a larger buffer and try again. </p>
        /// </remarks>
        /// <doc-id>dd316625</doc-id>
        /// <unmanaged>HRESULT IDWriteTextAnalyzer::GetGlyphs([In, Buffer] const wchar_t* textString,[In] unsigned int textLength,[In] IDWriteFontFace* fontFace,[In] BOOL isSideways,[In] BOOL isRightToLeft,[In] const DWRITE_SCRIPT_ANALYSIS* scriptAnalysis,[In, Optional] const wchar_t* localeName,[In, Optional] IDWriteNumberSubstitution* numberSubstitution,[In, Optional] const void** features,[In, Buffer, Optional] const unsigned int* featureRangeLengths,[In] unsigned int featureRanges,[In] unsigned int maxGlyphCount,[Out, Buffer] unsigned short* clusterMap,[Out, Buffer] DWRITE_SHAPING_TEXT_PROPERTIES* textProps,[Out, Buffer] unsigned short* glyphIndices,[Out, Buffer] DWRITE_SHAPING_GLYPH_PROPERTIES* glyphProps,[Out] unsigned int* actualGlyphCount)</unmanaged>
        /// <unmanaged-short>IDWriteTextAnalyzer::GetGlyphs</unmanaged-short>
        internal unsafe void GetGlyphs(System.String textString, System.Int32 textLength, SharpDX.DirectWrite.FontFace fontFace, SharpDX.Mathematics.Interop.RawBool isSideways, SharpDX.Mathematics.Interop.RawBool isRightToLeft, SharpDX.DirectWrite.ScriptAnalysis scriptAnalysis, System.String localeName, SharpDX.DirectWrite.NumberSubstitution numberSubstitution, System.IntPtr features, System.Int32[] featureRangeLengths, System.Int32 featureRanges, System.Int32 maxGlyphCount, System.Int16[] clusterMap, SharpDX.DirectWrite.ShapingTextProperties[] textProps, System.Int16[] glyphIndices, SharpDX.DirectWrite.ShapingGlyphProperties[] glyphProps, out System.Int32 actualGlyphCount)
        {
            System.IntPtr fontFace_ = System.IntPtr.Zero;
            System.IntPtr numberSubstitution_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fontFace_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.FontFace>(fontFace);
            numberSubstitution_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.NumberSubstitution>(numberSubstitution);
            fixed (void *actualGlyphCount_ = &actualGlyphCount)
                fixed (void *glyphProps_ = glyphProps)
                    fixed (void *glyphIndices_ = glyphIndices)
                        fixed (void *textProps_ = textProps)
                            fixed (void *clusterMap_ = clusterMap)
                                fixed (void *featureRangeLengths_ = featureRangeLengths)
                                    fixed (char *localeName_ = localeName)
                                        fixed (char *textString_ = textString)
                                            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, (void *)textString_, textLength, (void *)fontFace_, isSideways, isRightToLeft, &scriptAnalysis, (void *)localeName_, (void *)numberSubstitution_, (void *)features, featureRangeLengths_, featureRanges, maxGlyphCount, clusterMap_, textProps_, glyphIndices_, glyphProps_, actualGlyphCount_, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Places glyphs output from the <strong>GetGlyphs</strong> method according to the font  and the writing system's rendering rules. </p>
        /// </summary>
        /// <param name = "textString">No documentation.</param>
        /// <param name = "clusterMap">No documentation.</param>
        /// <param name = "textProps">No documentation.</param>
        /// <param name = "textLength">No documentation.</param>
        /// <param name = "glyphIndices">No documentation.</param>
        /// <param name = "glyphProps">No documentation.</param>
        /// <param name = "glyphCount">No documentation.</param>
        /// <param name = "fontFace">No documentation.</param>
        /// <param name = "fontEmSize">No documentation.</param>
        /// <param name = "isSideways">No documentation.</param>
        /// <param name = "isRightToLeft">No documentation.</param>
        /// <param name = "scriptAnalysis">No documentation.</param>
        /// <param name = "localeName">No documentation.</param>
        /// <param name = "features">No documentation.</param>
        /// <param name = "featureRangeLengths">No documentation.</param>
        /// <param name = "featureRanges">No documentation.</param>
        /// <param name = "glyphAdvances">No documentation.</param>
        /// <param name = "glyphOffsets">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd316622</doc-id>
        /// <unmanaged>HRESULT IDWriteTextAnalyzer::GetGlyphPlacements([In, Buffer] const wchar_t* textString,[In, Buffer] const unsigned short* clusterMap,[Out, Buffer] DWRITE_SHAPING_TEXT_PROPERTIES* textProps,[In] unsigned int textLength,[In, Buffer] const unsigned short* glyphIndices,[In, Buffer] const DWRITE_SHAPING_GLYPH_PROPERTIES* glyphProps,[In] unsigned int glyphCount,[In] IDWriteFontFace* fontFace,[In] float fontEmSize,[In] BOOL isSideways,[In] BOOL isRightToLeft,[In] const DWRITE_SCRIPT_ANALYSIS* scriptAnalysis,[In, Optional] const wchar_t* localeName,[In, Optional] const void** features,[In, Buffer, Optional] const unsigned int* featureRangeLengths,[In] unsigned int featureRanges,[Out, Buffer] float* glyphAdvances,[Out, Buffer] DWRITE_GLYPH_OFFSET* glyphOffsets)</unmanaged>
        /// <unmanaged-short>IDWriteTextAnalyzer::GetGlyphPlacements</unmanaged-short>
        internal unsafe void GetGlyphPlacements(System.String textString, System.Int16[] clusterMap, SharpDX.DirectWrite.ShapingTextProperties[] textProps, System.Int32 textLength, System.Int16[] glyphIndices, SharpDX.DirectWrite.ShapingGlyphProperties[] glyphProps, System.Int32 glyphCount, SharpDX.DirectWrite.FontFace fontFace, System.Single fontEmSize, SharpDX.Mathematics.Interop.RawBool isSideways, SharpDX.Mathematics.Interop.RawBool isRightToLeft, SharpDX.DirectWrite.ScriptAnalysis scriptAnalysis, System.String localeName, System.IntPtr features, System.Int32[] featureRangeLengths, System.Int32 featureRanges, System.Single[] glyphAdvances, SharpDX.DirectWrite.GlyphOffset[] glyphOffsets)
        {
            System.IntPtr fontFace_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fontFace_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.FontFace>(fontFace);
            fixed (void *glyphOffsets_ = glyphOffsets)
                fixed (void *glyphAdvances_ = glyphAdvances)
                    fixed (void *featureRangeLengths_ = featureRangeLengths)
                        fixed (char *localeName_ = localeName)
                            fixed (void *glyphProps_ = glyphProps)
                                fixed (void *glyphIndices_ = glyphIndices)
                                    fixed (void *textProps_ = textProps)
                                        fixed (void *clusterMap_ = clusterMap)
                                            fixed (char *textString_ = textString)
                                                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, (void *)textString_, clusterMap_, textProps_, textLength, glyphIndices_, glyphProps_, glyphCount, (void *)fontFace_, fontEmSize, isSideways, isRightToLeft, &scriptAnalysis, (void *)localeName_, (void *)features, featureRangeLengths_, featureRanges, glyphAdvances_, glyphOffsets_, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Place glyphs output from the <strong>GetGlyphs</strong> method according to the font  and the writing system's rendering rules.</p>
        /// </summary>
        /// <param name = "textString">No documentation.</param>
        /// <param name = "clusterMap">No documentation.</param>
        /// <param name = "textProps">No documentation.</param>
        /// <param name = "textLength">No documentation.</param>
        /// <param name = "glyphIndices">No documentation.</param>
        /// <param name = "glyphProps">No documentation.</param>
        /// <param name = "glyphCount">No documentation.</param>
        /// <param name = "fontFace">No documentation.</param>
        /// <param name = "fontEmSize">No documentation.</param>
        /// <param name = "pixelsPerDip">No documentation.</param>
        /// <param name = "transform">No documentation.</param>
        /// <param name = "useGdiNatural">No documentation.</param>
        /// <param name = "isSideways">No documentation.</param>
        /// <param name = "isRightToLeft">No documentation.</param>
        /// <param name = "scriptAnalysis">No documentation.</param>
        /// <param name = "localeName">No documentation.</param>
        /// <param name = "features">No documentation.</param>
        /// <param name = "featureRangeLengths">No documentation.</param>
        /// <param name = "featureRanges">No documentation.</param>
        /// <param name = "glyphAdvances">No documentation.</param>
        /// <param name = "glyphOffsets">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd941790</doc-id>
        /// <unmanaged>HRESULT IDWriteTextAnalyzer::GetGdiCompatibleGlyphPlacements([In, Buffer] const wchar_t* textString,[In, Buffer] const unsigned short* clusterMap,[In, Buffer] DWRITE_SHAPING_TEXT_PROPERTIES* textProps,[In] unsigned int textLength,[In, Buffer] const unsigned short* glyphIndices,[In, Buffer] const DWRITE_SHAPING_GLYPH_PROPERTIES* glyphProps,[In] unsigned int glyphCount,[In] IDWriteFontFace* fontFace,[In] float fontEmSize,[In] float pixelsPerDip,[In, Optional] const DWRITE_MATRIX* transform,[In] BOOL useGdiNatural,[In] BOOL isSideways,[In] BOOL isRightToLeft,[In] const DWRITE_SCRIPT_ANALYSIS* scriptAnalysis,[In, Optional] const wchar_t* localeName,[In, Optional] const void** features,[In, Buffer, Optional] const unsigned int* featureRangeLengths,[In] unsigned int featureRanges,[Out, Buffer] float* glyphAdvances,[Out, Buffer] DWRITE_GLYPH_OFFSET* glyphOffsets)</unmanaged>
        /// <unmanaged-short>IDWriteTextAnalyzer::GetGdiCompatibleGlyphPlacements</unmanaged-short>
        internal unsafe void GetGdiCompatibleGlyphPlacements(System.String textString, System.Int16[] clusterMap, SharpDX.DirectWrite.ShapingTextProperties[] textProps, System.Int32 textLength, System.Int16[] glyphIndices, SharpDX.DirectWrite.ShapingGlyphProperties[] glyphProps, System.Int32 glyphCount, SharpDX.DirectWrite.FontFace fontFace, System.Single fontEmSize, System.Single pixelsPerDip, SharpDX.Mathematics.Interop.RawMatrix3x2? transform, SharpDX.Mathematics.Interop.RawBool useGdiNatural, SharpDX.Mathematics.Interop.RawBool isSideways, SharpDX.Mathematics.Interop.RawBool isRightToLeft, SharpDX.DirectWrite.ScriptAnalysis scriptAnalysis, System.String localeName, System.IntPtr features, System.Int32[] featureRangeLengths, System.Int32 featureRanges, System.Single[] glyphAdvances, SharpDX.DirectWrite.GlyphOffset[] glyphOffsets)
        {
            System.IntPtr fontFace_ = System.IntPtr.Zero;
            SharpDX.Mathematics.Interop.RawMatrix3x2 transform_;
            SharpDX.Result __result__;
            fontFace_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.FontFace>(fontFace);
            if (transform != null)
                transform_ = transform.Value;
            fixed (void *glyphOffsets_ = glyphOffsets)
                fixed (void *glyphAdvances_ = glyphAdvances)
                    fixed (void *featureRangeLengths_ = featureRangeLengths)
                        fixed (char *localeName_ = localeName)
                            fixed (void *glyphProps_ = glyphProps)
                                fixed (void *glyphIndices_ = glyphIndices)
                                    fixed (void *textProps_ = textProps)
                                        fixed (void *clusterMap_ = clusterMap)
                                            fixed (char *textString_ = textString)
                                                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, (void *)textString_, clusterMap_, textProps_, textLength, glyphIndices_, glyphProps_, glyphCount, (void *)fontFace_, fontEmSize, pixelsPerDip, transform == null ? (void *)0 : &transform_, useGdiNatural, isSideways, isRightToLeft, &scriptAnalysis, (void *)localeName_, (void *)features, featureRangeLengths_, featureRanges, glyphAdvances_, glyphOffsets_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("80DAD800-E21F-4E83-96CE-BFCCE500DB7C")]
    public partial class TextAnalyzer1 : SharpDX.DirectWrite.TextAnalyzer
    {
        public TextAnalyzer1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator TextAnalyzer1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new TextAnalyzer1(nativePtr);
        /// <summary>
        /// <p>Applies spacing between characters, properly adjusting glyph clusters and diacritics.</p>
        /// </summary>
        /// <param name = "leadingSpacing"><dd> <p>The spacing before each character, in reading order.</p> </dd></param>
        /// <param name = "trailingSpacing"><dd> <p>The spacing after each character, in reading order.</p> </dd></param>
        /// <param name = "minimumAdvanceWidth"><dd> <p>The minimum advance of each character, to prevent characters from becoming too thin or zero-width. This must be zero or greater.</p> </dd></param>
        /// <param name = "textLength"><dd> <p>The length of the clustermap and original text.</p> </dd></param>
        /// <param name = "glyphCount"><dd> <p>The number of glyphs.</p> </dd></param>
        /// <param name = "clusterMap"><dd> <p>Mapping from character ranges to glyph ranges.</p> </dd></param>
        /// <param name = "glyphAdvances"><dd> <p>The advance width of each glyph.</p> </dd></param>
        /// <param name = "glyphOffsets"><dd> <p>The offset of the origin of each glyph.</p> </dd></param>
        /// <param name = "glyphProperties"><dd> <p>Properties of each glyph, from GetGlyphs.</p> </dd></param>
        /// <param name = "modifiedGlyphAdvances"><dd> <p>The new advance width of each glyph.</p> </dd></param>
        /// <param name = "modifiedGlyphOffsets"><dd> <p>The new offset of the origin of each glyph.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The input and output advances/offsets are allowed to alias the same array.</p>
        /// </remarks>
        /// <doc-id>hh780430</doc-id>
        /// <unmanaged>HRESULT IDWriteTextAnalyzer1::ApplyCharacterSpacing([In] float leadingSpacing,[In] float trailingSpacing,[In] float minimumAdvanceWidth,[In] unsigned int textLength,[In] unsigned int glyphCount,[In, Buffer] const unsigned short* clusterMap,[In, Buffer] const float* glyphAdvances,[In, Buffer] const DWRITE_GLYPH_OFFSET* glyphOffsets,[In, Buffer] const DWRITE_SHAPING_GLYPH_PROPERTIES* glyphProperties,[Out, Buffer] float* modifiedGlyphAdvances,[Out, Buffer] DWRITE_GLYPH_OFFSET* modifiedGlyphOffsets)</unmanaged>
        /// <unmanaged-short>IDWriteTextAnalyzer1::ApplyCharacterSpacing</unmanaged-short>
        public unsafe void ApplyCharacterSpacing(System.Single leadingSpacing, System.Single trailingSpacing, System.Single minimumAdvanceWidth, System.Int32 textLength, System.Int32 glyphCount, System.Int16[] clusterMap, System.Single[] glyphAdvances, SharpDX.DirectWrite.GlyphOffset[] glyphOffsets, SharpDX.DirectWrite.ShapingGlyphProperties[] glyphProperties, System.Single[] modifiedGlyphAdvances, SharpDX.DirectWrite.GlyphOffset[] modifiedGlyphOffsets)
        {
            SharpDX.Result __result__;
            fixed (void *modifiedGlyphOffsets_ = modifiedGlyphOffsets)
                fixed (void *modifiedGlyphAdvances_ = modifiedGlyphAdvances)
                    fixed (void *glyphProperties_ = glyphProperties)
                        fixed (void *glyphOffsets_ = glyphOffsets)
                            fixed (void *glyphAdvances_ = glyphAdvances)
                                fixed (void *clusterMap_ = clusterMap)
                                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, leadingSpacing, trailingSpacing, minimumAdvanceWidth, textLength, glyphCount, clusterMap_, glyphAdvances_, glyphOffsets_, glyphProperties_, modifiedGlyphAdvances_, modifiedGlyphOffsets_, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the given baseline from the font.</p>
        /// </summary>
        /// <param name = "fontFace"><dd>  <p>The font face to read.</p> </dd></param>
        /// <param name = "baseline"><dd>  <p>A <strong><see cref = "SharpDX.DirectWrite.Baseline"/></strong>-typed value that specifies the baseline of interest.</p> </dd></param>
        /// <param name = "isVertical"><dd>  <p>Whether the baseline is vertical or horizontal.</p> </dd></param>
        /// <param name = "isSimulationAllowed"><dd>  <p>Simulate the baseline if it is missing in the font.</p> </dd></param>
        /// <param name = "scriptAnalysis"><dd>  <p>Script analysis result from AnalyzeScript.</p> <strong>Note</strong>??You can pass an empty script analysis structure, like this <code><see cref = "SharpDX.DirectWrite.ScriptAnalysis"/> scriptAnalysis = {};</code>, and this method will return the default baseline. ? </dd></param>
        /// <param name = "localeName"><dd>  <p>The language of the run.</p> </dd></param>
        /// <param name = "baselineCoordinate"><dd>  <p>The baseline coordinate value in design units.</p> </dd></param>
        /// <param name = "exists"><dd>  <p>Whether the returned baseline exists in the font.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>If the baseline does not exist in the font, it is not considered an error, but the function will return exists = false. You may then use heuristics to calculate the missing base, or, if the flag simulationAllowed is true, the function will compute a reasonable approximation for you.</p>
        /// </remarks>
        /// <doc-id>hh780431</doc-id>
        /// <unmanaged>HRESULT IDWriteTextAnalyzer1::GetBaseline([In] IDWriteFontFace* fontFace,[In] DWRITE_BASELINE baseline,[In] BOOL isVertical,[In] BOOL isSimulationAllowed,[In] DWRITE_SCRIPT_ANALYSIS scriptAnalysis,[In, Optional] const wchar_t* localeName,[Out] int* baselineCoordinate,[Out] BOOL* exists)</unmanaged>
        /// <unmanaged-short>IDWriteTextAnalyzer1::GetBaseline</unmanaged-short>
        public unsafe void GetBaseline(SharpDX.DirectWrite.FontFace fontFace, SharpDX.DirectWrite.Baseline baseline, SharpDX.Mathematics.Interop.RawBool isVertical, SharpDX.Mathematics.Interop.RawBool isSimulationAllowed, SharpDX.DirectWrite.ScriptAnalysis scriptAnalysis, System.String localeName, out System.Int32 baselineCoordinate, out SharpDX.Mathematics.Interop.RawBool exists)
        {
            System.IntPtr fontFace_ = System.IntPtr.Zero;
            exists = default (SharpDX.Mathematics.Interop.RawBool);
            SharpDX.Result __result__;
            fontFace_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.FontFace>(fontFace);
            fixed (void *exists_ = &exists)
                fixed (void *baselineCoordinate_ = &baselineCoordinate)
                    fixed (char *localeName_ = localeName)
                        __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, (void *)fontFace_, unchecked ((System.Int32)baseline), isVertical, isSimulationAllowed, scriptAnalysis, (void *)localeName_, baselineCoordinate_, exists_, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Analyzes a text range for script orientation, reading text and attributes from the source and reporting results to the sink callback <strong>SetGlyphOrientation</strong>.</p>
        /// </summary>
        /// <param name = "analysisSource">No documentation.</param>
        /// <param name = "textPosition">No documentation.</param>
        /// <param name = "textLength">No documentation.</param>
        /// <param name = "analysisSink">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh780429</doc-id>
        /// <unmanaged>HRESULT IDWriteTextAnalyzer1::AnalyzeVerticalGlyphOrientation([In] IDWriteTextAnalysisSource1* analysisSource,[In] unsigned int textPosition,[In] unsigned int textLength,[In] IDWriteTextAnalysisSink1* analysisSink)</unmanaged>
        /// <unmanaged-short>IDWriteTextAnalyzer1::AnalyzeVerticalGlyphOrientation</unmanaged-short>
        public unsafe void AnalyzeVerticalGlyphOrientation(SharpDX.DirectWrite.TextAnalysisSource1 analysisSource, System.Int32 textPosition, System.Int32 textLength, SharpDX.DirectWrite.TextAnalysisSink1 analysisSink)
        {
            System.IntPtr analysisSource_ = System.IntPtr.Zero;
            System.IntPtr analysisSink_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            analysisSource_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.TextAnalysisSource1>(analysisSource);
            analysisSink_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.TextAnalysisSink1>(analysisSink);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)analysisSource_, textPosition, textLength, (void *)analysisSink_, (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Returns 2x3 transform matrix for the respective angle to draw the glyph run.</p>
        /// </summary>
        /// <param name = "glyphOrientationAngle"><dd>  <p>A <strong><see cref = "SharpDX.DirectWrite.GlyphOrientationAngle"/></strong>-typed value that specifies the angle that was reported into <strong>IDWriteTextAnalysisSink1::SetGlyphOrientation</strong>.</p> </dd></param>
        /// <param name = "isSideways"><dd>  <p>Whether the run's glyphs are sideways or not.</p> </dd></param>
        /// <param name = "transform"><dd>  <p>Returned transform.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The translation component of the transform returned is zero.</p>
        /// </remarks>
        /// <doc-id>hh780432</doc-id>
        /// <unmanaged>HRESULT IDWriteTextAnalyzer1::GetGlyphOrientationTransform([In] DWRITE_GLYPH_ORIENTATION_ANGLE glyphOrientationAngle,[In] BOOL isSideways,[Out] DWRITE_MATRIX* transform)</unmanaged>
        /// <unmanaged-short>IDWriteTextAnalyzer1::GetGlyphOrientationTransform</unmanaged-short>
        public unsafe void GetGlyphOrientationTransform(SharpDX.DirectWrite.GlyphOrientationAngle glyphOrientationAngle, SharpDX.Mathematics.Interop.RawBool isSideways, out SharpDX.Mathematics.Interop.RawMatrix3x2 transform)
        {
            transform = default (SharpDX.Mathematics.Interop.RawMatrix3x2);
            SharpDX.Result __result__;
            fixed (void *transform_ = &transform)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, unchecked ((System.Int32)glyphOrientationAngle), isSideways, transform_, (*(void ***)this._nativePointer)[13]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the properties for a given script.</p>
        /// </summary>
        /// <param name = "scriptAnalysis"><dd>  <p>The script for a run of text returned from <strong>IDWriteTextAnalyzer::AnalyzeScript</strong>.</p> </dd></param>
        /// <param name = "scriptProperties"><dd>  <p>A reference to a <strong><see cref = "SharpDX.DirectWrite.ScriptProperties"/></strong> structure that describes info for the script.</p> </dd></param>
        /// <returns><p>Returns properties for the given script. If the script is invalid, it returns generic properties for the unknown script and E_INVALIDARG.</p></returns>
        /// <doc-id>hh780435</doc-id>
        /// <unmanaged>HRESULT IDWriteTextAnalyzer1::GetScriptProperties([In] DWRITE_SCRIPT_ANALYSIS scriptAnalysis,[Out] DWRITE_SCRIPT_PROPERTIES* scriptProperties)</unmanaged>
        /// <unmanaged-short>IDWriteTextAnalyzer1::GetScriptProperties</unmanaged-short>
        public unsafe void GetScriptProperties(SharpDX.DirectWrite.ScriptAnalysis scriptAnalysis, out SharpDX.DirectWrite.ScriptProperties scriptProperties)
        {
            scriptProperties = default (SharpDX.DirectWrite.ScriptProperties);
            SharpDX.Result __result__;
            fixed (void *scriptProperties_ = &scriptProperties)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, scriptAnalysis, scriptProperties_, (*(void ***)this._nativePointer)[14]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Determines the complexity of text, and whether you need to call <strong>IDWriteTextAnalyzer::GetGlyphs</strong> for full script shaping. </p>
        /// </summary>
        /// <param name = "textString">No documentation.</param>
        /// <param name = "textLength">No documentation.</param>
        /// <param name = "fontFace">No documentation.</param>
        /// <param name = "isTextSimple">No documentation.</param>
        /// <param name = "textLengthRead">No documentation.</param>
        /// <param name = "glyphIndices">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Text is not simple if the characters are part of a script that has complex shaping requirements, require bidi analysis, combine with other characters, reside in the supplementary planes, or have glyphs that participate in standard OpenType features. The length returned will not split combining marks from their base characters.</p>
        /// </remarks>
        /// <doc-id>hh780436</doc-id>
        /// <unmanaged>HRESULT IDWriteTextAnalyzer1::GetTextComplexity([In, Buffer] const wchar_t* textString,[In] unsigned int textLength,[In] IDWriteFontFace* fontFace,[Out] BOOL* isTextSimple,[In] unsigned int* textLengthRead,[Out, Buffer, Optional] unsigned short* glyphIndices)</unmanaged>
        /// <unmanaged-short>IDWriteTextAnalyzer1::GetTextComplexity</unmanaged-short>
        public unsafe void GetTextComplexity(System.String textString, System.Int32 textLength, SharpDX.DirectWrite.FontFace fontFace, out SharpDX.Mathematics.Interop.RawBool isTextSimple, System.Int32 textLengthRead, System.Int16[] glyphIndices)
        {
            System.IntPtr fontFace_ = System.IntPtr.Zero;
            isTextSimple = default (SharpDX.Mathematics.Interop.RawBool);
            SharpDX.Result __result__;
            fontFace_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.FontFace>(fontFace);
            fixed (void *glyphIndices_ = glyphIndices)
                fixed (void *isTextSimple_ = &isTextSimple)
                    fixed (char *textString_ = textString)
                        __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)textString_, textLength, (void *)fontFace_, isTextSimple_, &textLengthRead, glyphIndices_, (*(void ***)this._nativePointer)[15]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves justification opportunity information for each of the glyphs given the text and shaping glyph properties.</p>
        /// </summary>
        /// <param name = "fontFace"><dd>  <p>Font face that was used for shaping. This is mainly important for returning correct results of the kashida width. </p> <p>May be <c>null</c>. </p> </dd></param>
        /// <param name = "fontEmSize"><dd>  <p>Font em size used for the glyph run.</p> </dd></param>
        /// <param name = "scriptAnalysis"><dd>  <p>Script of the text from the itemizer.</p> </dd></param>
        /// <param name = "textLength"><dd>  <p>Length of the text.</p> </dd></param>
        /// <param name = "glyphCount"><dd>  <p>Number of glyphs.</p> </dd></param>
        /// <param name = "textString"><dd>  <p>Characters used to produce the glyphs.</p> </dd></param>
        /// <param name = "clusterMap"><dd>  <p>Clustermap produced from shaping.</p> </dd></param>
        /// <param name = "glyphProperties"><dd>  <p>Glyph properties produced from shaping.</p> </dd></param>
        /// <param name = "justificationOpportunities"><dd>  <p>A reference to a <strong><see cref = "SharpDX.DirectWrite.JustificationOpportunity"/></strong> structure that receives info for the allowed justification expansion/compression for each glyph.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>This function is called per-run, after shaping is done via the <strong>IDWriteTextAnalyzer::GetGlyphs</strong> method. </p><strong>Note</strong>??this function only supports natural metrics (<strong>DWRITE_MEASURING_MODE_NATURAL</strong>).?
        /// </remarks>
        /// <doc-id>hh780433</doc-id>
        /// <unmanaged>HRESULT IDWriteTextAnalyzer1::GetJustificationOpportunities([In, Optional] IDWriteFontFace* fontFace,[In] float fontEmSize,[In] DWRITE_SCRIPT_ANALYSIS scriptAnalysis,[In] unsigned int textLength,[In] unsigned int glyphCount,[In, Buffer] const wchar_t* textString,[In, Buffer] const unsigned short* clusterMap,[In, Buffer] const DWRITE_SHAPING_GLYPH_PROPERTIES* glyphProperties,[Out, Buffer] DWRITE_JUSTIFICATION_OPPORTUNITY* justificationOpportunities)</unmanaged>
        /// <unmanaged-short>IDWriteTextAnalyzer1::GetJustificationOpportunities</unmanaged-short>
        public unsafe void GetJustificationOpportunities(SharpDX.DirectWrite.FontFace fontFace, System.Single fontEmSize, SharpDX.DirectWrite.ScriptAnalysis scriptAnalysis, System.Int32 textLength, System.Int32 glyphCount, System.String textString, System.Int16[] clusterMap, SharpDX.DirectWrite.ShapingGlyphProperties[] glyphProperties, SharpDX.DirectWrite.JustificationOpportunity[] justificationOpportunities)
        {
            System.IntPtr fontFace_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fontFace_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.FontFace>(fontFace);
            fixed (void *justificationOpportunities_ = justificationOpportunities)
                fixed (void *glyphProperties_ = glyphProperties)
                    fixed (void *clusterMap_ = clusterMap)
                        fixed (char *textString_ = textString)
                            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, (void *)fontFace_, fontEmSize, scriptAnalysis, textLength, glyphCount, (void *)textString_, clusterMap_, glyphProperties_, justificationOpportunities_, (*(void ***)this._nativePointer)[16]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Justifies an array of glyph advances to fit the line width.</p>
        /// </summary>
        /// <param name = "lineWidth"><dd>  <p>The line width.</p> </dd></param>
        /// <param name = "glyphCount"><dd>  <p>The glyph count.</p> </dd></param>
        /// <param name = "justificationOpportunities"><dd>  <p>A reference to a <strong><see cref = "SharpDX.DirectWrite.JustificationOpportunity"/></strong> structure that contains info for the allowed justification expansion/compression for each glyph. Get this info from <strong>IDWriteTextAnalyzer1::GetJustificationOpportunities</strong>. </p> </dd></param>
        /// <param name = "glyphAdvances"><dd>  <p>An array of glyph advances.</p> </dd></param>
        /// <param name = "glyphOffsets"><dd>  <p>An array of glyph offsets.</p> </dd></param>
        /// <param name = "justifiedGlyphAdvances"><dd>  <p>The returned array of justified glyph advances.</p> </dd></param>
        /// <param name = "justifiedGlyphOffsets"><dd>  <p>The returned array of justified glyph offsets.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>You call  <strong>JustifyGlyphAdvances</strong> after you call <strong>IDWriteTextAnalyzer1::GetJustificationOpportunities</strong> to collect all the opportunities, and <strong>JustifyGlyphAdvances</strong> spans across the entire line. The input and output arrays are allowed to alias each other, permitting in-place update.</p>
        /// </remarks>
        /// <doc-id>hh780437</doc-id>
        /// <unmanaged>HRESULT IDWriteTextAnalyzer1::JustifyGlyphAdvances([In] float lineWidth,[In] unsigned int glyphCount,[In, Buffer] const DWRITE_JUSTIFICATION_OPPORTUNITY* justificationOpportunities,[In, Buffer] const float* glyphAdvances,[In, Buffer] const DWRITE_GLYPH_OFFSET* glyphOffsets,[Out, Buffer] float* justifiedGlyphAdvances,[Out, Buffer, Optional] DWRITE_GLYPH_OFFSET* justifiedGlyphOffsets)</unmanaged>
        /// <unmanaged-short>IDWriteTextAnalyzer1::JustifyGlyphAdvances</unmanaged-short>
        public unsafe void JustifyGlyphAdvances(System.Single lineWidth, System.Int32 glyphCount, SharpDX.DirectWrite.JustificationOpportunity[] justificationOpportunities, System.Single[] glyphAdvances, SharpDX.DirectWrite.GlyphOffset[] glyphOffsets, System.Single[] justifiedGlyphAdvances, SharpDX.DirectWrite.GlyphOffset[] justifiedGlyphOffsets)
        {
            SharpDX.Result __result__;
            fixed (void *justifiedGlyphOffsets_ = justifiedGlyphOffsets)
                fixed (void *justifiedGlyphAdvances_ = justifiedGlyphAdvances)
                    fixed (void *glyphOffsets_ = glyphOffsets)
                        fixed (void *glyphAdvances_ = glyphAdvances)
                            fixed (void *justificationOpportunities_ = justificationOpportunities)
                                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, lineWidth, glyphCount, justificationOpportunities_, glyphAdvances_, glyphOffsets_, justifiedGlyphAdvances_, justifiedGlyphOffsets_, (*(void ***)this._nativePointer)[17]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Fills in new glyphs for complex scripts where justification increased the advances of glyphs, such as Arabic with kashida.</p>
        /// </summary>
        /// <param name = "fontFace"><dd>  <p>Font face used for shaping.</p> <p>May be <c>null</c>.</p> </dd></param>
        /// <param name = "fontEmSize"><dd>  <p>Font em size used for the glyph run.</p> </dd></param>
        /// <param name = "scriptAnalysis"><dd>  <p>Script of the text from the itemizer.</p> </dd></param>
        /// <param name = "textLength"><dd>  <p>Length of the text.</p> </dd></param>
        /// <param name = "glyphCount"><dd>  <p>Number of glyphs.</p> </dd></param>
        /// <param name = "maxGlyphCount"><dd>  <p>Maximum number of output glyphs allocated by caller.</p> </dd></param>
        /// <param name = "clusterMap"><dd>  <p>Clustermap produced from shaping.</p> </dd></param>
        /// <param name = "glyphIndices"><dd>  <p>Original glyphs produced from shaping.</p> </dd></param>
        /// <param name = "glyphAdvances"><dd>  <p>Original glyph advances produced from shaping.</p> </dd></param>
        /// <param name = "justifiedGlyphAdvances"><dd>  <p>Justified glyph advances from <strong>IDWriteTextAnalyzer1::JustifyGlyphAdvances</strong>. </p> </dd></param>
        /// <param name = "justifiedGlyphOffsets"><dd>  <p>Justified glyph offsets from <strong>IDWriteTextAnalyzer1::JustifyGlyphAdvances</strong>. </p> </dd></param>
        /// <param name = "glyphProperties"><dd>  <p>Properties of each glyph, from <strong>IDWriteTextAnalyzer::GetGlyphs</strong>. </p> </dd></param>
        /// <param name = "actualGlyphCount"><dd>  <p>The new glyph count written to the modified arrays, or the needed glyph count if the size is not large enough.</p> </dd></param>
        /// <param name = "modifiedClusterMap"><dd>  <p>Updated clustermap.</p> </dd></param>
        /// <param name = "modifiedGlyphIndices"><dd>  <p>Updated glyphs with new glyphs inserted where needed.</p> </dd></param>
        /// <param name = "modifiedGlyphAdvances"><dd>  <p>Updated glyph advances.</p> </dd></param>
        /// <param name = "modifiedGlyphOffsets"><dd>  <p>Updated glyph offsets.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>You call <strong>GetJustifiedGlyphs</strong> after the line has been justified, and it is per-run. </p><p>You should call <strong>GetJustifiedGlyphs</strong> if <strong>IDWriteTextAnalyzer1::GetScriptProperties</strong> returns a non-null <strong><see cref = "SharpDX.DirectWrite.ScriptProperties"/>.justificationCharacter</strong> for that script.</p><p> Use  <strong>GetJustifiedGlyphs</strong> mainly for cursive scripts like Arabic. If <em>maxGlyphCount</em> is not large enough, <strong>GetJustifiedGlyphs</strong> returns the error E_NOT_SUFFICIENT_BUFFER and fills the variable  to which <em>actualGlyphCount</em> points with the needed glyph count.</p>
        /// </remarks>
        /// <doc-id>hh780434</doc-id>
        /// <unmanaged>HRESULT IDWriteTextAnalyzer1::GetJustifiedGlyphs([In, Optional] IDWriteFontFace* fontFace,[In] float fontEmSize,[In] DWRITE_SCRIPT_ANALYSIS scriptAnalysis,[In] unsigned int textLength,[In] unsigned int glyphCount,[In] unsigned int maxGlyphCount,[In, Buffer, Optional] const unsigned short* clusterMap,[In, Buffer] const unsigned short* glyphIndices,[In, Buffer] const float* glyphAdvances,[In, Buffer] const float* justifiedGlyphAdvances,[In, Buffer] const DWRITE_GLYPH_OFFSET* justifiedGlyphOffsets,[In, Buffer] const DWRITE_SHAPING_GLYPH_PROPERTIES* glyphProperties,[In] unsigned int* actualGlyphCount,[Out, Buffer, Optional] unsigned short* modifiedClusterMap,[Out, Buffer] unsigned short* modifiedGlyphIndices,[Out, Buffer] float* modifiedGlyphAdvances,[Out, Buffer] DWRITE_GLYPH_OFFSET* modifiedGlyphOffsets)</unmanaged>
        /// <unmanaged-short>IDWriteTextAnalyzer1::GetJustifiedGlyphs</unmanaged-short>
        public unsafe void GetJustifiedGlyphs(SharpDX.DirectWrite.FontFace fontFace, System.Single fontEmSize, SharpDX.DirectWrite.ScriptAnalysis scriptAnalysis, System.Int32 textLength, System.Int32 glyphCount, System.Int32 maxGlyphCount, System.Int16[] clusterMap, System.Int16[] glyphIndices, System.Single[] glyphAdvances, System.Single[] justifiedGlyphAdvances, SharpDX.DirectWrite.GlyphOffset[] justifiedGlyphOffsets, SharpDX.DirectWrite.ShapingGlyphProperties[] glyphProperties, System.Int32 actualGlyphCount, System.Int16[] modifiedClusterMap, System.Int16[] modifiedGlyphIndices, System.Single[] modifiedGlyphAdvances, SharpDX.DirectWrite.GlyphOffset[] modifiedGlyphOffsets)
        {
            System.IntPtr fontFace_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fontFace_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.FontFace>(fontFace);
            fixed (void *modifiedGlyphOffsets_ = modifiedGlyphOffsets)
                fixed (void *modifiedGlyphAdvances_ = modifiedGlyphAdvances)
                    fixed (void *modifiedGlyphIndices_ = modifiedGlyphIndices)
                        fixed (void *modifiedClusterMap_ = modifiedClusterMap)
                            fixed (void *glyphProperties_ = glyphProperties)
                                fixed (void *justifiedGlyphOffsets_ = justifiedGlyphOffsets)
                                    fixed (void *justifiedGlyphAdvances_ = justifiedGlyphAdvances)
                                        fixed (void *glyphAdvances_ = glyphAdvances)
                                            fixed (void *glyphIndices_ = glyphIndices)
                                                fixed (void *clusterMap_ = clusterMap)
                                                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, (void *)fontFace_, fontEmSize, scriptAnalysis, textLength, glyphCount, maxGlyphCount, clusterMap_, glyphIndices_, glyphAdvances_, justifiedGlyphAdvances_, justifiedGlyphOffsets_, glyphProperties_, &actualGlyphCount, modifiedClusterMap_, modifiedGlyphIndices_, modifiedGlyphAdvances_, modifiedGlyphOffsets_, (*(void ***)this._nativePointer)[18]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("553A9FF3-5693-4DF7-B52B-74806F7F2EB9")]
    public partial class TextAnalyzer2 : SharpDX.DirectWrite.TextAnalyzer1
    {
        public TextAnalyzer2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator TextAnalyzer2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new TextAnalyzer2(nativePtr);
        /// <summary>
        /// <p>Returns 2x3 transform matrix for the respective angle to draw the glyph run.</p><p>Extends <strong>IDWriteTextAnalyzer1::GetGlyphOrientationTransform</strong> to pass valid values for the baseline origin rather than zeroes.</p>
        /// </summary>
        /// <param name = "glyphOrientationAngle">No documentation.</param>
        /// <param name = "isSideways">No documentation.</param>
        /// <param name = "originX">No documentation.</param>
        /// <param name = "originY">No documentation.</param>
        /// <param name = "transform">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn280484</doc-id>
        /// <unmanaged>HRESULT IDWriteTextAnalyzer2::GetGlyphOrientationTransform([In] DWRITE_GLYPH_ORIENTATION_ANGLE glyphOrientationAngle,[In] BOOL isSideways,[In] float originX,[In] float originY,[Out] DWRITE_MATRIX* transform)</unmanaged>
        /// <unmanaged-short>IDWriteTextAnalyzer2::GetGlyphOrientationTransform</unmanaged-short>
        public unsafe void GetGlyphOrientationTransform(SharpDX.DirectWrite.GlyphOrientationAngle glyphOrientationAngle, SharpDX.Mathematics.Interop.RawBool isSideways, System.Single originX, System.Single originY, out SharpDX.Mathematics.Interop.RawMatrix3x2 transform)
        {
            transform = default (SharpDX.Mathematics.Interop.RawMatrix3x2);
            SharpDX.Result __result__;
            fixed (void *transform_ = &transform)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, unchecked ((System.Int32)glyphOrientationAngle), isSideways, originX, originY, transform_, (*(void ***)this._nativePointer)[19]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Returns a complete list of OpenType features available for a script or font. If a feature is partially supported, then this method indicates that it is supported. </p>
        /// </summary>
        /// <param name = "fontFace"><dd>  <p>The font face to get features from.</p> </dd></param>
        /// <param name = "scriptAnalysis"><dd>  <p>The script analysis for the script or font to check.</p> </dd></param>
        /// <param name = "localeName"><dd>  <p>The locale name to check.</p> </dd></param>
        /// <param name = "maxTagCount"><dd>  <p>The maximum number of tags to return.</p> </dd></param>
        /// <param name = "actualTagCount"><dd>  <p>The actual number of tags returned.</p> </dd></param>
        /// <param name = "tags"><dd>  <p>An array of OpenType font feature tags.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn280456</doc-id>
        /// <unmanaged>HRESULT IDWriteTextAnalyzer2::GetTypographicFeatures([In] IDWriteFontFace* fontFace,[In] DWRITE_SCRIPT_ANALYSIS scriptAnalysis,[In, Optional] const wchar_t* localeName,[In] unsigned int maxTagCount,[Out] unsigned int* actualTagCount,[Out, Buffer] DWRITE_FONT_FEATURE_TAG* tags)</unmanaged>
        /// <unmanaged-short>IDWriteTextAnalyzer2::GetTypographicFeatures</unmanaged-short>
        public unsafe void GetTypographicFeatures(SharpDX.DirectWrite.FontFace fontFace, SharpDX.DirectWrite.ScriptAnalysis scriptAnalysis, System.String localeName, System.Int32 maxTagCount, out System.Int32 actualTagCount, SharpDX.DirectWrite.FontFeatureTag[] tags)
        {
            System.IntPtr fontFace_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fontFace_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.FontFace>(fontFace);
            fixed (void *tags_ = tags)
                fixed (void *actualTagCount_ = &actualTagCount)
                    fixed (char *localeName_ = localeName)
                        __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, (void *)fontFace_, scriptAnalysis, (void *)localeName_, maxTagCount, actualTagCount_, tags_, (*(void ***)this._nativePointer)[20]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Checks if a typographic feature is available for a glyph or a set of glyphs.</p>
        /// </summary>
        /// <param name = "fontFace"><dd> <p>The font face to read glyph information from.</p> </dd></param>
        /// <param name = "scriptAnalysis"><dd> <p>The script analysis for the script or font to check.</p> </dd></param>
        /// <param name = "localeName"><dd> <p>The locale name to check.</p> </dd></param>
        /// <param name = "featureTag"><dd> <p>The font feature tag to check.</p> </dd></param>
        /// <param name = "glyphCount"><dd> <p>The number of glyphs to check.</p> </dd></param>
        /// <param name = "glyphIndices"><dd> <p>An array of glyph indices to check.</p> </dd></param>
        /// <param name = "featureApplies"><dd> <p>An array of integers that indicate whether or not the font feature applies to each glyph specified.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn280455</doc-id>
        /// <unmanaged>HRESULT IDWriteTextAnalyzer2::CheckTypographicFeature([In] IDWriteFontFace* fontFace,[In] DWRITE_SCRIPT_ANALYSIS scriptAnalysis,[In, Optional] const wchar_t* localeName,[In] DWRITE_FONT_FEATURE_TAG featureTag,[In] unsigned int glyphCount,[In, Buffer] const unsigned short* glyphIndices,[Out, Buffer] unsigned char* featureApplies)</unmanaged>
        /// <unmanaged-short>IDWriteTextAnalyzer2::CheckTypographicFeature</unmanaged-short>
        public unsafe void CheckTypographicFeature(SharpDX.DirectWrite.FontFace fontFace, SharpDX.DirectWrite.ScriptAnalysis scriptAnalysis, System.String localeName, SharpDX.DirectWrite.FontFeatureTag featureTag, System.Int32 glyphCount, System.Int16[] glyphIndices, System.Byte[] featureApplies)
        {
            System.IntPtr fontFace_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fontFace_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.FontFace>(fontFace);
            fixed (void *featureApplies_ = featureApplies)
                fixed (void *glyphIndices_ = glyphIndices)
                    fixed (char *localeName_ = localeName)
                        __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, (void *)fontFace_, scriptAnalysis, (void *)localeName_, unchecked ((System.Int32)featureTag), glyphCount, glyphIndices_, featureApplies_, (*(void ***)this._nativePointer)[21]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("9c906818-31d7-4fd3-a151-7c5e225db55a")]
    public partial class TextFormat : SharpDX.ComObject
    {
        public TextFormat(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator TextFormat(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new TextFormat(nativePtr);
        /// <summary>
        /// <p>Gets or sets the alignment option of text relative to the layout box's leading and trailing edge. </p>
        /// </summary>
        /// <doc-id>dd316681</doc-id>
        /// <unmanaged>GetTextAlignment / SetTextAlignment</unmanaged>
        /// <unmanaged-short>GetTextAlignment</unmanaged-short>
        public SharpDX.DirectWrite.TextAlignment TextAlignment
        {
            get => GetTextAlignment();
            set => SetTextAlignment(value);
        }

        /// <summary>
        /// <p>Gets or sets the alignment option of a paragraph which is  relative to the top and bottom edges of a layout box. </p>
        /// </summary>
        /// <doc-id>dd316675</doc-id>
        /// <unmanaged>GetParagraphAlignment / SetParagraphAlignment</unmanaged>
        /// <unmanaged-short>GetParagraphAlignment</unmanaged-short>
        public SharpDX.DirectWrite.ParagraphAlignment ParagraphAlignment
        {
            get => GetParagraphAlignment();
            set => SetParagraphAlignment(value);
        }

        /// <summary>
        /// <p>Gets or sets the word wrapping option. </p>
        /// </summary>
        /// <doc-id>dd316688</doc-id>
        /// <unmanaged>GetWordWrapping / SetWordWrapping</unmanaged>
        /// <unmanaged-short>GetWordWrapping</unmanaged-short>
        public SharpDX.DirectWrite.WordWrapping WordWrapping
        {
            get => GetWordWrapping();
            set => SetWordWrapping(value);
        }

        /// <summary>
        /// <p>Gets or sets the  current reading direction for text in a paragraph. </p>
        /// </summary>
        /// <doc-id>dd316678</doc-id>
        /// <unmanaged>GetReadingDirection / SetReadingDirection</unmanaged>
        /// <unmanaged-short>GetReadingDirection</unmanaged-short>
        public SharpDX.DirectWrite.ReadingDirection ReadingDirection
        {
            get => GetReadingDirection();
            set => SetReadingDirection(value);
        }

        /// <summary>
        /// <p>Gets or sets the direction that text lines flow. </p>
        /// </summary>
        /// <doc-id>dd316631</doc-id>
        /// <unmanaged>GetFlowDirection / SetFlowDirection</unmanaged>
        /// <unmanaged-short>GetFlowDirection</unmanaged-short>
        public SharpDX.DirectWrite.FlowDirection FlowDirection
        {
            get => GetFlowDirection();
            set => SetFlowDirection(value);
        }

        /// <summary>
        /// <p>Gets or sets the  incremental tab stop position. </p>
        /// </summary>
        /// <doc-id>dd316655</doc-id>
        /// <unmanaged>GetIncrementalTabStop / SetIncrementalTabStop</unmanaged>
        /// <unmanaged-short>GetIncrementalTabStop</unmanaged-short>
        public System.Single IncrementalTabStop
        {
            get => GetIncrementalTabStop();
            set => SetIncrementalTabStop(value);
        }

        /// <summary>
        /// <p> Gets the current font collection. </p>
        /// </summary>
        /// <doc-id>dd316633</doc-id>
        /// <unmanaged>GetFontCollection</unmanaged>
        /// <unmanaged-short>GetFontCollection</unmanaged-short>
        public SharpDX.DirectWrite.FontCollection FontCollection
        {
            get
            {
                GetFontCollection(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p> Gets the font weight of the text. </p>
        /// </summary>
        /// <doc-id>dd316652</doc-id>
        /// <unmanaged>GetFontWeight</unmanaged>
        /// <unmanaged-short>GetFontWeight</unmanaged-short>
        public SharpDX.DirectWrite.FontWeight FontWeight
        {
            get => GetFontWeight();
        }

        /// <summary>
        /// <p> Gets the font style of the text.</p>
        /// </summary>
        /// <doc-id>dd316649</doc-id>
        /// <unmanaged>GetFontStyle</unmanaged>
        /// <unmanaged-short>GetFontStyle</unmanaged-short>
        public SharpDX.DirectWrite.FontStyle FontStyle
        {
            get => GetFontStyle();
        }

        /// <summary>
        /// <p> Gets the font stretch of the text. </p>
        /// </summary>
        /// <doc-id>dd316646</doc-id>
        /// <unmanaged>GetFontStretch</unmanaged>
        /// <unmanaged-short>GetFontStretch</unmanaged-short>
        public SharpDX.DirectWrite.FontStretch FontStretch
        {
            get => GetFontStretch();
        }

        /// <summary>
        /// <p> Gets the font  size in DIP unites. </p>
        /// </summary>
        /// <doc-id>dd316643</doc-id>
        /// <unmanaged>GetFontSize</unmanaged>
        /// <unmanaged-short>GetFontSize</unmanaged-short>
        public System.Single FontSize
        {
            get => GetFontSize();
        }

        /// <summary>
        /// <p>Sets the alignment of text in a paragraph, relative to the leading and trailing edge of a layout box for a <strong><see cref = "SharpDX.DirectWrite.TextFormat"/></strong> interface.</p>
        /// </summary>
        /// <param name = "textAlignment">No documentation.</param>
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>The textAlignment argument is invalid.</p> </td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p> The text can be aligned to the leading or trailing edge of the layout box, or it can be centered.  The following illustration shows text with the alignment set to <strong>DWRITE_TEXT_ALIGNMENT_LEADING</strong>, <strong>DWRITE_TEXT_ALIGNMENT_CENTER</strong>, and <strong>DWRITE_TEXT_ALIGNMENT_TRAILING</strong>, respectively.  </p><p></p><strong>Note</strong>??The alignment is dependent on reading direction, the above is for left-to-right reading direction.  For right-to-left reading direction it would be the opposite.?<p>See <strong><see cref = "SharpDX.DirectWrite.TextAlignment"/></strong> for more information. </p>
        /// </remarks>
        /// <doc-id>dd316709</doc-id>
        /// <unmanaged>HRESULT IDWriteTextFormat::SetTextAlignment([In] DWRITE_TEXT_ALIGNMENT textAlignment)</unmanaged>
        /// <unmanaged-short>IDWriteTextFormat::SetTextAlignment</unmanaged-short>
        internal unsafe void SetTextAlignment(SharpDX.DirectWrite.TextAlignment textAlignment)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)textAlignment), (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Sets the alignment option of a paragraph relative to the layout box's top and bottom edge. </p>
        /// </summary>
        /// <param name = "paragraphAlignment"><dd>  <p>The paragraph alignment option being set for a paragraph; see <strong><see cref = "SharpDX.DirectWrite.ParagraphAlignment"/></strong> for more information.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd316702</doc-id>
        /// <unmanaged>HRESULT IDWriteTextFormat::SetParagraphAlignment([In] DWRITE_PARAGRAPH_ALIGNMENT paragraphAlignment)</unmanaged>
        /// <unmanaged-short>IDWriteTextFormat::SetParagraphAlignment</unmanaged-short>
        internal unsafe void SetParagraphAlignment(SharpDX.DirectWrite.ParagraphAlignment paragraphAlignment)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)paragraphAlignment), (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Sets the word wrapping option. </p>
        /// </summary>
        /// <param name = "wordWrapping"><dd>  <p>The word wrapping option being set for a paragraph; see <strong><see cref = "SharpDX.DirectWrite.WordWrapping"/></strong> for more information.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd316715</doc-id>
        /// <unmanaged>HRESULT IDWriteTextFormat::SetWordWrapping([In] DWRITE_WORD_WRAPPING wordWrapping)</unmanaged>
        /// <unmanaged-short>IDWriteTextFormat::SetWordWrapping</unmanaged-short>
        internal unsafe void SetWordWrapping(SharpDX.DirectWrite.WordWrapping wordWrapping)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)wordWrapping), (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Sets the paragraph reading direction. </p>
        /// </summary>
        /// <param name = "readingDirection"><dd>  <p> The text reading direction (for example, <strong>DWRITE_READING_DIRECTION_RIGHT_TO_LEFT</strong> for languages, such as  Arabic, that read from right to left) for a paragraph. </p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p> The reading direction and flow direction must always be set 90 degrees orthogonal to each other, or else you will get the error DWRITE_E_FLOWDIRECTIONCONFLICTS when you  use layout functions like Draw or GetMetrics. So if you set a vertical reading direction (for example, to DWRITE_READING_DIRECTION_TOP_TO_BOTTOM), then you must also  use SetFlowDirection to set the flow direction appropriately (for example, to DWRITE_FLOW_DIRECTION_RIGHT_TO_LEFT). </p>
        /// </remarks>
        /// <doc-id>dd316705</doc-id>
        /// <unmanaged>HRESULT IDWriteTextFormat::SetReadingDirection([In] DWRITE_READING_DIRECTION readingDirection)</unmanaged>
        /// <unmanaged-short>IDWriteTextFormat::SetReadingDirection</unmanaged-short>
        internal unsafe void SetReadingDirection(SharpDX.DirectWrite.ReadingDirection readingDirection)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)readingDirection), (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Sets the  paragraph flow direction. </p>
        /// </summary>
        /// <param name = "flowDirection"><dd>  <p>The paragraph flow direction; see <strong><see cref = "SharpDX.DirectWrite.FlowDirection"/></strong> for more information.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd316691</doc-id>
        /// <unmanaged>HRESULT IDWriteTextFormat::SetFlowDirection([In] DWRITE_FLOW_DIRECTION flowDirection)</unmanaged>
        /// <unmanaged-short>IDWriteTextFormat::SetFlowDirection</unmanaged-short>
        internal unsafe void SetFlowDirection(SharpDX.DirectWrite.FlowDirection flowDirection)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)flowDirection), (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Sets a fixed distance between two adjacent tab stops. </p>
        /// </summary>
        /// <param name = "incrementalTabStop"><dd>  <p>The fixed distance between two adjacent tab stops.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd316695</doc-id>
        /// <unmanaged>HRESULT IDWriteTextFormat::SetIncrementalTabStop([In] float incrementalTabStop)</unmanaged>
        /// <unmanaged-short>IDWriteTextFormat::SetIncrementalTabStop</unmanaged-short>
        internal unsafe void SetIncrementalTabStop(System.Single incrementalTabStop)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, incrementalTabStop, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Sets trimming options for text overflowing the layout width. </p>
        /// </summary>
        /// <param name = "trimmingOptions"><dd>  <p>Text trimming options.</p> </dd></param>
        /// <param name = "trimmingSign"><dd>  <p>Application-defined omission sign. This parameter may be <strong><c>null</c></strong>. See <strong><see cref = "SharpDX.DirectWrite.InlineObject"/></strong> for more information.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd316712</doc-id>
        /// <unmanaged>HRESULT IDWriteTextFormat::SetTrimming([In] const DWRITE_TRIMMING* trimmingOptions,[In, Optional] IDWriteInlineObject* trimmingSign)</unmanaged>
        /// <unmanaged-short>IDWriteTextFormat::SetTrimming</unmanaged-short>
        public unsafe void SetTrimming(SharpDX.DirectWrite.Trimming trimmingOptions, SharpDX.DirectWrite.InlineObject trimmingSign)
        {
            System.IntPtr trimmingSign_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            trimmingSign_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.InlineObject>(trimmingSign);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &trimmingOptions, (void *)trimmingSign_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Sets the  line spacing. </p>
        /// </summary>
        /// <param name = "lineSpacingMethod"><dd>  <p>Specifies how line height is being determined; see <strong><see cref = "SharpDX.DirectWrite.LineSpacingMethod"/></strong> for more information.</p> </dd></param>
        /// <param name = "lineSpacing"><dd>  <p>The line height, or distance between one baseline to another.</p> </dd></param>
        /// <param name = "baseline"><dd>  <p>The distance from top of line to baseline. A reasonable ratio to <em>lineSpacing</em> is 80 percent.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p> For the default method, spacing depends solely on the content. For uniform spacing, the specified line height overrides the content. </p>
        /// </remarks>
        /// <doc-id>dd316698</doc-id>
        /// <unmanaged>HRESULT IDWriteTextFormat::SetLineSpacing([In] DWRITE_LINE_SPACING_METHOD lineSpacingMethod,[In] float lineSpacing,[In] float baseline)</unmanaged>
        /// <unmanaged-short>IDWriteTextFormat::SetLineSpacing</unmanaged-short>
        public unsafe void SetLineSpacing(SharpDX.DirectWrite.LineSpacingMethod lineSpacingMethod, System.Single lineSpacing, System.Single baseline)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)lineSpacingMethod), lineSpacing, baseline, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Gets the alignment option of text relative to the layout box's leading and trailing edge. </p>
        /// </summary>
        /// <returns><p>Returns the text alignment option of the current paragraph.</p></returns>
        /// <doc-id>dd316681</doc-id>
        /// <unmanaged>DWRITE_TEXT_ALIGNMENT IDWriteTextFormat::GetTextAlignment()</unmanaged>
        /// <unmanaged-short>IDWriteTextFormat::GetTextAlignment</unmanaged-short>
        internal unsafe SharpDX.DirectWrite.TextAlignment GetTextAlignment()
        {
            SharpDX.DirectWrite.TextAlignment __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirectWriteTextAlignment(this._nativePointer, (*(void ***)this._nativePointer)[11]);
            return __result__;
        }

        /// <summary>
        /// <p> Gets the alignment option of a paragraph which is  relative to the top and bottom edges of a layout box. </p>
        /// </summary>
        /// <returns><p>A value that indicates the current paragraph alignment option.</p></returns>
        /// <doc-id>dd316675</doc-id>
        /// <unmanaged>DWRITE_PARAGRAPH_ALIGNMENT IDWriteTextFormat::GetParagraphAlignment()</unmanaged>
        /// <unmanaged-short>IDWriteTextFormat::GetParagraphAlignment</unmanaged-short>
        internal unsafe SharpDX.DirectWrite.ParagraphAlignment GetParagraphAlignment()
        {
            SharpDX.DirectWrite.ParagraphAlignment __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirectWriteParagraphAlignment(this._nativePointer, (*(void ***)this._nativePointer)[12]);
            return __result__;
        }

        /// <summary>
        /// <p> Gets the word wrapping option. </p>
        /// </summary>
        /// <returns><p>Returns the word wrapping option; see <strong><see cref = "SharpDX.DirectWrite.WordWrapping"/></strong> for more information.</p></returns>
        /// <doc-id>dd316688</doc-id>
        /// <unmanaged>DWRITE_WORD_WRAPPING IDWriteTextFormat::GetWordWrapping()</unmanaged>
        /// <unmanaged-short>IDWriteTextFormat::GetWordWrapping</unmanaged-short>
        internal unsafe SharpDX.DirectWrite.WordWrapping GetWordWrapping()
        {
            SharpDX.DirectWrite.WordWrapping __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirectWriteWordWrapping(this._nativePointer, (*(void ***)this._nativePointer)[13]);
            return __result__;
        }

        /// <summary>
        /// <p> Gets the  current reading direction for text in a paragraph. </p>
        /// </summary>
        /// <returns><p>A value that indicates the current reading direction for text in a  paragraph.</p></returns>
        /// <doc-id>dd316678</doc-id>
        /// <unmanaged>DWRITE_READING_DIRECTION IDWriteTextFormat::GetReadingDirection()</unmanaged>
        /// <unmanaged-short>IDWriteTextFormat::GetReadingDirection</unmanaged-short>
        internal unsafe SharpDX.DirectWrite.ReadingDirection GetReadingDirection()
        {
            SharpDX.DirectWrite.ReadingDirection __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirectWriteReadingDirection(this._nativePointer, (*(void ***)this._nativePointer)[14]);
            return __result__;
        }

        /// <summary>
        /// <p> Gets the direction that text lines flow. </p>
        /// </summary>
        /// <returns><p>The direction that text lines flow within their parent container.  For example, <strong>DWRITE_FLOW_DIRECTION_TOP_TO_BOTTOM</strong> indicates that text lines are placed from top to bottom.</p></returns>
        /// <doc-id>dd316631</doc-id>
        /// <unmanaged>DWRITE_FLOW_DIRECTION IDWriteTextFormat::GetFlowDirection()</unmanaged>
        /// <unmanaged-short>IDWriteTextFormat::GetFlowDirection</unmanaged-short>
        internal unsafe SharpDX.DirectWrite.FlowDirection GetFlowDirection()
        {
            SharpDX.DirectWrite.FlowDirection __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirectWriteFlowDirection(this._nativePointer, (*(void ***)this._nativePointer)[15]);
            return __result__;
        }

        /// <summary>
        /// <p> Gets the  incremental tab stop position. </p>
        /// </summary>
        /// <returns><p>The incremental tab stop value.</p></returns>
        /// <doc-id>dd316655</doc-id>
        /// <unmanaged>float IDWriteTextFormat::GetIncrementalTabStop()</unmanaged>
        /// <unmanaged-short>IDWriteTextFormat::GetIncrementalTabStop</unmanaged-short>
        internal unsafe System.Single GetIncrementalTabStop()
        {
            System.Single __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallfloat(this._nativePointer, (*(void ***)this._nativePointer)[16]);
            return __result__;
        }

        /// <summary>
        /// <p> Gets the trimming options for text that overflows the layout box. </p>
        /// </summary>
        /// <param name = "trimmingOptions"><dd>  <p>When this method returns, it contains a reference to a <strong><see cref = "SharpDX.DirectWrite.Trimming"/></strong> structure that holds the text trimming options for the overflowing text.</p> </dd></param>
        /// <param name = "trimmingSign"><dd>  <p>When this method returns, contains an address of a reference to a trimming omission sign. This parameter may be <strong><c>null</c></strong>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd316684</doc-id>
        /// <unmanaged>HRESULT IDWriteTextFormat::GetTrimming([Out] DWRITE_TRIMMING* trimmingOptions,[Out] IDWriteInlineObject** trimmingSign)</unmanaged>
        /// <unmanaged-short>IDWriteTextFormat::GetTrimming</unmanaged-short>
        public unsafe void GetTrimming(out SharpDX.DirectWrite.Trimming trimmingOptions, out SharpDX.DirectWrite.InlineObject trimmingSign)
        {
            trimmingOptions = default (SharpDX.DirectWrite.Trimming);
            System.IntPtr trimmingSign_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *trimmingOptions_ = &trimmingOptions)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, trimmingOptions_, &trimmingSign_, (*(void ***)this._nativePointer)[17]);
            if (trimmingSign_ != System.IntPtr.Zero)
                trimmingSign = new SharpDX.DirectWrite.InlineObjectNative(trimmingSign_);
            else
                trimmingSign = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Gets the line spacing adjustment set for a multiline text paragraph. </p>
        /// </summary>
        /// <param name = "lineSpacingMethod"><dd>  <p>A value that indicates how line height is determined.</p> </dd></param>
        /// <param name = "lineSpacing"><dd>  <p>When this method returns, contains the line height, or  distance between one baseline to another.</p> </dd></param>
        /// <param name = "baseline"><dd>  <p>When this method returns, contains the distance from top of line to baseline. A reasonable ratio to <em>lineSpacing</em> is 80 percent.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd316657</doc-id>
        /// <unmanaged>HRESULT IDWriteTextFormat::GetLineSpacing([Out] DWRITE_LINE_SPACING_METHOD* lineSpacingMethod,[Out] float* lineSpacing,[Out] float* baseline)</unmanaged>
        /// <unmanaged-short>IDWriteTextFormat::GetLineSpacing</unmanaged-short>
        public unsafe void GetLineSpacing(out SharpDX.DirectWrite.LineSpacingMethod lineSpacingMethod, out System.Single lineSpacing, out System.Single baseline)
        {
            SharpDX.Result __result__;
            fixed (void *baseline_ = &baseline)
                fixed (void *lineSpacing_ = &lineSpacing)
                    fixed (void *lineSpacingMethod_ = &lineSpacingMethod)
                        __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, lineSpacingMethod_, lineSpacing_, baseline_, (*(void ***)this._nativePointer)[18]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Gets the current font collection. </p>
        /// </summary>
        /// <param name = "fontCollection"><dd>  <p>When this method returns, contains an address of a reference to the font collection being used for the current text.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd316633</doc-id>
        /// <unmanaged>HRESULT IDWriteTextFormat::GetFontCollection([Out] IDWriteFontCollection** fontCollection)</unmanaged>
        /// <unmanaged-short>IDWriteTextFormat::GetFontCollection</unmanaged-short>
        internal unsafe void GetFontCollection(out SharpDX.DirectWrite.FontCollection fontCollection)
        {
            System.IntPtr fontCollection_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &fontCollection_, (*(void ***)this._nativePointer)[19]);
            if (fontCollection_ != System.IntPtr.Zero)
                fontCollection = new SharpDX.DirectWrite.FontCollection(fontCollection_);
            else
                fontCollection = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Gets the length of the font family name. </p>
        /// </summary>
        /// <returns><p>The size of the character array, in character count, not including the terminated <strong><c>null</c></strong> character.</p></returns>
        /// <doc-id>dd316640</doc-id>
        /// <unmanaged>unsigned int IDWriteTextFormat::GetFontFamilyNameLength()</unmanaged>
        /// <unmanaged-short>IDWriteTextFormat::GetFontFamilyNameLength</unmanaged-short>
        internal unsafe System.Int32 GetFontFamilyNameLength()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[20]);
            return __result__;
        }

        /// <summary>
        /// <p> Gets a copy of the font family name. </p>
        /// </summary>
        /// <param name = "fontFamilyName"><dd>  <p>When this method returns, contains a reference to a character array, which is null-terminated, that receives the current font family name. The buffer allocated for this array should be at least the size, in elements, of <em>nameSize</em>.</p> </dd></param>
        /// <param name = "nameSize"><dd>  <p>The size of the <em>fontFamilyName</em> character array, in character count, including the terminated <strong><c>null</c></strong> character.  To find the size of <em>fontFamilyName</em>, use <strong>GetFontFamilyNameLength</strong>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd316636</doc-id>
        /// <unmanaged>HRESULT IDWriteTextFormat::GetFontFamilyName([Out, Buffer] wchar_t* fontFamilyName,[In] unsigned int nameSize)</unmanaged>
        /// <unmanaged-short>IDWriteTextFormat::GetFontFamilyName</unmanaged-short>
        internal unsafe void GetFontFamilyName(System.IntPtr fontFamilyName, System.Int32 nameSize)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)fontFamilyName, nameSize, (*(void ***)this._nativePointer)[21]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Gets the font weight of the text. </p>
        /// </summary>
        /// <returns><p>A value that indicates the type of weight (such as normal, bold, or black). </p></returns>
        /// <doc-id>dd316652</doc-id>
        /// <unmanaged>DWRITE_FONT_WEIGHT IDWriteTextFormat::GetFontWeight()</unmanaged>
        /// <unmanaged-short>IDWriteTextFormat::GetFontWeight</unmanaged-short>
        internal unsafe SharpDX.DirectWrite.FontWeight GetFontWeight()
        {
            SharpDX.DirectWrite.FontWeight __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirectWriteFontWeight(this._nativePointer, (*(void ***)this._nativePointer)[22]);
            return __result__;
        }

        /// <summary>
        /// <p> Gets the font style of the text.</p>
        /// </summary>
        /// <returns><p>A value which indicates the type of font style (such as  slope or incline).</p></returns>
        /// <doc-id>dd316649</doc-id>
        /// <unmanaged>DWRITE_FONT_STYLE IDWriteTextFormat::GetFontStyle()</unmanaged>
        /// <unmanaged-short>IDWriteTextFormat::GetFontStyle</unmanaged-short>
        internal unsafe SharpDX.DirectWrite.FontStyle GetFontStyle()
        {
            SharpDX.DirectWrite.FontStyle __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirectWriteFontStyle(this._nativePointer, (*(void ***)this._nativePointer)[23]);
            return __result__;
        }

        /// <summary>
        /// <p> Gets the font stretch of the text. </p>
        /// </summary>
        /// <returns><p>A value which indicates the type of font stretch (such as  normal or condensed).</p></returns>
        /// <doc-id>dd316646</doc-id>
        /// <unmanaged>DWRITE_FONT_STRETCH IDWriteTextFormat::GetFontStretch()</unmanaged>
        /// <unmanaged-short>IDWriteTextFormat::GetFontStretch</unmanaged-short>
        internal unsafe SharpDX.DirectWrite.FontStretch GetFontStretch()
        {
            SharpDX.DirectWrite.FontStretch __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirectWriteFontStretch(this._nativePointer, (*(void ***)this._nativePointer)[24]);
            return __result__;
        }

        /// <summary>
        /// <p> Gets the font  size in DIP unites. </p>
        /// </summary>
        /// <returns><p>The current font size in DIP units.</p></returns>
        /// <doc-id>dd316643</doc-id>
        /// <unmanaged>float IDWriteTextFormat::GetFontSize()</unmanaged>
        /// <unmanaged-short>IDWriteTextFormat::GetFontSize</unmanaged-short>
        internal unsafe System.Single GetFontSize()
        {
            System.Single __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallfloat(this._nativePointer, (*(void ***)this._nativePointer)[25]);
            return __result__;
        }

        /// <summary>
        /// <p> Gets the length of the locale name. </p>
        /// </summary>
        /// <returns><p>The size of the character array in character count, not including the terminated <strong><c>null</c></strong> character.</p></returns>
        /// <doc-id>dd316674</doc-id>
        /// <unmanaged>unsigned int IDWriteTextFormat::GetLocaleNameLength()</unmanaged>
        /// <unmanaged-short>IDWriteTextFormat::GetLocaleNameLength</unmanaged-short>
        internal unsafe System.Int32 GetLocaleNameLength()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[26]);
            return __result__;
        }

        /// <summary>
        /// <p> Gets a copy of the locale name. </p>
        /// </summary>
        /// <param name = "localeName"><dd>  <p>Contains a character array that receives the current locale name.</p> </dd></param>
        /// <param name = "nameSize"><dd>  <p>The size of the character array, in character count, including the terminated <strong><c>null</c></strong> character. Use <strong>GetLocaleNameLength</strong> to get the size of the locale name character array.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd316659</doc-id>
        /// <unmanaged>HRESULT IDWriteTextFormat::GetLocaleName([Out, Buffer] wchar_t* localeName,[In] unsigned int nameSize)</unmanaged>
        /// <unmanaged-short>IDWriteTextFormat::GetLocaleName</unmanaged-short>
        internal unsafe void GetLocaleName(System.IntPtr localeName, System.Int32 nameSize)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)localeName, nameSize, (*(void ***)this._nativePointer)[27]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("5F174B49-0D8B-4CFB-8BCA-F1CCE9D06C67")]
    public partial class TextFormat1 : SharpDX.DirectWrite.TextFormat
    {
        public TextFormat1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator TextFormat1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new TextFormat1(nativePtr);
        /// <summary>
        /// <p>Get or sets the preferred orientation of glyphs when using a vertical reading direction.</p>
        /// </summary>
        /// <doc-id>dn894598</doc-id>
        /// <unmanaged>GetVerticalGlyphOrientation / SetVerticalGlyphOrientation</unmanaged>
        /// <unmanaged-short>GetVerticalGlyphOrientation</unmanaged-short>
        public SharpDX.DirectWrite.VerticalGlyphOrientation VerticalGlyphOrientation
        {
            get => GetVerticalGlyphOrientation();
            set => SetVerticalGlyphOrientation(value);
        }

        /// <summary>
        /// <p>Gets or sets the wrapping mode of the last line.</p>
        /// </summary>
        /// <doc-id>dn894596</doc-id>
        /// <unmanaged>GetLastLineWrapping / SetLastLineWrapping</unmanaged>
        /// <unmanaged-short>GetLastLineWrapping</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool LastLineWrapping
        {
            get => GetLastLineWrapping();
            set => SetLastLineWrapping(value);
        }

        /// <summary>
        /// <p>Gets or sets the optical margin alignment for the text format.</p>
        /// </summary>
        /// <doc-id>dn894597</doc-id>
        /// <unmanaged>GetOpticalAlignment / SetOpticalAlignment</unmanaged>
        /// <unmanaged-short>GetOpticalAlignment</unmanaged-short>
        public SharpDX.DirectWrite.OptimizationIcalAlignment OpticalAlignment
        {
            get => GetOpticalAlignment();
            set => SetOpticalAlignment(value);
        }

        /// <summary>
        /// <p>Gets or sets the current fallback. If none was ever set since creating the layout, it will be nullptr.</p>
        /// </summary>
        /// <doc-id>dn280486</doc-id>
        /// <unmanaged>GetFontFallback / SetFontFallback</unmanaged>
        /// <unmanaged-short>GetFontFallback</unmanaged-short>
        public SharpDX.DirectWrite.FontFallback FontFallback
        {
            get
            {
                GetFontFallback(out var __output__);
                return __output__;
            }

            set => SetFontFallback(value);
        }

        /// <summary>
        /// <p>Sets the orientation of a text format.</p>
        /// </summary>
        /// <param name = "glyphOrientation"><dd>  <p>The orientation to apply to the text format.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn280489</doc-id>
        /// <unmanaged>HRESULT IDWriteTextFormat1::SetVerticalGlyphOrientation([In] DWRITE_VERTICAL_GLYPH_ORIENTATION glyphOrientation)</unmanaged>
        /// <unmanaged-short>IDWriteTextFormat1::SetVerticalGlyphOrientation</unmanaged-short>
        internal unsafe void SetVerticalGlyphOrientation(SharpDX.DirectWrite.VerticalGlyphOrientation glyphOrientation)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)glyphOrientation), (*(void ***)this._nativePointer)[28]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Get the preferred orientation of glyphs when using a vertical reading direction.</p>
        /// </summary>
        /// <returns><p>The preferred orientation of glyphs when using a vertical reading direction.</p></returns>
        /// <doc-id>dn894598</doc-id>
        /// <unmanaged>DWRITE_VERTICAL_GLYPH_ORIENTATION IDWriteTextFormat1::GetVerticalGlyphOrientation()</unmanaged>
        /// <unmanaged-short>IDWriteTextFormat1::GetVerticalGlyphOrientation</unmanaged-short>
        internal unsafe SharpDX.DirectWrite.VerticalGlyphOrientation GetVerticalGlyphOrientation()
        {
            SharpDX.DirectWrite.VerticalGlyphOrientation __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirectWriteVerticalGlyphOrientation(this._nativePointer, (*(void ***)this._nativePointer)[29]);
            return __result__;
        }

        /// <summary>
        /// <p>Sets the wrapping mode of the last line.</p>
        /// </summary>
        /// <param name = "isLastLineWrappingEnabled"><dd>  <p>If set to <see cref = "SharpDX.Result.False"/>, the last line is not wrapped. If set to TRUE, the last line is wrapped.</p> <p>The last line is wrapped by default.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn280490</doc-id>
        /// <unmanaged>HRESULT IDWriteTextFormat1::SetLastLineWrapping([In] BOOL isLastLineWrappingEnabled)</unmanaged>
        /// <unmanaged-short>IDWriteTextFormat1::SetLastLineWrapping</unmanaged-short>
        internal unsafe void SetLastLineWrapping(SharpDX.Mathematics.Interop.RawBool isLastLineWrappingEnabled)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, isLastLineWrappingEnabled, (*(void ***)this._nativePointer)[30]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the wrapping mode of the last line.</p>
        /// </summary>
        /// <returns><p>Returns <see cref = "SharpDX.Result.False"/> if the last line is not wrapped; TRUE if the last line is wrapped.</p></returns>
        /// <doc-id>dn894596</doc-id>
        /// <unmanaged>BOOL IDWriteTextFormat1::GetLastLineWrapping()</unmanaged>
        /// <unmanaged-short>IDWriteTextFormat1::GetLastLineWrapping</unmanaged-short>
        internal unsafe SharpDX.Mathematics.Interop.RawBool GetLastLineWrapping()
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, (*(void ***)this._nativePointer)[31]);
            return __result__;
        }

        /// <summary>
        /// <p>Sets the optical margin alignment for the text format.</p><p> By default, glyphs are aligned to the margin by the default origin and side-bearings of the glyph. If you specify <strong>DWRITE_OPTICAL_ALIGNMENT_USING_SIDE_BEARINGS</strong>, then the alignment Suses the side bearings to offset the glyph from the aligned edge to ensure the ink of the glyphs are aligned. </p>
        /// </summary>
        /// <param name = "opticalAlignment"><dd> <p>The optical alignment to set.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn280488</doc-id>
        /// <unmanaged>HRESULT IDWriteTextFormat1::SetOpticalAlignment([In] DWRITE_OPTICAL_ALIGNMENT opticalAlignment)</unmanaged>
        /// <unmanaged-short>IDWriteTextFormat1::SetOpticalAlignment</unmanaged-short>
        internal unsafe void SetOpticalAlignment(SharpDX.DirectWrite.OptimizationIcalAlignment opticalAlignment)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)opticalAlignment), (*(void ***)this._nativePointer)[32]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the optical margin alignment for the text format.</p>
        /// </summary>
        /// <returns><p>The optical alignment.</p></returns>
        /// <doc-id>dn894597</doc-id>
        /// <unmanaged>DWRITE_OPTICAL_ALIGNMENT IDWriteTextFormat1::GetOpticalAlignment()</unmanaged>
        /// <unmanaged-short>IDWriteTextFormat1::GetOpticalAlignment</unmanaged-short>
        internal unsafe SharpDX.DirectWrite.OptimizationIcalAlignment GetOpticalAlignment()
        {
            SharpDX.DirectWrite.OptimizationIcalAlignment __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirectWriteOptimizationIcalAlignment(this._nativePointer, (*(void ***)this._nativePointer)[33]);
            return __result__;
        }

        /// <summary>
        /// <p> Applies the custom font fallback onto the layout. If none is set, it uses the default system fallback list. </p>
        /// </summary>
        /// <param name = "fontFallback"><dd>  <p>The font fallback to apply to the layout.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn280487</doc-id>
        /// <unmanaged>HRESULT IDWriteTextFormat1::SetFontFallback([In] IDWriteFontFallback* fontFallback)</unmanaged>
        /// <unmanaged-short>IDWriteTextFormat1::SetFontFallback</unmanaged-short>
        internal unsafe void SetFontFallback(SharpDX.DirectWrite.FontFallback fontFallback)
        {
            System.IntPtr fontFallback_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fontFallback_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.FontFallback>(fontFallback);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)fontFallback_, (*(void ***)this._nativePointer)[34]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the current fallback. If none was ever set since creating the layout, it will be nullptr.</p>
        /// </summary>
        /// <param name = "fontFallback"><dd>  <p>Contains an address of a reference to the the current font fallback object.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn280486</doc-id>
        /// <unmanaged>HRESULT IDWriteTextFormat1::GetFontFallback([Out] IDWriteFontFallback** fontFallback)</unmanaged>
        /// <unmanaged-short>IDWriteTextFormat1::GetFontFallback</unmanaged-short>
        internal unsafe void GetFontFallback(out SharpDX.DirectWrite.FontFallback fontFallback)
        {
            System.IntPtr fontFallback_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &fontFallback_, (*(void ***)this._nativePointer)[35]);
            if (fontFallback_ != System.IntPtr.Zero)
                fontFallback = new SharpDX.DirectWrite.FontFallback(fontFallback_);
            else
                fontFallback = null;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("F67E0EDD-9E3D-4ECC-8C32-4183253DFE70")]
    public partial class TextFormat2 : SharpDX.DirectWrite.TextFormat1
    {
        public TextFormat2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator TextFormat2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new TextFormat2(nativePtr);
        /// <summary>
        /// <p>Gets or sets the line spacing adjustment set for a multiline text paragraph. </p>
        /// </summary>
        /// <doc-id>mt574122</doc-id>
        /// <unmanaged>GetLineSpacing / SetLineSpacing</unmanaged>
        /// <unmanaged-short>GetLineSpacing</unmanaged-short>
        public SharpDX.DirectWrite.LineSpacing LineSpacing
        {
            get
            {
                GetLineSpacing(out var __output__);
                return __output__;
            }

            set => SetLineSpacing(ref value);
        }

        /// <summary>
        /// <p>Set line spacing.</p>
        /// </summary>
        /// <param name = "lineSpacingOptions"><dd>  <p>How to manage space between lines.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>mt574123</doc-id>
        /// <unmanaged>HRESULT IDWriteTextFormat2::SetLineSpacing([In] const DWRITE_LINE_SPACING* lineSpacingOptions)</unmanaged>
        /// <unmanaged-short>IDWriteTextFormat2::SetLineSpacing</unmanaged-short>
        internal unsafe void SetLineSpacing(ref SharpDX.DirectWrite.LineSpacing lineSpacingOptions)
        {
            SharpDX.Result __result__;
            fixed (void *lineSpacingOptions_ = &lineSpacingOptions)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, lineSpacingOptions_, (*(void ***)this._nativePointer)[36]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the line spacing adjustment set for a multiline text paragraph. </p>
        /// </summary>
        /// <param name = "lineSpacingOptions"><dd>  <p>A structure describing how the space between lines is managed for the paragraph.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>mt574122</doc-id>
        /// <unmanaged>HRESULT IDWriteTextFormat2::GetLineSpacing([Out] DWRITE_LINE_SPACING* lineSpacingOptions)</unmanaged>
        /// <unmanaged-short>IDWriteTextFormat2::GetLineSpacing</unmanaged-short>
        internal unsafe void GetLineSpacing(out SharpDX.DirectWrite.LineSpacing lineSpacingOptions)
        {
            lineSpacingOptions = default (SharpDX.DirectWrite.LineSpacing);
            SharpDX.Result __result__;
            fixed (void *lineSpacingOptions_ = &lineSpacingOptions)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, lineSpacingOptions_, (*(void ***)this._nativePointer)[37]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("53737037-6d14-410b-9bfe-0b182bb70961")]
    public partial class TextLayout : SharpDX.DirectWrite.TextFormat
    {
        public TextLayout(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator TextLayout(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new TextLayout(nativePtr);
        /// <summary>
        /// <p>Gets or sets the layout maximum width. </p>
        /// </summary>
        /// <doc-id>dd316781</doc-id>
        /// <unmanaged>GetMaxWidth / SetMaxWidth</unmanaged>
        /// <unmanaged-short>GetMaxWidth</unmanaged-short>
        public System.Single MaxWidth
        {
            get => GetMaxWidth();
            set => SetMaxWidth(value);
        }

        /// <summary>
        /// <p>Gets or sets the layout maximum height. </p>
        /// </summary>
        /// <doc-id>dd316776</doc-id>
        /// <unmanaged>GetMaxHeight / SetMaxHeight</unmanaged>
        /// <unmanaged-short>GetMaxHeight</unmanaged-short>
        public System.Single MaxHeight
        {
            get => GetMaxHeight();
            set => SetMaxHeight(value);
        }

        /// <summary>
        /// <p> Retrieves overall metrics for the formatted string. </p>
        /// </summary>
        /// <doc-id>dd316785</doc-id>
        /// <unmanaged>GetMetrics</unmanaged>
        /// <unmanaged-short>GetMetrics</unmanaged-short>
        public SharpDX.DirectWrite.TextMetrics Metrics
        {
            get
            {
                GetMetrics(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Returns the overhangs (in DIPs) of the layout and all objects contained in it, including text glyphs and inline objects.</p>
        /// </summary>
        /// <remarks>
        /// <p>Underlines and strikethroughs do not contribute to the black box determination, since these are actually drawn by the renderer, which is allowed to draw them in any variety of styles.</p>
        /// </remarks>
        /// <doc-id>dd316790</doc-id>
        /// <unmanaged>GetOverhangMetrics</unmanaged>
        /// <unmanaged-short>GetOverhangMetrics</unmanaged-short>
        public SharpDX.DirectWrite.OverhangMetrics OverhangMetrics
        {
            get
            {
                GetOverhangMetrics(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p> Sets the layout maximum width.</p>
        /// </summary>
        /// <param name = "maxWidth"><dd>  <p>A value that indicates the maximum width of the layout box.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371511</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout::SetMaxWidth([In] float maxWidth)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout::SetMaxWidth</unmanaged-short>
        internal unsafe void SetMaxWidth(System.Single maxWidth)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, maxWidth, (*(void ***)this._nativePointer)[28]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Sets the layout maximum height. </p>
        /// </summary>
        /// <param name = "maxHeight"><dd>  <p>A value that indicates the maximum height of the layout box. </p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371507</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout::SetMaxHeight([In] float maxHeight)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout::SetMaxHeight</unmanaged-short>
        internal unsafe void SetMaxHeight(System.Single maxHeight)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, maxHeight, (*(void ***)this._nativePointer)[29]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Sets the font collection. </p>
        /// </summary>
        /// <param name = "fontCollection"><dd>  <p>The font collection to set.</p> </dd></param>
        /// <param name = "textRange"><dd>  <p>Text range to which this change applies.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371481</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout::SetFontCollection([In] IDWriteFontCollection* fontCollection,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout::SetFontCollection</unmanaged-short>
        public unsafe void SetFontCollection(SharpDX.DirectWrite.FontCollection fontCollection, SharpDX.DirectWrite.TextRange textRange)
        {
            System.IntPtr fontCollection_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fontCollection_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.FontCollection>(fontCollection);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, (void *)fontCollection_, textRange, (*(void ***)this._nativePointer)[30]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Sets null-terminated font family name for text within a specified  text range. </p>
        /// </summary>
        /// <param name = "fontFamilyName"><dd>  <p>The font family name that applies to the entire text string within the range specified by <em>textRange</em>.</p> </dd></param>
        /// <param name = "textRange"><dd>  <p>Text range to which this change applies.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371487</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout::SetFontFamilyName([In] const wchar_t* fontFamilyName,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout::SetFontFamilyName</unmanaged-short>
        public unsafe void SetFontFamilyName(System.String fontFamilyName, SharpDX.DirectWrite.TextRange textRange)
        {
            SharpDX.Result __result__;
            fixed (char *fontFamilyName_ = fontFamilyName)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, (void *)fontFamilyName_, textRange, (*(void ***)this._nativePointer)[31]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Sets the font weight for text within a text range specified by a <strong><see cref = "SharpDX.DirectWrite.TextRange"/></strong> structure. </p>
        /// </summary>
        /// <param name = "fontWeight">No documentation.</param>
        /// <param name = "textRange">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The font weight can be set to one of the predefined font weight values provided in the <strong><see cref = "SharpDX.DirectWrite.FontWeight"/></strong> enumeration or an integer from 1 to 999.  Values outside this range will cause the method to fail with an <strong>E_INVALIDARG</strong> return value.</p><p>The following illustration shows an example of Normal and UltraBold weights for the Palatino Linotype typeface.</p>
        /// </remarks>
        /// <doc-id>dd371498</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout::SetFontWeight([In] DWRITE_FONT_WEIGHT fontWeight,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout::SetFontWeight</unmanaged-short>
        public unsafe void SetFontWeight(SharpDX.DirectWrite.FontWeight fontWeight, SharpDX.DirectWrite.TextRange textRange)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, unchecked ((System.Int32)fontWeight), textRange, (*(void ***)this._nativePointer)[32]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Sets the font style for  text within a text range specified by a <strong><see cref = "SharpDX.DirectWrite.TextRange"/></strong> structure.</p>
        /// </summary>
        /// <param name = "fontStyle">No documentation.</param>
        /// <param name = "textRange">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The font style can be set to Normal, Italic or Oblique. The following illustration shows  three styles for the Palatino font.  For more information, see <strong><see cref = "SharpDX.DirectWrite.FontStyle"/></strong>.</p><p></p>
        /// </remarks>
        /// <doc-id>dd371495</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout::SetFontStyle([In] DWRITE_FONT_STYLE fontStyle,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout::SetFontStyle</unmanaged-short>
        public unsafe void SetFontStyle(SharpDX.DirectWrite.FontStyle fontStyle, SharpDX.DirectWrite.TextRange textRange)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, unchecked ((System.Int32)fontStyle), textRange, (*(void ***)this._nativePointer)[33]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Sets the  font stretch for text within a specified text range. </p>
        /// </summary>
        /// <param name = "fontStretch"><dd>  <p>A value which indicates the type of font stretch for text within the range specified by <em>textRange</em>.</p> </dd></param>
        /// <param name = "textRange"><dd>  <p>Text range to which this change applies.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371493</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout::SetFontStretch([In] DWRITE_FONT_STRETCH fontStretch,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout::SetFontStretch</unmanaged-short>
        public unsafe void SetFontStretch(SharpDX.DirectWrite.FontStretch fontStretch, SharpDX.DirectWrite.TextRange textRange)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, unchecked ((System.Int32)fontStretch), textRange, (*(void ***)this._nativePointer)[34]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the font size in DIP units for text within a specified text range. </p>
        /// </summary>
        /// <param name = "fontSize"><dd>  <p>The  font size in DIP units to be set for   text in the range specified by <em>textRange</em>. </p> </dd></param>
        /// <param name = "textRange"><dd>  <p>Text range to which this change applies.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371490</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout::SetFontSize([In] float fontSize,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout::SetFontSize</unmanaged-short>
        public unsafe void SetFontSize(System.Single fontSize, SharpDX.DirectWrite.TextRange textRange)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, fontSize, textRange, (*(void ***)this._nativePointer)[35]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>The <strong><see cref = "SharpDX.DirectWrite.TextLayout"/></strong> interface represents a block of text after it has been fully analyzed and formatted.</p>
        /// </summary>
        /// <param name = "hasUnderline">No documentation.</param>
        /// <param name = "textRange">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <remarks>
        /// <p>To get a reference to the <strong><see cref = "SharpDX.DirectWrite.TextLayout"/></strong> interface, the application must call the <strong>IDWriteFactory::CreateTextLayout</strong> method, as shown in the following code.  </p><pre> // Create a text layout using the text format.
        /// if (SUCCEEDED(hr))
        /// { <see cref = "SharpDX.Mathematics.Interop.RawRectangle"/> rect; GetClientRect(hwnd_, &amp;rect);  float width  = rect.right  / dpiScaleX_; float height = rect.bottom / dpiScaleY_; hr = pDWriteFactory_-&gt;CreateTextLayout( wszText_,      // The string to be laid out and formatted. cTextLength_,  // The length of the string. pTextFormat_,  // The text format to apply to the string (contains font information, etc). width,         // The width of the layout box. height,        // The height of the layout box. &amp;pTextLayout_  // The <see cref = "SharpDX.DirectWrite.TextLayout"/> interface reference. );
        /// } </pre><p>The <strong><see cref = "SharpDX.DirectWrite.TextLayout"/></strong> interface allows the application to change the format for ranges of the text it represents, specified by a <strong><see cref = "SharpDX.DirectWrite.TextRange"/></strong> structure.   The following example shows how to set the font weight for a text range.</p><pre> // Set the font weight to bold for the first 5 letters.
        /// <see cref = "SharpDX.DirectWrite.TextRange"/> textRange = {0, 4}; if (SUCCEEDED(hr))
        /// { hr = pTextLayout_-&gt;SetFontWeight(DWRITE_FONT_WEIGHT_BOLD, textRange);
        /// } </pre><p><strong><see cref = "SharpDX.DirectWrite.TextLayout"/></strong> also provides methods for adding strikethrough,  underline, and inline objects to the text.</p><p>To draw the block of text represented by an <strong><see cref = "SharpDX.DirectWrite.TextLayout"/></strong> object, Direct2D provides the <strong>ID2D1RenderTarget::DrawTextLayout</strong> method. To draw using a custom renderer implement an <strong><see cref = "SharpDX.DirectWrite.TextRenderer"/></strong> interface and  call the  <strong>IDWriteTextLayout::Draw</strong> method</p>
        /// </remarks>
        /// <doc-id>dd316718</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout::SetUnderline([In] BOOL hasUnderline,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout::SetUnderline</unmanaged-short>
        public unsafe void SetUnderline(SharpDX.Mathematics.Interop.RawBool hasUnderline, SharpDX.DirectWrite.TextRange textRange)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, hasUnderline, textRange, (*(void ***)this._nativePointer)[36]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets strikethrough for text within a specified text range. </p>
        /// </summary>
        /// <param name = "hasStrikethrough"><dd>  <p>A Boolean flag that indicates whether strikethrough takes place in the range specified by <em>textRange</em>.</p> </dd></param>
        /// <param name = "textRange"><dd>  <p>Text range to which this change applies.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371514</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout::SetStrikethrough([In] BOOL hasStrikethrough,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout::SetStrikethrough</unmanaged-short>
        public unsafe void SetStrikethrough(SharpDX.Mathematics.Interop.RawBool hasStrikethrough, SharpDX.DirectWrite.TextRange textRange)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, hasStrikethrough, textRange, (*(void ***)this._nativePointer)[37]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Sets the application-defined drawing effect. </p>
        /// </summary>
        /// <param name = "drawingEffect"><dd>  <p>Application-defined drawing effects that apply to the range. This data object will be passed back to the application's drawing callbacks for final rendering.</p> </dd></param>
        /// <param name = "textRange"><dd>  <p>The text range to which this change applies.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>An <strong><see cref = "SharpDX.Direct2D1.Brush"/></strong>, such as a color or gradient brush, can be set as a drawing effect if you are using the <strong>ID2D1RenderTarget::DrawTextLayout</strong> to draw text and that brush will be used to draw the specified range of text.</p><p> This drawing effect is associated with the specified range and will be passed back to the application by way of the callback when the range is drawn at drawing time. </p>
        /// </remarks>
        /// <doc-id>dd371477</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout::SetDrawingEffect([In] IUnknown* drawingEffect,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout::SetDrawingEffect</unmanaged-short>
        public unsafe void SetDrawingEffect(System.IntPtr drawingEffect, SharpDX.DirectWrite.TextRange textRange)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, (void *)drawingEffect, textRange, (*(void ***)this._nativePointer)[38]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Sets the inline object. </p>
        /// </summary>
        /// <param name = "inlineObject"><dd>  <p>An application-defined inline object. </p> </dd></param>
        /// <param name = "textRange"><dd>  <p>Text range to which this change applies.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The application may call this function to specify the set of properties describing an application-defined inline object for specific range.</p><p> This inline object applies to the specified range and will be passed back to the application by way of the <strong>DrawInlineObject</strong> callback when the range is drawn. Any text in that range will be suppressed. </p>
        /// </remarks>
        /// <doc-id>dd371500</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout::SetInlineObject([In] IDWriteInlineObject* inlineObject,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout::SetInlineObject</unmanaged-short>
        public unsafe void SetInlineObject(SharpDX.DirectWrite.InlineObject inlineObject, SharpDX.DirectWrite.TextRange textRange)
        {
            System.IntPtr inlineObject_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            inlineObject_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.InlineObject>(inlineObject);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, (void *)inlineObject_, textRange, (*(void ***)this._nativePointer)[39]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Sets  font typography features for text within a specified text range. </p>
        /// </summary>
        /// <param name = "typography"><dd>  <p>Pointer to font typography settings. </p> </dd></param>
        /// <param name = "textRange"><dd>  <p>Text range to which this change applies.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371517</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout::SetTypography([In] IDWriteTypography* typography,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout::SetTypography</unmanaged-short>
        public unsafe void SetTypography(SharpDX.DirectWrite.Typography typography, SharpDX.DirectWrite.TextRange textRange)
        {
            System.IntPtr typography_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            typography_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.Typography>(typography);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, (void *)typography_, textRange, (*(void ***)this._nativePointer)[40]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Sets the locale name for text within a specified text range.</p>
        /// </summary>
        /// <param name = "localeName"><dd>  <p>A null-terminated locale name string.</p> </dd></param>
        /// <param name = "textRange"><dd>  <p>Text range to which this change applies.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371503</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout::SetLocaleName([In] const wchar_t* localeName,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout::SetLocaleName</unmanaged-short>
        public unsafe void SetLocaleName(System.String localeName, SharpDX.DirectWrite.TextRange textRange)
        {
            SharpDX.Result __result__;
            fixed (char *localeName_ = localeName)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, (void *)localeName_, textRange, (*(void ***)this._nativePointer)[41]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Gets the layout maximum width. </p>
        /// </summary>
        /// <returns><p>Returns the layout maximum width.</p></returns>
        /// <doc-id>dd316781</doc-id>
        /// <unmanaged>float IDWriteTextLayout::GetMaxWidth()</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout::GetMaxWidth</unmanaged-short>
        internal unsafe System.Single GetMaxWidth()
        {
            System.Single __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallfloat(this._nativePointer, (*(void ***)this._nativePointer)[42]);
            return __result__;
        }

        /// <summary>
        /// <p> Gets the layout maximum height. </p>
        /// </summary>
        /// <returns><p>The layout maximum height.</p></returns>
        /// <doc-id>dd316776</doc-id>
        /// <unmanaged>float IDWriteTextLayout::GetMaxHeight()</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout::GetMaxHeight</unmanaged-short>
        internal unsafe System.Single GetMaxHeight()
        {
            System.Single __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallfloat(this._nativePointer, (*(void ***)this._nativePointer)[43]);
            return __result__;
        }

        /// <summary>
        /// <p> Gets the font collection associated with the text at the specified position. </p>
        /// </summary>
        /// <param name = "currentPosition"><dd>  <p>The position of the text to inspect.</p> </dd></param>
        /// <param name = "textRange"><dd>  <p>The range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to the underline.</p> </dd></param>
        /// <returns><dd>  <p>Contains an address of a  reference to the current font collection.</p> </dd></returns>
        /// <doc-id>dd316735</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout::GetFontCollection([In] unsigned int currentPosition,[Out] IDWriteFontCollection** fontCollection,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout::GetFontCollection</unmanaged-short>
        public unsafe SharpDX.DirectWrite.FontCollection GetFontCollection(System.Int32 currentPosition, out SharpDX.DirectWrite.TextRange textRange)
        {
            SharpDX.DirectWrite.FontCollection fontCollection;
            System.IntPtr fontCollection_ = System.IntPtr.Zero;
            textRange = default (SharpDX.DirectWrite.TextRange);
            SharpDX.Result __result__;
            fixed (void *textRange_ = &textRange)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, currentPosition, &fontCollection_, textRange_, (*(void ***)this._nativePointer)[44]);
            if (fontCollection_ != System.IntPtr.Zero)
                fontCollection = new SharpDX.DirectWrite.FontCollection(fontCollection_);
            else
                fontCollection = null;
            __result__.CheckError();
            return fontCollection;
        }

        /// <summary>
        /// <p> Get the length of the font family name at the current position. </p>
        /// </summary>
        /// <param name = "currentPosition"><dd>  <p>The current text position.</p> </dd></param>
        /// <param name = "nameLength"><dd>  <p>When this method returns, contains the size of the character array containing the font family name, in character count, not including the terminated <strong><c>null</c></strong> character.</p> </dd></param>
        /// <param name = "textRange"><dd>  <p>The range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to the font family.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd316741</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout::GetFontFamilyNameLength([In] unsigned int currentPosition,[Out] unsigned int* nameLength,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout::GetFontFamilyNameLength</unmanaged-short>
        internal unsafe void GetFontFamilyNameLength(System.Int32 currentPosition, out System.Int32 nameLength, out SharpDX.DirectWrite.TextRange textRange)
        {
            textRange = default (SharpDX.DirectWrite.TextRange);
            SharpDX.Result __result__;
            fixed (void *textRange_ = &textRange)
                fixed (void *nameLength_ = &nameLength)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, currentPosition, nameLength_, textRange_, (*(void ***)this._nativePointer)[45]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Copies the font family name of the text at the specified position. </p>
        /// </summary>
        /// <param name = "currentPosition"><dd>  <p>The position of the text to examine.</p> </dd></param>
        /// <param name = "fontFamilyName"><dd>  <p>When this method returns, contains an array of characters that receives the current font family name. You must allocate storage for this parameter.</p> </dd></param>
        /// <param name = "nameSize"><dd>  <p>The size of the character array in character count including the terminated <strong><c>null</c></strong> character.</p> </dd></param>
        /// <param name = "textRange"><dd>  <p>The range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to the font family name.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd316738</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout::GetFontFamilyName([In] unsigned int currentPosition,[Out, Buffer] wchar_t* fontFamilyName,[In] unsigned int nameSize,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout::GetFontFamilyName</unmanaged-short>
        internal unsafe void GetFontFamilyName(System.Int32 currentPosition, System.IntPtr fontFamilyName, System.Int32 nameSize, out SharpDX.DirectWrite.TextRange textRange)
        {
            textRange = default (SharpDX.DirectWrite.TextRange);
            SharpDX.Result __result__;
            fixed (void *textRange_ = &textRange)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, currentPosition, (void *)fontFamilyName, nameSize, textRange_, (*(void ***)this._nativePointer)[46]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Gets the font weight of the text at the specified position. </p>
        /// </summary>
        /// <param name = "currentPosition"><dd>  <p>The position of the text to inspect.</p> </dd></param>
        /// <param name = "textRange"><dd>  <p>The range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to the font weight.</p> </dd></param>
        /// <returns><dd>  <p>When this method returns, contains a value which indicates the type of font weight being applied at the specified position.</p> </dd></returns>
        /// <doc-id>dd316753</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout::GetFontWeight([In] unsigned int currentPosition,[Out] DWRITE_FONT_WEIGHT* fontWeight,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout::GetFontWeight</unmanaged-short>
        public unsafe SharpDX.DirectWrite.FontWeight GetFontWeight(System.Int32 currentPosition, out SharpDX.DirectWrite.TextRange textRange)
        {
            SharpDX.DirectWrite.FontWeight fontWeight;
            textRange = default (SharpDX.DirectWrite.TextRange);
            SharpDX.Result __result__;
            fixed (void *textRange_ = &textRange)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, currentPosition, &fontWeight, textRange_, (*(void ***)this._nativePointer)[47]);
            __result__.CheckError();
            return fontWeight;
        }

        /// <summary>
        /// <p> Gets the font style (also known as slope) of the text at the specified position. </p>
        /// </summary>
        /// <param name = "currentPosition"><dd>  <p>The position of the text to inspect.</p> </dd></param>
        /// <param name = "textRange"><dd>  <p>The range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to the font style.</p> </dd></param>
        /// <returns><dd>  <p>When this method returns, contains a value which indicates the type of font style (also known as slope or incline) being applied at the specified position.</p> </dd></returns>
        /// <doc-id>dd316750</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout::GetFontStyle([In] unsigned int currentPosition,[Out] DWRITE_FONT_STYLE* fontStyle,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout::GetFontStyle</unmanaged-short>
        public unsafe SharpDX.DirectWrite.FontStyle GetFontStyle(System.Int32 currentPosition, out SharpDX.DirectWrite.TextRange textRange)
        {
            SharpDX.DirectWrite.FontStyle fontStyle;
            textRange = default (SharpDX.DirectWrite.TextRange);
            SharpDX.Result __result__;
            fixed (void *textRange_ = &textRange)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, currentPosition, &fontStyle, textRange_, (*(void ***)this._nativePointer)[48]);
            __result__.CheckError();
            return fontStyle;
        }

        /// <summary>
        /// <p> Gets the font stretch of the text at the specified position. </p>
        /// </summary>
        /// <param name = "currentPosition"><dd>  <p>The position of the text to inspect.</p> </dd></param>
        /// <param name = "textRange"><dd>  <p>The range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to the font stretch.</p> </dd></param>
        /// <returns><dd>  <p>When this method returns, contains a value which indicates the type of font stretch (also known as width) being applied at the specified position.</p> </dd></returns>
        /// <doc-id>dd316747</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout::GetFontStretch([In] unsigned int currentPosition,[Out] DWRITE_FONT_STRETCH* fontStretch,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout::GetFontStretch</unmanaged-short>
        public unsafe SharpDX.DirectWrite.FontStretch GetFontStretch(System.Int32 currentPosition, out SharpDX.DirectWrite.TextRange textRange)
        {
            SharpDX.DirectWrite.FontStretch fontStretch;
            textRange = default (SharpDX.DirectWrite.TextRange);
            SharpDX.Result __result__;
            fixed (void *textRange_ = &textRange)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, currentPosition, &fontStretch, textRange_, (*(void ***)this._nativePointer)[49]);
            __result__.CheckError();
            return fontStretch;
        }

        /// <summary>
        /// <p> Gets the font em height of the text at the specified position. </p>
        /// </summary>
        /// <param name = "currentPosition"><dd>  <p>The position of the text to inspect.</p> </dd></param>
        /// <param name = "textRange"><dd>  <p>The range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to the font size.</p> </dd></param>
        /// <returns><dd>  <p>When this method returns, contains the size of the font in ems  of the text at the specified position.</p> </dd></returns>
        /// <doc-id>dd316745</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout::GetFontSize([In] unsigned int currentPosition,[Out] float* fontSize,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout::GetFontSize</unmanaged-short>
        public unsafe System.Single GetFontSize(System.Int32 currentPosition, out SharpDX.DirectWrite.TextRange textRange)
        {
            System.Single fontSize;
            textRange = default (SharpDX.DirectWrite.TextRange);
            SharpDX.Result __result__;
            fixed (void *textRange_ = &textRange)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, currentPosition, &fontSize, textRange_, (*(void ***)this._nativePointer)[50]);
            __result__.CheckError();
            return fontSize;
        }

        /// <summary>
        /// <p> Gets the underline presence of the text at the specified position. </p>
        /// </summary>
        /// <param name = "currentPosition"><dd>  <p>The current text position.</p> </dd></param>
        /// <param name = "textRange"><dd>  <p>The range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to the underline.</p> </dd></param>
        /// <returns><dd>  <p>A Boolean  flag that indicates whether underline is present at the position indicated by <em>currentPosition</em>.</p> </dd></returns>
        /// <doc-id>dd371463</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout::GetUnderline([In] unsigned int currentPosition,[Out] BOOL* hasUnderline,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout::GetUnderline</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool HasUnderline(System.Int32 currentPosition, out SharpDX.DirectWrite.TextRange textRange)
        {
            SharpDX.Mathematics.Interop.RawBool hasUnderline;
            textRange = default (SharpDX.DirectWrite.TextRange);
            SharpDX.Result __result__;
            fixed (void *textRange_ = &textRange)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, currentPosition, &hasUnderline, textRange_, (*(void ***)this._nativePointer)[51]);
            __result__.CheckError();
            return hasUnderline;
        }

        /// <summary>
        /// <p> Get the strikethrough presence of the text at the specified position. </p>
        /// </summary>
        /// <param name = "currentPosition"><dd>  <p>The position of the text to inspect.</p> </dd></param>
        /// <param name = "textRange"><dd>  <p>Contains the range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to strikethrough.</p> </dd></param>
        /// <returns><dd>  <p>A Boolean  flag that indicates whether strikethrough is present at the position indicated by <em>currentPosition</em>.</p> </dd></returns>
        /// <doc-id>dd316793</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout::GetStrikethrough([In] unsigned int currentPosition,[Out] BOOL* hasStrikethrough,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout::GetStrikethrough</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool HasStrikethrough(System.Int32 currentPosition, out SharpDX.DirectWrite.TextRange textRange)
        {
            SharpDX.Mathematics.Interop.RawBool hasStrikethrough;
            textRange = default (SharpDX.DirectWrite.TextRange);
            SharpDX.Result __result__;
            fixed (void *textRange_ = &textRange)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, currentPosition, &hasStrikethrough, textRange_, (*(void ***)this._nativePointer)[52]);
            __result__.CheckError();
            return hasStrikethrough;
        }

        /// <summary>
        /// <p> Gets the application-defined drawing effect at the specified text position. </p>
        /// </summary>
        /// <param name = "currentPosition"><dd>  <p>The position of the text whose drawing effect is to be retrieved.</p> </dd></param>
        /// <param name = "textRange"><dd>  <p>Contains the range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to the drawing effect.</p> </dd></param>
        /// <returns><dd>  <p>When this method returns, contains an address of a reference to  the current application-defined drawing effect. Usually this effect is a foreground brush that  is used in glyph drawing.</p> </dd></returns>
        /// <doc-id>dd316732</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout::GetDrawingEffect([In] unsigned int currentPosition,[Out] IUnknown** drawingEffect,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout::GetDrawingEffect</unmanaged-short>
        internal unsafe System.IntPtr GetDrawingEffect_(System.Int32 currentPosition, out SharpDX.DirectWrite.TextRange textRange)
        {
            System.IntPtr drawingEffect;
            textRange = default (SharpDX.DirectWrite.TextRange);
            SharpDX.Result __result__;
            fixed (void *textRange_ = &textRange)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, currentPosition, &drawingEffect, textRange_, (*(void ***)this._nativePointer)[53]);
            __result__.CheckError();
            return drawingEffect;
        }

        /// <summary>
        /// <p> Gets the inline object at the specified position. </p>
        /// </summary>
        /// <param name = "currentPosition"><dd>  <p>The specified text position.</p> </dd></param>
        /// <param name = "textRange"><dd>  <p>The range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to the inline object.</p> </dd></param>
        /// <returns><dd>  <p>Contains the application-defined inline object.</p> </dd></returns>
        /// <doc-id>dd316758</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout::GetInlineObject([In] unsigned int currentPosition,[Out] IDWriteInlineObject** inlineObject,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout::GetInlineObject</unmanaged-short>
        public unsafe SharpDX.DirectWrite.InlineObject GetInlineObject(System.Int32 currentPosition, out SharpDX.DirectWrite.TextRange textRange)
        {
            SharpDX.DirectWrite.InlineObject inlineObject;
            System.IntPtr inlineObject_ = System.IntPtr.Zero;
            textRange = default (SharpDX.DirectWrite.TextRange);
            SharpDX.Result __result__;
            fixed (void *textRange_ = &textRange)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, currentPosition, &inlineObject_, textRange_, (*(void ***)this._nativePointer)[54]);
            if (inlineObject_ != System.IntPtr.Zero)
                inlineObject = new SharpDX.DirectWrite.InlineObjectNative(inlineObject_);
            else
                inlineObject = null;
            __result__.CheckError();
            return inlineObject;
        }

        /// <summary>
        /// <p> Gets the typography setting of the text at the specified position. </p>
        /// </summary>
        /// <param name = "currentPosition"><dd>  <p>The position of the text to inspect.</p> </dd></param>
        /// <param name = "textRange"><dd>  <p>The range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to the typography.</p> </dd></param>
        /// <returns><dd>  <p>When this method returns, contains an address of a  reference to the current typography setting.</p> </dd></returns>
        /// <doc-id>dd371459</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout::GetTypography([In] unsigned int currentPosition,[Out] IDWriteTypography** typography,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout::GetTypography</unmanaged-short>
        public unsafe SharpDX.DirectWrite.Typography GetTypography(System.Int32 currentPosition, out SharpDX.DirectWrite.TextRange textRange)
        {
            SharpDX.DirectWrite.Typography typography;
            System.IntPtr typography_ = System.IntPtr.Zero;
            textRange = default (SharpDX.DirectWrite.TextRange);
            SharpDX.Result __result__;
            fixed (void *textRange_ = &textRange)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, currentPosition, &typography_, textRange_, (*(void ***)this._nativePointer)[55]);
            if (typography_ != System.IntPtr.Zero)
                typography = new SharpDX.DirectWrite.Typography(typography_);
            else
                typography = null;
            __result__.CheckError();
            return typography;
        }

        /// <summary>
        /// <p> Gets the length of the locale name of the text at the specified position. </p>
        /// </summary>
        /// <param name = "currentPosition"><dd>  <p>The position of the text to inspect.</p> </dd></param>
        /// <param name = "nameLength"><dd>  <p>Size of the character array, in character count, not including the terminated <strong><c>null</c></strong> character.</p> </dd></param>
        /// <param name = "textRange"><dd>  <p>The range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to the locale name.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd316771</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout::GetLocaleNameLength([In] unsigned int currentPosition,[Out] unsigned int* nameLength,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout::GetLocaleNameLength</unmanaged-short>
        internal unsafe void GetLocaleNameLength(System.Int32 currentPosition, out System.Int32 nameLength, out SharpDX.DirectWrite.TextRange textRange)
        {
            textRange = default (SharpDX.DirectWrite.TextRange);
            SharpDX.Result __result__;
            fixed (void *textRange_ = &textRange)
                fixed (void *nameLength_ = &nameLength)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, currentPosition, nameLength_, textRange_, (*(void ***)this._nativePointer)[56]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Gets the locale name of the text at the specified position. </p>
        /// </summary>
        /// <param name = "currentPosition"><dd>  <p>The position of the text to inspect.</p> </dd></param>
        /// <param name = "localeName"><dd>  <p>When this method returns, contains the character array receiving the current locale name.</p> </dd></param>
        /// <param name = "nameSize"><dd>  <p>Size of the character array, in character count, including the terminated <strong><c>null</c></strong> character.</p> </dd></param>
        /// <param name = "textRange"><dd>  <p>The range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to the locale name.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd316767</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout::GetLocaleName([In] unsigned int currentPosition,[Out, Buffer] wchar_t* localeName,[In] unsigned int nameSize,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout::GetLocaleName</unmanaged-short>
        internal unsafe void GetLocaleName(System.Int32 currentPosition, System.IntPtr localeName, System.Int32 nameSize, out SharpDX.DirectWrite.TextRange textRange)
        {
            textRange = default (SharpDX.DirectWrite.TextRange);
            SharpDX.Result __result__;
            fixed (void *textRange_ = &textRange)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, currentPosition, (void *)localeName, nameSize, textRange_, (*(void ***)this._nativePointer)[57]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Draws text using the specified client drawing context.</p>
        /// </summary>
        /// <param name = "clientDrawingContext"><dd>  <p>An application-defined drawing context. </p> </dd></param>
        /// <param name = "renderer"><dd>  <p>Pointer to the set of callback functions used to draw parts of a text string.</p> </dd></param>
        /// <param name = "originX"><dd>  <p>The x-coordinate of the layout's left side.</p> </dd></param>
        /// <param name = "originY"><dd>  <p>The y-coordinate of the layout's top side.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>To draw text with this method, a <em>textLayout</em> object needs to be created by the application using <strong>IDWriteFactory::CreateTextLayout</strong>. </p><p>After the <em>textLayout</em> object is obtained, the application calls the  <strong>IDWriteTextLayout::Draw</strong> method  to draw the text, decorations, and inline objects. The actual drawing is done through the callback interface passed in as the <em>textRenderer</em> argument; there, the corresponding <strong>DrawGlyphRun</strong> API is called. </p><p>If you set a vertical text reading direction on <see cref = "SharpDX.DirectWrite.TextLayout"/> via SetReadingDirection with DWRITE_READING_DIRECTION_TOP_TO_BOTTOM (or bottom to top), then you must pass an interface that implements <see cref = "SharpDX.DirectWrite.TextRenderer1"/>. Otherwise you get the error DWRITE_E_TEXTRENDERERINCOMPATIBLE because the original <see cref = "SharpDX.DirectWrite.TextRenderer"/> interface only supported horizontal text.</p>
        /// </remarks>
        /// <doc-id>dd316726</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout::Draw([In, Optional] void* clientDrawingContext,[In] IDWriteTextRenderer* renderer,[In] float originX,[In] float originY)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout::Draw</unmanaged-short>
        public unsafe void Draw(System.IntPtr clientDrawingContext, SharpDX.DirectWrite.TextRenderer renderer, System.Single originX, System.Single originY)
        {
            System.IntPtr renderer_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            renderer_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.TextRenderer>(renderer);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)clientDrawingContext, (void *)renderer_, originX, originY, (*(void ***)this._nativePointer)[58]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Retrieves the information about each individual text line of the  text string. </p>
        /// </summary>
        /// <param name = "lineMetrics"><dd>  <p>When this method returns, contains a reference to an array of structures containing various calculated length values of individual text lines.</p> </dd></param>
        /// <param name = "maxLineCount"><dd>  <p>The maximum size of the <em>lineMetrics</em> array.</p> </dd></param>
        /// <param name = "actualLineCount"><dd>  <p>When this method returns, contains the actual size of the <em>lineMetrics</em> array that is needed.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p> If <em>maxLineCount</em> is not large enough E_NOT_SUFFICIENT_BUFFER, which is equivalent to HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER), is returned and <em>*actualLineCount</em> is set to the number of lines needed. </p>
        /// </remarks>
        /// <doc-id>dd316763</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout::GetLineMetrics([Out, Buffer, Optional] DWRITE_LINE_METRICS* lineMetrics,[In] unsigned int maxLineCount,[Out] unsigned int* actualLineCount)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout::GetLineMetrics</unmanaged-short>
        internal unsafe SharpDX.Result GetLineMetrics(SharpDX.DirectWrite.LineMetrics[] lineMetrics, System.Int32 maxLineCount, out System.Int32 actualLineCount)
        {
            SharpDX.Result __result__;
            fixed (void *actualLineCount_ = &actualLineCount)
                fixed (void *lineMetrics_ = lineMetrics)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, lineMetrics_, maxLineCount, actualLineCount_, (*(void ***)this._nativePointer)[59]);
            return __result__;
        }

        /// <summary>
        /// <p> Retrieves overall metrics for the formatted string. </p>
        /// </summary>
        /// <param name = "textMetrics"><dd>  <p>When this method returns, contains the measured distances of text and associated content after being formatted.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd316785</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout::GetMetrics([Out] DWRITE_TEXT_METRICS* textMetrics)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout::GetMetrics</unmanaged-short>
        internal unsafe void GetMetrics(out SharpDX.DirectWrite.TextMetrics textMetrics)
        {
            textMetrics = default (SharpDX.DirectWrite.TextMetrics);
            SharpDX.Result __result__;
            fixed (void *textMetrics_ = &textMetrics)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, textMetrics_, (*(void ***)this._nativePointer)[60]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Returns the overhangs (in DIPs) of the layout and all objects contained in it, including text glyphs and inline objects.</p>
        /// </summary>
        /// <param name = "overhangs"><dd>  <p>Overshoots of visible extents (in DIPs) outside the layout.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Underlines and strikethroughs do not contribute to the black box determination, since these are actually drawn by the renderer, which is allowed to draw them in any variety of styles.</p>
        /// </remarks>
        /// <doc-id>dd316790</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout::GetOverhangMetrics([Out] DWRITE_OVERHANG_METRICS* overhangs)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout::GetOverhangMetrics</unmanaged-short>
        internal unsafe void GetOverhangMetrics(out SharpDX.DirectWrite.OverhangMetrics overhangs)
        {
            overhangs = default (SharpDX.DirectWrite.OverhangMetrics);
            SharpDX.Result __result__;
            fixed (void *overhangs_ = &overhangs)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, overhangs_, (*(void ***)this._nativePointer)[61]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Retrieves logical properties and measurements of each glyph cluster. </p>
        /// </summary>
        /// <param name = "clusterMetrics"><dd>  <p>When this method returns, contains metrics, such as line-break or total advance width, for a glyph cluster.</p> </dd></param>
        /// <param name = "maxClusterCount"><dd>  <p>The maximum size of the <em>clusterMetrics</em> array.</p> </dd></param>
        /// <param name = "actualClusterCount"><dd>  <p>When this method returns, contains the actual size of the <em>clusterMetrics</em> array that is needed.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p> If <em>maxClusterCount</em> is not large enough, then E_NOT_SUFFICIENT_BUFFER, which is equivalent to HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER), is returned and <em>actualClusterCount</em> is set to the number of clusters needed. </p>
        /// </remarks>
        /// <doc-id>dd316729</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout::GetClusterMetrics([Out, Buffer, Optional] DWRITE_CLUSTER_METRICS* clusterMetrics,[In] unsigned int maxClusterCount,[Out] unsigned int* actualClusterCount)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout::GetClusterMetrics</unmanaged-short>
        internal unsafe SharpDX.Result GetClusterMetrics(SharpDX.DirectWrite.ClusterMetrics[] clusterMetrics, System.Int32 maxClusterCount, out System.Int32 actualClusterCount)
        {
            SharpDX.Result __result__;
            fixed (void *actualClusterCount_ = &actualClusterCount)
                fixed (void *clusterMetrics_ = clusterMetrics)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, clusterMetrics_, maxClusterCount, actualClusterCount_, (*(void ***)this._nativePointer)[62]);
            return __result__;
        }

        /// <summary>
        /// <p>Determines the minimum possible width the layout can be set to without emergency breaking between the characters of whole words occurring.</p>
        /// </summary>
        /// <returns><dd>  <p>Minimum width.</p> </dd></returns>
        /// <doc-id>dd316723</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout::DetermineMinWidth([Out] float* minWidth)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout::DetermineMinWidth</unmanaged-short>
        public unsafe System.Single DetermineMinWidth()
        {
            System.Single minWidth;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &minWidth, (*(void ***)this._nativePointer)[63]);
            __result__.CheckError();
            return minWidth;
        }

        /// <summary>
        /// <p> The application calls this function passing in a specific pixel location relative to the top-left location of the layout box and obtains the information about the correspondent hit-test metrics of the text string where the hit-test has occurred. When the specified pixel location is outside the text string, the function sets the output value <em>*isInside</em> to <strong><see cref = "SharpDX.Result.False"/></strong>. </p>
        /// </summary>
        /// <param name = "pointX"><dd>  <p>The pixel location X to hit-test, relative to the top-left location of the layout box.</p> </dd></param>
        /// <param name = "pointY"><dd>  <p>The pixel location Y to hit-test, relative to the top-left location of the layout box.</p> </dd></param>
        /// <param name = "isTrailingHit"><dd>  <p>An output flag that indicates whether the hit-test location is at the leading or the trailing side of the character. When the output <em>*isInside</em> value is set to <strong><see cref = "SharpDX.Result.False"/></strong>, this value is set according to the output <em>hitTestMetrics-&gt;textPosition</em> value to represent the edge closest to the hit-test location.</p> </dd></param>
        /// <param name = "isInside"><dd>  <p>An output flag that indicates whether the hit-test location is inside the text string. When <strong><see cref = "SharpDX.Result.False"/></strong>, the position nearest the text's edge is returned.</p> </dd></param>
        /// <returns><dd>  <p>The output geometry fully enclosing the hit-test location. When the output <em>*isInside</em> value is set to <strong><see cref = "SharpDX.Result.False"/></strong>, this structure represents the geometry enclosing the edge closest to the hit-test location.</p> </dd></returns>
        /// <doc-id>dd371464</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout::HitTestPoint([In] float pointX,[In] float pointY,[Out] BOOL* isTrailingHit,[Out] BOOL* isInside,[Out] DWRITE_HIT_TEST_METRICS* hitTestMetrics)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout::HitTestPoint</unmanaged-short>
        public unsafe SharpDX.DirectWrite.HitTestMetrics HitTestPoint(System.Single pointX, System.Single pointY, out SharpDX.Mathematics.Interop.RawBool isTrailingHit, out SharpDX.Mathematics.Interop.RawBool isInside)
        {
            isTrailingHit = default (SharpDX.Mathematics.Interop.RawBool);
            isInside = default (SharpDX.Mathematics.Interop.RawBool);
            SharpDX.DirectWrite.HitTestMetrics hitTestMetrics;
            SharpDX.Result __result__;
            fixed (void *isInside_ = &isInside)
                fixed (void *isTrailingHit_ = &isTrailingHit)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, pointX, pointY, isTrailingHit_, isInside_, &hitTestMetrics, (*(void ***)this._nativePointer)[64]);
            __result__.CheckError();
            return hitTestMetrics;
        }

        /// <summary>
        /// <p> The application calls this function to get the pixel location relative to the top-left of the layout box given the text position and the logical side of the position. This function is normally used as part of caret positioning of text where the caret is drawn at the location corresponding to the current text editing position. It may also be used as a way to programmatically obtain the geometry of a particular text position in UI automation. </p>
        /// </summary>
        /// <param name = "textPosition"><dd>  <p>The text position used to get the pixel location.</p> </dd></param>
        /// <param name = "isTrailingHit"><dd>  <p>A Boolean flag that indicates whether the pixel location is of the leading or the trailing side of the specified text position.</p> </dd></param>
        /// <param name = "ointXRef"><dd>  <p>When this method returns, contains the output pixel location X, relative to the top-left location of the layout box.</p> </dd></param>
        /// <param name = "ointYRef"><dd>  <p>When this method returns, contains the output pixel location Y, relative to the top-left location of the layout box.</p> </dd></param>
        /// <returns><dd>  <p>When this method returns, contains the output geometry fully enclosing the specified text position.</p> </dd></returns>
        /// <doc-id>dd371469</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout::HitTestTextPosition([In] unsigned int textPosition,[In] BOOL isTrailingHit,[Out] float* pointX,[Out] float* pointY,[Out] DWRITE_HIT_TEST_METRICS* hitTestMetrics)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout::HitTestTextPosition</unmanaged-short>
        public unsafe SharpDX.DirectWrite.HitTestMetrics HitTestTextPosition(System.Int32 textPosition, SharpDX.Mathematics.Interop.RawBool isTrailingHit, out System.Single ointXRef, out System.Single ointYRef)
        {
            SharpDX.DirectWrite.HitTestMetrics hitTestMetrics;
            SharpDX.Result __result__;
            fixed (void *ointYRef_ = &ointYRef)
                fixed (void *ointXRef_ = &ointXRef)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, textPosition, isTrailingHit, ointXRef_, ointYRef_, &hitTestMetrics, (*(void ***)this._nativePointer)[65]);
            __result__.CheckError();
            return hitTestMetrics;
        }

        /// <summary>
        /// <p> The application calls this function to get a set of hit-test metrics corresponding to a range of text positions. One of the main usages is to implement highlight selection of the text string. The function returns E_NOT_SUFFICIENT_BUFFER, which is equivalent to HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER), when the buffer size of hitTestMetrics is too small to hold all the regions calculated by the function. In this situation, the function sets the output value *actualHitTestMetricsCount to the number of geometries calculated. The application is responsible for allocating a new buffer of greater size and calling the function again. A good value to use as an initial value for maxHitTestMetricsCount may be calculated from the following equation: maxHitTestMetricsCount = lineCount * maxBidiReorderingDepth where lineCount is obtained from the value of the output argument *actualLineCount (from the function <strong><see cref = "SharpDX.DirectWrite.TextLayout"/></strong>::GetLineLengths), and the maxBidiReorderingDepth value from the <strong><see cref = "SharpDX.DirectWrite.TextMetrics"/></strong> structure of the output argument *textMetrics (from the function <strong><see cref = "SharpDX.DirectWrite.Factory"/></strong>::<strong>CreateTextLayout</strong>). </p>
        /// </summary>
        /// <param name = "textPosition">No documentation.</param>
        /// <param name = "textLength">No documentation.</param>
        /// <param name = "originX">No documentation.</param>
        /// <param name = "originY">No documentation.</param>
        /// <param name = "hitTestMetrics">No documentation.</param>
        /// <param name = "maxHitTestMetricsCount">No documentation.</param>
        /// <param name = "actualHitTestMetricsCount">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371473</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout::HitTestTextRange([In] unsigned int textPosition,[In] unsigned int textLength,[In] float originX,[In] float originY,[Out, Buffer, Optional] DWRITE_HIT_TEST_METRICS* hitTestMetrics,[In] unsigned int maxHitTestMetricsCount,[Out] unsigned int* actualHitTestMetricsCount)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout::HitTestTextRange</unmanaged-short>
        internal unsafe SharpDX.Result HitTestTextRange(System.Int32 textPosition, System.Int32 textLength, System.Single originX, System.Single originY, SharpDX.DirectWrite.HitTestMetrics[] hitTestMetrics, System.Int32 maxHitTestMetricsCount, out System.Int32 actualHitTestMetricsCount)
        {
            SharpDX.Result __result__;
            fixed (void *actualHitTestMetricsCount_ = &actualHitTestMetricsCount)
                fixed (void *hitTestMetrics_ = hitTestMetrics)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, textPosition, textLength, originX, originY, hitTestMetrics_, maxHitTestMetricsCount, actualHitTestMetricsCount_, (*(void ***)this._nativePointer)[66]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("9064D822-80A7-465C-A986-DF65F78B8FEB")]
    public partial class TextLayout1 : SharpDX.DirectWrite.TextLayout
    {
        public TextLayout1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator TextLayout1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new TextLayout1(nativePtr);
        /// <summary>
        /// <p>Enables or disables pair-kerning on a given text range.</p>
        /// </summary>
        /// <param name = "isPairKerningEnabled"><dd>  <p>The flag that indicates whether text is pair-kerned.</p> </dd></param>
        /// <param name = "textRange"><dd>  <p>The text range to which the change applies.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh780442</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout1::SetPairKerning([In] BOOL isPairKerningEnabled,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout1::SetPairKerning</unmanaged-short>
        public unsafe void SetPairKerning(SharpDX.Mathematics.Interop.RawBool isPairKerningEnabled, SharpDX.DirectWrite.TextRange textRange)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, isPairKerningEnabled, textRange, (*(void ***)this._nativePointer)[67]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets whether or not pair-kerning is enabled at given position.</p>
        /// </summary>
        /// <param name = "currentPosition"><dd>  <p>The current text position.</p> </dd></param>
        /// <param name = "isPairKerningEnabled"><dd>  <p>The flag that indicates whether text is pair-kerned.</p> </dd></param>
        /// <param name = "textRange"><dd>  <p>The position range of the current format.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh780440</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout1::GetPairKerning([In] unsigned int currentPosition,[Out] BOOL* isPairKerningEnabled,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout1::GetPairKerning</unmanaged-short>
        public unsafe void GetPairKerning(System.Int32 currentPosition, out SharpDX.Mathematics.Interop.RawBool isPairKerningEnabled, out SharpDX.DirectWrite.TextRange textRange)
        {
            isPairKerningEnabled = default (SharpDX.Mathematics.Interop.RawBool);
            textRange = default (SharpDX.DirectWrite.TextRange);
            SharpDX.Result __result__;
            fixed (void *textRange_ = &textRange)
                fixed (void *isPairKerningEnabled_ = &isPairKerningEnabled)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, currentPosition, isPairKerningEnabled_, textRange_, (*(void ***)this._nativePointer)[68]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the spacing between characters.</p>
        /// </summary>
        /// <param name = "leadingSpacing"><dd>  <p>The spacing before each character, in reading order.</p> </dd></param>
        /// <param name = "trailingSpacing"><dd>  <p>The spacing after each character, in reading order.</p> </dd></param>
        /// <param name = "minimumAdvanceWidth"><dd>  <p>The minimum advance of each character, to prevent characters from becoming too thin or zero-width. This must be zero or greater.</p> </dd></param>
        /// <param name = "textRange"><dd>  <p>Text range to which this change applies.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh780441</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout1::SetCharacterSpacing([In] float leadingSpacing,[In] float trailingSpacing,[In] float minimumAdvanceWidth,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout1::SetCharacterSpacing</unmanaged-short>
        public unsafe void SetCharacterSpacing(System.Single leadingSpacing, System.Single trailingSpacing, System.Single minimumAdvanceWidth, SharpDX.DirectWrite.TextRange textRange)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, leadingSpacing, trailingSpacing, minimumAdvanceWidth, textRange, (*(void ***)this._nativePointer)[69]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the spacing between characters.</p>
        /// </summary>
        /// <param name = "currentPosition"><dd>  <p>The current text position.</p> </dd></param>
        /// <param name = "leadingSpacing"><dd>  <p>The spacing before each character, in reading order.</p> </dd></param>
        /// <param name = "trailingSpacing"><dd>  <p>The spacing after each character, in reading order.</p> </dd></param>
        /// <param name = "minimumAdvanceWidth"><dd>  <p>The minimum advance of each character, to prevent characters from becoming too thin or zero-width. This must be zero or greater.</p> </dd></param>
        /// <param name = "textRange"><dd>  <p>The position range of the current format.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh780439</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout1::GetCharacterSpacing([In] unsigned int currentPosition,[Out] float* leadingSpacing,[Out] float* trailingSpacing,[Out] float* minimumAdvanceWidth,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout1::GetCharacterSpacing</unmanaged-short>
        public unsafe void GetCharacterSpacing(System.Int32 currentPosition, out System.Single leadingSpacing, out System.Single trailingSpacing, out System.Single minimumAdvanceWidth, out SharpDX.DirectWrite.TextRange textRange)
        {
            textRange = default (SharpDX.DirectWrite.TextRange);
            SharpDX.Result __result__;
            fixed (void *textRange_ = &textRange)
                fixed (void *minimumAdvanceWidth_ = &minimumAdvanceWidth)
                    fixed (void *trailingSpacing_ = &trailingSpacing)
                        fixed (void *leadingSpacing_ = &leadingSpacing)
                            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, currentPosition, leadingSpacing_, trailingSpacing_, minimumAdvanceWidth_, textRange_, (*(void ***)this._nativePointer)[70]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("1093C18F-8D5E-43F0-B064-0917311B525E")]
    public partial class TextLayout2 : SharpDX.DirectWrite.TextLayout1
    {
        public TextLayout2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator TextLayout2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new TextLayout2(nativePtr);
        /// <summary>
        /// <p> Retrieves overall metrics for the formatted string. </p>
        /// </summary>
        /// <doc-id>dn280492</doc-id>
        /// <unmanaged>GetMetrics</unmanaged>
        /// <unmanaged-short>GetMetrics</unmanaged-short>
        public SharpDX.DirectWrite.TextMetrics1 Metrics
        {
            get
            {
                GetMetrics(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Get or sets the preferred orientation of glyphs when using a vertical reading direction.</p>
        /// </summary>
        /// <doc-id>dn482048</doc-id>
        /// <unmanaged>GetVerticalGlyphOrientation / SetVerticalGlyphOrientation</unmanaged>
        /// <unmanaged-short>GetVerticalGlyphOrientation</unmanaged-short>
        public SharpDX.DirectWrite.VerticalGlyphOrientation VerticalGlyphOrientation
        {
            get => GetVerticalGlyphOrientation();
            set => SetVerticalGlyphOrientation(value);
        }

        /// <summary>
        /// <p>Get or sets whether or not the last word on the last line is wrapped.</p>
        /// </summary>
        /// <doc-id>dn482046</doc-id>
        /// <unmanaged>GetLastLineWrapping / SetLastLineWrapping</unmanaged>
        /// <unmanaged-short>GetLastLineWrapping</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool LastLineWrapping
        {
            get => GetLastLineWrapping();
            set => SetLastLineWrapping(value);
        }

        /// <summary>
        /// <p>Get or sets how the glyphs align to the edges the margin.  </p>
        /// </summary>
        /// <doc-id>dn482047</doc-id>
        /// <unmanaged>GetOpticalAlignment / SetOpticalAlignment</unmanaged>
        /// <unmanaged-short>GetOpticalAlignment</unmanaged-short>
        public SharpDX.DirectWrite.OptimizationIcalAlignment OpticalAlignment
        {
            get => GetOpticalAlignment();
            set => SetOpticalAlignment(value);
        }

        /// <summary>
        /// <p>Get or sets the current font fallback object.  </p>
        /// </summary>
        /// <doc-id>dn482045</doc-id>
        /// <unmanaged>GetFontFallback / SetFontFallback</unmanaged>
        /// <unmanaged-short>GetFontFallback</unmanaged-short>
        public SharpDX.DirectWrite.FontFallback FontFallback
        {
            get
            {
                GetFontFallback(out var __output__);
                return __output__;
            }

            set => SetFontFallback(value);
        }

        /// <summary>
        /// <p> Retrieves overall metrics for the formatted string. </p>
        /// </summary>
        /// <param name = "textMetrics"><dd>  <p>When this method returns, contains the measured distances of text and associated content after being formatted.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn280492</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout2::GetMetrics([Out] DWRITE_TEXT_METRICS1* textMetrics)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout2::GetMetrics</unmanaged-short>
        internal unsafe void GetMetrics(out SharpDX.DirectWrite.TextMetrics1 textMetrics)
        {
            textMetrics = default (SharpDX.DirectWrite.TextMetrics1);
            SharpDX.Result __result__;
            fixed (void *textMetrics_ = &textMetrics)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, textMetrics_, (*(void ***)this._nativePointer)[71]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Set the preferred orientation of glyphs when using a vertical reading direction.</p>
        /// </summary>
        /// <param name = "glyphOrientation"><dd> <p>Preferred glyph orientation.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn482052</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout2::SetVerticalGlyphOrientation([In] DWRITE_VERTICAL_GLYPH_ORIENTATION glyphOrientation)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout2::SetVerticalGlyphOrientation</unmanaged-short>
        internal unsafe void SetVerticalGlyphOrientation(SharpDX.DirectWrite.VerticalGlyphOrientation glyphOrientation)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)glyphOrientation), (*(void ***)this._nativePointer)[72]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Get the preferred orientation of glyphs when using a vertical reading direction.</p>
        /// </summary>
        /// <returns>No documentation.</returns>
        /// <doc-id>dn482048</doc-id>
        /// <unmanaged>DWRITE_VERTICAL_GLYPH_ORIENTATION IDWriteTextLayout2::GetVerticalGlyphOrientation()</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout2::GetVerticalGlyphOrientation</unmanaged-short>
        internal unsafe SharpDX.DirectWrite.VerticalGlyphOrientation GetVerticalGlyphOrientation()
        {
            SharpDX.DirectWrite.VerticalGlyphOrientation __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirectWriteVerticalGlyphOrientation(this._nativePointer, (*(void ***)this._nativePointer)[73]);
            return __result__;
        }

        /// <summary>
        /// <p>Set whether or not the last word on the last line is wrapped. </p>
        /// </summary>
        /// <param name = "isLastLineWrappingEnabled"><dd> <p>Line wrapping option.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn482050</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout2::SetLastLineWrapping([In] BOOL isLastLineWrappingEnabled)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout2::SetLastLineWrapping</unmanaged-short>
        internal unsafe void SetLastLineWrapping(SharpDX.Mathematics.Interop.RawBool isLastLineWrappingEnabled)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, isLastLineWrappingEnabled, (*(void ***)this._nativePointer)[74]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Get whether or not the last word on the last line is wrapped.</p>
        /// </summary>
        /// <returns>No documentation.</returns>
        /// <doc-id>dn482046</doc-id>
        /// <unmanaged>BOOL IDWriteTextLayout2::GetLastLineWrapping()</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout2::GetLastLineWrapping</unmanaged-short>
        internal unsafe SharpDX.Mathematics.Interop.RawBool GetLastLineWrapping()
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, (*(void ***)this._nativePointer)[75]);
            return __result__;
        }

        /// <summary>
        /// <p>Set how the glyphs align to the edges the margin.  Default behavior is to align glyphs using their default glyphs metrics, which include side bearings. </p>
        /// </summary>
        /// <param name = "opticalAlignment"><dd> <p>Optical alignment option.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn482051</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout2::SetOpticalAlignment([In] DWRITE_OPTICAL_ALIGNMENT opticalAlignment)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout2::SetOpticalAlignment</unmanaged-short>
        internal unsafe void SetOpticalAlignment(SharpDX.DirectWrite.OptimizationIcalAlignment opticalAlignment)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)opticalAlignment), (*(void ***)this._nativePointer)[76]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Get how the glyphs align to the edges the margin.  </p>
        /// </summary>
        /// <returns>No documentation.</returns>
        /// <doc-id>dn482047</doc-id>
        /// <unmanaged>DWRITE_OPTICAL_ALIGNMENT IDWriteTextLayout2::GetOpticalAlignment()</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout2::GetOpticalAlignment</unmanaged-short>
        internal unsafe SharpDX.DirectWrite.OptimizationIcalAlignment GetOpticalAlignment()
        {
            SharpDX.DirectWrite.OptimizationIcalAlignment __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirectWriteOptimizationIcalAlignment(this._nativePointer, (*(void ***)this._nativePointer)[77]);
            return __result__;
        }

        /// <summary>
        /// <p>Apply a custom font fallback onto layout. If none is specified, the layout uses the system fallback list. </p>
        /// </summary>
        /// <param name = "fontFallback"><dd> <p> Custom font fallback created from <strong>IDWriteFontFallbackBuilder::CreateFontFallback</strong> or <strong>IDWriteFactory2::GetSystemFontFallback</strong>. </p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn482049</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout2::SetFontFallback([In] IDWriteFontFallback* fontFallback)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout2::SetFontFallback</unmanaged-short>
        internal unsafe void SetFontFallback(SharpDX.DirectWrite.FontFallback fontFallback)
        {
            System.IntPtr fontFallback_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fontFallback_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.FontFallback>(fontFallback);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)fontFallback_, (*(void ***)this._nativePointer)[78]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Get the current font fallback object.  </p>
        /// </summary>
        /// <param name = "fontFallback"><dd> <p>The current font fallback object.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn482045</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout2::GetFontFallback([Out] IDWriteFontFallback** fontFallback)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout2::GetFontFallback</unmanaged-short>
        internal unsafe void GetFontFallback(out SharpDX.DirectWrite.FontFallback fontFallback)
        {
            System.IntPtr fontFallback_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &fontFallback_, (*(void ***)this._nativePointer)[79]);
            if (fontFallback_ != System.IntPtr.Zero)
                fontFallback = new SharpDX.DirectWrite.FontFallback(fontFallback_);
            else
                fontFallback = null;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("07DDCD52-020E-4DE8-AC33-6C953D83F92D")]
    public partial class TextLayout3 : SharpDX.DirectWrite.TextLayout2
    {
        public TextLayout3(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator TextLayout3(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new TextLayout3(nativePtr);
        /// <summary>
        /// <p>Gets or sets line spacing information.</p>
        /// </summary>
        /// <doc-id>dn900407</doc-id>
        /// <unmanaged>GetLineSpacing / SetLineSpacing</unmanaged>
        /// <unmanaged-short>GetLineSpacing</unmanaged-short>
        public SharpDX.DirectWrite.LineSpacing LineSpacing
        {
            get
            {
                GetLineSpacing(out var __output__);
                return __output__;
            }

            set => SetLineSpacing(ref value);
        }

        /// <summary>
        /// <p>Invalidates the layout, forcing layout to remeasure before calling the    metrics or drawing functions. This is useful if the locality of a font     changes, and layout should be redrawn, or if the size of a client     implemented <see cref = "SharpDX.DirectWrite.InlineObject"/> changes. </p>
        /// </summary>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn900408</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout3::InvalidateLayout()</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout3::InvalidateLayout</unmanaged-short>
        public unsafe void InvalidateLayout()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[80]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Set line spacing.</p>
        /// </summary>
        /// <param name = "lineSpacingOptions"><dd> <p>How to manage space between lines.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn900409</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout3::SetLineSpacing([In] const DWRITE_LINE_SPACING* lineSpacingOptions)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout3::SetLineSpacing</unmanaged-short>
        internal unsafe void SetLineSpacing(ref SharpDX.DirectWrite.LineSpacing lineSpacingOptions)
        {
            SharpDX.Result __result__;
            fixed (void *lineSpacingOptions_ = &lineSpacingOptions)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, lineSpacingOptions_, (*(void ***)this._nativePointer)[81]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets line spacing information.</p>
        /// </summary>
        /// <param name = "lineSpacingOptions"><dd> <p>How to manage space between lines.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn900407</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout3::GetLineSpacing([Out] DWRITE_LINE_SPACING* lineSpacingOptions)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout3::GetLineSpacing</unmanaged-short>
        internal unsafe void GetLineSpacing(out SharpDX.DirectWrite.LineSpacing lineSpacingOptions)
        {
            lineSpacingOptions = default (SharpDX.DirectWrite.LineSpacing);
            SharpDX.Result __result__;
            fixed (void *lineSpacingOptions_ = &lineSpacingOptions)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, lineSpacingOptions_, (*(void ***)this._nativePointer)[82]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves properties of each line.</p>
        /// </summary>
        /// <param name = "lineMetrics"><dd> <p>The array to fill with line information.</p> </dd></param>
        /// <param name = "maxLineCount"><dd> <p>The maximum size of the lineMetrics array.</p> </dd></param>
        /// <param name = "actualLineCount"><dd> <p>The actual size of the lineMetrics     array that is needed.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p> If maxLineCount is not large enough E_NOT_SUFFICIENT_BUFFER,    which is equivalent to HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER),   is returned and actualLineCount is set to the number of lines    needed.</p>
        /// </remarks>
        /// <doc-id>dn900406</doc-id>
        /// <unmanaged>HRESULT IDWriteTextLayout3::GetLineMetrics([Out, Buffer, Optional] DWRITE_LINE_METRICS1* lineMetrics,[In] unsigned int maxLineCount,[Out] unsigned int* actualLineCount)</unmanaged>
        /// <unmanaged-short>IDWriteTextLayout3::GetLineMetrics</unmanaged-short>
        public unsafe void GetLineMetrics(SharpDX.DirectWrite.LineMetrics1[] lineMetrics, System.Int32 maxLineCount, out System.Int32 actualLineCount)
        {
            SharpDX.Result __result__;
            fixed (void *actualLineCount_ = &actualLineCount)
                fixed (void *lineMetrics_ = lineMetrics)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, lineMetrics_, maxLineCount, actualLineCount_, (*(void ***)this._nativePointer)[83]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("ef8a8135-5cc6-45fe-8825-c5a0724eb819")]
    public partial interface TextRenderer : SharpDX.DirectWrite.PixelSnapping
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("D3E0E934-22A0-427E-AAE4-7D9574B59DB1")]
    public partial interface TextRenderer1 : SharpDX.DirectWrite.TextRenderer
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("55f1112b-1dc2-4b3c-9541-f46894ed85b6")]
    public partial class Typography : SharpDX.ComObject
    {
        public Typography(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Typography(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Typography(nativePtr);
        /// <summary>
        /// <p> Gets the number of OpenType font features for the current font. </p>
        /// </summary>
        /// <remarks>
        /// <p>A single run of text can be associated with more than one typographic feature. The <strong><see cref = "SharpDX.DirectWrite.Typography"/></strong> object holds a list of these font features.</p>
        /// </remarks>
        /// <doc-id>dd371549</doc-id>
        /// <unmanaged>GetFontFeatureCount</unmanaged>
        /// <unmanaged-short>GetFontFeatureCount</unmanaged-short>
        public System.Int32 FontFeatureCount
        {
            get => GetFontFeatureCount();
        }

        /// <summary>
        /// <p> Adds an OpenType font feature. </p>
        /// </summary>
        /// <param name = "fontFeature"><dd>  <p>A structure that contains the OpenType name identifier and the execution parameter for the font feature being added.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371545</doc-id>
        /// <unmanaged>HRESULT IDWriteTypography::AddFontFeature([In] DWRITE_FONT_FEATURE fontFeature)</unmanaged>
        /// <unmanaged-short>IDWriteTypography::AddFontFeature</unmanaged-short>
        public unsafe void AddFontFeature(SharpDX.DirectWrite.FontFeature fontFeature)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, fontFeature, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Gets the number of OpenType font features for the current font. </p>
        /// </summary>
        /// <returns><p>The number of font features for the current text format.</p></returns>
        /// <remarks>
        /// <p>A single run of text can be associated with more than one typographic feature. The <strong><see cref = "SharpDX.DirectWrite.Typography"/></strong> object holds a list of these font features.</p>
        /// </remarks>
        /// <doc-id>dd371549</doc-id>
        /// <unmanaged>unsigned int IDWriteTypography::GetFontFeatureCount()</unmanaged>
        /// <unmanaged-short>IDWriteTypography::GetFontFeatureCount</unmanaged-short>
        internal unsafe System.Int32 GetFontFeatureCount()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[4]);
            return __result__;
        }

        /// <summary>
        /// <p> Gets the font feature at the specified index. </p>
        /// </summary>
        /// <param name = "fontFeatureIndex"><dd>  <p>The zero-based index of the font feature to retrieve.</p> </dd></param>
        /// <returns><dd>  <p>When this method returns, contains the font feature which is at the specified index.</p> </dd></returns>
        /// <remarks>
        /// <p>A single run of text can be associated with more than one typographic feature. The <strong><see cref = "SharpDX.DirectWrite.Typography"/></strong> object holds a list of these font features.</p>
        /// </remarks>
        /// <doc-id>dd371546</doc-id>
        /// <unmanaged>HRESULT IDWriteTypography::GetFontFeature([In] unsigned int fontFeatureIndex,[Out] DWRITE_FONT_FEATURE* fontFeature)</unmanaged>
        /// <unmanaged-short>IDWriteTypography::GetFontFeature</unmanaged-short>
        public unsafe SharpDX.DirectWrite.FontFeature GetFontFeature(System.Int32 fontFeatureIndex)
        {
            SharpDX.DirectWrite.FontFeature fontFeature;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, fontFeatureIndex, &fontFeature, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
            return fontFeature;
        }
    }
}
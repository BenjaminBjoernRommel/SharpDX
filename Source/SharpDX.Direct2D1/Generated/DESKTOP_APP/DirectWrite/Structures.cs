// <auto-generated/>

namespace SharpDX.DirectWrite
{
    /// <summary>
    /// <p>The <strong><see cref = "SharpDX.DirectWrite.CaretMetrics"/></strong> structure specifies the metrics for caret placement in a font.</p>
    /// </summary>
    /// <doc-id>jj126258</doc-id>
    /// <unmanaged>DWRITE_CARET_METRICS</unmanaged>
    /// <unmanaged-short>DWRITE_CARET_METRICS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct CaretMetrics
    {
        /// <summary>
        /// <dd> <p>Vertical rise of the caret in font design units. Rise / Run yields the caret angle. Rise = 1 for perfectly upright fonts (non-italic).</p> </dd>
        /// </summary>
        /// <doc-id>jj126258</doc-id>
        /// <unmanaged>slopeRise</unmanaged>
        /// <unmanaged-short>slopeRise</unmanaged-short>
        public System.Int16 SlopeRise;
        /// <summary>
        /// <dd> <p>Horizontal run of the caret in font design units. Rise / Run yields the caret angle. Run = 0 for perfectly upright fonts (non-italic).</p> </dd>
        /// </summary>
        /// <doc-id>jj126258</doc-id>
        /// <unmanaged>slopeRun</unmanaged>
        /// <unmanaged-short>slopeRun</unmanaged-short>
        public System.Int16 SlopeRun;
        /// <summary>
        /// <dd> <p>Horizontal offset of the caret, in font design units, along the baseline for good appearance. Offset = 0 for perfectly upright fonts (non-italic).</p> </dd>
        /// </summary>
        /// <doc-id>jj126258</doc-id>
        /// <unmanaged>offset</unmanaged>
        /// <unmanaged-short>offset</unmanaged-short>
        public System.Int16 Offset;
    }

    /// <summary>
    /// <p>Contains information about a glyph cluster.</p>
    /// </summary>
    /// <doc-id>dd368054</doc-id>
    /// <unmanaged>DWRITE_CLUSTER_METRICS</unmanaged>
    /// <unmanaged-short>DWRITE_CLUSTER_METRICS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Explicit, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct ClusterMetrics
    {
        /// <summary>
        /// <dd> <p>The total advance width of all glyphs in the cluster.</p> </dd>
        /// </summary>
        /// <doc-id>dd368054</doc-id>
        /// <unmanaged>width</unmanaged>
        /// <unmanaged-short>width</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(0)]
        public System.Single Width;
        /// <summary>
        /// <dd> <p>The number of text positions in the cluster.</p> </dd>
        /// </summary>
        /// <doc-id>dd368054</doc-id>
        /// <unmanaged>length</unmanaged>
        /// <unmanaged-short>length</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(4)]
        public System.Int16 Length;
        /// <summary>
        /// <dd> <p>Indicates whether a line can be broken right after the cluster.</p> </dd>
        /// </summary>
        /// <doc-id>dd368054</doc-id>
        /// <unmanaged>canWrapLineAfter</unmanaged>
        /// <unmanaged-short>canWrapLineAfter</unmanaged-short>
        public bool CanWrapLineAfter
        {
            get => 0 != ((_CanWrapLineAfter >> 0) & 1);
            set => this._CanWrapLineAfter = (System.Int16)((this._CanWrapLineAfter & ~(1 << 0)) | (((value ? 1 : 0) & 1) << 0));
        }

        [System.Runtime.InteropServices.FieldOffset(6)]
        internal System.Int16 _CanWrapLineAfter;
        /// <summary>
        /// <dd> <p>Indicates whether the cluster corresponds to a whitespace character.</p> </dd>
        /// </summary>
        /// <doc-id>dd368054</doc-id>
        /// <unmanaged>isWhitespace</unmanaged>
        /// <unmanaged-short>isWhitespace</unmanaged-short>
        public bool IsWhitespace
        {
            get => 0 != ((_IsWhitespace >> 1) & 1);
            set => this._IsWhitespace = (System.Int16)((this._IsWhitespace & ~(1 << 1)) | (((value ? 1 : 0) & 1) << 1));
        }

        [System.Runtime.InteropServices.FieldOffset(6)]
        internal System.Int16 _IsWhitespace;
        /// <summary>
        /// <dd> <p>Indicates whether the cluster corresponds to a newline character.</p> </dd>
        /// </summary>
        /// <doc-id>dd368054</doc-id>
        /// <unmanaged>isNewline</unmanaged>
        /// <unmanaged-short>isNewline</unmanaged-short>
        public bool IsNewline
        {
            get => 0 != ((_IsNewline >> 2) & 1);
            set => this._IsNewline = (System.Int16)((this._IsNewline & ~(1 << 2)) | (((value ? 1 : 0) & 1) << 2));
        }

        [System.Runtime.InteropServices.FieldOffset(6)]
        internal System.Int16 _IsNewline;
        /// <summary>
        /// <dd> <p>Indicates whether the cluster corresponds to a soft hyphen character.</p> </dd>
        /// </summary>
        /// <doc-id>dd368054</doc-id>
        /// <unmanaged>isSoftHyphen</unmanaged>
        /// <unmanaged-short>isSoftHyphen</unmanaged-short>
        public bool IsSoftHyphen
        {
            get => 0 != ((_IsSoftHyphen >> 3) & 1);
            set => this._IsSoftHyphen = (System.Int16)((this._IsSoftHyphen & ~(1 << 3)) | (((value ? 1 : 0) & 1) << 3));
        }

        [System.Runtime.InteropServices.FieldOffset(6)]
        internal System.Int16 _IsSoftHyphen;
        /// <summary>
        /// <dd> <p>Indicates whether the cluster is read from right to left.</p> </dd>
        /// </summary>
        /// <doc-id>dd368054</doc-id>
        /// <unmanaged>isRightToLeft</unmanaged>
        /// <unmanaged-short>isRightToLeft</unmanaged-short>
        public bool IsRightToLeft
        {
            get => 0 != ((_IsRightToLeft >> 4) & 1);
            set => this._IsRightToLeft = (System.Int16)((this._IsRightToLeft & ~(1 << 4)) | (((value ? 1 : 0) & 1) << 4));
        }

        [System.Runtime.InteropServices.FieldOffset(6)]
        internal System.Int16 _IsRightToLeft;
        /// <summary>
        /// <dd> <p>Reserved for future use.</p> </dd>
        /// </summary>
        /// <doc-id>dd368054</doc-id>
        /// <unmanaged>padding</unmanaged>
        /// <unmanaged-short>padding</unmanaged-short>
        internal System.Int16 Padding
        {
            get => (System.Int16)((_Padding >> 5) & 2047);
            set => this._Padding = (System.Int16)((this._Padding & ~(2047 << 5)) | ((value & 2047) << 5));
        }

        [System.Runtime.InteropServices.FieldOffset(6)]
        internal System.Int16 _Padding;
    }

    /// <summary>
    /// <p>Contains the information needed by renderers to draw glyph runs with glyph color information.  All coordinates are in device independent pixels (DIPs).</p>
    /// </summary>
    /// <doc-id>dn280407</doc-id>
    /// <unmanaged>DWRITE_COLOR_GLYPH_RUN</unmanaged>
    /// <unmanaged-short>DWRITE_COLOR_GLYPH_RUN</unmanaged-short>
    public partial struct ColorGlyphRun
    {
        /// <summary>
        /// <dd> <p>Glyph run to draw for this layer.</p> </dd>
        /// </summary>
        /// <doc-id>dn280407</doc-id>
        /// <unmanaged>glyphRun</unmanaged>
        /// <unmanaged-short>glyphRun</unmanaged-short>
        public SharpDX.DirectWrite.GlyphRun GlyphRun;
        /// <summary>
        /// <dd> <p>Pointer to the glyph run description for this layer. This may be <strong><c>null</c></strong>. For example, when the original glyph run is split into multiple layers, one layer might have a description and the others have none.</p> </dd>
        /// </summary>
        /// <doc-id>dn280407</doc-id>
        /// <unmanaged>glyphRunDescription</unmanaged>
        /// <unmanaged-short>glyphRunDescription</unmanaged-short>
        public System.IntPtr GlyphRunDescription;
        /// <summary>
        /// <dd> <p>X coordinate of the baseline origin for the layer.</p> </dd>
        /// </summary>
        /// <doc-id>dn280407</doc-id>
        /// <unmanaged>baselineOriginX</unmanaged>
        /// <unmanaged-short>baselineOriginX</unmanaged-short>
        public System.Single BaselineOriginX;
        /// <summary>
        /// <dd> <p>Y coordinate of the baseline origin for the layer.</p> </dd>
        /// </summary>
        /// <doc-id>dn280407</doc-id>
        /// <unmanaged>baselineOriginY</unmanaged>
        /// <unmanaged-short>baselineOriginY</unmanaged-short>
        public System.Single BaselineOriginY;
        /// <summary>
        /// <dd> <p>Color value of the run; if all members are zero, the run should be drawn using the current brush.</p> </dd>
        /// </summary>
        /// <doc-id>dn280407</doc-id>
        /// <unmanaged>runColor</unmanaged>
        /// <unmanaged-short>runColor</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawColor4 RunColor;
        /// <summary>
        /// <dd> <p>Zero-based index into the font?s color palette; if this is <strong>0xFFFF</strong>, the run should be drawn using the current brush.</p> </dd>
        /// </summary>
        /// <doc-id>dn280407</doc-id>
        /// <unmanaged>paletteIndex</unmanaged>
        /// <unmanaged-short>paletteIndex</unmanaged-short>
        public System.Int16 PaletteIndex;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.DirectWrite.GlyphRun.__Native GlyphRun;
            public System.IntPtr GlyphRunDescription;
            public System.Single BaselineOriginX;
            public System.Single BaselineOriginY;
            public SharpDX.Mathematics.Interop.RawColor4 RunColor;
            public System.Int16 PaletteIndex;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            GlyphRun.__MarshalFree(ref @ref.GlyphRun);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            {
                GlyphRun = new SharpDX.DirectWrite.GlyphRun();
                GlyphRun.__MarshalFrom(ref @ref.GlyphRun);
            }

            GlyphRunDescription = @ref.GlyphRunDescription;
            BaselineOriginX = @ref.BaselineOriginX;
            BaselineOriginY = @ref.BaselineOriginY;
            RunColor = @ref.RunColor;
            PaletteIndex = @ref.PaletteIndex;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            GlyphRun.__MarshalTo(ref @ref.GlyphRun);
            @ref.GlyphRunDescription = GlyphRunDescription;
            @ref.BaselineOriginX = BaselineOriginX;
            @ref.BaselineOriginY = BaselineOriginY;
            @ref.RunColor = RunColor;
            @ref.PaletteIndex = PaletteIndex;
        }
    }

    /// <summary>
    /// <p>Represents a color glyph run. The IDWriteFactory4::TranslateColorGlyphRun method returns an ordered collection of color glyph runs of varying types depending on what the font supports.</p>
    /// </summary>
    /// <doc-id>mt725306</doc-id>
    /// <unmanaged>DWRITE_COLOR_GLYPH_RUN1</unmanaged>
    /// <unmanaged-short>DWRITE_COLOR_GLYPH_RUN1</unmanaged-short>
    public partial struct ColorGlyphRun1
    {
        /// <summary>
        /// <dd> <p>Glyph run to draw for this layer.</p> </dd>
        /// </summary>
        /// <doc-id>dn280407</doc-id>
        /// <unmanaged>glyphRun</unmanaged>
        /// <unmanaged-short>glyphRun</unmanaged-short>
        public SharpDX.DirectWrite.GlyphRun GlyphRun;
        /// <summary>
        /// <dd> <p>Pointer to the glyph run description for this layer. This may be <strong><c>null</c></strong>. For example, when the original glyph run is split into multiple layers, one layer might have a description and the others have none.</p> </dd>
        /// </summary>
        /// <doc-id>dn280407</doc-id>
        /// <unmanaged>glyphRunDescription</unmanaged>
        /// <unmanaged-short>glyphRunDescription</unmanaged-short>
        public System.IntPtr GlyphRunDescription;
        /// <summary>
        /// <dd> <p>X coordinate of the baseline origin for the layer.</p> </dd>
        /// </summary>
        /// <doc-id>dn280407</doc-id>
        /// <unmanaged>baselineOriginX</unmanaged>
        /// <unmanaged-short>baselineOriginX</unmanaged-short>
        public System.Single BaselineOriginX;
        /// <summary>
        /// <dd> <p>Y coordinate of the baseline origin for the layer.</p> </dd>
        /// </summary>
        /// <doc-id>dn280407</doc-id>
        /// <unmanaged>baselineOriginY</unmanaged>
        /// <unmanaged-short>baselineOriginY</unmanaged-short>
        public System.Single BaselineOriginY;
        /// <summary>
        /// <dd> <p>Color value of the run; if all members are zero, the run should be drawn using the current brush.</p> </dd>
        /// </summary>
        /// <doc-id>dn280407</doc-id>
        /// <unmanaged>runColor</unmanaged>
        /// <unmanaged-short>runColor</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawColor4 RunColor;
        /// <summary>
        /// <dd> <p>Zero-based index into the font?s color palette; if this is <strong>0xFFFF</strong>, the run should be drawn using the current brush.</p> </dd>
        /// </summary>
        /// <doc-id>dn280407</doc-id>
        /// <unmanaged>paletteIndex</unmanaged>
        /// <unmanaged-short>paletteIndex</unmanaged-short>
        public System.Int16 PaletteIndex;
        /// <summary>
        /// <dd> <p>Type of glyph image format for this color run. Exactly one type will be set since TranslateColorGlyphRun has already broken down the run into separate parts.</p> </dd>
        /// </summary>
        /// <doc-id>mt725306</doc-id>
        /// <unmanaged>glyphImageFormat</unmanaged>
        /// <unmanaged-short>glyphImageFormat</unmanaged-short>
        public SharpDX.Direct2D1.GlyphImageFormatS GlyphImageFormat;
        /// <summary>
        /// <dd> <p>Measuring mode to use for this glyph run.</p> </dd>
        /// </summary>
        /// <doc-id>mt725306</doc-id>
        /// <unmanaged>measuringMode</unmanaged>
        /// <unmanaged-short>measuringMode</unmanaged-short>
        public SharpDX.Direct2D1.MeasuringMode MeasuringMode;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.DirectWrite.GlyphRun.__Native GlyphRun;
            public System.IntPtr GlyphRunDescription;
            public System.Single BaselineOriginX;
            public System.Single BaselineOriginY;
            public SharpDX.Mathematics.Interop.RawColor4 RunColor;
            public System.Int16 PaletteIndex;
            public SharpDX.Direct2D1.GlyphImageFormatS GlyphImageFormat;
            public SharpDX.Direct2D1.MeasuringMode MeasuringMode;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            GlyphRun.__MarshalFree(ref @ref.GlyphRun);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            {
                GlyphRun = new SharpDX.DirectWrite.GlyphRun();
                GlyphRun.__MarshalFrom(ref @ref.GlyphRun);
            }

            GlyphRunDescription = @ref.GlyphRunDescription;
            BaselineOriginX = @ref.BaselineOriginX;
            BaselineOriginY = @ref.BaselineOriginY;
            RunColor = @ref.RunColor;
            PaletteIndex = @ref.PaletteIndex;
            GlyphImageFormat = @ref.GlyphImageFormat;
            MeasuringMode = @ref.MeasuringMode;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            GlyphRun.__MarshalTo(ref @ref.GlyphRun);
            @ref.GlyphRunDescription = GlyphRunDescription;
            @ref.BaselineOriginX = BaselineOriginX;
            @ref.BaselineOriginY = BaselineOriginY;
            @ref.RunColor = RunColor;
            @ref.PaletteIndex = PaletteIndex;
            @ref.GlyphImageFormat = GlyphImageFormat;
            @ref.MeasuringMode = MeasuringMode;
        }
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>DWRITE_FILE_FRAGMENT</unmanaged>
    /// <unmanaged-short>DWRITE_FILE_FRAGMENT</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct FileFragment
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>fileOffset</unmanaged>
        /// <unmanaged-short>fileOffset</unmanaged-short>
        public System.Int64 FileOffset;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>fragmentSize</unmanaged>
        /// <unmanaged-short>fragmentSize</unmanaged-short>
        public System.Int64 FragmentSize;
    }

    /// <summary>
    /// <p>Specifies properties used to identify and execute typographic features in the current font face.</p>
    /// </summary>
    /// <remarks>
    /// <p>A non-zero value generally enables the feature execution, while the zero value disables it. A feature requiring a selector uses this value to indicate the selector index.</p><p>The OpenType standard provides access to typographic features available in the font by means of a feature tag with the associated parameters. The OpenType feature tag is a 4-byte identifier of the registered name of a feature. For example, the 'kern' feature name tag is used to identify the 'Kerning' feature in OpenType font. Similarly, the OpenType feature tag for 'Standard Ligatures' and 'Fractions' is 'liga' and 'frac' respectively. Since a single run can be associated with more than one typographic features, the Text String API accepts typographic settings for a run as a list of features and are executed in the order they are specified.</p><p>The value of the tag member represents the OpenType name tag of the feature, while the param value represents additional parameter for the execution of the feature referred by the tag member. Both <strong>nameTag</strong> and <strong>parameter</strong> are stored as little endian, the same convention followed by GDI.  Most features treat the Param value as a binary value that indicates whether to turn the execution of the feature on or off, with it being off by default in the majority of cases. Some features, however, treat this value as an integral value representing the integer index to the list of alternate results it may produce during the execution; for instance, the feature 'Stylistic Alternates' or 'salt' uses the <strong>parameter</strong> value as an index to the list of alternate substituting glyphs it could produce for a specified glyph. </p>
    /// </remarks>
    /// <doc-id>dd368066</doc-id>
    /// <unmanaged>DWRITE_FONT_FEATURE</unmanaged>
    /// <unmanaged-short>DWRITE_FONT_FEATURE</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct FontFeature
    {
        /// <summary>
        /// <dd> <p>The feature OpenType name identifier.</p> </dd>
        /// </summary>
        /// <doc-id>dd368066</doc-id>
        /// <unmanaged>nameTag</unmanaged>
        /// <unmanaged-short>nameTag</unmanaged-short>
        public SharpDX.DirectWrite.FontFeatureTag NameTag;
        /// <summary>
        /// <dd> <p>The execution parameter of the feature.</p> </dd>
        /// </summary>
        /// <doc-id>dd368066</doc-id>
        /// <unmanaged>parameter</unmanaged>
        /// <unmanaged-short>parameter</unmanaged-short>
        public System.Int32 Parameter;
    }

    /// <summary>
    /// <p>The <strong><see cref = "SharpDX.DirectWrite.FontMetrics"/></strong> structure specifies the metrics that are applicable to all glyphs within the font face.</p>
    /// </summary>
    /// <doc-id>dd368074</doc-id>
    /// <unmanaged>DWRITE_FONT_METRICS</unmanaged>
    /// <unmanaged-short>DWRITE_FONT_METRICS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct FontMetrics
    {
        /// <summary>
        /// <dd> <p>The number of font design units per em unit. Font files use their own coordinate system of font design units. A font design unit is the smallest measurable unit in the em square, an imaginary square that is used to size and align glyphs. The concept of em square is used as a reference scale factor when defining font size and device transformation semantics. The size of one em square is also commonly used to compute the paragraph identation value.</p> </dd>
        /// </summary>
        /// <doc-id>dd368074</doc-id>
        /// <unmanaged>designUnitsPerEm</unmanaged>
        /// <unmanaged-short>designUnitsPerEm</unmanaged-short>
        public System.Int16 DesignUnitsPerEm;
        /// <summary>
        /// <dd> <p>The ascent value of the font face in font design units. Ascent is the distance from the top of font character alignment box to the English baseline.</p> </dd>
        /// </summary>
        /// <doc-id>dd368074</doc-id>
        /// <unmanaged>ascent</unmanaged>
        /// <unmanaged-short>ascent</unmanaged-short>
        public System.Int16 Ascent;
        /// <summary>
        /// <dd> <p>The descent value of the font face in font design units. Descent is the distance from the bottom of font character alignment box to the English baseline.</p> </dd>
        /// </summary>
        /// <doc-id>dd368074</doc-id>
        /// <unmanaged>descent</unmanaged>
        /// <unmanaged-short>descent</unmanaged-short>
        public System.Int16 Descent;
        /// <summary>
        /// <dd> <p>The line gap in font design units. Recommended additional white space to add between lines to improve legibility. The recommended line spacing (baseline-to-baseline distance) is  the sum of <strong>ascent</strong>, <strong>descent</strong>, and <strong>lineGap</strong>. The line gap is usually positive or zero but can be negative, in which case the recommended line spacing is less than the height of the character alignment box.</p> </dd>
        /// </summary>
        /// <doc-id>dd368074</doc-id>
        /// <unmanaged>lineGap</unmanaged>
        /// <unmanaged-short>lineGap</unmanaged-short>
        public System.Int16 LineGap;
        /// <summary>
        /// <dd> <p>The cap height value of the font face in font design units. Cap height is the distance from the English baseline to the top of a typical English capital. Capital "H" is often used as a reference character for the purpose of calculating the cap height value.</p> </dd>
        /// </summary>
        /// <doc-id>dd368074</doc-id>
        /// <unmanaged>capHeight</unmanaged>
        /// <unmanaged-short>capHeight</unmanaged-short>
        public System.Int16 CapHeight;
        /// <summary>
        /// <dd> <p>The x-height value of the font face in font design units. x-height is the distance from the English baseline to the top of lowercase letter "x", or a similar lowercase character.</p> </dd>
        /// </summary>
        /// <doc-id>dd368074</doc-id>
        /// <unmanaged>xHeight</unmanaged>
        /// <unmanaged-short>xHeight</unmanaged-short>
        public System.Int16 XHeight;
        /// <summary>
        /// <dd> <p>The underline position value of the font face in font design units. Underline position is the position of underline relative to the English baseline. The value is usually made negative in order to place the underline below the baseline.</p> </dd>
        /// </summary>
        /// <doc-id>dd368074</doc-id>
        /// <unmanaged>underlinePosition</unmanaged>
        /// <unmanaged-short>underlinePosition</unmanaged-short>
        public System.Int16 UnderlinePosition;
        /// <summary>
        /// <dd> <p>The suggested underline thickness value of the font face in font design units.</p> </dd>
        /// </summary>
        /// <doc-id>dd368074</doc-id>
        /// <unmanaged>underlineThickness</unmanaged>
        /// <unmanaged-short>underlineThickness</unmanaged-short>
        public System.Int16 UnderlineThickness;
        /// <summary>
        /// <dd> <p>The strikethrough position value of the font face in font design units. Strikethrough position is the position of strikethrough relative to the English baseline. The value is usually made positive in order to place the strikethrough above the baseline.</p> </dd>
        /// </summary>
        /// <doc-id>dd368074</doc-id>
        /// <unmanaged>strikethroughPosition</unmanaged>
        /// <unmanaged-short>strikethroughPosition</unmanaged-short>
        public System.Int16 StrikethroughPosition;
        /// <summary>
        /// <dd> <p>The suggested strikethrough thickness value of the font face in font design units.</p> </dd>
        /// </summary>
        /// <doc-id>dd368074</doc-id>
        /// <unmanaged>strikethroughThickness</unmanaged>
        /// <unmanaged-short>strikethroughThickness</unmanaged-short>
        public System.Int16 StrikethroughThickness;
    }

    /// <summary>
    /// <p>The <strong><see cref = "SharpDX.DirectWrite.FontMetrics1"/></strong> structure specifies the metrics that are applicable to all glyphs within the font face.</p>
    /// </summary>
    /// <remarks>
    /// <p><strong><see cref = "SharpDX.DirectWrite.FontMetrics1"/></strong> inherits from <strong><see cref = "SharpDX.DirectWrite.FontMetrics"/></strong>:</p><code> struct <see cref = "SharpDX.DirectWrite.FontMetrics1"/> : public <see cref = "SharpDX.DirectWrite.FontMetrics"/>
    /// {
    /// ...
    /// };</code>
    /// </remarks>
    /// <doc-id>jj126259</doc-id>
    /// <unmanaged>DWRITE_FONT_METRICS1</unmanaged>
    /// <unmanaged-short>DWRITE_FONT_METRICS1</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct FontMetrics1
    {
        /// <summary>
        /// <dd> <p>The number of font design units per em unit. Font files use their own coordinate system of font design units. A font design unit is the smallest measurable unit in the em square, an imaginary square that is used to size and align glyphs. The concept of em square is used as a reference scale factor when defining font size and device transformation semantics. The size of one em square is also commonly used to compute the paragraph identation value.</p> </dd>
        /// </summary>
        /// <doc-id>dd368074</doc-id>
        /// <unmanaged>designUnitsPerEm</unmanaged>
        /// <unmanaged-short>designUnitsPerEm</unmanaged-short>
        public System.Int16 DesignUnitsPerEm;
        /// <summary>
        /// <dd> <p>The ascent value of the font face in font design units. Ascent is the distance from the top of font character alignment box to the English baseline.</p> </dd>
        /// </summary>
        /// <doc-id>dd368074</doc-id>
        /// <unmanaged>ascent</unmanaged>
        /// <unmanaged-short>ascent</unmanaged-short>
        public System.Int16 Ascent;
        /// <summary>
        /// <dd> <p>The descent value of the font face in font design units. Descent is the distance from the bottom of font character alignment box to the English baseline.</p> </dd>
        /// </summary>
        /// <doc-id>dd368074</doc-id>
        /// <unmanaged>descent</unmanaged>
        /// <unmanaged-short>descent</unmanaged-short>
        public System.Int16 Descent;
        /// <summary>
        /// <dd> <p>The line gap in font design units. Recommended additional white space to add between lines to improve legibility. The recommended line spacing (baseline-to-baseline distance) is  the sum of <strong>ascent</strong>, <strong>descent</strong>, and <strong>lineGap</strong>. The line gap is usually positive or zero but can be negative, in which case the recommended line spacing is less than the height of the character alignment box.</p> </dd>
        /// </summary>
        /// <doc-id>dd368074</doc-id>
        /// <unmanaged>lineGap</unmanaged>
        /// <unmanaged-short>lineGap</unmanaged-short>
        public System.Int16 LineGap;
        /// <summary>
        /// <dd> <p>The cap height value of the font face in font design units. Cap height is the distance from the English baseline to the top of a typical English capital. Capital "H" is often used as a reference character for the purpose of calculating the cap height value.</p> </dd>
        /// </summary>
        /// <doc-id>dd368074</doc-id>
        /// <unmanaged>capHeight</unmanaged>
        /// <unmanaged-short>capHeight</unmanaged-short>
        public System.Int16 CapHeight;
        /// <summary>
        /// <dd> <p>The x-height value of the font face in font design units. x-height is the distance from the English baseline to the top of lowercase letter "x", or a similar lowercase character.</p> </dd>
        /// </summary>
        /// <doc-id>dd368074</doc-id>
        /// <unmanaged>xHeight</unmanaged>
        /// <unmanaged-short>xHeight</unmanaged-short>
        public System.Int16 XHeight;
        /// <summary>
        /// <dd> <p>The underline position value of the font face in font design units. Underline position is the position of underline relative to the English baseline. The value is usually made negative in order to place the underline below the baseline.</p> </dd>
        /// </summary>
        /// <doc-id>dd368074</doc-id>
        /// <unmanaged>underlinePosition</unmanaged>
        /// <unmanaged-short>underlinePosition</unmanaged-short>
        public System.Int16 UnderlinePosition;
        /// <summary>
        /// <dd> <p>The suggested underline thickness value of the font face in font design units.</p> </dd>
        /// </summary>
        /// <doc-id>dd368074</doc-id>
        /// <unmanaged>underlineThickness</unmanaged>
        /// <unmanaged-short>underlineThickness</unmanaged-short>
        public System.Int16 UnderlineThickness;
        /// <summary>
        /// <dd> <p>The strikethrough position value of the font face in font design units. Strikethrough position is the position of strikethrough relative to the English baseline. The value is usually made positive in order to place the strikethrough above the baseline.</p> </dd>
        /// </summary>
        /// <doc-id>dd368074</doc-id>
        /// <unmanaged>strikethroughPosition</unmanaged>
        /// <unmanaged-short>strikethroughPosition</unmanaged-short>
        public System.Int16 StrikethroughPosition;
        /// <summary>
        /// <dd> <p>The suggested strikethrough thickness value of the font face in font design units.</p> </dd>
        /// </summary>
        /// <doc-id>dd368074</doc-id>
        /// <unmanaged>strikethroughThickness</unmanaged>
        /// <unmanaged-short>strikethroughThickness</unmanaged-short>
        public System.Int16 StrikethroughThickness;
        /// <summary>
        /// <dd> <p>Left edge of accumulated bounding blackbox of all glyphs in the font.</p> </dd>
        /// </summary>
        /// <doc-id>jj126259</doc-id>
        /// <unmanaged>glyphBoxLeft</unmanaged>
        /// <unmanaged-short>glyphBoxLeft</unmanaged-short>
        public System.Int16 GlyphBoxLeft;
        /// <summary>
        /// <dd> <p>Top edge of accumulated bounding blackbox of all glyphs in the font.</p> </dd>
        /// </summary>
        /// <doc-id>jj126259</doc-id>
        /// <unmanaged>glyphBoxTop</unmanaged>
        /// <unmanaged-short>glyphBoxTop</unmanaged-short>
        public System.Int16 GlyphBoxTop;
        /// <summary>
        /// <dd> <p>Right edge of accumulated bounding blackbox of all glyphs in the font.</p> </dd>
        /// </summary>
        /// <doc-id>jj126259</doc-id>
        /// <unmanaged>glyphBoxRight</unmanaged>
        /// <unmanaged-short>glyphBoxRight</unmanaged-short>
        public System.Int16 GlyphBoxRight;
        /// <summary>
        /// <dd> <p>Bottom edge of accumulated bounding blackbox of all glyphs in the font.</p> </dd>
        /// </summary>
        /// <doc-id>jj126259</doc-id>
        /// <unmanaged>glyphBoxBottom</unmanaged>
        /// <unmanaged-short>glyphBoxBottom</unmanaged-short>
        public System.Int16 GlyphBoxBottom;
        /// <summary>
        /// <dd> <p>Horizontal position of the subscript relative to the baseline origin. This is typically negative (to the left) in italic and oblique fonts, and zero in regular fonts.</p> </dd>
        /// </summary>
        /// <doc-id>jj126259</doc-id>
        /// <unmanaged>subscriptPositionX</unmanaged>
        /// <unmanaged-short>subscriptPositionX</unmanaged-short>
        public System.Int16 SubscriptPositionX;
        /// <summary>
        /// <dd> <p>Vertical position of the subscript relative to the baseline. This is typically negative.</p> </dd>
        /// </summary>
        /// <doc-id>jj126259</doc-id>
        /// <unmanaged>subscriptPositionY</unmanaged>
        /// <unmanaged-short>subscriptPositionY</unmanaged-short>
        public System.Int16 SubscriptPositionY;
        /// <summary>
        /// <dd> <p>Horizontal size of the subscript em box in design units, used to scale the simulated subscript relative to the full em box size. This is the numerator of the scaling ratio where denominator is the design units per em. If this member is zero, the font does not specify a scale factor, and the client uses its own policy.</p> </dd>
        /// </summary>
        /// <doc-id>jj126259</doc-id>
        /// <unmanaged>subscriptSizeX</unmanaged>
        /// <unmanaged-short>subscriptSizeX</unmanaged-short>
        public System.Int16 SubscriptSizeX;
        /// <summary>
        /// <dd> <p>Vertical size of the subscript em box in design units, used to scale the simulated subscript relative to the full em box size. This is the numerator of the scaling ratio where denominator is the design units per em. If this member is zero, the font does not specify a scale factor, and the client uses its own policy.</p> </dd>
        /// </summary>
        /// <doc-id>jj126259</doc-id>
        /// <unmanaged>subscriptSizeY</unmanaged>
        /// <unmanaged-short>subscriptSizeY</unmanaged-short>
        public System.Int16 SubscriptSizeY;
        /// <summary>
        /// <dd> <p>Horizontal position of the superscript relative to the baseline origin. This is typically positive (to the right) in italic and oblique fonts, and zero in regular fonts.</p> </dd>
        /// </summary>
        /// <doc-id>jj126259</doc-id>
        /// <unmanaged>superscriptPositionX</unmanaged>
        /// <unmanaged-short>superscriptPositionX</unmanaged-short>
        public System.Int16 SuperscriptPositionX;
        /// <summary>
        /// <dd> <p>Vertical position of the superscript relative to the baseline. This is typically positive.</p> </dd>
        /// </summary>
        /// <doc-id>jj126259</doc-id>
        /// <unmanaged>superscriptPositionY</unmanaged>
        /// <unmanaged-short>superscriptPositionY</unmanaged-short>
        public System.Int16 SuperscriptPositionY;
        /// <summary>
        /// <dd> <p>Horizontal size of the superscript em box in design units, used to scale the simulated superscript relative to the full em box size. This is the numerator of the scaling ratio where denominator is the design units per em. If this member is zero, the font does not specify a scale factor, and the client should use its own policy.</p> </dd>
        /// </summary>
        /// <doc-id>jj126259</doc-id>
        /// <unmanaged>superscriptSizeX</unmanaged>
        /// <unmanaged-short>superscriptSizeX</unmanaged-short>
        public System.Int16 SuperscriptSizeX;
        /// <summary>
        /// <dd> <p>Vertical size of the superscript em box in design units, used to scale the simulated superscript relative to the full em box size. This is the numerator of the scaling ratio where denominator is the design units per em. If this member is zero, the font does not specify a scale factor, and the client should use its own policy.</p> </dd>
        /// </summary>
        /// <doc-id>jj126259</doc-id>
        /// <unmanaged>superscriptSizeY</unmanaged>
        /// <unmanaged-short>superscriptSizeY</unmanaged-short>
        public System.Int16 SuperscriptSizeY;
        /// <summary>
        /// <dd> <p>A Boolean value that indicates that the ascent, descent, and lineGap are based on newer 'typographic' values in the font, rather than legacy values.</p> </dd>
        /// </summary>
        /// <doc-id>jj126259</doc-id>
        /// <unmanaged>hasTypographicMetrics</unmanaged>
        /// <unmanaged-short>hasTypographicMetrics</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool HasTypographicMetrics;
    }

    /// <summary>
    /// <p>Font property used for filtering font sets and building a font set with explicit properties.</p>
    /// </summary>
    /// <doc-id>dn933212</doc-id>
    /// <unmanaged>DWRITE_FONT_PROPERTY</unmanaged>
    /// <unmanaged-short>DWRITE_FONT_PROPERTY</unmanaged-short>
    public partial struct FontProperty
    {
        /// <summary>
        /// <dd> <p>Specifies the requested font property, such as DWRITE_FONT_PROPERTY_ID_FAMILY_NAME.</p> </dd>
        /// </summary>
        /// <doc-id>dn933212</doc-id>
        /// <unmanaged>propertyId</unmanaged>
        /// <unmanaged-short>propertyId</unmanaged-short>
        public SharpDX.DirectWrite.FontPropertyId PropertyId;
        /// <summary>
        /// <dd> <p>Specifies the value, such as "Segoe UI".</p> </dd>
        /// </summary>
        /// <doc-id>dn933212</doc-id>
        /// <unmanaged>propertyValue</unmanaged>
        /// <unmanaged-short>propertyValue</unmanaged-short>
        public System.String PropertyValue;
        /// <summary>
        /// <dd> <p>Specifies the locale to use, such as "en-US". Simply leave this empty when used with the font set filtering functions, as they will find a match regardless of language. For passing to AddFontFaceReference, the localeName specifies the language of the property value.</p> </dd>
        /// </summary>
        /// <doc-id>dn933212</doc-id>
        /// <unmanaged>localeName</unmanaged>
        /// <unmanaged-short>localeName</unmanaged-short>
        public System.String LocaleName;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.DirectWrite.FontPropertyId PropertyId;
            public System.IntPtr PropertyValue;
            public System.IntPtr LocaleName;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.PropertyValue);
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.LocaleName);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            PropertyId = @ref.PropertyId;
            PropertyValue = System.Runtime.InteropServices.Marshal.PtrToStringUni(@ref.PropertyValue);
            LocaleName = System.Runtime.InteropServices.Marshal.PtrToStringUni(@ref.LocaleName);
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.PropertyId = PropertyId;
            @ref.PropertyValue = System.Runtime.InteropServices.Marshal.StringToHGlobalUni(PropertyValue);
            @ref.LocaleName = System.Runtime.InteropServices.Marshal.StringToHGlobalUni(LocaleName);
        }
    }

    /// <summary>
    /// <p>Data for a single glyph from GetGlyphImageData.</p>
    /// </summary>
    /// <doc-id>mt725307</doc-id>
    /// <unmanaged>DWRITE_GLYPH_IMAGE_DATA</unmanaged>
    /// <unmanaged-short>DWRITE_GLYPH_IMAGE_DATA</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct GlyphImageData
    {
        /// <summary>
        /// <dd> <p>Pointer to the glyph data.</p> </dd>
        /// </summary>
        /// <doc-id>mt725307</doc-id>
        /// <unmanaged>imageData</unmanaged>
        /// <unmanaged-short>imageData</unmanaged-short>
        public System.IntPtr ImageData;
        /// <summary>
        /// <dd> <p>Size of glyph data in bytes.</p> </dd>
        /// </summary>
        /// <doc-id>mt725307</doc-id>
        /// <unmanaged>imageDataSize</unmanaged>
        /// <unmanaged-short>imageDataSize</unmanaged-short>
        public System.Int32 ImageDataSize;
        /// <summary>
        /// <dd> <p>Unique identifier for the glyph data. Clients may use this to cache a parsed/decompressed version and tell whether a repeated call to the same font returns the same data.</p> </dd>
        /// </summary>
        /// <doc-id>mt725307</doc-id>
        /// <unmanaged>uniqueDataId</unmanaged>
        /// <unmanaged-short>uniqueDataId</unmanaged-short>
        public System.Int32 UniqueDataId;
        /// <summary>
        /// <dd> <p>Pixels per em of the returned data. For non-scalable raster data (PNG/TIFF/JPG), this can be larger or smaller than requested from GetGlyphImageData when there isn't an exact match. For scaling intermediate sizes, use: desired pixels per em * font em size / actual pixels per em.</p> </dd>
        /// </summary>
        /// <doc-id>mt725307</doc-id>
        /// <unmanaged>pixelsPerEm</unmanaged>
        /// <unmanaged-short>pixelsPerEm</unmanaged-short>
        public System.Int32 PixelsPerEm;
        /// <summary>
        /// <dd> <p>Size of image when the format is pixel data.</p> </dd>
        /// </summary>
        /// <doc-id>mt725307</doc-id>
        /// <unmanaged>pixelSize</unmanaged>
        /// <unmanaged-short>pixelSize</unmanaged-short>
        public SharpDX.Size2 PixelSize;
        /// <summary>
        /// <dd> <p>Left origin along the horizontal Roman baseline.</p> </dd>
        /// </summary>
        /// <doc-id>mt725307</doc-id>
        /// <unmanaged>horizontalLeftOrigin</unmanaged>
        /// <unmanaged-short>horizontalLeftOrigin</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawPoint HorizontalLeftOrigin;
        /// <summary>
        /// <dd> <p>Right origin along the horizontal Roman baseline.</p> </dd>
        /// </summary>
        /// <doc-id>mt725307</doc-id>
        /// <unmanaged>horizontalRightOrigin</unmanaged>
        /// <unmanaged-short>horizontalRightOrigin</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawPoint HorizontalRightOrigin;
        /// <summary>
        /// <dd> <p>Top origin along the vertical central baseline.</p> </dd>
        /// </summary>
        /// <doc-id>mt725307</doc-id>
        /// <unmanaged>verticalTopOrigin</unmanaged>
        /// <unmanaged-short>verticalTopOrigin</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawPoint VerticalTopOrigin;
        /// <summary>
        /// <dd> <p>Bottom origin along vertical central baseline.</p> </dd>
        /// </summary>
        /// <doc-id>mt725307</doc-id>
        /// <unmanaged>verticalBottomOrigin</unmanaged>
        /// <unmanaged-short>verticalBottomOrigin</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawPoint VerticalBottomOrigin;
    }

    /// <summary>
    /// <p>Specifies the metrics of an individual glyph. The units depend on how the metrics are obtained.</p>
    /// </summary>
    /// <doc-id>dd368084</doc-id>
    /// <unmanaged>DWRITE_GLYPH_METRICS</unmanaged>
    /// <unmanaged-short>DWRITE_GLYPH_METRICS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct GlyphMetrics
    {
        /// <summary>
        /// <dd> <p>Specifies the X offset from the glyph origin to the left edge of the black box. The glyph origin is the current horizontal writing position. A negative value means the black box extends to the left of the origin (often true for lowercase italic 'f').</p> </dd>
        /// </summary>
        /// <doc-id>dd368084</doc-id>
        /// <unmanaged>leftSideBearing</unmanaged>
        /// <unmanaged-short>leftSideBearing</unmanaged-short>
        public System.Int32 LeftSideBearing;
        /// <summary>
        /// <dd> <p>Specifies the X offset from the origin of the current glyph to the origin of the next glyph when writing horizontally.</p> </dd>
        /// </summary>
        /// <doc-id>dd368084</doc-id>
        /// <unmanaged>advanceWidth</unmanaged>
        /// <unmanaged-short>advanceWidth</unmanaged-short>
        public System.Int32 AdvanceWidth;
        /// <summary>
        /// <dd> <p>Specifies the X offset from the right edge of the black box to the origin of the next glyph when writing horizontally. The value is negative when the right edge of the black box overhangs the layout box.</p> </dd>
        /// </summary>
        /// <doc-id>dd368084</doc-id>
        /// <unmanaged>rightSideBearing</unmanaged>
        /// <unmanaged-short>rightSideBearing</unmanaged-short>
        public System.Int32 RightSideBearing;
        /// <summary>
        /// <dd> <p>Specifies the vertical offset from the vertical origin to the top of the black box. Thus, a positive value adds whitespace whereas a negative value means the glyph overhangs the top of the layout box.</p> </dd>
        /// </summary>
        /// <doc-id>dd368084</doc-id>
        /// <unmanaged>topSideBearing</unmanaged>
        /// <unmanaged-short>topSideBearing</unmanaged-short>
        public System.Int32 TopSideBearing;
        /// <summary>
        /// <dd> <p>Specifies the Y offset from the vertical origin of the current glyph to the vertical origin of the next glyph when writing vertically. Note that the term "origin" by itself denotes the horizontal origin. The vertical origin is different. Its Y coordinate is specified by <strong>verticalOriginY</strong> value, and its X coordinate is half the <strong>advanceWidth</strong> to the right of the horizontal origin.</p> </dd>
        /// </summary>
        /// <doc-id>dd368084</doc-id>
        /// <unmanaged>advanceHeight</unmanaged>
        /// <unmanaged-short>advanceHeight</unmanaged-short>
        public System.Int32 AdvanceHeight;
        /// <summary>
        /// <dd> <p>Specifies the vertical distance from the bottom edge of the black box to the advance height. This is positive when the bottom edge of the black box is within the layout box, or negative when the bottom edge of black box overhangs the layout box.</p> </dd>
        /// </summary>
        /// <doc-id>dd368084</doc-id>
        /// <unmanaged>bottomSideBearing</unmanaged>
        /// <unmanaged-short>bottomSideBearing</unmanaged-short>
        public System.Int32 BottomSideBearing;
        /// <summary>
        /// <dd> <p>Specifies the Y coordinate of a glyph's vertical origin, in the font's design coordinate system. The y coordinate of a glyph's vertical origin is the sum of the glyph's top side bearing and the top (that is, yMax) of the glyph's bounding box.</p> </dd>
        /// </summary>
        /// <doc-id>dd368084</doc-id>
        /// <unmanaged>verticalOriginY</unmanaged>
        /// <unmanaged-short>verticalOriginY</unmanaged-short>
        public System.Int32 VerticalOriginY;
    }

    /// <summary>
    /// <p>The optional adjustment to a glyph's position.</p>
    /// </summary>
    /// <remarks>
    /// <p>An glyph offset changes the position of a glyph without affecting the pen position. Offsets are in logical, pre-transform units.</p>
    /// </remarks>
    /// <doc-id>dd368086</doc-id>
    /// <unmanaged>DWRITE_GLYPH_OFFSET</unmanaged>
    /// <unmanaged-short>DWRITE_GLYPH_OFFSET</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct GlyphOffset
    {
        /// <summary>
        /// <dd> <p>The offset in the advance direction of the run. A positive advance offset moves the glyph to the right (in pre-transform coordinates) if the run is left-to-right or to the left if the run is right-to-left.</p> </dd>
        /// </summary>
        /// <doc-id>dd368086</doc-id>
        /// <unmanaged>advanceOffset</unmanaged>
        /// <unmanaged-short>advanceOffset</unmanaged-short>
        public System.Single AdvanceOffset;
        /// <summary>
        /// <dd> <p>The offset in the ascent direction, that is, the direction ascenders point. A positive ascender offset moves the glyph up (in pre-transform coordinates).  A negative ascender offset moves the glyph down.</p> </dd>
        /// </summary>
        /// <doc-id>dd368086</doc-id>
        /// <unmanaged>ascenderOffset</unmanaged>
        /// <unmanaged-short>ascenderOffset</unmanaged-short>
        public System.Single AscenderOffset;
    }

    /// <summary>
    /// <p>Contains the information needed by renderers to draw glyph runs.  All coordinates are in device independent pixels (DIPs). </p>
    /// </summary>
    /// <doc-id>dd368089</doc-id>
    /// <unmanaged>DWRITE_GLYPH_RUN</unmanaged>
    /// <unmanaged-short>DWRITE_GLYPH_RUN</unmanaged-short>
    public partial class GlyphRun
    {
        /// <summary>
        /// <dd> <p>The physical font face object to draw with.</p> </dd>
        /// </summary>
        /// <doc-id>dd368089</doc-id>
        /// <unmanaged>fontFace</unmanaged>
        /// <unmanaged-short>fontFace</unmanaged-short>
        internal SharpDX.DirectWrite.FontFace FontFacePointer;
        /// <summary>
        /// <dd> <p>The logical size of the font in DIPs (equals 1/96 inch), not points.</p> </dd>
        /// </summary>
        /// <doc-id>dd368089</doc-id>
        /// <unmanaged>fontEmSize</unmanaged>
        /// <unmanaged-short>fontEmSize</unmanaged-short>
        public System.Single FontSize;
        /// <summary>
        /// <dd> <p>The number of glyphs in the glyph run.</p> </dd>
        /// </summary>
        /// <doc-id>dd368089</doc-id>
        /// <unmanaged>glyphCount</unmanaged>
        /// <unmanaged-short>glyphCount</unmanaged-short>
        internal System.Int32 GlyphCount;
        /// <summary>
        /// <dd> <p>A reference to an array of indices to render for the glyph run.</p> </dd>
        /// </summary>
        /// <doc-id>dd368089</doc-id>
        /// <unmanaged>glyphIndices</unmanaged>
        /// <unmanaged-short>glyphIndices</unmanaged-short>
        internal System.IntPtr GlyphIndicesPointer;
        /// <summary>
        /// <dd> <p>A reference to an array containing glyph advance widths for the glyph run.</p> </dd>
        /// </summary>
        /// <doc-id>dd368089</doc-id>
        /// <unmanaged>glyphAdvances</unmanaged>
        /// <unmanaged-short>glyphAdvances</unmanaged-short>
        internal System.IntPtr GlyphAdvancesPointer;
        /// <summary>
        /// <dd> <p>A reference to an array containing glyph offsets for the glyph run.</p> </dd>
        /// </summary>
        /// <doc-id>dd368089</doc-id>
        /// <unmanaged>glyphOffsets</unmanaged>
        /// <unmanaged-short>glyphOffsets</unmanaged-short>
        internal System.IntPtr GlyphOffsetsPointer;
        /// <summary>
        /// <dd> <p>If true, specifies that glyphs are rotated 90 degrees to the left and vertical metrics are used. Vertical writing is achieved by specifying <strong>isSideways</strong> = true and rotating the entire run 90 degrees to the right via a rotate transform.</p> </dd>
        /// </summary>
        /// <doc-id>dd368089</doc-id>
        /// <unmanaged>isSideways</unmanaged>
        /// <unmanaged-short>isSideways</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsSideways;
        /// <summary>
        /// <dd> <p>The implicit resolved bidi level of the run. Odd levels indicate right-to-left languages like Hebrew and Arabic, while even levels indicate left-to-right languages like English and Japanese (when written horizontally). For right-to-left languages, the text origin is on the right, and text should be drawn to the left.</p> </dd>
        /// </summary>
        /// <doc-id>dd368089</doc-id>
        /// <unmanaged>bidiLevel</unmanaged>
        /// <unmanaged-short>bidiLevel</unmanaged-short>
        public System.Int32 BidiLevel;
    }

    /// <summary>
    /// <p>Contains additional properties related to those in <strong><see cref = "SharpDX.DirectWrite.GlyphRun"/></strong>.</p>
    /// </summary>
    /// <doc-id>dd368091</doc-id>
    /// <unmanaged>DWRITE_GLYPH_RUN_DESCRIPTION</unmanaged>
    /// <unmanaged-short>DWRITE_GLYPH_RUN_DESCRIPTION</unmanaged-short>
    public partial class GlyphRunDescription
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd368091</doc-id>
        /// <unmanaged>localeName</unmanaged>
        /// <unmanaged-short>localeName</unmanaged-short>
        public System.String LocaleName;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd368091</doc-id>
        /// <unmanaged>string</unmanaged>
        /// <unmanaged-short>string</unmanaged-short>
        public System.String Text;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd368091</doc-id>
        /// <unmanaged>stringLength</unmanaged>
        /// <unmanaged-short>stringLength</unmanaged-short>
        internal System.Int32 TextLength;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd368091</doc-id>
        /// <unmanaged>clusterMap</unmanaged>
        /// <unmanaged-short>clusterMap</unmanaged-short>
        public System.IntPtr ClusterMap;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd368091</doc-id>
        /// <unmanaged>textPosition</unmanaged>
        /// <unmanaged-short>textPosition</unmanaged-short>
        public System.Int32 TextPosition;
    }

    /// <summary>
    /// <p>Describes the region obtained by a hit test.</p>
    /// </summary>
    /// <doc-id>dd368092</doc-id>
    /// <unmanaged>DWRITE_HIT_TEST_METRICS</unmanaged>
    /// <unmanaged-short>DWRITE_HIT_TEST_METRICS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct HitTestMetrics
    {
        /// <summary>
        /// <dd> <p>The first text position within the hit region. </p> </dd>
        /// </summary>
        /// <doc-id>dd368092</doc-id>
        /// <unmanaged>textPosition</unmanaged>
        /// <unmanaged-short>textPosition</unmanaged-short>
        public System.Int32 TextPosition;
        /// <summary>
        /// <dd> <p>The number of text positions within the hit region. </p> </dd>
        /// </summary>
        /// <doc-id>dd368092</doc-id>
        /// <unmanaged>length</unmanaged>
        /// <unmanaged-short>length</unmanaged-short>
        public System.Int32 Length;
        /// <summary>
        /// <dd> <p>The x-coordinate of the upper-left corner of the hit region.</p> </dd>
        /// </summary>
        /// <doc-id>dd368092</doc-id>
        /// <unmanaged>left</unmanaged>
        /// <unmanaged-short>left</unmanaged-short>
        public System.Single Left;
        /// <summary>
        /// <dd> <p>The y-coordinate of the upper-left corner of the hit region.</p> </dd>
        /// </summary>
        /// <doc-id>dd368092</doc-id>
        /// <unmanaged>top</unmanaged>
        /// <unmanaged-short>top</unmanaged-short>
        public System.Single Top;
        /// <summary>
        /// <dd> <p>The width of the hit region.</p> </dd>
        /// </summary>
        /// <doc-id>dd368092</doc-id>
        /// <unmanaged>width</unmanaged>
        /// <unmanaged-short>width</unmanaged-short>
        public System.Single Width;
        /// <summary>
        /// <dd> <p>The height of the hit region.</p> </dd>
        /// </summary>
        /// <doc-id>dd368092</doc-id>
        /// <unmanaged>height</unmanaged>
        /// <unmanaged-short>height</unmanaged-short>
        public System.Single Height;
        /// <summary>
        /// <dd> <p>The <strong>BIDI level</strong> of the text positions within the hit region.</p> </dd>
        /// </summary>
        /// <doc-id>dd368092</doc-id>
        /// <unmanaged>bidiLevel</unmanaged>
        /// <unmanaged-short>bidiLevel</unmanaged-short>
        public System.Int32 BidiLevel;
        /// <summary>
        /// <dd> <p>true if the hit region contains text; otherwise, false.</p> </dd>
        /// </summary>
        /// <doc-id>dd368092</doc-id>
        /// <unmanaged>isText</unmanaged>
        /// <unmanaged-short>isText</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsText;
        /// <summary>
        /// <dd> <p>true if the text range is trimmed; otherwise, false.</p> </dd>
        /// </summary>
        /// <doc-id>dd368092</doc-id>
        /// <unmanaged>isTrimmed</unmanaged>
        /// <unmanaged-short>isTrimmed</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsTrimmed;
    }

    /// <summary>
    /// <p>Contains properties describing the geometric measurement of an
    /// application-defined inline object.</p>
    /// </summary>
    /// <doc-id>dd368096</doc-id>
    /// <unmanaged>DWRITE_INLINE_OBJECT_METRICS</unmanaged>
    /// <unmanaged-short>DWRITE_INLINE_OBJECT_METRICS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct InlineObjectMetrics
    {
        /// <summary>
        /// <dd> <p>The width of the inline object.</p> </dd>
        /// </summary>
        /// <doc-id>dd368096</doc-id>
        /// <unmanaged>width</unmanaged>
        /// <unmanaged-short>width</unmanaged-short>
        public System.Single Width;
        /// <summary>
        /// <dd> <p>The height of the inline object.</p> </dd>
        /// </summary>
        /// <doc-id>dd368096</doc-id>
        /// <unmanaged>height</unmanaged>
        /// <unmanaged-short>height</unmanaged-short>
        public System.Single Height;
        /// <summary>
        /// <dd> <p>The distance from the top of the object to the point where it is lined up with the adjacent text.  If the baseline is at the bottom, then <strong>baseline</strong> simply equals <strong>height</strong>.</p> </dd>
        /// </summary>
        /// <doc-id>dd368096</doc-id>
        /// <unmanaged>baseline</unmanaged>
        /// <unmanaged-short>baseline</unmanaged-short>
        public System.Single Baseline;
        /// <summary>
        /// <dd> <p>A Boolean flag that indicates whether the object is to be placed upright or alongside the text baseline for vertical text.</p> </dd>
        /// </summary>
        /// <doc-id>dd368096</doc-id>
        /// <unmanaged>supportsSideways</unmanaged>
        /// <unmanaged-short>supportsSideways</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool SupportsSideways;
    }

    /// <summary>
    /// <p>The <strong><see cref = "SharpDX.DirectWrite.JustificationOpportunity"/></strong> structure specifies justification info per glyph.</p>
    /// </summary>
    /// <doc-id>jj126261</doc-id>
    /// <unmanaged>DWRITE_JUSTIFICATION_OPPORTUNITY</unmanaged>
    /// <unmanaged-short>DWRITE_JUSTIFICATION_OPPORTUNITY</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Explicit, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct JustificationOpportunity
    {
        /// <summary>
        /// <dd> <p>Minimum amount of expansion to apply to the side of the glyph. This might vary from zero to infinity, typically being zero except for kashida.</p> </dd>
        /// </summary>
        /// <doc-id>jj126261</doc-id>
        /// <unmanaged>expansionMinimum</unmanaged>
        /// <unmanaged-short>expansionMinimum</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(0)]
        public System.Single ExpansionMinimum;
        /// <summary>
        /// <dd> <p>Maximum amount of expansion to apply to the side of the glyph. This might vary from zero to infinity, being zero for fixed-size characters and connected scripts, and non-zero for discrete scripts, and non-zero for cursive scripts at expansion points.</p> </dd>
        /// </summary>
        /// <doc-id>jj126261</doc-id>
        /// <unmanaged>expansionMaximum</unmanaged>
        /// <unmanaged-short>expansionMaximum</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(4)]
        public System.Single ExpansionMaximum;
        /// <summary>
        /// <dd> <p>Maximum amount of compression to apply to the side of the glyph. This might vary from zero up to the glyph cluster size.</p> </dd>
        /// </summary>
        /// <doc-id>jj126261</doc-id>
        /// <unmanaged>compressionMaximum</unmanaged>
        /// <unmanaged-short>compressionMaximum</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public System.Single CompressionMaximum;
        /// <summary>
        /// <dd> <p>Priority of this expansion point. Larger priorities are applied later, while priority zero does nothing.</p> </dd>
        /// </summary>
        /// <doc-id>jj126261</doc-id>
        /// <unmanaged>expansionPriority</unmanaged>
        /// <unmanaged-short>expansionPriority</unmanaged-short>
        public System.Int32 ExpansionPriority
        {
            get => (System.Int32)((_ExpansionPriority >> 0) & 255);
            set => this._ExpansionPriority = (System.Int32)((this._ExpansionPriority & ~(255 << 0)) | ((value & 255) << 0));
        }

        [System.Runtime.InteropServices.FieldOffset(12)]
        internal System.Int32 _ExpansionPriority;
        /// <summary>
        /// <dd> <p>Priority of this compression point. Larger priorities are applied later, while priority zero does nothing.</p> </dd>
        /// </summary>
        /// <doc-id>jj126261</doc-id>
        /// <unmanaged>compressionPriority</unmanaged>
        /// <unmanaged-short>compressionPriority</unmanaged-short>
        public System.Int32 CompressionPriority
        {
            get => (System.Int32)((_CompressionPriority >> 8) & 255);
            set => this._CompressionPriority = (System.Int32)((this._CompressionPriority & ~(255 << 8)) | ((value & 255) << 8));
        }

        [System.Runtime.InteropServices.FieldOffset(12)]
        internal System.Int32 _CompressionPriority;
        /// <summary>
        /// <dd> <p>Allow this expansion point to use up any remaining slack space even after all expansion priorities have been used up.</p> </dd>
        /// </summary>
        /// <doc-id>jj126261</doc-id>
        /// <unmanaged>allowResidualExpansion</unmanaged>
        /// <unmanaged-short>allowResidualExpansion</unmanaged-short>
        public bool AllowResidualExpansion
        {
            get => 0 != ((_AllowResidualExpansion >> 16) & 1);
            set => this._AllowResidualExpansion = (System.Int32)((this._AllowResidualExpansion & ~(1 << 16)) | (((value ? 1 : 0) & 1) << 16));
        }

        [System.Runtime.InteropServices.FieldOffset(12)]
        internal System.Int32 _AllowResidualExpansion;
        /// <summary>
        /// <dd> <p>Allow this compression point to use up any remaining space even after all compression priorities have been used up.</p> </dd>
        /// </summary>
        /// <doc-id>jj126261</doc-id>
        /// <unmanaged>allowResidualCompression</unmanaged>
        /// <unmanaged-short>allowResidualCompression</unmanaged-short>
        public bool AllowResidualCompression
        {
            get => 0 != ((_AllowResidualCompression >> 17) & 1);
            set => this._AllowResidualCompression = (System.Int32)((this._AllowResidualCompression & ~(1 << 17)) | (((value ? 1 : 0) & 1) << 17));
        }

        [System.Runtime.InteropServices.FieldOffset(12)]
        internal System.Int32 _AllowResidualCompression;
        /// <summary>
        /// <dd> <p>Apply expansion and compression to the leading edge of the glyph. This bit is <strong><see cref = "SharpDX.Result.False"/></strong> (0) for connected scripts, fixed-size characters, and diacritics. It is generally <strong><see cref = "SharpDX.Result.False"/></strong> within a multi-glyph cluster, unless the script allows expansion of glyphs within a cluster, like Thai.</p> </dd>
        /// </summary>
        /// <doc-id>jj126261</doc-id>
        /// <unmanaged>applyToLeadingEdge</unmanaged>
        /// <unmanaged-short>applyToLeadingEdge</unmanaged-short>
        public bool ApplyToLeadingEdge
        {
            get => 0 != ((_ApplyToLeadingEdge >> 18) & 1);
            set => this._ApplyToLeadingEdge = (System.Int32)((this._ApplyToLeadingEdge & ~(1 << 18)) | (((value ? 1 : 0) & 1) << 18));
        }

        [System.Runtime.InteropServices.FieldOffset(12)]
        internal System.Int32 _ApplyToLeadingEdge;
        /// <summary>
        /// <dd> <p>Apply expansion and compression to the trailing edge of the glyph. This bit is <strong><see cref = "SharpDX.Result.False"/></strong> (0) for connected scripts, fixed-size characters, and diacritics. It is generally <strong><see cref = "SharpDX.Result.False"/></strong> within a multi-glyph cluster, unless the script allows expansion of glyphs within a cluster, like Thai.</p> </dd>
        /// </summary>
        /// <doc-id>jj126261</doc-id>
        /// <unmanaged>applyToTrailingEdge</unmanaged>
        /// <unmanaged-short>applyToTrailingEdge</unmanaged-short>
        public bool ApplyToTrailingEdge
        {
            get => 0 != ((_ApplyToTrailingEdge >> 19) & 1);
            set => this._ApplyToTrailingEdge = (System.Int32)((this._ApplyToTrailingEdge & ~(1 << 19)) | (((value ? 1 : 0) & 1) << 19));
        }

        [System.Runtime.InteropServices.FieldOffset(12)]
        internal System.Int32 _ApplyToTrailingEdge;
        /// <summary>
        /// <dd> <p>Reserved</p> </dd>
        /// </summary>
        /// <doc-id>jj126261</doc-id>
        /// <unmanaged>reserved</unmanaged>
        /// <unmanaged-short>reserved</unmanaged-short>
        public System.Int32 Reserved
        {
            get => (System.Int32)((_Reserved >> 20) & 4095);
            set => this._Reserved = (System.Int32)((this._Reserved & ~(4095 << 20)) | ((value & 4095) << 20));
        }

        [System.Runtime.InteropServices.FieldOffset(12)]
        internal System.Int32 _Reserved;
    }

    /// <summary>
    /// <p>Line breakpoint characteristics of a character.</p>
    /// </summary>
    /// <doc-id>dd368098</doc-id>
    /// <unmanaged>DWRITE_LINE_BREAKPOINT</unmanaged>
    /// <unmanaged-short>DWRITE_LINE_BREAKPOINT</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Explicit, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct LineBreakpoint
    {
        /// <summary>
        /// <dd> <p>Indicates a breaking condition before the character.</p> </dd>
        /// </summary>
        /// <doc-id>dd368098</doc-id>
        /// <unmanaged>breakConditionBefore</unmanaged>
        /// <unmanaged-short>breakConditionBefore</unmanaged-short>
        internal System.Byte BreakConditionBefore_
        {
            get => (System.Byte)((_BreakConditionBefore_ >> 0) & 3);
            set => this._BreakConditionBefore_ = (System.Byte)((this._BreakConditionBefore_ & ~(3 << 0)) | ((value & 3) << 0));
        }

        [System.Runtime.InteropServices.FieldOffset(0)]
        internal System.Byte _BreakConditionBefore_;
        /// <summary>
        /// <dd> <p>Indicates a breaking condition after the character.</p> </dd>
        /// </summary>
        /// <doc-id>dd368098</doc-id>
        /// <unmanaged>breakConditionAfter</unmanaged>
        /// <unmanaged-short>breakConditionAfter</unmanaged-short>
        internal System.Byte BreakConditionAfter_
        {
            get => (System.Byte)((_BreakConditionAfter_ >> 2) & 3);
            set => this._BreakConditionAfter_ = (System.Byte)((this._BreakConditionAfter_ & ~(3 << 2)) | ((value & 3) << 2));
        }

        [System.Runtime.InteropServices.FieldOffset(0)]
        internal System.Byte _BreakConditionAfter_;
        /// <summary>
        /// <dd> <p>Indicates that the character is some form of whitespace, which may be meaningful for justification.</p> </dd>
        /// </summary>
        /// <doc-id>dd368098</doc-id>
        /// <unmanaged>isWhitespace</unmanaged>
        /// <unmanaged-short>isWhitespace</unmanaged-short>
        public bool IsWhitespace
        {
            get => 0 != ((_IsWhitespace >> 4) & 1);
            set => this._IsWhitespace = (System.Byte)((this._IsWhitespace & ~(1 << 4)) | (((value ? 1 : 0) & 1) << 4));
        }

        [System.Runtime.InteropServices.FieldOffset(0)]
        internal System.Byte _IsWhitespace;
        /// <summary>
        /// <dd> <p>Indicates that the character is a soft hyphen, often used to indicate hyphenation points inside words.</p> </dd>
        /// </summary>
        /// <doc-id>dd368098</doc-id>
        /// <unmanaged>isSoftHyphen</unmanaged>
        /// <unmanaged-short>isSoftHyphen</unmanaged-short>
        public bool IsSoftHyphen
        {
            get => 0 != ((_IsSoftHyphen >> 5) & 1);
            set => this._IsSoftHyphen = (System.Byte)((this._IsSoftHyphen & ~(1 << 5)) | (((value ? 1 : 0) & 1) << 5));
        }

        [System.Runtime.InteropServices.FieldOffset(0)]
        internal System.Byte _IsSoftHyphen;
        /// <summary>
        /// <dd> <p>Reserved for future use.</p> </dd>
        /// </summary>
        /// <doc-id>dd368098</doc-id>
        /// <unmanaged>padding</unmanaged>
        /// <unmanaged-short>padding</unmanaged-short>
        internal System.Byte Padding
        {
            get => (System.Byte)((_Padding >> 6) & 3);
            set => this._Padding = (System.Byte)((this._Padding & ~(3 << 6)) | ((value & 3) << 6));
        }

        [System.Runtime.InteropServices.FieldOffset(0)]
        internal System.Byte _Padding;
    }

    /// <summary>
    /// <p>Contains information about a formatted line of text.</p>
    /// </summary>
    /// <doc-id>dd368099</doc-id>
    /// <unmanaged>DWRITE_LINE_METRICS</unmanaged>
    /// <unmanaged-short>DWRITE_LINE_METRICS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct LineMetrics
    {
        /// <summary>
        /// <dd> <p>The number of text positions in the text line.  This includes any trailing whitespace and newline characters.</p> </dd>
        /// </summary>
        /// <doc-id>dd368099</doc-id>
        /// <unmanaged>length</unmanaged>
        /// <unmanaged-short>length</unmanaged-short>
        public System.Int32 Length;
        /// <summary>
        /// <dd> <p>The number of whitespace positions at the end of the text line.  Newline sequences are considered whitespace.</p> </dd>
        /// </summary>
        /// <doc-id>dd368099</doc-id>
        /// <unmanaged>trailingWhitespaceLength</unmanaged>
        /// <unmanaged-short>trailingWhitespaceLength</unmanaged-short>
        public System.Int32 TrailingWhitespaceLength;
        /// <summary>
        /// <dd> <p>The number of characters in the newline sequence at the end of the text line.  If the count is zero, then the text line was either wrapped or it is the end of the text.</p> </dd>
        /// </summary>
        /// <doc-id>dd368099</doc-id>
        /// <unmanaged>newlineLength</unmanaged>
        /// <unmanaged-short>newlineLength</unmanaged-short>
        public System.Int32 NewlineLength;
        /// <summary>
        /// <dd> <p>The height of the text line.</p> </dd>
        /// </summary>
        /// <doc-id>dd368099</doc-id>
        /// <unmanaged>height</unmanaged>
        /// <unmanaged-short>height</unmanaged-short>
        public System.Single Height;
        /// <summary>
        /// <dd> <p>The distance from the top of the text line to its baseline.</p> </dd>
        /// </summary>
        /// <doc-id>dd368099</doc-id>
        /// <unmanaged>baseline</unmanaged>
        /// <unmanaged-short>baseline</unmanaged-short>
        public System.Single Baseline;
        /// <summary>
        /// <dd> <p>The line is trimmed.</p> </dd>
        /// </summary>
        /// <doc-id>dd368099</doc-id>
        /// <unmanaged>isTrimmed</unmanaged>
        /// <unmanaged-short>isTrimmed</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsTrimmed;
    }

    /// <summary>
    /// <p>Contains information about a formatted line of text.</p>
    /// </summary>
    /// <doc-id>dn933215</doc-id>
    /// <unmanaged>DWRITE_LINE_METRICS1</unmanaged>
    /// <unmanaged-short>DWRITE_LINE_METRICS1</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct LineMetrics1
    {
        /// <summary>
        /// <dd> <p>The number of text positions in the text line.  This includes any trailing whitespace and newline characters.</p> </dd>
        /// </summary>
        /// <doc-id>dd368099</doc-id>
        /// <unmanaged>length</unmanaged>
        /// <unmanaged-short>length</unmanaged-short>
        public System.Int32 Length;
        /// <summary>
        /// <dd> <p>The number of whitespace positions at the end of the text line.  Newline sequences are considered whitespace.</p> </dd>
        /// </summary>
        /// <doc-id>dd368099</doc-id>
        /// <unmanaged>trailingWhitespaceLength</unmanaged>
        /// <unmanaged-short>trailingWhitespaceLength</unmanaged-short>
        public System.Int32 TrailingWhitespaceLength;
        /// <summary>
        /// <dd> <p>The number of characters in the newline sequence at the end of the text line.  If the count is zero, then the text line was either wrapped or it is the end of the text.</p> </dd>
        /// </summary>
        /// <doc-id>dd368099</doc-id>
        /// <unmanaged>newlineLength</unmanaged>
        /// <unmanaged-short>newlineLength</unmanaged-short>
        public System.Int32 NewlineLength;
        /// <summary>
        /// <dd> <p>The height of the text line.</p> </dd>
        /// </summary>
        /// <doc-id>dd368099</doc-id>
        /// <unmanaged>height</unmanaged>
        /// <unmanaged-short>height</unmanaged-short>
        public System.Single Height;
        /// <summary>
        /// <dd> <p>The distance from the top of the text line to its baseline.</p> </dd>
        /// </summary>
        /// <doc-id>dd368099</doc-id>
        /// <unmanaged>baseline</unmanaged>
        /// <unmanaged-short>baseline</unmanaged-short>
        public System.Single Baseline;
        /// <summary>
        /// <dd> <p>The line is trimmed.</p> </dd>
        /// </summary>
        /// <doc-id>dd368099</doc-id>
        /// <unmanaged>isTrimmed</unmanaged>
        /// <unmanaged-short>isTrimmed</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsTrimmed;
        /// <summary>
        /// <dd> <p>White space before the content of the line. This is included in the line height and baseline distances. If the line is formatted horizontally either with a uniform line spacing or with proportional line spacing, this value represents the extra space above the content.</p> </dd>
        /// </summary>
        /// <doc-id>dn933215</doc-id>
        /// <unmanaged>leadingBefore</unmanaged>
        /// <unmanaged-short>leadingBefore</unmanaged-short>
        public System.Single LeadingBefore;
        /// <summary>
        /// <dd> <p>White space after the content of the line. This is included in the height of the line. If the line is formatted horizontally either with a uniform line spacing or with proportional line spacing, this value represents the extra space below the content.</p> </dd>
        /// </summary>
        /// <doc-id>dn933215</doc-id>
        /// <unmanaged>leadingAfter</unmanaged>
        /// <unmanaged-short>leadingAfter</unmanaged-short>
        public System.Single LeadingAfter;
    }

    /// <summary>
    /// <p></p>
    /// </summary>
    /// <doc-id>dn933216</doc-id>
    /// <unmanaged>DWRITE_LINE_SPACING</unmanaged>
    /// <unmanaged-short>DWRITE_LINE_SPACING</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct LineSpacing
    {
        /// <summary>
        /// <dd> <p>Method used to determine line spacing.</p> </dd>
        /// </summary>
        /// <doc-id>dn933216</doc-id>
        /// <unmanaged>method</unmanaged>
        /// <unmanaged-short>method</unmanaged-short>
        public SharpDX.DirectWrite.LineSpacingMethod Method;
        /// <summary>
        /// <dd> <p>Spacing between lines. The interpretation of this parameter depends upon the line spacing method, as follows: </p> <ul> <li>Line spacing: ignored</li> <li>uniform line spacing: explicit distance in DIPs between lines</li> <li>proportional line spacing: a scaling factor to be applied to the computed line height;  for each line, the height of the line is computed as for default line spacing, and the scaling factor is applied to that value.</li> </ul> </dd>
        /// </summary>
        /// <doc-id>dn933216</doc-id>
        /// <unmanaged>height</unmanaged>
        /// <unmanaged-short>height</unmanaged-short>
        public System.Single Height;
        /// <summary>
        /// <dd> <p>Distance from top of line to baseline.  The interpretation of this parameter depends upon the line spacing method, as follows: </p> <ul> <li>default line spacing: ignored</li> <li>uniform line spacing: explicit distance in DIPs from the top of the line to the baseline</li> <li>proportional line spacing: a scaling factor applied to the computed baseline; for each line,  the baseline distance is computed as for default line spacing, and the scaling factor is applied to that value.</li> </ul> </dd>
        /// </summary>
        /// <doc-id>dn933216</doc-id>
        /// <unmanaged>baseline</unmanaged>
        /// <unmanaged-short>baseline</unmanaged-short>
        public System.Single Baseline;
        /// <summary>
        /// <dd> <p>Proportion of the entire leading distributed before the line. The allowed value is between 0 and 1.0. The remaining leading is distributed after the line. It is ignored for the default and uniform line spacing methods. The leading that is available to distribute before or after the line depends on the values of the height and baseline parameters.</p> </dd>
        /// </summary>
        /// <doc-id>dn933216</doc-id>
        /// <unmanaged>leadingBefore</unmanaged>
        /// <unmanaged-short>leadingBefore</unmanaged-short>
        public System.Single LeadingBefore;
        /// <summary>
        /// <dd> <p>Specify whether <strong><see cref = "SharpDX.DirectWrite.FontMetrics"/></strong>::lineGap value should be part of the line metrics.</p> </dd>
        /// </summary>
        /// <doc-id>dn933216</doc-id>
        /// <unmanaged>fontLineGapUsage</unmanaged>
        /// <unmanaged-short>fontLineGapUsage</unmanaged-short>
        public SharpDX.DirectWrite.FontLineGapUsage FontLineGapUsage;
    }

    /// <summary>
    /// <p>Indicates how much any visible DIPs (device independent pixels) overshoot each side of the layout or inline objects.</p><p>Positive overhangs indicate that the visible area extends outside the layout box or inline object, while negative values mean there is whitespace inside. The returned values are unaffected by rendering transforms or pixel snapping.  Additionally, they may not exactly match the final target's pixel bounds after applying grid fitting and hinting.</p>
    /// </summary>
    /// <doc-id>dd368109</doc-id>
    /// <unmanaged>DWRITE_OVERHANG_METRICS</unmanaged>
    /// <unmanaged-short>DWRITE_OVERHANG_METRICS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct OverhangMetrics
    {
        /// <summary>
        /// <dd> <p>The distance from the left-most visible DIP to its  left-alignment edge.</p> </dd>
        /// </summary>
        /// <doc-id>dd368109</doc-id>
        /// <unmanaged>left</unmanaged>
        /// <unmanaged-short>left</unmanaged-short>
        public System.Single Left;
        /// <summary>
        /// <dd> <p>The distance from the top-most visible DIP to its  top alignment edge.</p> </dd>
        /// </summary>
        /// <doc-id>dd368109</doc-id>
        /// <unmanaged>top</unmanaged>
        /// <unmanaged-short>top</unmanaged-short>
        public System.Single Top;
        /// <summary>
        /// <dd> <p>The distance from the right-most visible DIP to its  right-alignment edge.</p> </dd>
        /// </summary>
        /// <doc-id>dd368109</doc-id>
        /// <unmanaged>right</unmanaged>
        /// <unmanaged-short>right</unmanaged-short>
        public System.Single Right;
        /// <summary>
        /// <dd> <p>The distance from the bottom-most visible DIP to its lower-alignment edge.</p> </dd>
        /// </summary>
        /// <doc-id>dd368109</doc-id>
        /// <unmanaged>bottom</unmanaged>
        /// <unmanaged-short>bottom</unmanaged-short>
        public System.Single Bottom;
    }

    /// <summary>
    /// <p>The <strong><see cref = "SharpDX.DirectWrite.Panose"/></strong> union describes typeface classification values that you use with <strong>IDWriteFont1::GetPanose</strong> to select and match the font.</p>
    /// </summary>
    /// <remarks>
    /// <strong>Note</strong>??The <strong>familyKind</strong> member (index 0) is the only stable entry in the 10-byte array because all the entries that follow can change dynamically depending on the context of the first member.?
    /// </remarks>
    /// <doc-id>hh995027</doc-id>
    /// <unmanaged>DWRITE_PANOSE</unmanaged>
    /// <unmanaged-short>DWRITE_PANOSE</unmanaged-short>
    public partial struct Panose
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh995027</doc-id>
        /// <unmanaged>values</unmanaged>
        /// <unmanaged-short>values</unmanaged-short>
        public System.Byte[] Values
        {
            get => _Values ?? (_Values = new System.Byte[10]);
            private set => _Values = value;
        }

        internal System.Byte[] _Values;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh995027</doc-id>
        /// <unmanaged>familyKind</unmanaged>
        /// <unmanaged-short>familyKind</unmanaged-short>
        public System.Byte FamilyKind;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh995027</doc-id>
        /// <unmanaged>text</unmanaged>
        /// <unmanaged-short>text</unmanaged-short>
        public SharpDX.DirectWrite.PanoseText Text;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh995027</doc-id>
        /// <unmanaged>script</unmanaged>
        /// <unmanaged-short>script</unmanaged-short>
        public SharpDX.DirectWrite.PanoseScript Script;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh995027</doc-id>
        /// <unmanaged>decorative</unmanaged>
        /// <unmanaged-short>decorative</unmanaged-short>
        public SharpDX.DirectWrite.PanoseDecorative Decorative;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh995027</doc-id>
        /// <unmanaged>symbol</unmanaged>
        /// <unmanaged-short>symbol</unmanaged-short>
        public SharpDX.DirectWrite.PanoseSymbol Symbol;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Explicit, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            [System.Runtime.InteropServices.FieldOffset(0)]
            public System.Byte Values;
            [System.Runtime.InteropServices.FieldOffset(1)]
            public System.Byte __Values1;
            [System.Runtime.InteropServices.FieldOffset(2)]
            public System.Byte __Values2;
            [System.Runtime.InteropServices.FieldOffset(3)]
            public System.Byte __Values3;
            [System.Runtime.InteropServices.FieldOffset(4)]
            public System.Byte __Values4;
            [System.Runtime.InteropServices.FieldOffset(5)]
            public System.Byte __Values5;
            [System.Runtime.InteropServices.FieldOffset(6)]
            public System.Byte __Values6;
            [System.Runtime.InteropServices.FieldOffset(7)]
            public System.Byte __Values7;
            [System.Runtime.InteropServices.FieldOffset(8)]
            public System.Byte __Values8;
            [System.Runtime.InteropServices.FieldOffset(9)]
            public System.Byte __Values9;
            [System.Runtime.InteropServices.FieldOffset(0)]
            public System.Byte FamilyKind;
            [System.Runtime.InteropServices.FieldOffset(0)]
            public SharpDX.DirectWrite.PanoseText Text;
            [System.Runtime.InteropServices.FieldOffset(0)]
            public SharpDX.DirectWrite.PanoseScript Script;
            [System.Runtime.InteropServices.FieldOffset(0)]
            public SharpDX.DirectWrite.PanoseDecorative Decorative;
            [System.Runtime.InteropServices.FieldOffset(0)]
            public SharpDX.DirectWrite.PanoseSymbol Symbol;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            fixed (void *__to = &Values[0], __from = &@ref.Values)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 10 * sizeof (System.Byte));
            FamilyKind = @ref.FamilyKind;
            Text = @ref.Text;
            Script = @ref.Script;
            Decorative = @ref.Decorative;
            Symbol = @ref.Symbol;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            fixed (void *__from = &Values[0], __to = &@ref.Values)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 10 * sizeof (System.Byte));
            @ref.FamilyKind = FamilyKind;
            @ref.Text = Text;
            @ref.Script = Script;
            @ref.Decorative = Decorative;
            @ref.Symbol = Symbol;
        }
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>DWRITE_PANOSE_INNER_2</unmanaged>
    /// <unmanaged-short>DWRITE_PANOSE_INNER_2</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct PanoseDecorative
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>familyKind</unmanaged>
        /// <unmanaged-short>familyKind</unmanaged-short>
        public System.Byte FamilyKind;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>decorativeClass</unmanaged>
        /// <unmanaged-short>decorativeClass</unmanaged-short>
        public System.Byte DecorativeClass;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>weight</unmanaged>
        /// <unmanaged-short>weight</unmanaged-short>
        public System.Byte Weight;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>aspect</unmanaged>
        /// <unmanaged-short>aspect</unmanaged-short>
        public System.Byte Aspect;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>contrast</unmanaged>
        /// <unmanaged-short>contrast</unmanaged-short>
        public System.Byte Contrast;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>serifVariant</unmanaged>
        /// <unmanaged-short>serifVariant</unmanaged-short>
        public System.Byte SerifVariant;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>fill</unmanaged>
        /// <unmanaged-short>fill</unmanaged-short>
        public System.Byte Fill;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>lining</unmanaged>
        /// <unmanaged-short>lining</unmanaged-short>
        public System.Byte Lining;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>decorativeTopology</unmanaged>
        /// <unmanaged-short>decorativeTopology</unmanaged-short>
        public System.Byte DecorativeTopology;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>characterRange</unmanaged>
        /// <unmanaged-short>characterRange</unmanaged-short>
        public System.Byte CharacterRange;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>DWRITE_PANOSE_INNER_1</unmanaged>
    /// <unmanaged-short>DWRITE_PANOSE_INNER_1</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct PanoseScript
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>familyKind</unmanaged>
        /// <unmanaged-short>familyKind</unmanaged-short>
        public System.Byte FamilyKind;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>toolKind</unmanaged>
        /// <unmanaged-short>toolKind</unmanaged-short>
        public System.Byte ToolKind;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>weight</unmanaged>
        /// <unmanaged-short>weight</unmanaged-short>
        public System.Byte Weight;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>spacing</unmanaged>
        /// <unmanaged-short>spacing</unmanaged-short>
        public System.Byte Spacing;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>aspectRatio</unmanaged>
        /// <unmanaged-short>aspectRatio</unmanaged-short>
        public System.Byte AspectRatio;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>contrast</unmanaged>
        /// <unmanaged-short>contrast</unmanaged-short>
        public System.Byte Contrast;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>scriptTopology</unmanaged>
        /// <unmanaged-short>scriptTopology</unmanaged-short>
        public System.Byte ScriptTopology;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>scriptForm</unmanaged>
        /// <unmanaged-short>scriptForm</unmanaged-short>
        public System.Byte ScriptForm;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>finials</unmanaged>
        /// <unmanaged-short>finials</unmanaged-short>
        public System.Byte Finials;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>xAscent</unmanaged>
        /// <unmanaged-short>xAscent</unmanaged-short>
        public System.Byte XAscent;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>DWRITE_PANOSE_INNER_3</unmanaged>
    /// <unmanaged-short>DWRITE_PANOSE_INNER_3</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct PanoseSymbol
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>familyKind</unmanaged>
        /// <unmanaged-short>familyKind</unmanaged-short>
        public System.Byte FamilyKind;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>symbolKind</unmanaged>
        /// <unmanaged-short>symbolKind</unmanaged-short>
        public System.Byte SymbolKind;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>weight</unmanaged>
        /// <unmanaged-short>weight</unmanaged-short>
        public System.Byte Weight;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>spacing</unmanaged>
        /// <unmanaged-short>spacing</unmanaged-short>
        public System.Byte Spacing;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>aspectRatioAndContrast</unmanaged>
        /// <unmanaged-short>aspectRatioAndContrast</unmanaged-short>
        public System.Byte AspectRatioAndContrast;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>aspectRatio94</unmanaged>
        /// <unmanaged-short>aspectRatio94</unmanaged-short>
        public System.Byte AspectRatio94;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>aspectRatio119</unmanaged>
        /// <unmanaged-short>aspectRatio119</unmanaged-short>
        public System.Byte AspectRatio119;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>aspectRatio157</unmanaged>
        /// <unmanaged-short>aspectRatio157</unmanaged-short>
        public System.Byte AspectRatio157;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>aspectRatio163</unmanaged>
        /// <unmanaged-short>aspectRatio163</unmanaged-short>
        public System.Byte AspectRatio163;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>aspectRatio211</unmanaged>
        /// <unmanaged-short>aspectRatio211</unmanaged-short>
        public System.Byte AspectRatio211;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>DWRITE_PANOSE_INNER_0</unmanaged>
    /// <unmanaged-short>DWRITE_PANOSE_INNER_0</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct PanoseText
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>familyKind</unmanaged>
        /// <unmanaged-short>familyKind</unmanaged-short>
        public System.Byte FamilyKind;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>serifStyle</unmanaged>
        /// <unmanaged-short>serifStyle</unmanaged-short>
        public System.Byte SerifStyle;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>weight</unmanaged>
        /// <unmanaged-short>weight</unmanaged-short>
        public System.Byte Weight;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>proportion</unmanaged>
        /// <unmanaged-short>proportion</unmanaged-short>
        public System.Byte Proportion;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>contrast</unmanaged>
        /// <unmanaged-short>contrast</unmanaged-short>
        public System.Byte Contrast;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>strokeVariation</unmanaged>
        /// <unmanaged-short>strokeVariation</unmanaged-short>
        public System.Byte StrokeVariation;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>armStyle</unmanaged>
        /// <unmanaged-short>armStyle</unmanaged-short>
        public System.Byte ArmStyle;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>letterform</unmanaged>
        /// <unmanaged-short>letterform</unmanaged-short>
        public System.Byte Letterform;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>midline</unmanaged>
        /// <unmanaged-short>midline</unmanaged-short>
        public System.Byte Midline;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>xHeight</unmanaged>
        /// <unmanaged-short>xHeight</unmanaged-short>
        public System.Byte XHeight;
    }

    /// <summary>
    /// <p>Stores the association of text and its writing system script, as well as some display attributes.</p>
    /// </summary>
    /// <doc-id>dd368120</doc-id>
    /// <unmanaged>DWRITE_SCRIPT_ANALYSIS</unmanaged>
    /// <unmanaged-short>DWRITE_SCRIPT_ANALYSIS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct ScriptAnalysis
    {
        /// <summary>
        /// <dd> <p>The zero-based index representation of writing system script.</p> </dd>
        /// </summary>
        /// <doc-id>dd368120</doc-id>
        /// <unmanaged>script</unmanaged>
        /// <unmanaged-short>script</unmanaged-short>
        public System.Int16 Script;
        /// <summary>
        /// <dd> <p>A value that indicates additional shaping requirement of text.</p> </dd>
        /// </summary>
        /// <doc-id>dd368120</doc-id>
        /// <unmanaged>shapes</unmanaged>
        /// <unmanaged-short>shapes</unmanaged-short>
        public SharpDX.DirectWrite.ScriptShapes Shapes;
    }

    /// <summary>
    /// <p>The <strong><see cref = "SharpDX.DirectWrite.ScriptProperties"/></strong> structure specifies script properties for caret navigation and justification.</p>
    /// </summary>
    /// <doc-id>jj126264</doc-id>
    /// <unmanaged>DWRITE_SCRIPT_PROPERTIES</unmanaged>
    /// <unmanaged-short>DWRITE_SCRIPT_PROPERTIES</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Explicit, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct ScriptProperties
    {
        /// <summary>
        /// <dd> <p>The standardized four character code for the given script. </p> <strong>Note</strong>??These only include the general Unicode scripts, not any additional ISO 15924 scripts for bibliographic distinction. ? </dd>
        /// </summary>
        /// <doc-id>jj126264</doc-id>
        /// <unmanaged>isoScriptCode</unmanaged>
        /// <unmanaged-short>isoScriptCode</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(0)]
        public System.Int32 IsoScriptCode;
        /// <summary>
        /// <dd> <p>The standardized numeric code, ranging 0-999.</p> </dd>
        /// </summary>
        /// <doc-id>jj126264</doc-id>
        /// <unmanaged>isoScriptNumber</unmanaged>
        /// <unmanaged-short>isoScriptNumber</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(4)]
        public System.Int32 IsoScriptNumber;
        /// <summary>
        /// <dd> <p>Number of characters to estimate look-ahead for complex scripts. Latin and all Kana are generally 1. Indic scripts are up to 15, and most others are 8.</p> <strong>Note</strong>??Combining marks and variation selectors can produce clusters that are longer than these look-aheads, so this estimate is considered typical language use. Diacritics must be tested explicitly separately. ? </dd>
        /// </summary>
        /// <doc-id>jj126264</doc-id>
        /// <unmanaged>clusterLookahead</unmanaged>
        /// <unmanaged-short>clusterLookahead</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public System.Int32 ClusterLookahead;
        /// <summary>
        /// <dd> <p>Appropriate character to elongate the given script for justification. For example:</p> <ul> <li>Arabic    - U+0640 Tatweel</li> <li>Ogham     - U+1680 Ogham Space Mark</li> </ul> </dd>
        /// </summary>
        /// <doc-id>jj126264</doc-id>
        /// <unmanaged>justificationCharacter</unmanaged>
        /// <unmanaged-short>justificationCharacter</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(12)]
        public System.Int32 JustificationCharacter;
        /// <summary>
        /// <dd> <p>Restrict the caret to whole clusters, like Thai and Devanagari. Scripts such as Arabic by default allow navigation between clusters. Others like Thai always navigate across whole clusters.</p> </dd>
        /// </summary>
        /// <doc-id>jj126264</doc-id>
        /// <unmanaged>restrictCaretToClusters</unmanaged>
        /// <unmanaged-short>restrictCaretToClusters</unmanaged-short>
        public bool RestrictCaretToClusters
        {
            get => 0 != ((_RestrictCaretToClusters >> 0) & 1);
            set => this._RestrictCaretToClusters = (System.Int32)((this._RestrictCaretToClusters & ~(1 << 0)) | (((value ? 1 : 0) & 1) << 0));
        }

        [System.Runtime.InteropServices.FieldOffset(16)]
        internal System.Int32 _RestrictCaretToClusters;
        /// <summary>
        /// <dd> <p>The language uses dividers between words, such as spaces between Latin or the Ethiopic wordspace. Examples include Latin, Greek, Devanagari, and Ethiopic. Chinese, Korean, and Thai are excluded.</p> </dd>
        /// </summary>
        /// <doc-id>jj126264</doc-id>
        /// <unmanaged>usesWordDividers</unmanaged>
        /// <unmanaged-short>usesWordDividers</unmanaged-short>
        public bool UsesWordDividers
        {
            get => 0 != ((_UsesWordDividers >> 1) & 1);
            set => this._UsesWordDividers = (System.Int32)((this._UsesWordDividers & ~(1 << 1)) | (((value ? 1 : 0) & 1) << 1));
        }

        [System.Runtime.InteropServices.FieldOffset(16)]
        internal System.Int32 _UsesWordDividers;
        /// <summary>
        /// <dd> <p>The characters are discrete units from each other. This includes both block scripts and clustered scripts. Examples include Latin, Greek, Cyrillic, Hebrew, Chinese, and Thai.</p> </dd>
        /// </summary>
        /// <doc-id>jj126264</doc-id>
        /// <unmanaged>isDiscreteWriting</unmanaged>
        /// <unmanaged-short>isDiscreteWriting</unmanaged-short>
        public bool IsDiscreteWriting
        {
            get => 0 != ((_IsDiscreteWriting >> 2) & 1);
            set => this._IsDiscreteWriting = (System.Int32)((this._IsDiscreteWriting & ~(1 << 2)) | (((value ? 1 : 0) & 1) << 2));
        }

        [System.Runtime.InteropServices.FieldOffset(16)]
        internal System.Int32 _IsDiscreteWriting;
        /// <summary>
        /// <dd> <p>The language is a block script, expanding between characters. Examples include Chinese, Japanese, Korean, and Bopomofo.</p> </dd>
        /// </summary>
        /// <doc-id>jj126264</doc-id>
        /// <unmanaged>isBlockWriting</unmanaged>
        /// <unmanaged-short>isBlockWriting</unmanaged-short>
        public bool IsBlockWriting
        {
            get => 0 != ((_IsBlockWriting >> 3) & 1);
            set => this._IsBlockWriting = (System.Int32)((this._IsBlockWriting & ~(1 << 3)) | (((value ? 1 : 0) & 1) << 3));
        }

        [System.Runtime.InteropServices.FieldOffset(16)]
        internal System.Int32 _IsBlockWriting;
        /// <summary>
        /// <dd> <p>The language is justified within glyph clusters, not just between glyph clusters, such as the character sequence of Thai Lu and Sara Am (U+E026, U+E033), which form a single cluster but still expand between them. Examples include Thai, Lao, and Khmer.</p> </dd>
        /// </summary>
        /// <doc-id>jj126264</doc-id>
        /// <unmanaged>isDistributedWithinCluster</unmanaged>
        /// <unmanaged-short>isDistributedWithinCluster</unmanaged-short>
        public bool IsDistributedWithinCluster
        {
            get => 0 != ((_IsDistributedWithinCluster >> 4) & 1);
            set => this._IsDistributedWithinCluster = (System.Int32)((this._IsDistributedWithinCluster & ~(1 << 4)) | (((value ? 1 : 0) & 1) << 4));
        }

        [System.Runtime.InteropServices.FieldOffset(16)]
        internal System.Int32 _IsDistributedWithinCluster;
        /// <summary>
        /// <dd> <p>The script's clusters are connected to each other (such as the baseline-linked Devanagari), and no separation is added between characters.</p> <strong>Note</strong>??Cursively linked scripts like Arabic are also connected (but not all connected scripts are cursive).  ? <p>Examples include Devanagari, Arabic, Syriac, Bengala, Gurmukhi, and Ogham. Latin, Chinese, and Thaana are excluded.</p> </dd>
        /// </summary>
        /// <doc-id>jj126264</doc-id>
        /// <unmanaged>isConnectedWriting</unmanaged>
        /// <unmanaged-short>isConnectedWriting</unmanaged-short>
        public bool IsConnectedWriting
        {
            get => 0 != ((_IsConnectedWriting >> 5) & 1);
            set => this._IsConnectedWriting = (System.Int32)((this._IsConnectedWriting & ~(1 << 5)) | (((value ? 1 : 0) & 1) << 5));
        }

        [System.Runtime.InteropServices.FieldOffset(16)]
        internal System.Int32 _IsConnectedWriting;
        /// <summary>
        /// <dd> <p>The script is naturally cursive (Arabic and Syriac), meaning it uses other justification methods like kashida extension rather than inter-character spacing.</p> <strong>Note</strong>?? Although other scripts like Latin and Japanese might actually support handwritten cursive forms, they are not considered cursive scripts. ? <p>Examples include Arabic, Syriac, and Mongolian. Thaana, Devanagari, Latin, and Chinese are excluded.</p> </dd>
        /// </summary>
        /// <doc-id>jj126264</doc-id>
        /// <unmanaged>isCursiveWriting</unmanaged>
        /// <unmanaged-short>isCursiveWriting</unmanaged-short>
        public bool IsCursiveWriting
        {
            get => 0 != ((_IsCursiveWriting >> 6) & 1);
            set => this._IsCursiveWriting = (System.Int32)((this._IsCursiveWriting & ~(1 << 6)) | (((value ? 1 : 0) & 1) << 6));
        }

        [System.Runtime.InteropServices.FieldOffset(16)]
        internal System.Int32 _IsCursiveWriting;
        /// <summary>
        /// <dd> <p>Reserved</p> </dd>
        /// </summary>
        /// <doc-id>jj126264</doc-id>
        /// <unmanaged>reserved</unmanaged>
        /// <unmanaged-short>reserved</unmanaged-short>
        public System.Int32 Reserved
        {
            get => (System.Int32)((_Reserved >> 7) & 33554431);
            set => this._Reserved = (System.Int32)((this._Reserved & ~(33554431 << 7)) | ((value & 33554431) << 7));
        }

        [System.Runtime.InteropServices.FieldOffset(16)]
        internal System.Int32 _Reserved;
    }

    /// <summary>
    /// <p>Contains shaping output properties for an output glyph.</p>
    /// </summary>
    /// <doc-id>dd368123</doc-id>
    /// <unmanaged>DWRITE_SHAPING_GLYPH_PROPERTIES</unmanaged>
    /// <unmanaged-short>DWRITE_SHAPING_GLYPH_PROPERTIES</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Explicit, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct ShapingGlyphProperties
    {
        /// <summary>
        /// <dd> <p>Indicates that the glyph has justification applied.</p> </dd>
        /// </summary>
        /// <doc-id>dd368123</doc-id>
        /// <unmanaged>justification</unmanaged>
        /// <unmanaged-short>justification</unmanaged-short>
        internal System.Int16 Justification_
        {
            get => (System.Int16)((_Justification_ >> 0) & 15);
            set => this._Justification_ = (System.Int16)((this._Justification_ & ~(15 << 0)) | ((value & 15) << 0));
        }

        [System.Runtime.InteropServices.FieldOffset(0)]
        internal System.Int16 _Justification_;
        /// <summary>
        /// <dd> <p>Indicates that the glyph is the start of a cluster.</p> </dd>
        /// </summary>
        /// <doc-id>dd368123</doc-id>
        /// <unmanaged>isClusterStart</unmanaged>
        /// <unmanaged-short>isClusterStart</unmanaged-short>
        public bool IsClusterStart
        {
            get => 0 != ((_IsClusterStart >> 4) & 1);
            set => this._IsClusterStart = (System.Int16)((this._IsClusterStart & ~(1 << 4)) | (((value ? 1 : 0) & 1) << 4));
        }

        [System.Runtime.InteropServices.FieldOffset(0)]
        internal System.Int16 _IsClusterStart;
        /// <summary>
        /// <dd> <p>Indicates that the glyph is a diacritic mark.</p> </dd>
        /// </summary>
        /// <doc-id>dd368123</doc-id>
        /// <unmanaged>isDiacritic</unmanaged>
        /// <unmanaged-short>isDiacritic</unmanaged-short>
        public bool IsDiacritic
        {
            get => 0 != ((_IsDiacritic >> 5) & 1);
            set => this._IsDiacritic = (System.Int16)((this._IsDiacritic & ~(1 << 5)) | (((value ? 1 : 0) & 1) << 5));
        }

        [System.Runtime.InteropServices.FieldOffset(0)]
        internal System.Int16 _IsDiacritic;
        /// <summary>
        /// <dd> <p>Indicates that the glyph is a word boundary with no visible space.</p> </dd>
        /// </summary>
        /// <doc-id>dd368123</doc-id>
        /// <unmanaged>isZeroWidthSpace</unmanaged>
        /// <unmanaged-short>isZeroWidthSpace</unmanaged-short>
        public bool IsZeroWidthSpace
        {
            get => 0 != ((_IsZeroWidthSpace >> 6) & 1);
            set => this._IsZeroWidthSpace = (System.Int16)((this._IsZeroWidthSpace & ~(1 << 6)) | (((value ? 1 : 0) & 1) << 6));
        }

        [System.Runtime.InteropServices.FieldOffset(0)]
        internal System.Int16 _IsZeroWidthSpace;
        /// <summary>
        /// <dd> <p>Reserved for future use.</p> </dd>
        /// </summary>
        /// <doc-id>dd368123</doc-id>
        /// <unmanaged>reserved</unmanaged>
        /// <unmanaged-short>reserved</unmanaged-short>
        internal System.Int16 Reserved
        {
            get => (System.Int16)((_Reserved >> 7) & 511);
            set => this._Reserved = (System.Int16)((this._Reserved & ~(511 << 7)) | ((value & 511) << 7));
        }

        [System.Runtime.InteropServices.FieldOffset(0)]
        internal System.Int16 _Reserved;
    }

    /// <summary>
    /// <p>Shaping output properties for an output glyph.</p>
    /// </summary>
    /// <doc-id>dd368125</doc-id>
    /// <unmanaged>DWRITE_SHAPING_TEXT_PROPERTIES</unmanaged>
    /// <unmanaged-short>DWRITE_SHAPING_TEXT_PROPERTIES</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Explicit, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct ShapingTextProperties
    {
        /// <summary>
        /// <dd> <p>Indicates that the glyph is shaped alone.</p> </dd>
        /// </summary>
        /// <doc-id>dd368125</doc-id>
        /// <unmanaged>isShapedAlone</unmanaged>
        /// <unmanaged-short>isShapedAlone</unmanaged-short>
        public bool IsShapedAlone
        {
            get => 0 != ((_IsShapedAlone >> 0) & 1);
            set => this._IsShapedAlone = (System.Int16)((this._IsShapedAlone & ~(1 << 0)) | (((value ? 1 : 0) & 1) << 0));
        }

        [System.Runtime.InteropServices.FieldOffset(0)]
        internal System.Int16 _IsShapedAlone;
        /// <summary>
        /// <dd> <p>Reserved for future use.</p> </dd>
        /// </summary>
        /// <doc-id>dd368125</doc-id>
        /// <unmanaged>reserved1</unmanaged>
        /// <unmanaged-short>reserved1</unmanaged-short>
        public bool Reserved1
        {
            get => 0 != ((_Reserved1 >> 1) & 1);
            set => this._Reserved1 = (System.Int16)((this._Reserved1 & ~(1 << 1)) | (((value ? 1 : 0) & 1) << 1));
        }

        [System.Runtime.InteropServices.FieldOffset(0)]
        internal System.Int16 _Reserved1;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd368125</doc-id>
        /// <unmanaged>canBreakShapingAfter</unmanaged>
        /// <unmanaged-short>canBreakShapingAfter</unmanaged-short>
        public bool CanBreakShapingAfter
        {
            get => 0 != ((_CanBreakShapingAfter >> 2) & 1);
            set => this._CanBreakShapingAfter = (System.Int16)((this._CanBreakShapingAfter & ~(1 << 2)) | (((value ? 1 : 0) & 1) << 2));
        }

        [System.Runtime.InteropServices.FieldOffset(0)]
        internal System.Int16 _CanBreakShapingAfter;
        /// <summary>
        /// <dd> <p>Reserved for future use.</p> </dd>
        /// </summary>
        /// <doc-id>dd368125</doc-id>
        /// <unmanaged>reserved</unmanaged>
        /// <unmanaged-short>reserved</unmanaged-short>
        internal System.Int16 Reserved
        {
            get => (System.Int16)((_Reserved >> 3) & 8191);
            set => this._Reserved = (System.Int16)((this._Reserved & ~(8191 << 3)) | ((value & 8191) << 3));
        }

        [System.Runtime.InteropServices.FieldOffset(0)]
        internal System.Int16 _Reserved;
    }

    /// <summary>
    /// <p>Contains information regarding the size and placement of strikethroughs. All coordinates are in device independent pixels (DIPs).</p>
    /// </summary>
    /// <doc-id>dd368126</doc-id>
    /// <unmanaged>DWRITE_STRIKETHROUGH</unmanaged>
    /// <unmanaged-short>DWRITE_STRIKETHROUGH</unmanaged-short>
    public partial struct Strikethrough
    {
        /// <summary>
        /// <dd> <p>A value that indicates the width of the strikethrough, measured parallel to the baseline.</p> </dd>
        /// </summary>
        /// <doc-id>dd368126</doc-id>
        /// <unmanaged>width</unmanaged>
        /// <unmanaged-short>width</unmanaged-short>
        public System.Single Width;
        /// <summary>
        /// <dd> <p>A value that indicates the thickness of the strikethrough, measured perpendicular to the baseline.</p> </dd>
        /// </summary>
        /// <doc-id>dd368126</doc-id>
        /// <unmanaged>thickness</unmanaged>
        /// <unmanaged-short>thickness</unmanaged-short>
        public System.Single Thickness;
        /// <summary>
        /// <dd> <p>A value that indicates the offset of the strikethrough from the baseline.  A positive offset represents a position below the baseline and  a negative offset is above.  Typically, the offset will be negative.</p> </dd>
        /// </summary>
        /// <doc-id>dd368126</doc-id>
        /// <unmanaged>offset</unmanaged>
        /// <unmanaged-short>offset</unmanaged-short>
        public System.Single Offset;
        /// <summary>
        /// <dd> <p>Reading direction of the text associated with the strikethrough.  This value is used to interpret whether the width value runs horizontally  or vertically.</p> </dd>
        /// </summary>
        /// <doc-id>dd368126</doc-id>
        /// <unmanaged>readingDirection</unmanaged>
        /// <unmanaged-short>readingDirection</unmanaged-short>
        public SharpDX.DirectWrite.ReadingDirection ReadingDirection;
        /// <summary>
        /// <dd> <p>Flow direction of the text associated with the strikethrough.  This value is used to interpret whether the thickness value advances top to  bottom, left to right, or right to left.</p> </dd>
        /// </summary>
        /// <doc-id>dd368126</doc-id>
        /// <unmanaged>flowDirection</unmanaged>
        /// <unmanaged-short>flowDirection</unmanaged-short>
        public SharpDX.DirectWrite.FlowDirection FlowDirection;
        /// <summary>
        /// <dd> <p>An array of characters containing the locale of the  text that is the strikethrough is being drawn over. </p> </dd>
        /// </summary>
        /// <doc-id>dd368126</doc-id>
        /// <unmanaged>localeName</unmanaged>
        /// <unmanaged-short>localeName</unmanaged-short>
        public System.String LocaleName;
        /// <summary>
        /// <dd> <p>The measuring mode can be useful to the renderer to determine how underlines are rendered, such as rounding the thickness to a whole pixel in GDI-compatible modes.</p> </dd>
        /// </summary>
        /// <doc-id>dd368126</doc-id>
        /// <unmanaged>measuringMode</unmanaged>
        /// <unmanaged-short>measuringMode</unmanaged-short>
        public SharpDX.Direct2D1.MeasuringMode MeasuringMode;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.Single Width;
            public System.Single Thickness;
            public System.Single Offset;
            public SharpDX.DirectWrite.ReadingDirection ReadingDirection;
            public SharpDX.DirectWrite.FlowDirection FlowDirection;
            public System.IntPtr LocaleName;
            public SharpDX.Direct2D1.MeasuringMode MeasuringMode;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.LocaleName);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Width = @ref.Width;
            Thickness = @ref.Thickness;
            Offset = @ref.Offset;
            ReadingDirection = @ref.ReadingDirection;
            FlowDirection = @ref.FlowDirection;
            LocaleName = System.Runtime.InteropServices.Marshal.PtrToStringUni(@ref.LocaleName);
            MeasuringMode = @ref.MeasuringMode;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Width = Width;
            @ref.Thickness = Thickness;
            @ref.Offset = Offset;
            @ref.ReadingDirection = ReadingDirection;
            @ref.FlowDirection = FlowDirection;
            @ref.LocaleName = System.Runtime.InteropServices.Marshal.StringToHGlobalUni(LocaleName);
            @ref.MeasuringMode = MeasuringMode;
        }
    }

    /// <summary>
    /// <p>Contains the metrics associated with text after layout.  All coordinates are in device independent pixels (DIPs).</p>
    /// </summary>
    /// <doc-id>dd368135</doc-id>
    /// <unmanaged>DWRITE_TEXT_METRICS</unmanaged>
    /// <unmanaged-short>DWRITE_TEXT_METRICS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct TextMetrics
    {
        /// <summary>
        /// <dd> <p>A value that indicates the left-most point of formatted text relative to the layout box,  while excluding any glyph overhang.</p> </dd>
        /// </summary>
        /// <doc-id>dd368135</doc-id>
        /// <unmanaged>left</unmanaged>
        /// <unmanaged-short>left</unmanaged-short>
        public System.Single Left;
        /// <summary>
        /// <dd> <p>A value that indicates the top-most point of formatted text relative to the layout box, while excluding any glyph overhang.</p> </dd>
        /// </summary>
        /// <doc-id>dd368135</doc-id>
        /// <unmanaged>top</unmanaged>
        /// <unmanaged-short>top</unmanaged-short>
        public System.Single Top;
        /// <summary>
        /// <dd> <p>A value that indicates the width of the formatted text, while ignoring trailing whitespace  at the end of each line.</p> </dd>
        /// </summary>
        /// <doc-id>dd368135</doc-id>
        /// <unmanaged>width</unmanaged>
        /// <unmanaged-short>width</unmanaged-short>
        public System.Single Width;
        /// <summary>
        /// <dd> <p>The width of the formatted text, taking into account the  trailing whitespace at the end of each line.</p> </dd>
        /// </summary>
        /// <doc-id>dd368135</doc-id>
        /// <unmanaged>widthIncludingTrailingWhitespace</unmanaged>
        /// <unmanaged-short>widthIncludingTrailingWhitespace</unmanaged-short>
        public System.Single WidthIncludingTrailingWhitespace;
        /// <summary>
        /// <dd> <p>The height of the formatted text. The height of an empty string  is set to the same value as that of the default font.</p> </dd>
        /// </summary>
        /// <doc-id>dd368135</doc-id>
        /// <unmanaged>height</unmanaged>
        /// <unmanaged-short>height</unmanaged-short>
        public System.Single Height;
        /// <summary>
        /// <dd> <p>The initial width given to the layout. It can be either larger or smaller than the  text content width, depending on whether the text  was wrapped.</p> </dd>
        /// </summary>
        /// <doc-id>dd368135</doc-id>
        /// <unmanaged>layoutWidth</unmanaged>
        /// <unmanaged-short>layoutWidth</unmanaged-short>
        public System.Single LayoutWidth;
        /// <summary>
        /// <dd> <p>Initial height given to the layout. Depending on the length of the text, it may be larger or smaller than the text content height.</p> </dd>
        /// </summary>
        /// <doc-id>dd368135</doc-id>
        /// <unmanaged>layoutHeight</unmanaged>
        /// <unmanaged-short>layoutHeight</unmanaged-short>
        public System.Single LayoutHeight;
        /// <summary>
        /// <dd> <p>The maximum reordering count of any line of text, used  to calculate the most number of hit-testing boxes needed.  If the layout has no bidirectional text, or no text at all,  the minimum level is 1.</p> </dd>
        /// </summary>
        /// <doc-id>dd368135</doc-id>
        /// <unmanaged>maxBidiReorderingDepth</unmanaged>
        /// <unmanaged-short>maxBidiReorderingDepth</unmanaged-short>
        public System.Int32 MaxBidiReorderingDepth;
        /// <summary>
        /// <dd> <p>Total number of lines.</p> </dd>
        /// </summary>
        /// <doc-id>dd368135</doc-id>
        /// <unmanaged>lineCount</unmanaged>
        /// <unmanaged-short>lineCount</unmanaged-short>
        public System.Int32 LineCount;
    }

    /// <summary>
    /// <p>Contains the metrics associated with text after layout.  All coordinates are in device independent pixels (DIPs).</p>
    /// </summary>
    /// <doc-id>dd368135</doc-id>
    /// <unmanaged>DWRITE_TEXT_METRICS1</unmanaged>
    /// <unmanaged-short>DWRITE_TEXT_METRICS1</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct TextMetrics1
    {
        /// <summary>
        /// <dd> <p>A value that indicates the left-most point of formatted text relative to the layout box,  while excluding any glyph overhang.</p> </dd>
        /// </summary>
        /// <doc-id>dd368135</doc-id>
        /// <unmanaged>left</unmanaged>
        /// <unmanaged-short>left</unmanaged-short>
        public System.Single Left;
        /// <summary>
        /// <dd> <p>A value that indicates the top-most point of formatted text relative to the layout box, while excluding any glyph overhang.</p> </dd>
        /// </summary>
        /// <doc-id>dd368135</doc-id>
        /// <unmanaged>top</unmanaged>
        /// <unmanaged-short>top</unmanaged-short>
        public System.Single Top;
        /// <summary>
        /// <dd> <p>A value that indicates the width of the formatted text, while ignoring trailing whitespace  at the end of each line.</p> </dd>
        /// </summary>
        /// <doc-id>dd368135</doc-id>
        /// <unmanaged>width</unmanaged>
        /// <unmanaged-short>width</unmanaged-short>
        public System.Single Width;
        /// <summary>
        /// <dd> <p>The width of the formatted text, taking into account the  trailing whitespace at the end of each line.</p> </dd>
        /// </summary>
        /// <doc-id>dd368135</doc-id>
        /// <unmanaged>widthIncludingTrailingWhitespace</unmanaged>
        /// <unmanaged-short>widthIncludingTrailingWhitespace</unmanaged-short>
        public System.Single WidthIncludingTrailingWhitespace;
        /// <summary>
        /// <dd> <p>The height of the formatted text. The height of an empty string  is set to the same value as that of the default font.</p> </dd>
        /// </summary>
        /// <doc-id>dd368135</doc-id>
        /// <unmanaged>height</unmanaged>
        /// <unmanaged-short>height</unmanaged-short>
        public System.Single Height;
        /// <summary>
        /// <dd> <p>The initial width given to the layout. It can be either larger or smaller than the  text content width, depending on whether the text  was wrapped.</p> </dd>
        /// </summary>
        /// <doc-id>dd368135</doc-id>
        /// <unmanaged>layoutWidth</unmanaged>
        /// <unmanaged-short>layoutWidth</unmanaged-short>
        public System.Single LayoutWidth;
        /// <summary>
        /// <dd> <p>Initial height given to the layout. Depending on the length of the text, it may be larger or smaller than the text content height.</p> </dd>
        /// </summary>
        /// <doc-id>dd368135</doc-id>
        /// <unmanaged>layoutHeight</unmanaged>
        /// <unmanaged-short>layoutHeight</unmanaged-short>
        public System.Single LayoutHeight;
        /// <summary>
        /// <dd> <p>The maximum reordering count of any line of text, used  to calculate the most number of hit-testing boxes needed.  If the layout has no bidirectional text, or no text at all,  the minimum level is 1.</p> </dd>
        /// </summary>
        /// <doc-id>dd368135</doc-id>
        /// <unmanaged>maxBidiReorderingDepth</unmanaged>
        /// <unmanaged-short>maxBidiReorderingDepth</unmanaged-short>
        public System.Int32 MaxBidiReorderingDepth;
        /// <summary>
        /// <dd> <p>Total number of lines.</p> </dd>
        /// </summary>
        /// <doc-id>dd368135</doc-id>
        /// <unmanaged>lineCount</unmanaged>
        /// <unmanaged-short>lineCount</unmanaged-short>
        public System.Int32 LineCount;
        /// <summary>
        /// <dd> <p>A value that indicates the left-most point of formatted text relative to the layout box,  while excluding any glyph overhang.</p> </dd>
        /// </summary>
        /// <doc-id>dd368135</doc-id>
        /// <unmanaged>heightIncludingTrailingWhitespace</unmanaged>
        /// <unmanaged-short>heightIncludingTrailingWhitespace</unmanaged-short>
        public System.Single HeightIncludingTrailingWhitespace;
    }

    /// <summary>
    /// <p>Specifies a range of text positions where format is applied in the text represented by an <strong><see cref = "SharpDX.DirectWrite.TextLayout"/></strong> object.</p>
    /// </summary>
    /// <doc-id>dd368137</doc-id>
    /// <unmanaged>DWRITE_TEXT_RANGE</unmanaged>
    /// <unmanaged-short>DWRITE_TEXT_RANGE</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct TextRange
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd368137</doc-id>
        /// <unmanaged>startPosition</unmanaged>
        /// <unmanaged-short>startPosition</unmanaged-short>
        public System.Int32 StartPosition;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd368137</doc-id>
        /// <unmanaged>length</unmanaged>
        /// <unmanaged-short>length</unmanaged-short>
        public System.Int32 Length;
    }

    /// <summary>
    /// <p>Specifies the trimming option for text overflowing the layout box. </p>
    /// </summary>
    /// <doc-id>dd368139</doc-id>
    /// <unmanaged>DWRITE_TRIMMING</unmanaged>
    /// <unmanaged-short>DWRITE_TRIMMING</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct Trimming
    {
        /// <summary>
        /// <dd> <p>A value that specifies  the text granularity used to trim text overflowing the layout box.</p> </dd>
        /// </summary>
        /// <doc-id>dd368139</doc-id>
        /// <unmanaged>granularity</unmanaged>
        /// <unmanaged-short>granularity</unmanaged-short>
        public SharpDX.DirectWrite.TrimmingGranularity Granularity;
        /// <summary>
        /// <dd> <p>A character code used as the delimiter that signals the beginning of the portion of text to be preserved.  Text starting from the Nth occurence of the delimiter (where N equals delimiterCount) counting backwards from the end of the text block will be preserved. For example, given the text is a path like c:\A\B\C\D\file.txt and delimiter equal to '\' and delimiterCount equal to 1, the file.txt portion of the text would be preserved.   Specifying a delimiterCount of 2 would preserve D\file.txt. </p> </dd>
        /// </summary>
        /// <doc-id>dd368139</doc-id>
        /// <unmanaged>delimiter</unmanaged>
        /// <unmanaged-short>delimiter</unmanaged-short>
        public System.Int32 Delimiter;
        /// <summary>
        /// <dd> <p>The delimiter count, counting from the end of the text, to preserve text from.</p> </dd>
        /// </summary>
        /// <doc-id>dd368139</doc-id>
        /// <unmanaged>delimiterCount</unmanaged>
        /// <unmanaged-short>delimiterCount</unmanaged-short>
        public System.Int32 DelimiterCount;
    }

    /// <summary>
    /// <p>Contains a set of typographic features to be applied during text shaping.</p>
    /// </summary>
    /// <doc-id>dd368143</doc-id>
    /// <unmanaged>DWRITE_TYPOGRAPHIC_FEATURES</unmanaged>
    /// <unmanaged-short>DWRITE_TYPOGRAPHIC_FEATURES</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    internal partial struct TypographicFeatures
    {
        /// <summary>
        /// <dd> <p>A reference to a structure that specifies properties used to identify and execute typographic features in the font.</p> </dd>
        /// </summary>
        /// <doc-id>dd368143</doc-id>
        /// <unmanaged>features</unmanaged>
        /// <unmanaged-short>features</unmanaged-short>
        public System.IntPtr Features;
        /// <summary>
        /// <dd> <p>A value that indicates the number of features being applied to a font face.</p> </dd>
        /// </summary>
        /// <doc-id>dd368143</doc-id>
        /// <unmanaged>featureCount</unmanaged>
        /// <unmanaged-short>featureCount</unmanaged-short>
        public System.Int32 FeatureCount;
    }

    /// <summary>
    /// <p>Contains information about the width, thickness, offset, run height, reading direction, and flow direction of an underline. </p>
    /// </summary>
    /// <remarks>
    /// <p>All coordinates are in device independent pixels (DIPs).</p>
    /// </remarks>
    /// <doc-id>dd368145</doc-id>
    /// <unmanaged>DWRITE_UNDERLINE</unmanaged>
    /// <unmanaged-short>DWRITE_UNDERLINE</unmanaged-short>
    public partial struct Underline
    {
        /// <summary>
        /// <dd> <p>A value that indicates the width of the underline, measured parallel to the baseline.</p> </dd>
        /// </summary>
        /// <doc-id>dd368145</doc-id>
        /// <unmanaged>width</unmanaged>
        /// <unmanaged-short>width</unmanaged-short>
        public System.Single Width;
        /// <summary>
        /// <dd> <p>A value that indicates the thickness of the underline, measured perpendicular to the baseline.</p> </dd>
        /// </summary>
        /// <doc-id>dd368145</doc-id>
        /// <unmanaged>thickness</unmanaged>
        /// <unmanaged-short>thickness</unmanaged-short>
        public System.Single Thickness;
        /// <summary>
        /// <dd> <p>A value that indicates the offset of the underline from the baseline. A positive offset represents a position below the baseline (away from the text) and a negative offset is above (toward the text).</p> </dd>
        /// </summary>
        /// <doc-id>dd368145</doc-id>
        /// <unmanaged>offset</unmanaged>
        /// <unmanaged-short>offset</unmanaged-short>
        public System.Single Offset;
        /// <summary>
        /// <dd> <p>A value that indicates the height of the tallest run where the underline is applied.</p> </dd>
        /// </summary>
        /// <doc-id>dd368145</doc-id>
        /// <unmanaged>runHeight</unmanaged>
        /// <unmanaged-short>runHeight</unmanaged-short>
        public System.Single RunHeight;
        /// <summary>
        /// <dd> <p>A value that indicates the reading direction of the text associated with the underline. This value is used to interpret whether the width value runs horizontally or vertically.</p> </dd>
        /// </summary>
        /// <doc-id>dd368145</doc-id>
        /// <unmanaged>readingDirection</unmanaged>
        /// <unmanaged-short>readingDirection</unmanaged-short>
        public SharpDX.DirectWrite.ReadingDirection ReadingDirection;
        /// <summary>
        /// <dd> <p>A value that indicates the flow direction of the text associated with the underline. This value is used to interpret whether the thickness value advances top to bottom, left to right, or right to left.</p> </dd>
        /// </summary>
        /// <doc-id>dd368145</doc-id>
        /// <unmanaged>flowDirection</unmanaged>
        /// <unmanaged-short>flowDirection</unmanaged-short>
        public SharpDX.DirectWrite.FlowDirection FlowDirection;
        /// <summary>
        /// <dd> <p>An array of characters which contains the locale of the text that the underline is being drawn under.  For example, in vertical text, the underline belongs on the left for Chinese but on the right for Japanese. </p> </dd>
        /// </summary>
        /// <doc-id>dd368145</doc-id>
        /// <unmanaged>localeName</unmanaged>
        /// <unmanaged-short>localeName</unmanaged-short>
        public System.String LocaleName;
        /// <summary>
        /// <dd> <p>The measuring mode can be useful to the renderer to determine how underlines are rendered, such as rounding the thickness to a whole pixel in GDI-compatible modes.</p> </dd>
        /// </summary>
        /// <doc-id>dd368145</doc-id>
        /// <unmanaged>measuringMode</unmanaged>
        /// <unmanaged-short>measuringMode</unmanaged-short>
        public SharpDX.Direct2D1.MeasuringMode MeasuringMode;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.Single Width;
            public System.Single Thickness;
            public System.Single Offset;
            public System.Single RunHeight;
            public SharpDX.DirectWrite.ReadingDirection ReadingDirection;
            public SharpDX.DirectWrite.FlowDirection FlowDirection;
            public System.IntPtr LocaleName;
            public SharpDX.Direct2D1.MeasuringMode MeasuringMode;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.LocaleName);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Width = @ref.Width;
            Thickness = @ref.Thickness;
            Offset = @ref.Offset;
            RunHeight = @ref.RunHeight;
            ReadingDirection = @ref.ReadingDirection;
            FlowDirection = @ref.FlowDirection;
            LocaleName = System.Runtime.InteropServices.Marshal.PtrToStringUni(@ref.LocaleName);
            MeasuringMode = @ref.MeasuringMode;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Width = Width;
            @ref.Thickness = Thickness;
            @ref.Offset = Offset;
            @ref.RunHeight = RunHeight;
            @ref.ReadingDirection = ReadingDirection;
            @ref.FlowDirection = FlowDirection;
            @ref.LocaleName = System.Runtime.InteropServices.Marshal.StringToHGlobalUni(LocaleName);
            @ref.MeasuringMode = MeasuringMode;
        }
    }

    /// <summary>
    /// <p>The <strong><see cref = "SharpDX.DirectWrite.UnicodeRange"/></strong> structure specifies the range of Unicode code points.</p>
    /// </summary>
    /// <doc-id>jj126265</doc-id>
    /// <unmanaged>DWRITE_UNICODE_RANGE</unmanaged>
    /// <unmanaged-short>DWRITE_UNICODE_RANGE</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct UnicodeRange
    {
        /// <summary>
        /// <dd> <p>The first code point in the Unicode range.</p> </dd>
        /// </summary>
        /// <doc-id>jj126265</doc-id>
        /// <unmanaged>first</unmanaged>
        /// <unmanaged-short>first</unmanaged-short>
        public System.Int32 First;
        /// <summary>
        /// <dd> <p>The last code point in the Unicode range.</p> </dd>
        /// </summary>
        /// <doc-id>jj126265</doc-id>
        /// <unmanaged>last</unmanaged>
        /// <unmanaged-short>last</unmanaged-short>
        public System.Int32 Last;
    }
}
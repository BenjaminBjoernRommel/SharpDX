// <auto-generated/>

namespace SharpDX.MediaFoundation
{
    /// <summary>
    /// <p> </p><p>Contains an image that is stored as metadata for a media source. This structure is used as the data item for the <strong>WM/Picture</strong> metadata attribute.</p>
    /// </summary>
    /// <remarks>
    /// <p>The <strong>WM/Picture</strong> attribute is defined in the Windows Media Format SDK. The attribute contains a picture related to the content, such as album art.</p><p>To get this attribute from a media source, call <strong>IMFMetadata::GetProperty</strong>, passing in the constant g_wszWMPicture for the <em>pwszName</em> parameter. The method retrieves a <strong><see cref = "SharpDX.Win32.Variant"/></strong> that contains a binary array (VT_BLOB). The layout of the array is as follows:</p><ul> <li><strong><see cref = "SharpDX.MediaFoundation.AsfFlatPicture"/></strong> structure. </li> <li> Null-terminated wide-character string that contains the MIME type. </li> <li> Null-terminated wide-character string that contains a description. </li> <li> <p>Image data.</p> </li> </ul><p>This format differs from the <strong>WM_PICTURE</strong> structure used in the Windows Media Format SDK. The <strong>WM_PICTURE</strong> structure contains internal references to two strings and the image data. If the structure is copied, these references become invalid. The <strong><see cref = "SharpDX.MediaFoundation.AsfFlatPicture"/></strong> structure does not contain internal references, so it is safe to copy the structure.</p>
    /// </remarks>
    /// <doc-id>ms696178</doc-id>
    /// <unmanaged>ASF_FLAT_PICTURE</unmanaged>
    /// <unmanaged-short>ASF_FLAT_PICTURE</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct AsfFlatPicture
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms696178</doc-id>
        /// <unmanaged>bPictureType</unmanaged>
        /// <unmanaged-short>bPictureType</unmanaged-short>
        public System.Byte BPictureType;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms696178</doc-id>
        /// <unmanaged>dwDataLen</unmanaged>
        /// <unmanaged-short>dwDataLen</unmanaged-short>
        public System.Int32 DwDataLen;
    }

    /// <summary>
    /// <p> </p><p>Contains synchronized lyrics stored as metadata for a media source. This structure is used as the data item for the <strong>WM/Lyrics_Synchronised</strong> metadata attribute.</p>
    /// </summary>
    /// <remarks>
    /// <p>The <strong>WM/Lyrics_Synchronised</strong> attribute is defined in the Windows Media Format SDK. The attribute contains lyrics synchronized to times in the source file.</p><p>To get this attribute from a media source, call <strong>IMFMetadata::GetProperty</strong>, passing in the constant g_wszWMLyrics_Synchronised for the <em>pwszName</em> parameter. The method retrieves a <strong><see cref = "SharpDX.Win32.Variant"/></strong> that contains a binary array (VT_BLOB). The layout of the array is as follows:</p><ul> <li> <p><strong><see cref = "SharpDX.MediaFoundation.AsfFlatSynchronisedLyrics"/></strong> structure.</p> </li> <li> <p>Null-terminated wide-character string that contains a description.</p> </li> <li> <p>Lyric data. The format of the lyric data is described in the Windows Media Format SDK documentation.</p> </li> </ul><p>This format differs from the <strong>WM_SYNCHRONISED_LYRICS</strong> structure used in the Windows Media Format SDK. The <strong>WM_SYNCHRONISED_LYRICS</strong> structure contains internal references to two strings and the lyric data. If the structure is copied, these references become invalid. The <strong><see cref = "SharpDX.MediaFoundation.AsfFlatSynchronisedLyrics"/></strong> structure does not contain internal references, so it is safe to copy the structure.</p>
    /// </remarks>
    /// <doc-id>ms697057</doc-id>
    /// <unmanaged>ASF_FLAT_SYNCHRONISED_LYRICS</unmanaged>
    /// <unmanaged-short>ASF_FLAT_SYNCHRONISED_LYRICS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct AsfFlatSynchronisedLyrics
    {
        /// <summary>
        /// <dd> <p>Specifies the format of time stamps in the lyrics. This member is equivalent to the <strong>bTimeStampFormat</strong> member in the <strong>WM_SYNCHRONISED_LYRICS</strong> structure. The <strong>WM_SYNCHRONISED_LYRICS</strong> structure is documented in the Windows Media Format SDK.</p> </dd>
        /// </summary>
        /// <doc-id>ms697057</doc-id>
        /// <unmanaged>bTimeStampFormat</unmanaged>
        /// <unmanaged-short>bTimeStampFormat</unmanaged-short>
        public System.Byte BTimeStampFormat;
        /// <summary>
        /// <dd> <p>Specifies the type of synchronized strings that are in the lyric data. This member is equivalent to the <strong>bContentType</strong> member in the <strong>WM_SYNCHRONISED_LYRICS</strong> structure.</p> </dd>
        /// </summary>
        /// <doc-id>ms697057</doc-id>
        /// <unmanaged>bContentType</unmanaged>
        /// <unmanaged-short>bContentType</unmanaged-short>
        public System.Byte BContentType;
        /// <summary>
        /// <dd> <p>Size, in bytes, of the lyric data.</p> </dd>
        /// </summary>
        /// <doc-id>ms697057</doc-id>
        /// <unmanaged>dwLyricsLen</unmanaged>
        /// <unmanaged-short>dwLyricsLen</unmanaged-short>
        public System.Int32 DwLyricsLen;
    }

    /// <summary>
    /// <p> </p><p>Describes the indexing configuration for a stream and type of index.</p>
    /// </summary>
    /// <doc-id>ms696174</doc-id>
    /// <unmanaged>ASF_INDEX_DESCRIPTOR</unmanaged>
    /// <unmanaged-short>ASF_INDEX_DESCRIPTOR</unmanaged-short>
    public partial struct AsfIndexDescriptor
    {
        /// <summary>
        /// <dd> <p> <strong><see cref = "SharpDX.MediaFoundation.AsfIndexIdentifier"/></strong> structure that identifies the stream number and the type of index.</p> </dd>
        /// </summary>
        /// <doc-id>ms696174</doc-id>
        /// <unmanaged>Identifier</unmanaged>
        /// <unmanaged-short>Identifier</unmanaged-short>
        public SharpDX.MediaFoundation.AsfIndexIdentifier Identifier;
        /// <summary>
        /// <dd> <p>Number of bytes used for each index entry. If the value is MFASFINDEXER_PER_ENTRY_BYTES_DYNAMIC, the index entries have variable size.</p> </dd>
        /// </summary>
        /// <doc-id>ms696174</doc-id>
        /// <unmanaged>cPerEntryBytes</unmanaged>
        /// <unmanaged-short>cPerEntryBytes</unmanaged-short>
        public System.Int16 CPerEntryBytes;
        /// <summary>
        /// <dd> <p>Optional text description of the index.</p> </dd>
        /// </summary>
        /// <doc-id>ms696174</doc-id>
        /// <unmanaged>szDescription</unmanaged>
        /// <unmanaged-short>szDescription</unmanaged-short>
        public System.String SzDescription;
        /// <summary>
        /// <dd> <p>Indexing interval. The units of this value depend on the index type. A value of MFASFINDEXER_NO_FIXED_INTERVAL indicates that there is no fixed indexing interval.</p> </dd>
        /// </summary>
        /// <doc-id>ms696174</doc-id>
        /// <unmanaged>dwInterval</unmanaged>
        /// <unmanaged-short>dwInterval</unmanaged-short>
        public System.Int32 DwInterval;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.MediaFoundation.AsfIndexIdentifier Identifier;
            public System.Int16 CPerEntryBytes;
            public System.Char SzDescription;
            public System.Char __SzDescription1;
            public System.Char __SzDescription2;
            public System.Char __SzDescription3;
            public System.Char __SzDescription4;
            public System.Char __SzDescription5;
            public System.Char __SzDescription6;
            public System.Char __SzDescription7;
            public System.Char __SzDescription8;
            public System.Char __SzDescription9;
            public System.Char __SzDescription10;
            public System.Char __SzDescription11;
            public System.Char __SzDescription12;
            public System.Char __SzDescription13;
            public System.Char __SzDescription14;
            public System.Char __SzDescription15;
            public System.Char __SzDescription16;
            public System.Char __SzDescription17;
            public System.Char __SzDescription18;
            public System.Char __SzDescription19;
            public System.Char __SzDescription20;
            public System.Char __SzDescription21;
            public System.Char __SzDescription22;
            public System.Char __SzDescription23;
            public System.Char __SzDescription24;
            public System.Char __SzDescription25;
            public System.Char __SzDescription26;
            public System.Char __SzDescription27;
            public System.Char __SzDescription28;
            public System.Char __SzDescription29;
            public System.Char __SzDescription30;
            public System.Char __SzDescription31;
            public System.Int32 DwInterval;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Identifier = @ref.Identifier;
            CPerEntryBytes = @ref.CPerEntryBytes;
            fixed (void *__ptr = &@ref.SzDescription)
                SzDescription = SharpDX.Utilities.PtrToStringUni((System.IntPtr)__ptr, 31);
            DwInterval = @ref.DwInterval;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Identifier = Identifier;
            @ref.CPerEntryBytes = CPerEntryBytes;
            fixed (char *__from = SzDescription, __to = &@ref.SzDescription)
            {
                int SzDescription_length = System.Math.Min((SzDescription?.Length ?? 0) * 2, 31 * 2);
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, SzDescription_length);
                __to[SzDescription_length] = '\0';
            }

            @ref.DwInterval = DwInterval;
        }
    }

    /// <summary>
    /// <p> Specifies an index for the ASF indexer object. </p>
    /// </summary>
    /// <remarks>
    /// <p> The index object of an ASF file can contain a number of distinct indexes. Each index is identified by the type of index and the stream number. No ASF index object can contain more than one index for a particular combination of stream number and index type.</p>
    /// </remarks>
    /// <doc-id>ms700100</doc-id>
    /// <unmanaged>ASF_INDEX_IDENTIFIER</unmanaged>
    /// <unmanaged-short>ASF_INDEX_IDENTIFIER</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct AsfIndexIdentifier
    {
        /// <summary>
        /// <dd> <p> The type of index. Currently this value must be GUID_NULL, which specifies time-based indexing. </p> </dd>
        /// </summary>
        /// <doc-id>ms700100</doc-id>
        /// <unmanaged>guidIndexType</unmanaged>
        /// <unmanaged-short>guidIndexType</unmanaged-short>
        public System.Guid GuidIndexType;
        /// <summary>
        /// <dd> <p> The stream number to which this structure applies. </p> </dd>
        /// </summary>
        /// <doc-id>ms700100</doc-id>
        /// <unmanaged>wStreamNumber</unmanaged>
        /// <unmanaged-short>wStreamNumber</unmanaged-short>
        public System.Int16 WStreamNumber;
    }

    /// <summary>
    /// <p> </p><p>Contains statistics about the progress of the ASF multiplexer.</p>
    /// </summary>
    /// <remarks>
    /// <p>Use <strong>IMFASFMultiplexer::GetStatistics</strong> to retrieve this structure.</p>
    /// </remarks>
    /// <doc-id>ms696231</doc-id>
    /// <unmanaged>ASF_MUX_STATISTICS</unmanaged>
    /// <unmanaged-short>ASF_MUX_STATISTICS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct AsfMuxStatistics
    {
        /// <summary>
        /// <dd> <p>Number of frames written by the ASF multiplexer.</p> </dd>
        /// </summary>
        /// <doc-id>ms696231</doc-id>
        /// <unmanaged>cFramesWritten</unmanaged>
        /// <unmanaged-short>cFramesWritten</unmanaged-short>
        public System.Int32 CFramesWritten;
        /// <summary>
        /// <dd> <p>Number of frames dropped by the ASF multiplexer.</p> </dd>
        /// </summary>
        /// <doc-id>ms696231</doc-id>
        /// <unmanaged>cFramesDropped</unmanaged>
        /// <unmanaged-short>cFramesDropped</unmanaged-short>
        public System.Int32 CFramesDropped;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>MFAudioDecoderDegradationInfo</unmanaged>
    /// <unmanaged-short>MFAudioDecoderDegradationInfo</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct AudioDecoderDegradationInfo
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>eDegradationReason</unmanaged>
        /// <unmanaged-short>eDegradationReason</unmanaged-short>
        public SharpDX.MediaFoundation.TAudioDecoderDegradationReason EDegradationReason;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>eType</unmanaged>
        /// <unmanaged-short>eType</unmanaged-short>
        public SharpDX.MediaFoundation.TAudioDecoderDegradationType EType;
    }

    /// <summary>
    /// <p> </p><p>Describes a 4:4:4:4 Y'Cb'Cr' sample.</p>
    /// </summary>
    /// <doc-id>ms701580</doc-id>
    /// <unmanaged>MFAYUVSample</unmanaged>
    /// <unmanaged-short>MFAYUVSample</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct AYUVSample
    {
        /// <summary>
        /// <dd> <p>Cr (chroma difference) value.</p> </dd>
        /// </summary>
        /// <doc-id>ms701580</doc-id>
        /// <unmanaged>bCrValue</unmanaged>
        /// <unmanaged-short>bCrValue</unmanaged-short>
        public System.Byte BCrValue;
        /// <summary>
        /// <dd> <p>Cb (chroma difference) value.</p> </dd>
        /// </summary>
        /// <doc-id>ms701580</doc-id>
        /// <unmanaged>bCbValue</unmanaged>
        /// <unmanaged-short>bCbValue</unmanaged-short>
        public System.Byte BCbValue;
        /// <summary>
        /// <dd> <p>Y (luma) value.</p> </dd>
        /// </summary>
        /// <doc-id>ms701580</doc-id>
        /// <unmanaged>bYValue</unmanaged>
        /// <unmanaged-short>bYValue</unmanaged-short>
        public System.Byte BYValue;
        /// <summary>
        /// <dd> <p>Alpha value.</p> </dd>
        /// </summary>
        /// <doc-id>ms701580</doc-id>
        /// <unmanaged>bSampleAlpha8</unmanaged>
        /// <unmanaged-short>bSampleAlpha8</unmanaged-short>
        public System.Byte BSampleAlpha8;
    }

    /// <summary>
    /// <p> </p><p>Specifies the buffering parameters for a network byte stream.</p>
    /// </summary>
    /// <doc-id>aa370446</doc-id>
    /// <unmanaged>MFBYTESTREAM_BUFFERING_PARAMS</unmanaged>
    /// <unmanaged-short>MFBYTESTREAM_BUFFERING_PARAMS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct ByteStreamBufferingParameters
    {
        /// <summary>
        /// <dd> <p>Size of the file, in bytes. If the total size is unknown, set this member to -1.</p> </dd>
        /// </summary>
        /// <doc-id>aa370446</doc-id>
        /// <unmanaged>cbTotalFileSize</unmanaged>
        /// <unmanaged-short>cbTotalFileSize</unmanaged-short>
        public System.Int64 CbTotalFileSize;
        /// <summary>
        /// <dd> <p>Size of the playable media data in the file, excluding any trailing data that is not useful for playback. If this value is unknown, set this member to -1.</p> </dd>
        /// </summary>
        /// <doc-id>aa370446</doc-id>
        /// <unmanaged>cbPlayableDataSize</unmanaged>
        /// <unmanaged-short>cbPlayableDataSize</unmanaged-short>
        public System.Int64 CbPlayableDataSize;
        /// <summary>
        /// <dd> <p>Pointer to an array of <strong><see cref = "SharpDX.MediaFoundation.LeakyBucketPair"/></strong> structures. Each member of the array gives the buffer window for a particular bit rate.</p> </dd>
        /// </summary>
        /// <doc-id>aa370446</doc-id>
        /// <unmanaged>prgBuckets</unmanaged>
        /// <unmanaged-short>prgBuckets</unmanaged-short>
        public System.IntPtr PrgBuckets;
        /// <summary>
        /// <dd> <p>The number of elements in the <strong>prgBuckets</strong> array.</p> </dd>
        /// </summary>
        /// <doc-id>aa370446</doc-id>
        /// <unmanaged>cBuckets</unmanaged>
        /// <unmanaged-short>cBuckets</unmanaged-short>
        public System.Int32 CBuckets;
        /// <summary>
        /// <dd> <p>Amount of data to buffer from the network, in 100-nanosecond units. This value is in addition to the buffer windows defined in the <strong>prgBuckets</strong> member.</p> </dd>
        /// </summary>
        /// <doc-id>aa370446</doc-id>
        /// <unmanaged>qwNetBufferingTime</unmanaged>
        /// <unmanaged-short>qwNetBufferingTime</unmanaged-short>
        public System.Int64 QwNetBufferingTime;
        /// <summary>
        /// <dd> <p>Amount of additional data to buffer when seeking, in 100-nanosecond units. This value reflects the fact that downloading must start from the previous key frame before the seek point. If the value is unknown, set this member to zero.</p> </dd>
        /// </summary>
        /// <doc-id>aa370446</doc-id>
        /// <unmanaged>qwExtraBufferingTimeDuringSeek</unmanaged>
        /// <unmanaged-short>qwExtraBufferingTimeDuringSeek</unmanaged-short>
        public System.Int64 QwExtraBufferingTimeDuringSeek;
        /// <summary>
        /// <dd> <p>The playback duration of the file, in 100-nanosecond units. If the duration is unknown, set this member to zero.</p> </dd>
        /// </summary>
        /// <doc-id>aa370446</doc-id>
        /// <unmanaged>qwPlayDuration</unmanaged>
        /// <unmanaged-short>qwPlayDuration</unmanaged-short>
        public System.Int64 QwPlayDuration;
        /// <summary>
        /// <dd> <p>Playback rate.</p> </dd>
        /// </summary>
        /// <doc-id>aa370446</doc-id>
        /// <unmanaged>dRate</unmanaged>
        /// <unmanaged-short>dRate</unmanaged-short>
        public System.Single DRate;
    }

    /// <summary>
    /// <p>Specifies a range of bytes.</p>
    /// </summary>
    /// <doc-id>hh162808</doc-id>
    /// <unmanaged>MF_BYTE_STREAM_CACHE_RANGE</unmanaged>
    /// <unmanaged-short>MF_BYTE_STREAM_CACHE_RANGE</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct ByteStreamCacheRange
    {
        /// <summary>
        /// <dd> <p>The offset, in bytes, of the start of the range.</p> </dd>
        /// </summary>
        /// <doc-id>hh162808</doc-id>
        /// <unmanaged>qwStartOffset</unmanaged>
        /// <unmanaged-short>qwStartOffset</unmanaged-short>
        public System.Int64 QwStartOffset;
        /// <summary>
        /// <dd> <p>The offset, in bytes, of the end of the range.</p> </dd>
        /// </summary>
        /// <doc-id>hh162808</doc-id>
        /// <unmanaged>qwEndOffset</unmanaged>
        /// <unmanaged-short>qwEndOffset</unmanaged-short>
        public System.Int64 QwEndOffset;
    }

    /// <summary>
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>A transform describing the location of a camera relative to other cameras or an established external reference.</p>
    /// </summary>
    /// <remarks>
    /// <p>The <strong>Position</strong> value should be expressed in real-world coordinates in units of meters. The coordinate system of both position and orientation should be right-handed Cartesian as shown in the following diagram. </p><strong>Important</strong>??<p>The position and orientation are expressed as transforms toward the reference frame or origin. For example, a <strong>Position</strong> value of {-5, 0, 0} means that the origin is 5 meters to the left of the sensor, and therefore the sensor is 5 meters to the right of the origin. A sensor that is positioned 2 meters above the origin should specify a <strong>Position</strong> of {0, -2, 0} because that is the translation from the sensor to the origin.</p> <p>If the sensor is aligned with the origin, the rotation is the identity quaternion and the forward vector is along the -Z axis  {0, 0, -1}. If the sensor is rotated +30 degrees around the Y axis from the origin, then the <strong>Orientation</strong> value should be a rotation of -30 degrees around the Y axis, because it represents the rotation from the sensor to the origin.</p>?
    /// </remarks>
    /// <doc-id>mt740393</doc-id>
    /// <unmanaged>MFCameraExtrinsic_CalibratedTransform</unmanaged>
    /// <unmanaged-short>MFCameraExtrinsic_CalibratedTransform</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct CameraExtrinsicCalibratedTransform
    {
        /// <summary>
        /// <dd> <p>A reference <see cref = "System.Guid"/> identifying the calibration process for the data, allowing different consumers to identify calibration data from the same process.</p> </dd>
        /// </summary>
        /// <doc-id>mt740393</doc-id>
        /// <unmanaged>CalibrationId</unmanaged>
        /// <unmanaged-short>CalibrationId</unmanaged-short>
        public System.Guid CalibrationId;
        /// <summary>
        /// <dd> <p>The transform position.</p> </dd>
        /// </summary>
        /// <doc-id>mt740393</doc-id>
        /// <unmanaged>Position</unmanaged>
        /// <unmanaged-short>Position</unmanaged-short>
        public SharpDX.MediaFoundation.Float3 Position;
        /// <summary>
        /// <dd> <p>The transform rotation.</p> </dd>
        /// </summary>
        /// <doc-id>mt740393</doc-id>
        /// <unmanaged>Orientation</unmanaged>
        /// <unmanaged-short>Orientation</unmanaged-short>
        public SharpDX.MediaFoundation.Quaternion Orientation;
    }

    /// <summary>
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Describes the location of a camera relative to other cameras or an established external reference.  </p>
    /// </summary>
    /// <doc-id>mt740392</doc-id>
    /// <unmanaged>MFCameraExtrinsics</unmanaged>
    /// <unmanaged-short>MFCameraExtrinsics</unmanaged-short>
    public partial struct CameraExtrinsics
    {
        /// <summary>
        /// <dd> <p>The number of transforms in the <em>CalibratedTransforms</em> array.</p> </dd>
        /// </summary>
        /// <doc-id>mt740392</doc-id>
        /// <unmanaged>TransformCount</unmanaged>
        /// <unmanaged-short>TransformCount</unmanaged-short>
        public System.Int32 TransformCount;
        /// <summary>
        /// <dd> <p>The array of transforms in the extrinsic data.</p> </dd>
        /// </summary>
        /// <doc-id>mt740392</doc-id>
        /// <unmanaged>CalibratedTransforms</unmanaged>
        /// <unmanaged-short>CalibratedTransforms</unmanaged-short>
        public SharpDX.MediaFoundation.CameraExtrinsicCalibratedTransform[] CalibratedTransforms
        {
            get => _CalibratedTransforms ?? (_CalibratedTransforms = new SharpDX.MediaFoundation.CameraExtrinsicCalibratedTransform[1]);
            private set => _CalibratedTransforms = value;
        }

        internal SharpDX.MediaFoundation.CameraExtrinsicCalibratedTransform[] _CalibratedTransforms;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.Int32 TransformCount;
            public SharpDX.MediaFoundation.CameraExtrinsicCalibratedTransform CalibratedTransforms;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            TransformCount = @ref.TransformCount;
            fixed (void *__to = &CalibratedTransforms[0], __from = &@ref.CalibratedTransforms)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 1 * sizeof (SharpDX.MediaFoundation.CameraExtrinsicCalibratedTransform));
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.TransformCount = TransformCount;
            fixed (void *__from = &CalibratedTransforms[0], __to = &@ref.CalibratedTransforms)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 1 * sizeof (SharpDX.MediaFoundation.CameraExtrinsicCalibratedTransform));
        }
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>MFCameraIntrinsic_CameraModel</unmanaged>
    /// <unmanaged-short>MFCameraIntrinsic_CameraModel</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct CameraIntrinsicCameraModel
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>FocalLength_x</unmanaged>
        /// <unmanaged-short>FocalLength_x</unmanaged-short>
        public System.Single FocalLengthX;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>FocalLength_y</unmanaged>
        /// <unmanaged-short>FocalLength_y</unmanaged-short>
        public System.Single FocalLengthY;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>PrincipalPoint_x</unmanaged>
        /// <unmanaged-short>PrincipalPoint_x</unmanaged-short>
        public System.Single PrincipalPointX;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>PrincipalPoint_y</unmanaged>
        /// <unmanaged-short>PrincipalPoint_y</unmanaged-short>
        public System.Single PrincipalPointY;
    }

    /// <summary>
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Represents a polynomial lens distortion model.</p>
    /// </summary>
    /// <doc-id>mt740394</doc-id>
    /// <unmanaged>MFCameraIntrinsic_DistortionModel</unmanaged>
    /// <unmanaged-short>MFCameraIntrinsic_DistortionModel</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct CameraIntrinsicDistortionModel
    {
        /// <summary>
        /// <dd> <p>The first radial distortion coefficient.</p> </dd>
        /// </summary>
        /// <doc-id>mt740394</doc-id>
        /// <unmanaged>Radial_k1</unmanaged>
        /// <unmanaged-short>Radial_k1</unmanaged-short>
        public System.Single RadialK1;
        /// <summary>
        /// <dd> <p>The second radial distortion coefficient.</p> </dd>
        /// </summary>
        /// <doc-id>mt740394</doc-id>
        /// <unmanaged>Radial_k2</unmanaged>
        /// <unmanaged-short>Radial_k2</unmanaged-short>
        public System.Single RadialK2;
        /// <summary>
        /// <dd> <p>The third radial distortion coefficient.</p> </dd>
        /// </summary>
        /// <doc-id>mt740394</doc-id>
        /// <unmanaged>Radial_k3</unmanaged>
        /// <unmanaged-short>Radial_k3</unmanaged-short>
        public System.Single RadialK3;
        /// <summary>
        /// <dd> <p>The first tangential distortion coefficient.</p> </dd>
        /// </summary>
        /// <doc-id>mt740394</doc-id>
        /// <unmanaged>Tangential_p1</unmanaged>
        /// <unmanaged-short>Tangential_p1</unmanaged-short>
        public System.Single TangentialP1;
        /// <summary>
        /// <dd> <p>The second tangential distortion coefficient.</p> </dd>
        /// </summary>
        /// <doc-id>mt740394</doc-id>
        /// <unmanaged>Tangential_p2</unmanaged>
        /// <unmanaged-short>Tangential_p2</unmanaged-short>
        public System.Single TangentialP2;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>MFCameraIntrinsic_DistortionModel6KT</unmanaged>
    /// <unmanaged-short>MFCameraIntrinsic_DistortionModel6KT</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct CameraIntrinsicDistortionModel6KT
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Radial_k1</unmanaged>
        /// <unmanaged-short>Radial_k1</unmanaged-short>
        public System.Single RadialK1;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Radial_k2</unmanaged>
        /// <unmanaged-short>Radial_k2</unmanaged-short>
        public System.Single RadialK2;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Radial_k3</unmanaged>
        /// <unmanaged-short>Radial_k3</unmanaged-short>
        public System.Single RadialK3;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Radial_k4</unmanaged>
        /// <unmanaged-short>Radial_k4</unmanaged-short>
        public System.Single RadialK4;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Radial_k5</unmanaged>
        /// <unmanaged-short>Radial_k5</unmanaged-short>
        public System.Single RadialK5;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Radial_k6</unmanaged>
        /// <unmanaged-short>Radial_k6</unmanaged-short>
        public System.Single RadialK6;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Tangential_p1</unmanaged>
        /// <unmanaged-short>Tangential_p1</unmanaged-short>
        public System.Single TangentialP1;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Tangential_p2</unmanaged>
        /// <unmanaged-short>Tangential_p2</unmanaged-short>
        public System.Single TangentialP2;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>MFCameraIntrinsic_DistortionModelArcTan</unmanaged>
    /// <unmanaged-short>MFCameraIntrinsic_DistortionModelArcTan</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct CameraIntrinsicDistortionModelArcTan
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Radial_k0</unmanaged>
        /// <unmanaged-short>Radial_k0</unmanaged-short>
        public System.Single RadialK0;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>DistortionCenter_x</unmanaged>
        /// <unmanaged-short>DistortionCenter_x</unmanaged-short>
        public System.Single DistortionCenterX;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>DistortionCenter_y</unmanaged>
        /// <unmanaged-short>DistortionCenter_y</unmanaged-short>
        public System.Single DistortionCenterY;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Tangential_x</unmanaged>
        /// <unmanaged-short>Tangential_x</unmanaged-short>
        public System.Single TangentialX;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Tangential_y</unmanaged>
        /// <unmanaged-short>Tangential_y</unmanaged-short>
        public System.Single TangentialY;
    }

    /// <summary>
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Represents a pinhole camera model. </p>
    /// </summary>
    /// <remarks>
    /// <p>For square pixels, the X and Y fields of the <strong>FocalLength</strong> should be the same.</p><p>The <strong>PrincipalPoint</strong> field is expressed in pixels, not in normalized coordinates. The  origin [0,0] is the bottom, left corner of the image.</p>
    /// </remarks>
    /// <doc-id>mt740395</doc-id>
    /// <unmanaged>MFCameraIntrinsic_PinholeCameraModel</unmanaged>
    /// <unmanaged-short>MFCameraIntrinsic_PinholeCameraModel</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct CameraIntrinsicPinholeCameraModel
    {
        /// <summary>
        /// <dd> <p>The focal length of the camera.</p> </dd>
        /// </summary>
        /// <doc-id>mt740395</doc-id>
        /// <unmanaged>FocalLength</unmanaged>
        /// <unmanaged-short>FocalLength</unmanaged-short>
        public SharpDX.MediaFoundation.Float2 FocalLength;
        /// <summary>
        /// <dd> <p>The principal point of the camera.</p> </dd>
        /// </summary>
        /// <doc-id>mt740395</doc-id>
        /// <unmanaged>PrincipalPoint</unmanaged>
        /// <unmanaged-short>PrincipalPoint</unmanaged-short>
        public SharpDX.MediaFoundation.Float2 PrincipalPoint;
    }

    /// <summary>
    /// <p>This structure contains blob information for the EV compensation feedback for the photo captured.</p>
    /// </summary>
    /// <doc-id>dn897242</doc-id>
    /// <unmanaged>CapturedMetadataExposureCompensation</unmanaged>
    /// <unmanaged-short>CapturedMetadataExposureCompensation</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct CapturedMetadataExposureCompensation
    {
        /// <summary>
        /// <dd> <p>A KSCAMERA_EXTENDEDPROP_EVCOMP_XXX step flag.</p> </dd>
        /// </summary>
        /// <doc-id>dn897242</doc-id>
        /// <unmanaged>Flags</unmanaged>
        /// <unmanaged-short>Flags</unmanaged-short>
        public System.Int64 Flags;
        /// <summary>
        /// <dd> <p>The EV compensation value in units of the step specified.</p> </dd>
        /// </summary>
        /// <doc-id>dn897242</doc-id>
        /// <unmanaged>Value</unmanaged>
        /// <unmanaged-short>Value</unmanaged-short>
        public System.Int32 Value;
    }

    /// <summary>
    /// <p>The CapturedMetadataISOGains structure describes the blob format for <strong>MF_CAPTURE_METADATA_ISO_GAINS</strong>.</p>
    /// </summary>
    /// <remarks>
    /// <p>The <strong>CapturedMetadataISOGains</strong> structure only describes the blob format for the <strong>MF_CAPTURE_METADATA_ISO_GAINS</strong> attribute.  The metadata item structure for ISO gains (<strong>KSCAMERA_METADATA_ITEMHEADER</strong> + ISO gains metadata payload) is up to driver and must be 8-byte aligned.</p>
    /// </remarks>
    /// <doc-id>dn927550</doc-id>
    /// <unmanaged>CapturedMetadataISOGains</unmanaged>
    /// <unmanaged-short>CapturedMetadataISOGains</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct CapturedMetadataISOGains
    {
        /// <summary>
        /// <dd></dd>
        /// </summary>
        /// <doc-id>dn927550</doc-id>
        /// <unmanaged>AnalogGain</unmanaged>
        /// <unmanaged-short>AnalogGain</unmanaged-short>
        public System.Single AnalogGain;
        /// <summary>
        /// <dd></dd>
        /// </summary>
        /// <doc-id>dn927550</doc-id>
        /// <unmanaged>DigitalGain</unmanaged>
        /// <unmanaged-short>DigitalGain</unmanaged-short>
        public System.Single DigitalGain;
    }

    /// <summary>
    /// <p>This structure describes the blob format for the <strong>MF_CAPTURE_METADATA_WHITEBALANCE_GAINS</strong> attribute.  </p>
    /// </summary>
    /// <remarks>
    /// <p>The <strong>MF_CAPTURE_METADATA_WHITEBALANCE_GAINS</strong> attribute contains the white balance gains applied to R, G, B by the sensor or ISP when the preview frame was captured. This is a unitless.</p><p>The <strong>CapturedMetadataWhiteBalanceGains</strong> structure only describes the blob format for the <strong>MF_CAPTURE_METADATA_WHITEBALANCE_GAINS</strong> attribute.  The metadata item structure for white balance gains (<strong>KSCAMERA_METADATA_ITEMHEADER</strong> + white balance gains metadata payload) is up to driver and must be 8-byte aligned.</p>
    /// </remarks>
    /// <doc-id>dn927556</doc-id>
    /// <unmanaged>CapturedMetadataWhiteBalanceGains</unmanaged>
    /// <unmanaged-short>CapturedMetadataWhiteBalanceGains</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct CapturedMetadataWhiteBalanceGains
    {
        /// <summary>
        /// <dd> <p>The  <strong>R</strong> value of the blob.</p> </dd>
        /// </summary>
        /// <doc-id>dn927556</doc-id>
        /// <unmanaged>R</unmanaged>
        /// <unmanaged-short>R</unmanaged-short>
        public System.Single R;
        /// <summary>
        /// <dd> <p>The  <strong>G</strong> value of the blob.</p> </dd>
        /// </summary>
        /// <doc-id>dn927556</doc-id>
        /// <unmanaged>G</unmanaged>
        /// <unmanaged-short>G</unmanaged-short>
        public System.Single G;
        /// <summary>
        /// <dd> <p>The  <strong>B</strong> value of the blob.</p> </dd>
        /// </summary>
        /// <doc-id>dn927556</doc-id>
        /// <unmanaged>B</unmanaged>
        /// <unmanaged-short>B</unmanaged-short>
        public System.Single B;
    }

    /// <summary>
    /// <p> Defines the properties of a clock. </p>
    /// </summary>
    /// <doc-id>ms695206</doc-id>
    /// <unmanaged>MFCLOCK_PROPERTIES</unmanaged>
    /// <unmanaged-short>MFCLOCK_PROPERTIES</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct ClockProperties
    {
        /// <summary>
        /// <dd> <p> The interval at which the clock correlates its clock time with the system time, in 100-nanosecond units. If the value is zero, the correlation is made whenever the <strong>IMFClock::GetCorrelatedTime</strong> method is called. </p> </dd>
        /// </summary>
        /// <doc-id>ms695206</doc-id>
        /// <unmanaged>qwCorrelationRate</unmanaged>
        /// <unmanaged-short>qwCorrelationRate</unmanaged-short>
        public System.Int64 QwCorrelationRate;
        /// <summary>
        /// <dd> <p> The unique identifier of the underlying device that provides the time. If two clocks have the same unique identifier, they are based on the same device. If the underlying device is not shared between two clocks, the value can be <strong>GUID_NULL</strong>. </p> </dd>
        /// </summary>
        /// <doc-id>ms695206</doc-id>
        /// <unmanaged>guidClockId</unmanaged>
        /// <unmanaged-short>guidClockId</unmanaged-short>
        public System.Guid GuidClockId;
        /// <summary>
        /// <dd> <p> A bitwise <strong>OR</strong> of flags from the <strong><see cref = "SharpDX.MediaFoundation.ClockRelationalFlags"/></strong> enumeration. </p> </dd>
        /// </summary>
        /// <doc-id>ms695206</doc-id>
        /// <unmanaged>dwClockFlags</unmanaged>
        /// <unmanaged-short>dwClockFlags</unmanaged-short>
        public System.Int32 DwClockFlags;
        /// <summary>
        /// <dd> <p> The clock frequency in Hz. A value of <strong>MFCLOCK_FREQUENCY_HNS</strong> means that the clock has a frequency of 10 MHz (100-nanosecond ticks), which is the standard <strong>MFTIME</strong> time unit in Media Foundation. If the <strong>IMFClock::GetClockCharacteristics</strong> method returns the <strong>MFCLOCK_CHARACTERISTICS_FLAG_FREQUENCY_10MHZ</strong> flag, the value of this field must be <strong>MFCLOCK_FREQUENCY_HNS</strong>. </p> </dd>
        /// </summary>
        /// <doc-id>ms695206</doc-id>
        /// <unmanaged>qwClockFrequency</unmanaged>
        /// <unmanaged-short>qwClockFrequency</unmanaged-short>
        public System.Int64 QwClockFrequency;
        /// <summary>
        /// <dd> <p> The amount of inaccuracy that may be present on the clock, in parts per billion (ppb). For example, an inaccuracy of 50 ppb means the clock might drift up to 50 seconds per billion seconds of real time. If the tolerance is not known, the value is <strong>MFCLOCK_TOLERANCE_UNKNOWN</strong>. This constant is equal to 50 parts per million (ppm). </p> </dd>
        /// </summary>
        /// <doc-id>ms695206</doc-id>
        /// <unmanaged>dwClockTolerance</unmanaged>
        /// <unmanaged-short>dwClockTolerance</unmanaged-short>
        public System.Int32 DwClockTolerance;
        /// <summary>
        /// <dd> <p> The amount of jitter that may be present, in 100-nanosecond units. Jitter is the variation in the frequency due to sampling the underlying clock. Jitter does not include inaccuracies caused by drift, which is reflected in the value of <strong>dwClockTolerance</strong>. </p> <p> For clocks based on a single device, the minimum jitter is the length of the tick period (the inverse of the frequency). For example, if the frequency is 10 Hz, the jitter is 0.1 second, which is 1,000,000 in <strong>MFTIME</strong> units. This value reflects the fact that the clock might be sampled just before the next tick, resulting in a clock time that is one period less than the actual time. If the frequency is greater than 10 MHz, the jitter should be set to 1 (the minimum value). </p> <p> If a clock's underlying hardware device does not directly time stamp the incoming data, the jitter also includes the time required to dispatch the driver's interrupt service routine (ISR). In that case, the expected jitter should include the following values: </p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>MFCLOCK_JITTER_ISR</strong></dt> </dl> </td><td> <p> Jitter due to time stamping during the device driver's ISR. </p> </td></tr> <tr><td><dl> <dt><strong>MFCLOCK_JITTER_DPC</strong></dt> </dl> </td><td> <p> Jitter due to time stamping during the deferred procedure call (DPC) processing. </p> </td></tr> <tr><td><dl> <dt><strong>MFCLOCK_JITTER_PASSIVE</strong></dt> </dl> </td><td> <p> Jitter due to dropping to normal thread execution before time stamping. </p> </td></tr> </table> <p>?</p> </dd>
        /// </summary>
        /// <doc-id>ms695206</doc-id>
        /// <unmanaged>dwClockJitter</unmanaged>
        /// <unmanaged-short>dwClockJitter</unmanaged-short>
        public System.Int32 DwClockJitter;
    }

    /// <summary>
    /// <p>Contains information about the data that you want to provide as input to a protection system function.</p>
    /// </summary>
    /// <doc-id>mt219216</doc-id>
    /// <unmanaged>MFCONTENTPROTECTIONDEVICE_INPUT_DATA</unmanaged>
    /// <unmanaged-short>MFCONTENTPROTECTIONDEVICE_INPUT_DATA</unmanaged-short>
    public partial struct ContentprotectiondeviceInputData
    {
        /// <summary>
        /// <dd> <p>The identifier of the function that you need to run. This value is defined by the implementation of the protection system.  </p> </dd>
        /// </summary>
        /// <doc-id>mt219216</doc-id>
        /// <unmanaged>HWProtectionFunctionID</unmanaged>
        /// <unmanaged-short>HWProtectionFunctionID</unmanaged-short>
        public System.Int32 HWProtectionFunctionID;
        /// <summary>
        /// <dd> <p>The size of the private data that the implementation of  the security processor implementation reserved. You can determine this value by calling the <strong>IMFContentProtectionDevice::GetPrivateDataByteCount</strong> method.</p> </dd>
        /// </summary>
        /// <doc-id>mt219216</doc-id>
        /// <unmanaged>PrivateDataByteCount</unmanaged>
        /// <unmanaged-short>PrivateDataByteCount</unmanaged-short>
        public System.Int32 PrivateDataByteCount;
        /// <summary>
        /// <dd> <p>The size of the data provided as input to the protection system function that you want to run.  </p> </dd>
        /// </summary>
        /// <doc-id>mt219216</doc-id>
        /// <unmanaged>HWProtectionDataByteCount</unmanaged>
        /// <unmanaged-short>HWProtectionDataByteCount</unmanaged-short>
        public System.Int32 HWProtectionDataByteCount;
        /// <summary>
        /// <dd> <p>Reserved.</p> </dd>
        /// </summary>
        /// <doc-id>mt219216</doc-id>
        /// <unmanaged>Reserved</unmanaged>
        /// <unmanaged-short>Reserved</unmanaged-short>
        public System.Int32 Reserved;
        /// <summary>
        /// <dd> <p>The data to provide as input to the protection system function.</p> <p>If the value of the <strong>PrivateDataByteCount</strong> member is greater than 0, bytes 0 through <strong>PrivateDataByteCount</strong> - 1 are reserved for use by the independent hardware vendor (IHV). Bytes <strong>PrivateDataByteCount</strong> through <strong>HWProtectionDataByteCount</strong> + <strong>PrivateDataByteCount</strong> - 1 contain the input data for the protection system function.    </p> <p>The protection system specification defines the format and size of the DRM function.</p> </dd>
        /// </summary>
        /// <doc-id>mt219216</doc-id>
        /// <unmanaged>InputData</unmanaged>
        /// <unmanaged-short>InputData</unmanaged-short>
        public System.Byte[] InputData
        {
            get => _InputData ?? (_InputData = new System.Byte[4]);
            private set => _InputData = value;
        }

        internal System.Byte[] _InputData;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.Int32 HWProtectionFunctionID;
            public System.Int32 PrivateDataByteCount;
            public System.Int32 HWProtectionDataByteCount;
            public System.Int32 Reserved;
            public System.Byte InputData;
            public System.Byte __InputData1;
            public System.Byte __InputData2;
            public System.Byte __InputData3;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            HWProtectionFunctionID = @ref.HWProtectionFunctionID;
            PrivateDataByteCount = @ref.PrivateDataByteCount;
            HWProtectionDataByteCount = @ref.HWProtectionDataByteCount;
            Reserved = @ref.Reserved;
            fixed (void *__to = &InputData[0], __from = &@ref.InputData)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 4 * sizeof (System.Byte));
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.HWProtectionFunctionID = HWProtectionFunctionID;
            @ref.PrivateDataByteCount = PrivateDataByteCount;
            @ref.HWProtectionDataByteCount = HWProtectionDataByteCount;
            @ref.Reserved = Reserved;
            fixed (void *__from = &InputData[0], __to = &@ref.InputData)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 4 * sizeof (System.Byte));
        }
    }

    /// <summary>
    /// <p>Contains information about the data you received as output from a protection system function.</p>
    /// </summary>
    /// <doc-id>mt219217</doc-id>
    /// <unmanaged>MFCONTENTPROTECTIONDEVICE_OUTPUT_DATA</unmanaged>
    /// <unmanaged-short>MFCONTENTPROTECTIONDEVICE_OUTPUT_DATA</unmanaged-short>
    public partial struct ContentprotectiondeviceOutputData
    {
        /// <summary>
        /// <dd> <p>The size of the private data that the implementation of the security processor reserves, in bytes. You can determine this value  by calling the <strong>IMFContentProtectionDevice::GetPrivateDataByteCount</strong> method.</p> </dd>
        /// </summary>
        /// <doc-id>mt219217</doc-id>
        /// <unmanaged>PrivateDataByteCount</unmanaged>
        /// <unmanaged-short>PrivateDataByteCount</unmanaged-short>
        public System.Int32 PrivateDataByteCount;
        /// <summary>
        /// <dd> <p>The maximum size of data that the independent hardware vendor (IHV) can return in the output buffer, in bytes.</p> </dd>
        /// </summary>
        /// <doc-id>mt219217</doc-id>
        /// <unmanaged>MaxHWProtectionDataByteCount</unmanaged>
        /// <unmanaged-short>MaxHWProtectionDataByteCount</unmanaged-short>
        public System.Int32 MaxHWProtectionDataByteCount;
        /// <summary>
        /// <dd> <p>The size of the data that the  IHV wrote to the output buffer, in bytes.</p> </dd>
        /// </summary>
        /// <doc-id>mt219217</doc-id>
        /// <unmanaged>HWProtectionDataByteCount</unmanaged>
        /// <unmanaged-short>HWProtectionDataByteCount</unmanaged-short>
        public System.Int32 HWProtectionDataByteCount;
        /// <summary>
        /// <dd> <p>The result of the protection system function.</p> </dd>
        /// </summary>
        /// <doc-id>mt219217</doc-id>
        /// <unmanaged>Status</unmanaged>
        /// <unmanaged-short>Status</unmanaged-short>
        public SharpDX.Result Status;
        /// <summary>
        /// <dd> <p>The number of 100 nanosecond units spent transporting the data.   </p> </dd>
        /// </summary>
        /// <doc-id>mt219217</doc-id>
        /// <unmanaged>TransportTimeInHundredsOfNanoseconds</unmanaged>
        /// <unmanaged-short>TransportTimeInHundredsOfNanoseconds</unmanaged-short>
        public System.Int64 TransportTimeInHundredsOfNanoseconds;
        /// <summary>
        /// <dd> <p>The number of 100 nanosecond units spent running the protection system function.  
        /// </p> </dd>
        /// </summary>
        /// <doc-id>mt219217</doc-id>
        /// <unmanaged>ExecutionTimeInHundredsOfNanoseconds</unmanaged>
        /// <unmanaged-short>ExecutionTimeInHundredsOfNanoseconds</unmanaged-short>
        public System.Int64 ExecutionTimeInHundredsOfNanoseconds;
        /// <summary>
        /// <dd> <p>The output of the protection system function.</p> <p>If the value of the <strong>PrivateDataByteCount</strong> member is greater than 0, bytes 0 through <strong>PrivateDataByteCount</strong> - 1 are reserved for IHV use.   Bytes <strong>PrivateDataByteCount</strong> through <strong>MaxHWProtectionDataByteCount</strong> + <strong>PrivateDataByteCount</strong> - 1 contain the region    of the array into which the driver should return the output data from the protection system function.</p> <p>The protection system specification defines the format and size of the    function.</p> </dd>
        /// </summary>
        /// <doc-id>mt219217</doc-id>
        /// <unmanaged>OutputData</unmanaged>
        /// <unmanaged-short>OutputData</unmanaged-short>
        public System.Byte[] OutputData
        {
            get => _OutputData ?? (_OutputData = new System.Byte[4]);
            private set => _OutputData = value;
        }

        internal System.Byte[] _OutputData;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.Int32 PrivateDataByteCount;
            public System.Int32 MaxHWProtectionDataByteCount;
            public System.Int32 HWProtectionDataByteCount;
            public SharpDX.Result Status;
            public System.Int64 TransportTimeInHundredsOfNanoseconds;
            public System.Int64 ExecutionTimeInHundredsOfNanoseconds;
            public System.Byte OutputData;
            public System.Byte __OutputData1;
            public System.Byte __OutputData2;
            public System.Byte __OutputData3;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            PrivateDataByteCount = @ref.PrivateDataByteCount;
            MaxHWProtectionDataByteCount = @ref.MaxHWProtectionDataByteCount;
            HWProtectionDataByteCount = @ref.HWProtectionDataByteCount;
            Status = @ref.Status;
            TransportTimeInHundredsOfNanoseconds = @ref.TransportTimeInHundredsOfNanoseconds;
            ExecutionTimeInHundredsOfNanoseconds = @ref.ExecutionTimeInHundredsOfNanoseconds;
            fixed (void *__to = &OutputData[0], __from = &@ref.OutputData)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 4 * sizeof (System.Byte));
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.PrivateDataByteCount = PrivateDataByteCount;
            @ref.MaxHWProtectionDataByteCount = MaxHWProtectionDataByteCount;
            @ref.HWProtectionDataByteCount = HWProtectionDataByteCount;
            @ref.Status = Status;
            @ref.TransportTimeInHundredsOfNanoseconds = TransportTimeInHundredsOfNanoseconds;
            @ref.ExecutionTimeInHundredsOfNanoseconds = ExecutionTimeInHundredsOfNanoseconds;
            fixed (void *__from = &OutputData[0], __to = &@ref.OutputData)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 4 * sizeof (System.Byte));
        }
    }

    /// <summary>
    /// <p>Advises the secure processor of the  Multimedia Class Scheduler service (MMCSS) parameters so that real-time tasks can be scheduled at the expected priority.</p>
    /// </summary>
    /// <doc-id>mt219218</doc-id>
    /// <unmanaged>MFCONTENTPROTECTIONDEVICE_REALTIMECLIENT_DATA</unmanaged>
    /// <unmanaged-short>MFCONTENTPROTECTIONDEVICE_REALTIMECLIENT_DATA</unmanaged-short>
    public partial struct ContentprotectiondeviceRealtimeclientData
    {
        /// <summary>
        /// <dd> <p>The identifier for the MMCSS task.</p> </dd>
        /// </summary>
        /// <doc-id>mt219218</doc-id>
        /// <unmanaged>TaskIndex</unmanaged>
        /// <unmanaged-short>TaskIndex</unmanaged-short>
        public System.Int32 TaskIndex;
        /// <summary>
        /// <dd> <p>The name of the MMCSS task.</p> </dd>
        /// </summary>
        /// <doc-id>mt219218</doc-id>
        /// <unmanaged>ClassName</unmanaged>
        /// <unmanaged-short>ClassName</unmanaged-short>
        public System.String ClassName;
        /// <summary>
        /// <dd> <p>The base priority of the thread that runs the MMCSS task.</p> </dd>
        /// </summary>
        /// <doc-id>mt219218</doc-id>
        /// <unmanaged>BasePriority</unmanaged>
        /// <unmanaged-short>BasePriority</unmanaged-short>
        public System.Int32 BasePriority;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.Int32 TaskIndex;
            public System.Char ClassName;
            public System.Char __ClassName1;
            public System.Char __ClassName2;
            public System.Char __ClassName3;
            public System.Char __ClassName4;
            public System.Char __ClassName5;
            public System.Char __ClassName6;
            public System.Char __ClassName7;
            public System.Char __ClassName8;
            public System.Char __ClassName9;
            public System.Char __ClassName10;
            public System.Char __ClassName11;
            public System.Char __ClassName12;
            public System.Char __ClassName13;
            public System.Char __ClassName14;
            public System.Char __ClassName15;
            public System.Char __ClassName16;
            public System.Char __ClassName17;
            public System.Char __ClassName18;
            public System.Char __ClassName19;
            public System.Char __ClassName20;
            public System.Char __ClassName21;
            public System.Char __ClassName22;
            public System.Char __ClassName23;
            public System.Char __ClassName24;
            public System.Char __ClassName25;
            public System.Char __ClassName26;
            public System.Char __ClassName27;
            public System.Char __ClassName28;
            public System.Char __ClassName29;
            public System.Char __ClassName30;
            public System.Char __ClassName31;
            public System.Char __ClassName32;
            public System.Char __ClassName33;
            public System.Char __ClassName34;
            public System.Char __ClassName35;
            public System.Char __ClassName36;
            public System.Char __ClassName37;
            public System.Char __ClassName38;
            public System.Char __ClassName39;
            public System.Char __ClassName40;
            public System.Char __ClassName41;
            public System.Char __ClassName42;
            public System.Char __ClassName43;
            public System.Char __ClassName44;
            public System.Char __ClassName45;
            public System.Char __ClassName46;
            public System.Char __ClassName47;
            public System.Char __ClassName48;
            public System.Char __ClassName49;
            public System.Char __ClassName50;
            public System.Char __ClassName51;
            public System.Char __ClassName52;
            public System.Char __ClassName53;
            public System.Char __ClassName54;
            public System.Char __ClassName55;
            public System.Char __ClassName56;
            public System.Char __ClassName57;
            public System.Char __ClassName58;
            public System.Char __ClassName59;
            public System.Char __ClassName60;
            public System.Char __ClassName61;
            public System.Char __ClassName62;
            public System.Char __ClassName63;
            public System.Char __ClassName64;
            public System.Char __ClassName65;
            public System.Char __ClassName66;
            public System.Char __ClassName67;
            public System.Char __ClassName68;
            public System.Char __ClassName69;
            public System.Char __ClassName70;
            public System.Char __ClassName71;
            public System.Char __ClassName72;
            public System.Char __ClassName73;
            public System.Char __ClassName74;
            public System.Char __ClassName75;
            public System.Char __ClassName76;
            public System.Char __ClassName77;
            public System.Char __ClassName78;
            public System.Char __ClassName79;
            public System.Char __ClassName80;
            public System.Char __ClassName81;
            public System.Char __ClassName82;
            public System.Char __ClassName83;
            public System.Char __ClassName84;
            public System.Char __ClassName85;
            public System.Char __ClassName86;
            public System.Char __ClassName87;
            public System.Char __ClassName88;
            public System.Char __ClassName89;
            public System.Char __ClassName90;
            public System.Char __ClassName91;
            public System.Char __ClassName92;
            public System.Char __ClassName93;
            public System.Char __ClassName94;
            public System.Char __ClassName95;
            public System.Char __ClassName96;
            public System.Char __ClassName97;
            public System.Char __ClassName98;
            public System.Char __ClassName99;
            public System.Char __ClassName100;
            public System.Char __ClassName101;
            public System.Char __ClassName102;
            public System.Char __ClassName103;
            public System.Char __ClassName104;
            public System.Char __ClassName105;
            public System.Char __ClassName106;
            public System.Char __ClassName107;
            public System.Char __ClassName108;
            public System.Char __ClassName109;
            public System.Char __ClassName110;
            public System.Char __ClassName111;
            public System.Char __ClassName112;
            public System.Char __ClassName113;
            public System.Char __ClassName114;
            public System.Char __ClassName115;
            public System.Char __ClassName116;
            public System.Char __ClassName117;
            public System.Char __ClassName118;
            public System.Char __ClassName119;
            public System.Char __ClassName120;
            public System.Char __ClassName121;
            public System.Char __ClassName122;
            public System.Char __ClassName123;
            public System.Char __ClassName124;
            public System.Char __ClassName125;
            public System.Char __ClassName126;
            public System.Char __ClassName127;
            public System.Char __ClassName128;
            public System.Char __ClassName129;
            public System.Char __ClassName130;
            public System.Char __ClassName131;
            public System.Char __ClassName132;
            public System.Char __ClassName133;
            public System.Char __ClassName134;
            public System.Char __ClassName135;
            public System.Char __ClassName136;
            public System.Char __ClassName137;
            public System.Char __ClassName138;
            public System.Char __ClassName139;
            public System.Char __ClassName140;
            public System.Char __ClassName141;
            public System.Char __ClassName142;
            public System.Char __ClassName143;
            public System.Char __ClassName144;
            public System.Char __ClassName145;
            public System.Char __ClassName146;
            public System.Char __ClassName147;
            public System.Char __ClassName148;
            public System.Char __ClassName149;
            public System.Char __ClassName150;
            public System.Char __ClassName151;
            public System.Char __ClassName152;
            public System.Char __ClassName153;
            public System.Char __ClassName154;
            public System.Char __ClassName155;
            public System.Char __ClassName156;
            public System.Char __ClassName157;
            public System.Char __ClassName158;
            public System.Char __ClassName159;
            public System.Char __ClassName160;
            public System.Char __ClassName161;
            public System.Char __ClassName162;
            public System.Char __ClassName163;
            public System.Char __ClassName164;
            public System.Char __ClassName165;
            public System.Char __ClassName166;
            public System.Char __ClassName167;
            public System.Char __ClassName168;
            public System.Char __ClassName169;
            public System.Char __ClassName170;
            public System.Char __ClassName171;
            public System.Char __ClassName172;
            public System.Char __ClassName173;
            public System.Char __ClassName174;
            public System.Char __ClassName175;
            public System.Char __ClassName176;
            public System.Char __ClassName177;
            public System.Char __ClassName178;
            public System.Char __ClassName179;
            public System.Char __ClassName180;
            public System.Char __ClassName181;
            public System.Char __ClassName182;
            public System.Char __ClassName183;
            public System.Char __ClassName184;
            public System.Char __ClassName185;
            public System.Char __ClassName186;
            public System.Char __ClassName187;
            public System.Char __ClassName188;
            public System.Char __ClassName189;
            public System.Char __ClassName190;
            public System.Char __ClassName191;
            public System.Char __ClassName192;
            public System.Char __ClassName193;
            public System.Char __ClassName194;
            public System.Char __ClassName195;
            public System.Char __ClassName196;
            public System.Char __ClassName197;
            public System.Char __ClassName198;
            public System.Char __ClassName199;
            public System.Char __ClassName200;
            public System.Char __ClassName201;
            public System.Char __ClassName202;
            public System.Char __ClassName203;
            public System.Char __ClassName204;
            public System.Char __ClassName205;
            public System.Char __ClassName206;
            public System.Char __ClassName207;
            public System.Char __ClassName208;
            public System.Char __ClassName209;
            public System.Char __ClassName210;
            public System.Char __ClassName211;
            public System.Char __ClassName212;
            public System.Char __ClassName213;
            public System.Char __ClassName214;
            public System.Char __ClassName215;
            public System.Char __ClassName216;
            public System.Char __ClassName217;
            public System.Char __ClassName218;
            public System.Char __ClassName219;
            public System.Char __ClassName220;
            public System.Char __ClassName221;
            public System.Char __ClassName222;
            public System.Char __ClassName223;
            public System.Char __ClassName224;
            public System.Char __ClassName225;
            public System.Char __ClassName226;
            public System.Char __ClassName227;
            public System.Char __ClassName228;
            public System.Char __ClassName229;
            public System.Char __ClassName230;
            public System.Char __ClassName231;
            public System.Char __ClassName232;
            public System.Char __ClassName233;
            public System.Char __ClassName234;
            public System.Char __ClassName235;
            public System.Char __ClassName236;
            public System.Char __ClassName237;
            public System.Char __ClassName238;
            public System.Char __ClassName239;
            public System.Char __ClassName240;
            public System.Char __ClassName241;
            public System.Char __ClassName242;
            public System.Char __ClassName243;
            public System.Char __ClassName244;
            public System.Char __ClassName245;
            public System.Char __ClassName246;
            public System.Char __ClassName247;
            public System.Char __ClassName248;
            public System.Char __ClassName249;
            public System.Char __ClassName250;
            public System.Char __ClassName251;
            public System.Char __ClassName252;
            public System.Char __ClassName253;
            public System.Char __ClassName254;
            public System.Char __ClassName255;
            public System.Char __ClassName256;
            public System.Char __ClassName257;
            public System.Char __ClassName258;
            public System.Char __ClassName259;
            public System.Int32 BasePriority;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            TaskIndex = @ref.TaskIndex;
            fixed (void *__ptr = &@ref.ClassName)
                ClassName = SharpDX.Utilities.PtrToStringUni((System.IntPtr)__ptr, 259);
            BasePriority = @ref.BasePriority;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.TaskIndex = TaskIndex;
            fixed (char *__from = ClassName, __to = &@ref.ClassName)
            {
                int ClassName_length = System.Math.Min((ClassName?.Length ?? 0) * 2, 259 * 2);
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, ClassName_length);
                __to[ClassName_length] = '\0';
            }

            @ref.BasePriority = BasePriority;
        }
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>DIRTYRECT_INFO</unmanaged>
    /// <unmanaged-short>DIRTYRECT_INFO</unmanaged-short>
    public partial struct DirtyrectInformation
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>FrameNumber</unmanaged>
        /// <unmanaged-short>FrameNumber</unmanaged-short>
        public System.Int32 FrameNumber;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>NumDirtyRects</unmanaged>
        /// <unmanaged-short>NumDirtyRects</unmanaged-short>
        public System.Int32 NumDirtyRects;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>DirtyRects</unmanaged>
        /// <unmanaged-short>DirtyRects</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawRectangle[] DirtyRects
        {
            get => _DirtyRects ?? (_DirtyRects = new SharpDX.Mathematics.Interop.RawRectangle[1]);
            private set => _DirtyRects = value;
        }

        internal SharpDX.Mathematics.Interop.RawRectangle[] _DirtyRects;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.Int32 FrameNumber;
            public System.Int32 NumDirtyRects;
            public SharpDX.Mathematics.Interop.RawRectangle DirtyRects;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            FrameNumber = @ref.FrameNumber;
            NumDirtyRects = @ref.NumDirtyRects;
            fixed (void *__to = &DirtyRects[0], __from = &@ref.DirtyRects)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 1 * sizeof (SharpDX.Mathematics.Interop.RawRectangle));
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.FrameNumber = FrameNumber;
            @ref.NumDirtyRects = NumDirtyRects;
            fixed (void *__from = &DirtyRects[0], __to = &@ref.DirtyRects)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 1 * sizeof (SharpDX.Mathematics.Interop.RawRectangle));
        }
    }

    /// <summary>
    /// <p> </p><p>The <strong><see cref = "SharpDX.MediaFoundation.DmoMediaType"/></strong> structure describes the format of the data used by a stream in a Microsoft DirectX Media Object (DMO).</p>
    /// </summary>
    /// <remarks>
    /// <p>This structure is identical to the DirectShow <strong><see cref = "SharpDX.Win32.Unsupported.AMMediaType"/></strong> structure. The <strong>bFixedSizeSamples</strong>, <strong>bTemporalCompression</strong>, and <strong>lSampleSize</strong> members are for compatibility with DirectShow. Other DMO clients are not required to use them.</p>
    /// </remarks>
    /// <doc-id>dd375504</doc-id>
    /// <unmanaged>DMO_MEDIA_TYPE</unmanaged>
    /// <unmanaged-short>DMO_MEDIA_TYPE</unmanaged-short>
    public partial struct DmoMediaType
    {
        /// <summary>
        /// <dd> <p>Major type <see cref = "System.Guid"/> of the stream.</p> </dd>
        /// </summary>
        /// <doc-id>dd375504</doc-id>
        /// <unmanaged>majortype</unmanaged>
        /// <unmanaged-short>majortype</unmanaged-short>
        public System.Guid Majortype;
        /// <summary>
        /// <dd> <p>Subtype <see cref = "System.Guid"/> of the stream.</p> </dd>
        /// </summary>
        /// <doc-id>dd375504</doc-id>
        /// <unmanaged>subtype</unmanaged>
        /// <unmanaged-short>subtype</unmanaged-short>
        public System.Guid Subtype;
        /// <summary>
        /// <dd> <p>If <strong>TRUE</strong>, samples are of a fixed size. This field is informational only. For audio, it is generally set to <strong>TRUE</strong>. For video, it is usually <strong>TRUE</strong> for uncompressed video and <strong><see cref = "SharpDX.Result.False"/></strong> for compressed video.</p> </dd>
        /// </summary>
        /// <doc-id>dd375504</doc-id>
        /// <unmanaged>bFixedSizeSamples</unmanaged>
        /// <unmanaged-short>bFixedSizeSamples</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool BFixedSizeSamples;
        /// <summary>
        /// <dd> <p>If <strong>TRUE</strong>, samples are compressed using temporal (interframe) compression. (A value of <strong>TRUE</strong> indicates that not all frames are key frames.) This field is informational only.</p> </dd>
        /// </summary>
        /// <doc-id>dd375504</doc-id>
        /// <unmanaged>bTemporalCompression</unmanaged>
        /// <unmanaged-short>bTemporalCompression</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool BTemporalCompression;
        /// <summary>
        /// <dd> <p>Size of the sample in bytes. For compressed data, the value can be zero.</p> </dd>
        /// </summary>
        /// <doc-id>dd375504</doc-id>
        /// <unmanaged>lSampleSize</unmanaged>
        /// <unmanaged-short>lSampleSize</unmanaged-short>
        public System.Int32 LSampleSize;
        /// <summary>
        /// <dd> <p><see cref = "System.Guid"/> specifying the format type. The <strong>pbFormat</strong> member points to the corresponding format structure. Format types include the following.</p> <table> <tr><th>Format type</th><th>Format structure</th></tr> <tr><td><dl> <dt><strong>FORMAT_DvInfo</strong></dt> </dl> </td><td> <p> <strong>DVINFO</strong> </p> </td></tr> <tr><td><dl> <dt><strong>FORMAT_MPEG2Video</strong></dt> </dl> </td><td> <p> <strong><see cref = "SharpDX.MediaFoundation.Mpeg2VideoInformation"/></strong> </p> </td></tr> <tr><td><dl> <dt><strong>FORMAT_MPEGVideo</strong></dt> </dl> </td><td> <p> <strong><see cref = "SharpDX.MediaFoundation.Mpeg1VideoInformation"/></strong> </p> </td></tr> <tr><td><dl> <dt><strong>FORMAT_None</strong></dt> </dl> </td><td> <p>None.</p> </td></tr> <tr><td><dl> <dt><strong>FORMAT_VideoInfo</strong></dt> </dl> </td><td> <p> <strong><see cref = "SharpDX.Win32.Unsupported.VideoInfoHeader"/></strong> </p> </td></tr> <tr><td><dl> <dt><strong>FORMAT_VideoInfo2</strong></dt> </dl> </td><td> <p> <strong><see cref = "SharpDX.MediaFoundation.VideoInformationHeader2"/></strong> </p> </td></tr> <tr><td><dl> <dt><strong>FORMAT_WaveFormatEx</strong></dt> </dl> </td><td> <p> <strong><see cref = "SharpDX.Multimedia.WaveFormat"/></strong> </p> </td></tr> </table> <p>?</p> </dd>
        /// </summary>
        /// <doc-id>dd375504</doc-id>
        /// <unmanaged>formattype</unmanaged>
        /// <unmanaged-short>formattype</unmanaged-short>
        public System.Guid Formattype;
        /// <summary>
        /// <dd> <p>Not used. Set to <strong><c>null</c></strong>.</p> </dd>
        /// </summary>
        /// <doc-id>dd375504</doc-id>
        /// <unmanaged>pUnk</unmanaged>
        /// <unmanaged-short>pUnk</unmanaged-short>
        public SharpDX.IUnknown PUnk;
        /// <summary>
        /// <dd> <p>Size of the format block of the media type.</p> </dd>
        /// </summary>
        /// <doc-id>dd375504</doc-id>
        /// <unmanaged>cbFormat</unmanaged>
        /// <unmanaged-short>cbFormat</unmanaged-short>
        public System.Int32 CbFormat;
        /// <summary>
        /// <dd> <p>Pointer to the format structure. The structure type is specified by the <strong>formattype</strong> member. The format structure must be present, unless <strong>formattype</strong> is GUID_NULL or FORMAT_None.</p> </dd>
        /// </summary>
        /// <doc-id>dd375504</doc-id>
        /// <unmanaged>pbFormat</unmanaged>
        /// <unmanaged-short>pbFormat</unmanaged-short>
        public System.IntPtr PbFormat;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.Guid Majortype;
            public System.Guid Subtype;
            public SharpDX.Mathematics.Interop.RawBool BFixedSizeSamples;
            public SharpDX.Mathematics.Interop.RawBool BTemporalCompression;
            public System.Int32 LSampleSize;
            public System.Guid Formattype;
            public System.IntPtr PUnk;
            public System.Int32 CbFormat;
            public System.IntPtr PbFormat;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Majortype = @ref.Majortype;
            Subtype = @ref.Subtype;
            BFixedSizeSamples = @ref.BFixedSizeSamples;
            BTemporalCompression = @ref.BTemporalCompression;
            LSampleSize = @ref.LSampleSize;
            Formattype = @ref.Formattype;
            if (@ref.PUnk != System.IntPtr.Zero)
                PUnk = new SharpDX.ComObject(@ref.PUnk);
            else
                PUnk = null;
            CbFormat = @ref.CbFormat;
            PbFormat = @ref.PbFormat;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Majortype = Majortype;
            @ref.Subtype = Subtype;
            @ref.BFixedSizeSamples = BFixedSizeSamples;
            @ref.BTemporalCompression = BTemporalCompression;
            @ref.LSampleSize = LSampleSize;
            @ref.Formattype = Formattype;
            @ref.PUnk = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(PUnk);
            @ref.CbFormat = CbFormat;
            @ref.PbFormat = PbFormat;
        }
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>DMO_OUTPUT_DATA_BUFFER</unmanaged>
    /// <unmanaged-short>DMO_OUTPUT_DATA_BUFFER</unmanaged-short>
    public partial struct DmoOutputDataBuffer
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>pBuffer</unmanaged>
        /// <unmanaged-short>pBuffer</unmanaged-short>
        public SharpDX.MediaFoundation.IMediaBuffer PBuffer;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>dwStatus</unmanaged>
        /// <unmanaged-short>dwStatus</unmanaged-short>
        public System.Int32 DwStatus;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>rtTimestamp</unmanaged>
        /// <unmanaged-short>rtTimestamp</unmanaged-short>
        public System.Int64 RtTimestamp;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>rtTimelength</unmanaged>
        /// <unmanaged-short>rtTimelength</unmanaged-short>
        public System.Int64 RtTimelength;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.IntPtr PBuffer;
            public System.Int32 DwStatus;
            public System.Int64 RtTimestamp;
            public System.Int64 RtTimelength;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            if (@ref.PBuffer != System.IntPtr.Zero)
                PBuffer = new SharpDX.MediaFoundation.IMediaBuffer(@ref.PBuffer);
            else
                PBuffer = null;
            DwStatus = @ref.DwStatus;
            RtTimestamp = @ref.RtTimestamp;
            RtTimelength = @ref.RtTimelength;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.PBuffer = SharpDX.CppObject.ToCallbackPtr<SharpDX.MediaFoundation.IMediaBuffer>(PBuffer);
            @ref.DwStatus = DwStatus;
            @ref.RtTimestamp = RtTimestamp;
            @ref.RtTimelength = RtTimelength;
        }
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>MFExtendedCameraIntrinsic_IntrinsicModel</unmanaged>
    /// <unmanaged-short>MFExtendedCameraIntrinsic_IntrinsicModel</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct ExtendedCameraIntrinsicIntrinsicModel
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Width</unmanaged>
        /// <unmanaged-short>Width</unmanaged-short>
        public System.Int32 Width;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Height</unmanaged>
        /// <unmanaged-short>Height</unmanaged-short>
        public System.Int32 Height;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>SplitFrameId</unmanaged>
        /// <unmanaged-short>SplitFrameId</unmanaged-short>
        public System.Int32 SplitFrameId;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>CameraModel</unmanaged>
        /// <unmanaged-short>CameraModel</unmanaged-short>
        public SharpDX.MediaFoundation.CameraIntrinsicCameraModel CameraModel;
    }

    /// <summary>
    /// <p>The <strong>FaceCharacterization</strong> structure describes the blob format for the <strong>MF_CAPTURE_METADATA_FACEROICHARACTERIZATIONS</strong> attribute.</p>
    /// </summary>
    /// <remarks>
    /// <p>The <strong>MF_CAPTURE_METADATA_FACEROICHARACTERIZATIONS</strong> attribute contains the blink and facial expression state for the face ROIs identified in <strong>MF_CAPTURE_METADATA_FACEROIS</strong>.  For a  device that does not support blink or facial expression detection, this attribute should be omitted.</p><p>The facial expressions that can be detected are defined as follows:</p><pre>#define MF_METADATAFACIALEXPRESSION_SMILE             0x00000001</pre><p>The <strong>FaceCharacterizationBlobHeader</strong> and <strong>FaceCharacterization</strong> structures only describe the blob format for the <strong>MF_CAPTURE_METADATA_FACEROICHARACTERIZATIONS</strong> attribute.  The metadata item structure for the face characterizations (<strong>KSCAMERA_METADATA_ITEMHEADER</strong> + face characterizations metadata payload) is up to driver and must be 8-byte aligned. </p>
    /// </remarks>
    /// <doc-id>dn927642</doc-id>
    /// <unmanaged>FaceCharacterization</unmanaged>
    /// <unmanaged-short>FaceCharacterization</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct FaceCharacterization
    {
        /// <summary>
        /// <dd> <p>0 indicates no blink for the left eye, 100 indicates definite blink for the left eye (0 - 100).</p> </dd>
        /// </summary>
        /// <doc-id>dn927642</doc-id>
        /// <unmanaged>BlinkScoreLeft</unmanaged>
        /// <unmanaged-short>BlinkScoreLeft</unmanaged-short>
        public System.Int32 BlinkScoreLeft;
        /// <summary>
        /// <dd> <p>0 indicates no blink for the right eye, 100 indicates definite blink for the right eye (0 - 100).</p> </dd>
        /// </summary>
        /// <doc-id>dn927642</doc-id>
        /// <unmanaged>BlinkScoreRight</unmanaged>
        /// <unmanaged-short>BlinkScoreRight</unmanaged-short>
        public System.Int32 BlinkScoreRight;
        /// <summary>
        /// <dd> <p>A  defined facial expression value.</p> </dd>
        /// </summary>
        /// <doc-id>dn927642</doc-id>
        /// <unmanaged>FacialExpression</unmanaged>
        /// <unmanaged-short>FacialExpression</unmanaged-short>
        public System.Int32 FacialExpression;
        /// <summary>
        /// <dd> <p>0 indicates no such facial expression as identified, 100 indicates definite such facial expression as defined (0 - 100).</p> </dd>
        /// </summary>
        /// <doc-id>dn927642</doc-id>
        /// <unmanaged>FacialExpressionScore</unmanaged>
        /// <unmanaged-short>FacialExpressionScore</unmanaged-short>
        public System.Int32 FacialExpressionScore;
    }

    /// <summary>
    /// <p>The <strong>FaceCharacterizationBlobHeader</strong> structure  describes the size and count information of the blob format for the <strong>MF_CAPTURE_METADATA_FACEROICHARACTERIZATIONS</strong> attribute.</p>
    /// </summary>
    /// <doc-id>dn927643</doc-id>
    /// <unmanaged>FaceCharacterizationBlobHeader</unmanaged>
    /// <unmanaged-short>FaceCharacterizationBlobHeader</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct FaceCharacterizationBlobHeader
    {
        /// <summary>
        /// <dd> <p>Size of this header + all following <strong>FaceCharacterization</strong> structures.</p> </dd>
        /// </summary>
        /// <doc-id>dn927643</doc-id>
        /// <unmanaged>Size</unmanaged>
        /// <unmanaged-short>Size</unmanaged-short>
        public System.Int32 Size;
        /// <summary>
        /// <dd> <p>Number of <strong>FaceCharacterization</strong> structures in the blob. Must match the number of <strong>FaceRectInfo</strong> structures in <strong>FaceRectInfoBlobHeader</strong>.</p> </dd>
        /// </summary>
        /// <doc-id>dn927643</doc-id>
        /// <unmanaged>Count</unmanaged>
        /// <unmanaged-short>Count</unmanaged-short>
        public System.Int32 Count;
    }

    /// <summary>
    /// <p>The <strong>FaceRectInfo</strong> structure describes the blob format for the <strong>MF_CAPTURE_METADATA_FACEROIS</strong> attribute.</p>
    /// </summary>
    /// <remarks>
    /// <p>The <strong>MF_CAPTURE_METADATA_FACEROIS</strong> attribute contains the face rectangle info detected by the driver.   By default driver\MFT0 should provide the face information on preview stream.  If the driver advertises the capability on other streams, driver\MFT must provide the face info on the corresponding streams if the application enables face detection on those streams.  When video stabilization is enabled on the driver, the face information should be provided post-video stabilization. The dominate face must be the first <strong>FaceRectInfo</strong> in the blob.</p><p>The <strong>FaceRectInfoBlobHeader</strong> and <strong>FaceRectInfo</strong> structures only describe the blob format for the <strong>MF_CAPTURE_METADATA_FACEROIS</strong> attribute.  The metadata item structure for face ROIs (<strong>KSCAMERA_METADATA_ITEMHEADER</strong> + face ROIs metadata payload) is up to driver and must be 8-byte aligned.</p>
    /// </remarks>
    /// <doc-id>dn927644</doc-id>
    /// <unmanaged>FaceRectInfo</unmanaged>
    /// <unmanaged-short>FaceRectInfo</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct FaceRectInfo
    {
        /// <summary>
        /// <dd> <p>Relative coordinates on the frame that face detection is running (Q31 format).</p> </dd>
        /// </summary>
        /// <doc-id>dn927644</doc-id>
        /// <unmanaged>Region</unmanaged>
        /// <unmanaged-short>Region</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawRectangle Region;
        /// <summary>
        /// <dd> <p>Confidence level of the region being a face (0 - 100).</p> </dd>
        /// </summary>
        /// <doc-id>dn927644</doc-id>
        /// <unmanaged>confidenceLevel</unmanaged>
        /// <unmanaged-short>confidenceLevel</unmanaged-short>
        public System.Int32 ConfidenceLevel;
    }

    /// <summary>
    /// <p>The <strong>FaceRectInfoBlobHeader</strong> structure describes the size and count information of the blob format for the <strong>MF_CAPTURE_METADATA_FACEROIS</strong> attribute.</p>
    /// </summary>
    /// <doc-id>dn927645</doc-id>
    /// <unmanaged>FaceRectInfoBlobHeader</unmanaged>
    /// <unmanaged-short>FaceRectInfoBlobHeader</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct FaceRectInfoBlobHeader
    {
        /// <summary>
        /// <dd> <p>Size of this header + all following <strong>FaceRectInfo</strong> structures.</p> </dd>
        /// </summary>
        /// <doc-id>dn927645</doc-id>
        /// <unmanaged>Size</unmanaged>
        /// <unmanaged-short>Size</unmanaged-short>
        public System.Int32 Size;
        /// <summary>
        /// <dd> <p>Number of <strong>FaceRectInfo</strong> structures in the blob.</p> </dd>
        /// </summary>
        /// <doc-id>dn927645</doc-id>
        /// <unmanaged>Count</unmanaged>
        /// <unmanaged-short>Count</unmanaged-short>
        public System.Int32 Count;
    }

    /// <summary>
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>A vector with two components.</p>
    /// </summary>
    /// <doc-id>mt740402</doc-id>
    /// <unmanaged>MF_FLOAT2</unmanaged>
    /// <unmanaged-short>MF_FLOAT2</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct Float2
    {
        /// <summary>
        /// <dd> <p>X component of the vector.</p> </dd>
        /// </summary>
        /// <doc-id>mt740402</doc-id>
        /// <unmanaged>x</unmanaged>
        /// <unmanaged-short>x</unmanaged-short>
        public System.Single X;
        /// <summary>
        /// <dd> <p>Y component of the vector.</p> </dd>
        /// </summary>
        /// <doc-id>mt740402</doc-id>
        /// <unmanaged>y</unmanaged>
        /// <unmanaged-short>y</unmanaged-short>
        public System.Single Y;
    }

    /// <summary>
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>A vector with three components.</p>
    /// </summary>
    /// <doc-id>mt740403</doc-id>
    /// <unmanaged>MF_FLOAT3</unmanaged>
    /// <unmanaged-short>MF_FLOAT3</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct Float3
    {
        /// <summary>
        /// <dd> <p>X component of the vector.</p> </dd>
        /// </summary>
        /// <doc-id>mt740403</doc-id>
        /// <unmanaged>x</unmanaged>
        /// <unmanaged-short>x</unmanaged-short>
        public System.Single X;
        /// <summary>
        /// <dd> <p>Y component of the vector.</p> </dd>
        /// </summary>
        /// <doc-id>mt740403</doc-id>
        /// <unmanaged>y</unmanaged>
        /// <unmanaged-short>y</unmanaged-short>
        public System.Single Y;
        /// <summary>
        /// <dd> <p>Z component of the vector.</p> </dd>
        /// </summary>
        /// <doc-id>mt740403</doc-id>
        /// <unmanaged>z</unmanaged>
        /// <unmanaged-short>z</unmanaged-short>
        public System.Single Z;
    }

    /// <summary>
    /// <p> </p><p>Contains coefficients used to transform multichannel audio into a smaller number of audio channels. This process is called <em>fold-down</em>.</p>
    /// </summary>
    /// <remarks>
    /// <p>To specify this information in the media type, set the <strong><see cref = "AudioFolddownMatrix"/></strong> attribute.</p><p>The ASF media source supports fold-down from six channels (5.1 audio) to two channels (stereo). It gets the information from the g_wszFold6To2Channels3 attribute in the ASF header. This attribute is documented in the Windows Media Format SDK documentation.</p>
    /// </remarks>
    /// <doc-id>aa369731</doc-id>
    /// <unmanaged>MFFOLDDOWN_MATRIX</unmanaged>
    /// <unmanaged-short>MFFOLDDOWN_MATRIX</unmanaged-short>
    public partial struct FolddownMatrix
    {
        /// <summary>
        /// <dd> <p>Size of the structure, in bytes.</p> </dd>
        /// </summary>
        /// <doc-id>aa369731</doc-id>
        /// <unmanaged>cbSize</unmanaged>
        /// <unmanaged-short>cbSize</unmanaged-short>
        public System.Int32 CbSize;
        /// <summary>
        /// <dd> <p>Number of source channels.</p> </dd>
        /// </summary>
        /// <doc-id>aa369731</doc-id>
        /// <unmanaged>cSrcChannels</unmanaged>
        /// <unmanaged-short>cSrcChannels</unmanaged-short>
        public System.Int32 CSrcChannels;
        /// <summary>
        /// <dd> <p>Number of destination channels.</p> </dd>
        /// </summary>
        /// <doc-id>aa369731</doc-id>
        /// <unmanaged>cDstChannels</unmanaged>
        /// <unmanaged-short>cDstChannels</unmanaged-short>
        public System.Int32 CDstChannels;
        /// <summary>
        /// <dd> <p>Specifies the assignment of audio channels to speaker positions in the transformed audio. This member is a bitwise <strong>OR</strong> of flags that define the speaker positions. For a list of valid flags, see <strong><see cref = "AudioChannelMask"/></strong> attribute.</p> </dd>
        /// </summary>
        /// <doc-id>aa369731</doc-id>
        /// <unmanaged>dwChannelMask</unmanaged>
        /// <unmanaged-short>dwChannelMask</unmanaged-short>
        public System.Int32 DwChannelMask;
        /// <summary>
        /// <dd> <p>Array that contains the fold-down coefficients. The number of coefficients is <strong>cSrcChannels</strong>?<strong>cDstChannels</strong>. If the number of coefficients is less than the size of the array, the remaining elements in the array are ignored. For more information about how the coefficients are applied, see Windows Media Audio Professional Codec Features.</p> </dd>
        /// </summary>
        /// <doc-id>aa369731</doc-id>
        /// <unmanaged>Coeff</unmanaged>
        /// <unmanaged-short>Coeff</unmanaged-short>
        public System.Int32[] Coeff
        {
            get => _Coeff ?? (_Coeff = new System.Int32[64]);
            private set => _Coeff = value;
        }

        internal System.Int32[] _Coeff;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.Int32 CbSize;
            public System.Int32 CSrcChannels;
            public System.Int32 CDstChannels;
            public System.Int32 DwChannelMask;
            public System.Int32 Coeff;
            public System.Int32 __Coeff1;
            public System.Int32 __Coeff2;
            public System.Int32 __Coeff3;
            public System.Int32 __Coeff4;
            public System.Int32 __Coeff5;
            public System.Int32 __Coeff6;
            public System.Int32 __Coeff7;
            public System.Int32 __Coeff8;
            public System.Int32 __Coeff9;
            public System.Int32 __Coeff10;
            public System.Int32 __Coeff11;
            public System.Int32 __Coeff12;
            public System.Int32 __Coeff13;
            public System.Int32 __Coeff14;
            public System.Int32 __Coeff15;
            public System.Int32 __Coeff16;
            public System.Int32 __Coeff17;
            public System.Int32 __Coeff18;
            public System.Int32 __Coeff19;
            public System.Int32 __Coeff20;
            public System.Int32 __Coeff21;
            public System.Int32 __Coeff22;
            public System.Int32 __Coeff23;
            public System.Int32 __Coeff24;
            public System.Int32 __Coeff25;
            public System.Int32 __Coeff26;
            public System.Int32 __Coeff27;
            public System.Int32 __Coeff28;
            public System.Int32 __Coeff29;
            public System.Int32 __Coeff30;
            public System.Int32 __Coeff31;
            public System.Int32 __Coeff32;
            public System.Int32 __Coeff33;
            public System.Int32 __Coeff34;
            public System.Int32 __Coeff35;
            public System.Int32 __Coeff36;
            public System.Int32 __Coeff37;
            public System.Int32 __Coeff38;
            public System.Int32 __Coeff39;
            public System.Int32 __Coeff40;
            public System.Int32 __Coeff41;
            public System.Int32 __Coeff42;
            public System.Int32 __Coeff43;
            public System.Int32 __Coeff44;
            public System.Int32 __Coeff45;
            public System.Int32 __Coeff46;
            public System.Int32 __Coeff47;
            public System.Int32 __Coeff48;
            public System.Int32 __Coeff49;
            public System.Int32 __Coeff50;
            public System.Int32 __Coeff51;
            public System.Int32 __Coeff52;
            public System.Int32 __Coeff53;
            public System.Int32 __Coeff54;
            public System.Int32 __Coeff55;
            public System.Int32 __Coeff56;
            public System.Int32 __Coeff57;
            public System.Int32 __Coeff58;
            public System.Int32 __Coeff59;
            public System.Int32 __Coeff60;
            public System.Int32 __Coeff61;
            public System.Int32 __Coeff62;
            public System.Int32 __Coeff63;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            CbSize = @ref.CbSize;
            CSrcChannels = @ref.CSrcChannels;
            CDstChannels = @ref.CDstChannels;
            DwChannelMask = @ref.DwChannelMask;
            fixed (void *__to = &Coeff[0], __from = &@ref.Coeff)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 64 * sizeof (System.Int32));
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.CbSize = CbSize;
            @ref.CSrcChannels = CSrcChannels;
            @ref.CDstChannels = CDstChannels;
            @ref.DwChannelMask = DwChannelMask;
            fixed (void *__from = &Coeff[0], __to = &@ref.Coeff)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 64 * sizeof (System.Int32));
        }
    }

    /// <summary>
    /// <p>The <strong>HistogramBlobHeader</strong> structure describes the blob size and the number of histograms in the blob for the <strong>MF_CAPTURE_METADATA_HISTOGRAM</strong> attribute.</p>
    /// </summary>
    /// <doc-id>dn927646</doc-id>
    /// <unmanaged>HistogramBlobHeader</unmanaged>
    /// <unmanaged-short>HistogramBlobHeader</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct HistogramBlobHeader
    {
        /// <summary>
        /// <dd> <p>Size of the entire histogram blob in bytes.</p> </dd>
        /// </summary>
        /// <doc-id>dn927646</doc-id>
        /// <unmanaged>Size</unmanaged>
        /// <unmanaged-short>Size</unmanaged-short>
        public System.Int32 Size;
        /// <summary>
        /// <dd> <p>Number of histograms in the blob. Each histogram is identified by a <strong>HistogramHeader</strong>.</p> </dd>
        /// </summary>
        /// <doc-id>dn927646</doc-id>
        /// <unmanaged>Histograms</unmanaged>
        /// <unmanaged-short>Histograms</unmanaged-short>
        public System.Int32 Histograms;
    }

    /// <summary>
    /// <p>The  <strong>HistogramDataHeader</strong> structure describes the blob format for the <strong>MF_CAPTURE_METADATA_HISTOGRAM</strong> attribute.  </p>
    /// </summary>
    /// <doc-id>dn927647</doc-id>
    /// <unmanaged>HistogramDataHeader</unmanaged>
    /// <unmanaged-short>HistogramDataHeader</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct HistogramDataHeader
    {
        /// <summary>
        /// <dd> <p>Size in bytes of this header + all following histogram data.</p> </dd>
        /// </summary>
        /// <doc-id>dn927647</doc-id>
        /// <unmanaged>Size</unmanaged>
        /// <unmanaged-short>Size</unmanaged-short>
        public System.Int32 Size;
        /// <summary>
        /// <dd> <p>Mask of the color channel for the histogram data.</p> </dd>
        /// </summary>
        /// <doc-id>dn927647</doc-id>
        /// <unmanaged>ChannelMask</unmanaged>
        /// <unmanaged-short>ChannelMask</unmanaged-short>
        public System.Int32 ChannelMask;
        /// <summary>
        /// <dd> <p>1 if linear, 0 if nonlinear.</p> </dd>
        /// </summary>
        /// <doc-id>dn927647</doc-id>
        /// <unmanaged>Linear</unmanaged>
        /// <unmanaged-short>Linear</unmanaged-short>
        public System.Int32 Linear;
    }

    /// <summary>
    /// <p>The  <strong>HistogramGrid</strong> structure describes the blob format for <strong>MF_CAPTURE_METADATA_HISTOGRAM</strong>.</p>
    /// </summary>
    /// <doc-id>dn927648</doc-id>
    /// <unmanaged>HistogramGrid</unmanaged>
    /// <unmanaged-short>HistogramGrid</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct HistogramGrid
    {
        /// <summary>
        /// <dd> <p>Width of the sensor output that histogram is collected from.</p> </dd>
        /// </summary>
        /// <doc-id>dn927648</doc-id>
        /// <unmanaged>Width</unmanaged>
        /// <unmanaged-short>Width</unmanaged-short>
        public System.Int32 Width;
        /// <summary>
        /// <dd> <p>Height of the sensor output that histogram is collected from.</p> </dd>
        /// </summary>
        /// <doc-id>dn927648</doc-id>
        /// <unmanaged>Height</unmanaged>
        /// <unmanaged-short>Height</unmanaged-short>
        public System.Int32 Height;
        /// <summary>
        /// <dd> <p>Absolute coordinates of the region on the sensor output that the histogram is collected for.</p> </dd>
        /// </summary>
        /// <doc-id>dn927648</doc-id>
        /// <unmanaged>Region</unmanaged>
        /// <unmanaged-short>Region</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawRectangle Region;
    }

    /// <summary>
    /// <p>The <strong>HistogramHeader</strong> structure describes the blob format for <strong>MF_CAPTURE_METADATA_HISTOGRAM</strong>.</p>
    /// </summary>
    /// <remarks>
    /// <p>The <strong>MF_CAPTURE_METADATA_HISTOGRAM</strong> attribute contains a  histogram when a preview frame is captured.</p><p>For the <strong>ChannelMasks</strong> field, the following bitmasks indicate the available channels in the histogram:</p><pre>#define MF_HISTOGRAM_CHANNEL_Y  0x00000001
    /// #define MF_HISTOGRAM_CHANNEL_R  0x00000002
    /// #define MF_HISTOGRAM_CHANNEL_G  0x00000004
    /// #define MF_HISTOGRAM_CHANNEL_B  0x00000008
    /// #define MF_HISTOGRAM_CHANNEL_Cb 0x00000010
    /// #define MF_HISTOGRAM_CHANNEL_Cr 0x00000020</pre><p>Each blob can contain multiple histograms collected from different regions or different color spaces of the same frame. Each histogram in the blob is identified by its own <strong>HistogramHeader</strong>. Each histogram has its own region and sensor output size associated. For full frame histogram, the region will match the sensor output size specified in <strong>HistogramGrid</strong>.</p><p>Histogram data for all available channels are grouped under one histogram. Histogram data for each channel is identified by a <strong>HistogramDataHeader</strong> immediate above the data. <strong>ChannelMasks</strong> indicate how many and what channels are having the histogram data, which is the bitwise OR of the supported <strong>MF_HISTOGRAM_CHANNEL_*</strong> bitmasks as defined above. <strong>ChannelMask</strong> indicates what channel the data is for, which is identified by any one of the <strong>MF_HISTOGRAM_CHANNEL_*</strong> bitmasks.</p><p>Histogram data is an array of <strong><see cref = "System.Int32"/></strong> with each entry representing the number of pixels falling under a set of tonal values as categorized by the bin.  The data in the array should start from bin 0 to bin N-1, where N is the number of bins in the histogram, for example, <strong>HistogramBlobHeader.Bins</strong>.</p><p>For Windows?10, if <strong>KSPROPERTY_CAMERACONTROL_EXTENDED_HISTOGRAM</strong> is supported, at minimum a full frame histogram with Y channel must be provided which should be the first histogram in the histogram blob.
    /// Note that <strong>HistogramBlobHeader</strong>, <strong>HistogramHeader</strong>, <strong>HistogramDataHeader</strong> and Histogram data only describe the blob format for the <strong>MF_CAPTURE_METADATA_HISTOGRAM</strong> attribute.  The metadata item structure for the histogram (<strong>KSCAMERA_METADATA_ITEMHEADER</strong> + all histogram metadata payload) is up to driver and must be 8-byte aligned.</p>
    /// </remarks>
    /// <doc-id>dn927649</doc-id>
    /// <unmanaged>HistogramHeader</unmanaged>
    /// <unmanaged-short>HistogramHeader</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct HistogramHeader
    {
        /// <summary>
        /// <dd> <p>Size of this header + (<strong>HistogramDataHeader</strong> + histogram data following) * number of channels available.</p> </dd>
        /// </summary>
        /// <doc-id>dn927649</doc-id>
        /// <unmanaged>Size</unmanaged>
        /// <unmanaged-short>Size</unmanaged-short>
        public System.Int32 Size;
        /// <summary>
        /// <dd> <p>Number of bins in the histogram.</p> </dd>
        /// </summary>
        /// <doc-id>dn927649</doc-id>
        /// <unmanaged>Bins</unmanaged>
        /// <unmanaged-short>Bins</unmanaged-short>
        public System.Int32 Bins;
        /// <summary>
        /// <dd> <p>Color space that the histogram is collected from</p> </dd>
        /// </summary>
        /// <doc-id>dn927649</doc-id>
        /// <unmanaged>FourCC</unmanaged>
        /// <unmanaged-short>FourCC</unmanaged-short>
        public System.Int32 FourCC;
        /// <summary>
        /// <dd> <p>Masks of the color channels that the histogram is collected for.</p> </dd>
        /// </summary>
        /// <doc-id>dn927649</doc-id>
        /// <unmanaged>ChannelMasks</unmanaged>
        /// <unmanaged-short>ChannelMasks</unmanaged-short>
        public System.Int32 ChannelMasks;
        /// <summary>
        /// <dd> <p>Grid that the histogram is collected from.</p> </dd>
        /// </summary>
        /// <doc-id>dn927649</doc-id>
        /// <unmanaged>Grid</unmanaged>
        /// <unmanaged-short>Grid</unmanaged-short>
        public SharpDX.MediaFoundation.HistogramGrid Grid;
    }

    /// <summary>
    /// <p> </p><p>Describes an action requested by an output trust authority (OTA). The request is sent to an input trust authority (ITA).</p>
    /// </summary>
    /// <doc-id>ms695312</doc-id>
    /// <unmanaged>MFINPUTTRUSTAUTHORITY_ACCESS_ACTION</unmanaged>
    /// <unmanaged-short>MFINPUTTRUSTAUTHORITY_ACCESS_ACTION</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct InputTrustauthorityAccessAction
    {
        /// <summary>
        /// <dd> <p>Specifies the action as a member of the <strong><see cref = "SharpDX.MediaFoundation.PolicymanagerAction"/></strong> enumeration.</p> </dd>
        /// </summary>
        /// <doc-id>ms695312</doc-id>
        /// <unmanaged>Action</unmanaged>
        /// <unmanaged-short>Action</unmanaged-short>
        public SharpDX.MediaFoundation.PolicymanagerAction Action;
        /// <summary>
        /// <dd> <p>Pointer to a buffer that contains a ticket object, provided by the OTA.</p> </dd>
        /// </summary>
        /// <doc-id>ms695312</doc-id>
        /// <unmanaged>pbTicket</unmanaged>
        /// <unmanaged-short>pbTicket</unmanaged-short>
        public System.IntPtr PbTicket;
        /// <summary>
        /// <dd> <p>Size of the ticket object, in bytes.</p> </dd>
        /// </summary>
        /// <doc-id>ms695312</doc-id>
        /// <unmanaged>cbTicket</unmanaged>
        /// <unmanaged-short>cbTicket</unmanaged-short>
        public System.Int32 CbTicket;
    }

    /// <summary>
    /// <p> </p><p>Contains parameters for the <strong>IMFInputTrustAuthority::BindAccess</strong> or <strong>IMFInputTrustAuthority::UpdateAccess</strong> method.</p>
    /// </summary>
    /// <doc-id>ms697403</doc-id>
    /// <unmanaged>MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS</unmanaged>
    /// <unmanaged-short>MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS</unmanaged-short>
    public partial struct InputTrustauthorityAccessParameters
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697403</doc-id>
        /// <unmanaged>dwSize</unmanaged>
        /// <unmanaged-short>dwSize</unmanaged-short>
        public System.Int32 DwSize;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697403</doc-id>
        /// <unmanaged>dwVer</unmanaged>
        /// <unmanaged-short>dwVer</unmanaged-short>
        public System.Int32 DwVer;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697403</doc-id>
        /// <unmanaged>cbSignatureOffset</unmanaged>
        /// <unmanaged-short>cbSignatureOffset</unmanaged-short>
        public System.Int32 CbSignatureOffset;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697403</doc-id>
        /// <unmanaged>cbSignatureSize</unmanaged>
        /// <unmanaged-short>cbSignatureSize</unmanaged-short>
        public System.Int32 CbSignatureSize;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697403</doc-id>
        /// <unmanaged>cbExtensionOffset</unmanaged>
        /// <unmanaged-short>cbExtensionOffset</unmanaged-short>
        public System.Int32 CbExtensionOffset;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697403</doc-id>
        /// <unmanaged>cbExtensionSize</unmanaged>
        /// <unmanaged-short>cbExtensionSize</unmanaged-short>
        public System.Int32 CbExtensionSize;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697403</doc-id>
        /// <unmanaged>cActions</unmanaged>
        /// <unmanaged-short>cActions</unmanaged-short>
        public System.Int32 CActions;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697403</doc-id>
        /// <unmanaged>rgOutputActions</unmanaged>
        /// <unmanaged-short>rgOutputActions</unmanaged-short>
        public SharpDX.MediaFoundation.InputTrustauthorityAccessAction[] RgOutputActions
        {
            get => _RgOutputActions ?? (_RgOutputActions = new SharpDX.MediaFoundation.InputTrustauthorityAccessAction[1]);
            private set => _RgOutputActions = value;
        }

        internal SharpDX.MediaFoundation.InputTrustauthorityAccessAction[] _RgOutputActions;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.Int32 DwSize;
            public System.Int32 DwVer;
            public System.Int32 CbSignatureOffset;
            public System.Int32 CbSignatureSize;
            public System.Int32 CbExtensionOffset;
            public System.Int32 CbExtensionSize;
            public System.Int32 CActions;
            public SharpDX.MediaFoundation.InputTrustauthorityAccessAction RgOutputActions;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            DwSize = @ref.DwSize;
            DwVer = @ref.DwVer;
            CbSignatureOffset = @ref.CbSignatureOffset;
            CbSignatureSize = @ref.CbSignatureSize;
            CbExtensionOffset = @ref.CbExtensionOffset;
            CbExtensionSize = @ref.CbExtensionSize;
            CActions = @ref.CActions;
            fixed (void *__to = &RgOutputActions[0], __from = &@ref.RgOutputActions)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 1 * sizeof (SharpDX.MediaFoundation.InputTrustauthorityAccessAction));
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.DwSize = DwSize;
            @ref.DwVer = DwVer;
            @ref.CbSignatureOffset = CbSignatureOffset;
            @ref.CbSignatureSize = CbSignatureSize;
            @ref.CbExtensionOffset = CbExtensionOffset;
            @ref.CbExtensionSize = CbExtensionSize;
            @ref.CActions = CActions;
            fixed (void *__from = &RgOutputActions[0], __to = &@ref.RgOutputActions)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 1 * sizeof (SharpDX.MediaFoundation.InputTrustauthorityAccessAction));
        }
    }

    /// <summary>
    /// <p> </p><p>Specifies the buffering requirements of a file.</p>
    /// </summary>
    /// <remarks>
    /// <p>This structure describes the buffering requirements for content encoded at the bit rate specified in the <strong>dwBitrate</strong>. The <strong>msBufferWindow</strong> member indicates how much data should be buffered before starting playback. The size of the buffer in bytes is <strong>msBufferWinow</strong>?<strong>dwBitrate</strong> / 8000.</p>
    /// </remarks>
    /// <doc-id>aa371870</doc-id>
    /// <unmanaged>MF_LEAKY_BUCKET_PAIR</unmanaged>
    /// <unmanaged-short>MF_LEAKY_BUCKET_PAIR</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct LeakyBucketPair
    {
        /// <summary>
        /// <dd> <p>Bit rate, in bits per second.</p> </dd>
        /// </summary>
        /// <doc-id>aa371870</doc-id>
        /// <unmanaged>dwBitrate</unmanaged>
        /// <unmanaged-short>dwBitrate</unmanaged-short>
        public System.Int32 DwBitrate;
        /// <summary>
        /// <dd> <p>Size of the buffer window, in milliseconds.</p> </dd>
        /// </summary>
        /// <doc-id>aa371870</doc-id>
        /// <unmanaged>msBufferWindow</unmanaged>
        /// <unmanaged-short>msBufferWindow</unmanaged-short>
        public System.Int32 MsBufferWindow;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>MACROBLOCK_DATA</unmanaged>
    /// <unmanaged-short>MACROBLOCK_DATA</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct MacroblockData
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>flags</unmanaged>
        /// <unmanaged-short>flags</unmanaged-short>
        public System.Int32 Flags;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>motionVectorX</unmanaged>
        /// <unmanaged-short>motionVectorX</unmanaged-short>
        public System.Int16 MotionVectorX;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>motionVectorY</unmanaged>
        /// <unmanaged-short>motionVectorY</unmanaged-short>
        public System.Int16 MotionVectorY;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>QPDelta</unmanaged>
        /// <unmanaged-short>QPDelta</unmanaged-short>
        public System.Int32 QPDelta;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>MFMediaKeyStatus</unmanaged>
    /// <unmanaged-short>MFMediaKeyStatus</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct MediaKeyStatus
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>pbKeyId</unmanaged>
        /// <unmanaged-short>pbKeyId</unmanaged-short>
        public System.IntPtr PbKeyId;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>cbKeyId</unmanaged>
        /// <unmanaged-short>cbKeyId</unmanaged-short>
        public System.Int32 CbKeyId;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>eMediaKeyStatus</unmanaged>
        /// <unmanaged-short>eMediaKeyStatus</unmanaged-short>
        public SharpDX.MediaFoundation.MediaKeyStatusState EMediaKeyStatus;
    }

    /// <summary>
    /// <p>The <strong>MetadataTimeStamps</strong> structure describes the blob format for the <strong>MF_CAPTURE_METADATA_FACEROITIMESTAMPS</strong> attribute.</p>
    /// </summary>
    /// <remarks>
    /// <p>The <strong>MF_CAPTURE_METADATA_FACEROITIMESTAMPS</strong> attribute contains the time stamp information for the face ROIs identified in <strong>MF_CAPTURE_METADATA_FACEROIS</strong>.  For a  device that cannot provide the time stamp for face ROIs, this attribute should be omitted.</p><p>For the <strong>Flags</strong> field, the following bit flags  indicate which time stamp is valid:</p><pre>#define MF_METADATATIMESTAMPS_DEVICE        0x00000001
    /// #define MF_METADATATIMESTAMPS_PRESENTATION  0x00000002</pre><p>MFT0 must set <strong>Flags</strong> to <strong>MF_METADATATIEMSTAMPS_DEVICE</strong> and the appropriate QPC time for <strong>Device</strong>, if the driver provides the timestamp metadata for the face ROIs.</p><p>The <strong>MetadataTimeStamps</strong> structure only describes the blob format for the <strong>MF_CAPTURE_METADATA_FACEROITIMESTAMPS</strong> attribute.  The metadata item structure for timestamp (<strong>KSCAMERA_METADATA_ITEMHEADER</strong> + timestamp metadata payload) is up to driver and must be 8-byte aligned.</p>
    /// </remarks>
    /// <doc-id>dn898736</doc-id>
    /// <unmanaged>MetadataTimeStamps</unmanaged>
    /// <unmanaged-short>MetadataTimeStamps</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct MetadataTimeStamps
    {
        /// <summary>
        /// <dd> <p>Bitwise OR of the <strong>MF_METADATATIMESTAMPS_*</strong> flags.</p> </dd>
        /// </summary>
        /// <doc-id>dn898736</doc-id>
        /// <unmanaged>Flags</unmanaged>
        /// <unmanaged-short>Flags</unmanaged-short>
        public System.Int32 Flags;
        /// <summary>
        /// <dd> <p>QPC time for the sample  the face rectangle is derived from (in 100ns).</p> </dd>
        /// </summary>
        /// <doc-id>dn898736</doc-id>
        /// <unmanaged>Device</unmanaged>
        /// <unmanaged-short>Device</unmanaged-short>
        public System.Int64 Device;
        /// <summary>
        /// <dd> <p>PTS for the sample  the face rectangle is derived from (in 100ns).</p> </dd>
        /// </summary>
        /// <doc-id>dn898736</doc-id>
        /// <unmanaged>Presentation</unmanaged>
        /// <unmanaged-short>Presentation</unmanaged-short>
        public System.Int64 Presentation;
    }

    /// <summary>
    /// <p>Provides information on a screen-to-screen move and a dirty rectangle copy operation.</p>
    /// </summary>
    /// <doc-id>hh406478</doc-id>
    /// <unmanaged>MOVE_RECT</unmanaged>
    /// <unmanaged-short>MOVE_RECT</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct MoveRectangle
    {
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Mathematics.Interop.RawPoint"/></strong> structure that describes the source (<em>x, y</em>) point where the source rectangle is copied from.</p> </dd>
        /// </summary>
        /// <doc-id>hh406478</doc-id>
        /// <unmanaged>SourcePoint</unmanaged>
        /// <unmanaged-short>SourcePoint</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawPoint SourcePoint;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure that contains the destination rectangle where the dirty rectangle is copied to.</p> </dd>
        /// </summary>
        /// <doc-id>hh406478</doc-id>
        /// <unmanaged>DestRect</unmanaged>
        /// <unmanaged-short>DestRect</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawRectangle DestRect;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>MOVEREGION_INFO</unmanaged>
    /// <unmanaged-short>MOVEREGION_INFO</unmanaged-short>
    public partial struct MoveregionInformation
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>FrameNumber</unmanaged>
        /// <unmanaged-short>FrameNumber</unmanaged-short>
        public System.Int32 FrameNumber;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>NumMoveRegions</unmanaged>
        /// <unmanaged-short>NumMoveRegions</unmanaged-short>
        public System.Int32 NumMoveRegions;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MoveRegions</unmanaged>
        /// <unmanaged-short>MoveRegions</unmanaged-short>
        public SharpDX.MediaFoundation.MoveRectangle[] MoveRegions
        {
            get => _MoveRegions ?? (_MoveRegions = new SharpDX.MediaFoundation.MoveRectangle[1]);
            private set => _MoveRegions = value;
        }

        internal SharpDX.MediaFoundation.MoveRectangle[] _MoveRegions;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.Int32 FrameNumber;
            public System.Int32 NumMoveRegions;
            public SharpDX.MediaFoundation.MoveRectangle MoveRegions;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            FrameNumber = @ref.FrameNumber;
            NumMoveRegions = @ref.NumMoveRegions;
            fixed (void *__to = &MoveRegions[0], __from = &@ref.MoveRegions)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 1 * sizeof (SharpDX.MediaFoundation.MoveRectangle));
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.FrameNumber = FrameNumber;
            @ref.NumMoveRegions = NumMoveRegions;
            fixed (void *__from = &MoveRegions[0], __to = &@ref.MoveRegions)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 1 * sizeof (SharpDX.MediaFoundation.MoveRectangle));
        }
    }

    /// <summary>
    /// <p>Contains encoding statistics from the Digital Living Network Alliance (DLNA) media sink.</p><p>This structure is used with the <see cref = "Statistics"/> attribute.</p>
    /// </summary>
    /// <doc-id>dd388511</doc-id>
    /// <unmanaged>MFMPEG2DLNASINKSTATS</unmanaged>
    /// <unmanaged-short>MFMPEG2DLNASINKSTATS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct Mpeg2dlnasinkstats
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd388511</doc-id>
        /// <unmanaged>cBytesWritten</unmanaged>
        /// <unmanaged-short>cBytesWritten</unmanaged-short>
        public System.Int64 CBytesWritten;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd388511</doc-id>
        /// <unmanaged>fPAL</unmanaged>
        /// <unmanaged-short>fPAL</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool FPAL;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd388511</doc-id>
        /// <unmanaged>fccVideo</unmanaged>
        /// <unmanaged-short>fccVideo</unmanaged-short>
        public System.Int32 FccVideo;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd388511</doc-id>
        /// <unmanaged>dwVideoWidth</unmanaged>
        /// <unmanaged-short>dwVideoWidth</unmanaged-short>
        public System.Int32 DwVideoWidth;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd388511</doc-id>
        /// <unmanaged>dwVideoHeight</unmanaged>
        /// <unmanaged-short>dwVideoHeight</unmanaged-short>
        public System.Int32 DwVideoHeight;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd388511</doc-id>
        /// <unmanaged>cVideoFramesReceived</unmanaged>
        /// <unmanaged-short>cVideoFramesReceived</unmanaged-short>
        public System.Int64 CVideoFramesReceived;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd388511</doc-id>
        /// <unmanaged>cVideoFramesEncoded</unmanaged>
        /// <unmanaged-short>cVideoFramesEncoded</unmanaged-short>
        public System.Int64 CVideoFramesEncoded;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd388511</doc-id>
        /// <unmanaged>cVideoFramesSkipped</unmanaged>
        /// <unmanaged-short>cVideoFramesSkipped</unmanaged-short>
        public System.Int64 CVideoFramesSkipped;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd388511</doc-id>
        /// <unmanaged>cBlackVideoFramesEncoded</unmanaged>
        /// <unmanaged-short>cBlackVideoFramesEncoded</unmanaged-short>
        public System.Int64 CBlackVideoFramesEncoded;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd388511</doc-id>
        /// <unmanaged>cVideoFramesDuplicated</unmanaged>
        /// <unmanaged-short>cVideoFramesDuplicated</unmanaged-short>
        public System.Int64 CVideoFramesDuplicated;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd388511</doc-id>
        /// <unmanaged>cAudioSamplesPerSec</unmanaged>
        /// <unmanaged-short>cAudioSamplesPerSec</unmanaged-short>
        public System.Int32 CAudioSamplesPerSec;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd388511</doc-id>
        /// <unmanaged>cAudioChannels</unmanaged>
        /// <unmanaged-short>cAudioChannels</unmanaged-short>
        public System.Int32 CAudioChannels;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd388511</doc-id>
        /// <unmanaged>cAudioBytesReceived</unmanaged>
        /// <unmanaged-short>cAudioBytesReceived</unmanaged-short>
        public System.Int64 CAudioBytesReceived;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd388511</doc-id>
        /// <unmanaged>cAudioFramesEncoded</unmanaged>
        /// <unmanaged-short>cAudioFramesEncoded</unmanaged-short>
        public System.Int64 CAudioFramesEncoded;
    }

    /// <summary>
    /// <p>Contains format data for a binary stream in an Advanced Streaming Format (ASF) file.</p>
    /// </summary>
    /// <remarks>
    /// <p>This structure is used with the <see cref = "ArbitraryHeader"/> media type attribute.</p><p>This structure corresponds to the first 60 bytes of the Type-Specific Data field of the Stream Properties Object, in files where the stream type is ASF_Binary_Media. For more information, see the ASF specification.</p><p>The Format Data field of the Type-Specific Data field is contained in the <see cref = "ArbitraryFormat"/> attribute of the media type.</p>
    /// </remarks>
    /// <doc-id>dd388931</doc-id>
    /// <unmanaged>MT_ARBITRARY_HEADER</unmanaged>
    /// <unmanaged-short>MT_ARBITRARY_HEADER</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct MtArbitraryHeader
    {
        /// <summary>
        /// <dd> <p>Major media type. This value is the <see cref = "System.Guid"/> stored in the Major Media Type field of the Type-Specific Data field of the ASF file. It might not match the major type <see cref = "System.Guid"/> from the Media Foundation media type. </p> </dd>
        /// </summary>
        /// <doc-id>dd388931</doc-id>
        /// <unmanaged>majortype</unmanaged>
        /// <unmanaged-short>majortype</unmanaged-short>
        public System.Guid Majortype;
        /// <summary>
        /// <dd> <p>Media subtype. </p> </dd>
        /// </summary>
        /// <doc-id>dd388931</doc-id>
        /// <unmanaged>subtype</unmanaged>
        /// <unmanaged-short>subtype</unmanaged-short>
        public System.Guid Subtype;
        /// <summary>
        /// <dd> <p>If <strong>TRUE</strong>, samples have a fixed size in bytes. Otherwise, samples have variable size.</p> </dd>
        /// </summary>
        /// <doc-id>dd388931</doc-id>
        /// <unmanaged>bFixedSizeSamples</unmanaged>
        /// <unmanaged-short>bFixedSizeSamples</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool BFixedSizeSamples;
        /// <summary>
        /// <dd> <p> If <strong>TRUE</strong>, the data in this stream uses temporal compression. Otherwise, samples are independent of each other.</p> </dd>
        /// </summary>
        /// <doc-id>dd388931</doc-id>
        /// <unmanaged>bTemporalCompression</unmanaged>
        /// <unmanaged-short>bTemporalCompression</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool BTemporalCompression;
        /// <summary>
        /// <dd> <p>If <strong>bFixedSizeSamples</strong> is <strong>TRUE</strong>, this member specifies the sample size in bytes. Otherwise, the value is ignored and should be 0.</p> </dd>
        /// </summary>
        /// <doc-id>dd388931</doc-id>
        /// <unmanaged>lSampleSize</unmanaged>
        /// <unmanaged-short>lSampleSize</unmanaged-short>
        public System.Int32 LSampleSize;
        /// <summary>
        /// <dd> <p>Format type <see cref = "System.Guid"/>. This <see cref = "System.Guid"/> identifies the structure of the additional format data, which is stored in the  <see cref = "ArbitraryFormat"/> attribute of the media type. If no additional format data is present, <strong>formattype</strong> equals GUID_NULL.</p> </dd>
        /// </summary>
        /// <doc-id>dd388931</doc-id>
        /// <unmanaged>formattype</unmanaged>
        /// <unmanaged-short>formattype</unmanaged-short>
        public System.Guid Formattype;
    }

    /// <summary>
    /// <p> </p><p>Defines custom color primaries for a video source. The color primaries define how to convert colors from RGB color space to CIE XYZ color space.</p>
    /// </summary>
    /// <remarks>
    /// <p>This structure is used with the <strong><see cref = "CustomVideoPrimaries"/></strong> attribute.</p>
    /// </remarks>
    /// <doc-id>ms696187</doc-id>
    /// <unmanaged>MT_CUSTOM_VIDEO_PRIMARIES</unmanaged>
    /// <unmanaged-short>MT_CUSTOM_VIDEO_PRIMARIES</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct MtCustomVideoPrimaries
    {
        /// <summary>
        /// <dd> <p>Red x-coordinate.</p> </dd>
        /// </summary>
        /// <doc-id>ms696187</doc-id>
        /// <unmanaged>fRx</unmanaged>
        /// <unmanaged-short>fRx</unmanaged-short>
        public System.Single FRx;
        /// <summary>
        /// <dd> <p>Red y-coordinate.</p> </dd>
        /// </summary>
        /// <doc-id>ms696187</doc-id>
        /// <unmanaged>fRy</unmanaged>
        /// <unmanaged-short>fRy</unmanaged-short>
        public System.Single FRy;
        /// <summary>
        /// <dd> <p>Green x-coordinate.</p> </dd>
        /// </summary>
        /// <doc-id>ms696187</doc-id>
        /// <unmanaged>fGx</unmanaged>
        /// <unmanaged-short>fGx</unmanaged-short>
        public System.Single FGx;
        /// <summary>
        /// <dd> <p>Green y-coordinate.</p> </dd>
        /// </summary>
        /// <doc-id>ms696187</doc-id>
        /// <unmanaged>fGy</unmanaged>
        /// <unmanaged-short>fGy</unmanaged-short>
        public System.Single FGy;
        /// <summary>
        /// <dd> <p>Blue x-coordinate.</p> </dd>
        /// </summary>
        /// <doc-id>ms696187</doc-id>
        /// <unmanaged>fBx</unmanaged>
        /// <unmanaged-short>fBx</unmanaged-short>
        public System.Single FBx;
        /// <summary>
        /// <dd> <p>Blue y-coordinate.</p> </dd>
        /// </summary>
        /// <doc-id>ms696187</doc-id>
        /// <unmanaged>fBy</unmanaged>
        /// <unmanaged-short>fBy</unmanaged-short>
        public System.Single FBy;
        /// <summary>
        /// <dd> <p>White point x-coordinate.</p> </dd>
        /// </summary>
        /// <doc-id>ms696187</doc-id>
        /// <unmanaged>fWx</unmanaged>
        /// <unmanaged-short>fWx</unmanaged-short>
        public System.Single FWx;
        /// <summary>
        /// <dd> <p>White point y-coordinate.</p> </dd>
        /// </summary>
        /// <doc-id>ms696187</doc-id>
        /// <unmanaged>fWy</unmanaged>
        /// <unmanaged-short>fWy</unmanaged-short>
        public System.Single FWy;
    }

    /// <summary>
    /// <p> </p><p>Contains the authentication information for the credential manager.</p>
    /// </summary>
    /// <doc-id>ms701554</doc-id>
    /// <unmanaged>MFNetCredentialManagerGetParam</unmanaged>
    /// <unmanaged-short>MFNetCredentialManagerGetParam</unmanaged-short>
    public partial struct NetCredentialManagerGetParam
    {
        /// <summary>
        /// <dd> <p>The response code of the authentication challenge. For example, NS_E_PROXY_ACCESSDENIED.</p> </dd>
        /// </summary>
        /// <doc-id>ms701554</doc-id>
        /// <unmanaged>hrOp</unmanaged>
        /// <unmanaged-short>hrOp</unmanaged-short>
        public SharpDX.Result HrOp;
        /// <summary>
        /// <dd> <p>Set this flag to <strong>TRUE</strong> if the currently logged on user's credentials should be used as the default credentials.</p> </dd>
        /// </summary>
        /// <doc-id>ms701554</doc-id>
        /// <unmanaged>fAllowLoggedOnUser</unmanaged>
        /// <unmanaged-short>fAllowLoggedOnUser</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool FAllowLoggedOnUser;
        /// <summary>
        /// <dd> <p>If <strong>TRUE</strong>, the authentication package will send unencrypted credentials over the network. Otherwise, the authentication package encrypts the credentials.</p> </dd>
        /// </summary>
        /// <doc-id>ms701554</doc-id>
        /// <unmanaged>fClearTextPackage</unmanaged>
        /// <unmanaged-short>fClearTextPackage</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool FClearTextPackage;
        /// <summary>
        /// <dd> <p>The original URL that requires authentication.</p> </dd>
        /// </summary>
        /// <doc-id>ms701554</doc-id>
        /// <unmanaged>pszUrl</unmanaged>
        /// <unmanaged-short>pszUrl</unmanaged-short>
        public System.String PszUrl;
        /// <summary>
        /// <dd> <p>The name of the site or proxy that requires authentication.</p> </dd>
        /// </summary>
        /// <doc-id>ms701554</doc-id>
        /// <unmanaged>pszSite</unmanaged>
        /// <unmanaged-short>pszSite</unmanaged-short>
        public System.String PszSite;
        /// <summary>
        /// <dd> <p>The name of the realm for this authentication.</p> </dd>
        /// </summary>
        /// <doc-id>ms701554</doc-id>
        /// <unmanaged>pszRealm</unmanaged>
        /// <unmanaged-short>pszRealm</unmanaged-short>
        public System.String PszRealm;
        /// <summary>
        /// <dd> <p>The name of the authentication package. For example, "Digest" or "MBS_BASIC".</p> </dd>
        /// </summary>
        /// <doc-id>ms701554</doc-id>
        /// <unmanaged>pszPackage</unmanaged>
        /// <unmanaged-short>pszPackage</unmanaged-short>
        public System.String PszPackage;
        /// <summary>
        /// <dd> <p>The number of times that the credential manager should retry after authentication fails.</p> </dd>
        /// </summary>
        /// <doc-id>ms701554</doc-id>
        /// <unmanaged>nRetries</unmanaged>
        /// <unmanaged-short>nRetries</unmanaged-short>
        public System.Int32 NRetries;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.Result HrOp;
            public SharpDX.Mathematics.Interop.RawBool FAllowLoggedOnUser;
            public SharpDX.Mathematics.Interop.RawBool FClearTextPackage;
            public System.IntPtr PszUrl;
            public System.IntPtr PszSite;
            public System.IntPtr PszRealm;
            public System.IntPtr PszPackage;
            public System.Int32 NRetries;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.PszUrl);
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.PszSite);
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.PszRealm);
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.PszPackage);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            HrOp = @ref.HrOp;
            FAllowLoggedOnUser = @ref.FAllowLoggedOnUser;
            FClearTextPackage = @ref.FClearTextPackage;
            PszUrl = System.Runtime.InteropServices.Marshal.PtrToStringUni(@ref.PszUrl);
            PszSite = System.Runtime.InteropServices.Marshal.PtrToStringUni(@ref.PszSite);
            PszRealm = System.Runtime.InteropServices.Marshal.PtrToStringUni(@ref.PszRealm);
            PszPackage = System.Runtime.InteropServices.Marshal.PtrToStringUni(@ref.PszPackage);
            NRetries = @ref.NRetries;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.HrOp = HrOp;
            @ref.FAllowLoggedOnUser = FAllowLoggedOnUser;
            @ref.FClearTextPackage = FClearTextPackage;
            @ref.PszUrl = System.Runtime.InteropServices.Marshal.StringToHGlobalUni(PszUrl);
            @ref.PszSite = System.Runtime.InteropServices.Marshal.StringToHGlobalUni(PszSite);
            @ref.PszRealm = System.Runtime.InteropServices.Marshal.StringToHGlobalUni(PszRealm);
            @ref.PszPackage = System.Runtime.InteropServices.Marshal.StringToHGlobalUni(PszPackage);
            @ref.NRetries = NRetries;
        }
    }

    /// <summary>
    /// <p> Specifies an offset as a fixed-point real number. </p>
    /// </summary>
    /// <remarks>
    /// <p> The value of the number is <strong>value</strong> + (<strong>fract</strong> / 65536.0f).</p>
    /// </remarks>
    /// <doc-id>ms704775</doc-id>
    /// <unmanaged>MFOffset</unmanaged>
    /// <unmanaged-short>MFOffset</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct Offset
    {
        /// <summary>
        /// <dd> <p> The fractional part of the number. </p> </dd>
        /// </summary>
        /// <doc-id>ms704775</doc-id>
        /// <unmanaged>fract</unmanaged>
        /// <unmanaged-short>fract</unmanaged-short>
        public System.Int16 Fract;
        /// <summary>
        /// <dd> <p> The integer part of the number. </p> </dd>
        /// </summary>
        /// <doc-id>ms704775</doc-id>
        /// <unmanaged>value</unmanaged>
        /// <unmanaged-short>value</unmanaged-short>
        public System.Int16 Value;
    }

    /// <summary>
    /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Event structure for the <strong>MFP_EVENT_TYPE_ACQUIRE_USER_CREDENTIAL</strong> event. This event is sent if the application plays a media file from a server that requires authentication. The application can respond by providing the user credentials.</p>
    /// </summary>
    /// <remarks>
    /// <p>To get a reference to this structure, cast the <em>pEventHeader</em> parameter of the <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong> callback method.  You can use the <strong>MFP_GET_ACQUIRE_USER_CREDENTIAL_EVENT</strong> macro for this purpose.</p><p>If the <strong>flags</strong> member contains the <strong>MFP_CREDENTIAL_PROMPT</strong> flag, the application should do the following:</p><ol> <li>Prompt the user to enter a user name and password.</li> <li>Store the user name in the credentials object by calling <strong>IMFNetCredential::SetUser</strong> on the <strong>pCredential</strong> reference.</li> <li>Store the password by calling <strong>IMFNetCredential::SetPassword</strong> on the <strong>pCredential</strong> reference.</li> </ol><p>To cancel authentication, set <strong>fProceedWithAuthentication</strong> equal to <strong><see cref = "SharpDX.Result.False"/></strong>.</p><p>By default, MFPlay uses the network source's implementation of <strong><see cref = "SharpDX.MediaFoundation.NetCredentialManager"/></strong> to manage credentials. An application can provide its own implementation of this interface as follows:</p><ol> <li>Call <strong>QueryInterface</strong> on the <strong><see cref = "SharpDX.MediaFoundation.PMediaPlayer"/></strong> reference to get the <strong><see cref = "SharpDX.ComObject"/></strong> interface.</li> <li>Call <strong>IPropertyStore::SetValue</strong> to set the <strong>MFNETSOURCE_CREDENTIAL_MANAGER</strong> property.</li> </ol>
    /// </remarks>
    /// <doc-id>dd375527</doc-id>
    /// <unmanaged>MFP_ACQUIRE_USER_CREDENTIAL_EVENT</unmanaged>
    /// <unmanaged-short>MFP_ACQUIRE_USER_CREDENTIAL_EVENT</unmanaged-short>
    public partial struct PAcquireUserCredentialEvent
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375527</doc-id>
        /// <unmanaged>header</unmanaged>
        /// <unmanaged-short>header</unmanaged-short>
        public SharpDX.MediaFoundation.PEventHeader Header;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375527</doc-id>
        /// <unmanaged>dwUserData</unmanaged>
        /// <unmanaged-short>dwUserData</unmanaged-short>
        public System.IntPtr DwUserData;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375527</doc-id>
        /// <unmanaged>fProceedWithAuthentication</unmanaged>
        /// <unmanaged-short>fProceedWithAuthentication</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool FProceedWithAuthentication;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375527</doc-id>
        /// <unmanaged>hrAuthenticationStatus</unmanaged>
        /// <unmanaged-short>hrAuthenticationStatus</unmanaged-short>
        public SharpDX.Result HrAuthenticationStatus;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375527</doc-id>
        /// <unmanaged>pwszURL</unmanaged>
        /// <unmanaged-short>pwszURL</unmanaged-short>
        public System.String PwszURL;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375527</doc-id>
        /// <unmanaged>pwszSite</unmanaged>
        /// <unmanaged-short>pwszSite</unmanaged-short>
        public System.String PwszSite;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375527</doc-id>
        /// <unmanaged>pwszRealm</unmanaged>
        /// <unmanaged-short>pwszRealm</unmanaged-short>
        public System.String PwszRealm;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375527</doc-id>
        /// <unmanaged>pwszPackage</unmanaged>
        /// <unmanaged-short>pwszPackage</unmanaged-short>
        public System.String PwszPackage;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375527</doc-id>
        /// <unmanaged>nRetries</unmanaged>
        /// <unmanaged-short>nRetries</unmanaged-short>
        public System.Int32 NRetries;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375527</doc-id>
        /// <unmanaged>flags</unmanaged>
        /// <unmanaged-short>flags</unmanaged-short>
        public System.Int32 Flags;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375527</doc-id>
        /// <unmanaged>pCredential</unmanaged>
        /// <unmanaged-short>pCredential</unmanaged-short>
        public SharpDX.MediaFoundation.NetCredential PCredential;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.MediaFoundation.PEventHeader.__Native Header;
            public System.IntPtr DwUserData;
            public SharpDX.Mathematics.Interop.RawBool FProceedWithAuthentication;
            public SharpDX.Result HrAuthenticationStatus;
            public System.IntPtr PwszURL;
            public System.IntPtr PwszSite;
            public System.IntPtr PwszRealm;
            public System.IntPtr PwszPackage;
            public System.Int32 NRetries;
            public System.Int32 Flags;
            public System.IntPtr PCredential;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            Header.__MarshalFree(ref @ref.Header);
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.PwszURL);
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.PwszSite);
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.PwszRealm);
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.PwszPackage);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Header.__MarshalFrom(ref @ref.Header);
            DwUserData = @ref.DwUserData;
            FProceedWithAuthentication = @ref.FProceedWithAuthentication;
            HrAuthenticationStatus = @ref.HrAuthenticationStatus;
            PwszURL = System.Runtime.InteropServices.Marshal.PtrToStringUni(@ref.PwszURL);
            PwszSite = System.Runtime.InteropServices.Marshal.PtrToStringUni(@ref.PwszSite);
            PwszRealm = System.Runtime.InteropServices.Marshal.PtrToStringUni(@ref.PwszRealm);
            PwszPackage = System.Runtime.InteropServices.Marshal.PtrToStringUni(@ref.PwszPackage);
            NRetries = @ref.NRetries;
            Flags = @ref.Flags;
            if (@ref.PCredential != System.IntPtr.Zero)
                PCredential = new SharpDX.MediaFoundation.NetCredential(@ref.PCredential);
            else
                PCredential = null;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            Header.__MarshalTo(ref @ref.Header);
            @ref.DwUserData = DwUserData;
            @ref.FProceedWithAuthentication = FProceedWithAuthentication;
            @ref.HrAuthenticationStatus = HrAuthenticationStatus;
            @ref.PwszURL = System.Runtime.InteropServices.Marshal.StringToHGlobalUni(PwszURL);
            @ref.PwszSite = System.Runtime.InteropServices.Marshal.StringToHGlobalUni(PwszSite);
            @ref.PwszRealm = System.Runtime.InteropServices.Marshal.StringToHGlobalUni(PwszRealm);
            @ref.PwszPackage = System.Runtime.InteropServices.Marshal.StringToHGlobalUni(PwszPackage);
            @ref.NRetries = NRetries;
            @ref.Flags = Flags;
            @ref.PCredential = SharpDX.CppObject.ToCallbackPtr<SharpDX.MediaFoundation.NetCredential>(PCredential);
        }
    }

    /// <summary>
    /// <p>Contains one palette entry in a color table.</p>
    /// </summary>
    /// <remarks>
    /// <p>This union can be used to represent both RGB palettes and Y'Cb'Cr' palettes. The video format that defines the palette determines which union member should be used.</p>
    /// </remarks>
    /// <doc-id>ms698970</doc-id>
    /// <unmanaged>MFPaletteEntry</unmanaged>
    /// <unmanaged-short>MFPaletteEntry</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Explicit, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct PaletteEntry
    {
        /// <summary>
        /// <dd> <p> <strong><see cref = "SharpDX.Mathematics.Interop.RawColorBGRA"/></strong> structure that contains an RGB color.</p> </dd>
        /// </summary>
        /// <doc-id>ms698970</doc-id>
        /// <unmanaged>ARGB</unmanaged>
        /// <unmanaged-short>ARGB</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(0)]
        public SharpDX.Mathematics.Interop.RawColorBGRA Argb;
        /// <summary>
        /// <dd> <p> <strong><see cref = "SharpDX.MediaFoundation.AYUVSample"/></strong> structure that contains a Y'Cb'Cr' color.</p> </dd>
        /// </summary>
        /// <doc-id>ms698970</doc-id>
        /// <unmanaged>AYCbCr</unmanaged>
        /// <unmanaged-short>AYCbCr</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(0)]
        public SharpDX.MediaFoundation.AYUVSample AYCbCr;
    }

    /// <summary>
    /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Event structure for the <strong>MFP_EVENT_TYPE_ERROR</strong> event. This event is sent if an error occurs during playback.  </p>
    /// </summary>
    /// <remarks>
    /// <p>To get a reference to this structure, cast the <em>pEventHeader</em> parameter of the <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong> method.  You can use the <strong>MFP_GET_ERROR_EVENT</strong> macro for this purpose.</p><p>This event is not used to signal the failure of an asynchronous <strong><see cref = "SharpDX.MediaFoundation.PMediaPlayer"/></strong> method. If an asynchronous method fails, the error is reported in the standard event listed for that method. The <strong>MFP_EVENT_TYPE_ERROR</strong> event is used for errors that happen outside the context of an asynchronous method call.</p>
    /// </remarks>
    /// <doc-id>dd375530</doc-id>
    /// <unmanaged>MFP_ERROR_EVENT</unmanaged>
    /// <unmanaged-short>MFP_ERROR_EVENT</unmanaged-short>
    public partial struct PErrorEvent
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375530</doc-id>
        /// <unmanaged>header</unmanaged>
        /// <unmanaged-short>header</unmanaged-short>
        public SharpDX.MediaFoundation.PEventHeader Header;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.MediaFoundation.PEventHeader.__Native Header;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            Header.__MarshalFree(ref @ref.Header);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Header.__MarshalFrom(ref @ref.Header);
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            Header.__MarshalTo(ref @ref.Header);
        }
    }

    /// <summary>
    /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Contains information that is common to  every type of MFPlay event.</p>
    /// </summary>
    /// <doc-id>dd375531</doc-id>
    /// <unmanaged>MFP_EVENT_HEADER</unmanaged>
    /// <unmanaged-short>MFP_EVENT_HEADER</unmanaged-short>
    public partial struct PEventHeader
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375531</doc-id>
        /// <unmanaged>eEventType</unmanaged>
        /// <unmanaged-short>eEventType</unmanaged-short>
        public SharpDX.MediaFoundation.PEventType EEventType;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375531</doc-id>
        /// <unmanaged>hrEvent</unmanaged>
        /// <unmanaged-short>hrEvent</unmanaged-short>
        public SharpDX.Result HrEvent;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375531</doc-id>
        /// <unmanaged>pMediaPlayer</unmanaged>
        /// <unmanaged-short>pMediaPlayer</unmanaged-short>
        public SharpDX.MediaFoundation.PMediaPlayer PMediaPlayer;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375531</doc-id>
        /// <unmanaged>eState</unmanaged>
        /// <unmanaged-short>eState</unmanaged-short>
        public SharpDX.MediaFoundation.PMediaPlayerState EState;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375531</doc-id>
        /// <unmanaged>pPropertyStore</unmanaged>
        /// <unmanaged-short>pPropertyStore</unmanaged-short>
        public SharpDX.ComObject PPropertyStore;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.MediaFoundation.PEventType EEventType;
            public SharpDX.Result HrEvent;
            public System.IntPtr PMediaPlayer;
            public SharpDX.MediaFoundation.PMediaPlayerState EState;
            public System.IntPtr PPropertyStore;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            EEventType = @ref.EEventType;
            HrEvent = @ref.HrEvent;
            if (@ref.PMediaPlayer != System.IntPtr.Zero)
                PMediaPlayer = new SharpDX.MediaFoundation.PMediaPlayer(@ref.PMediaPlayer);
            else
                PMediaPlayer = null;
            EState = @ref.EState;
            if (@ref.PPropertyStore != System.IntPtr.Zero)
                PPropertyStore = new SharpDX.ComObject(@ref.PPropertyStore);
            else
                PPropertyStore = null;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.EEventType = EEventType;
            @ref.HrEvent = HrEvent;
            @ref.PMediaPlayer = SharpDX.CppObject.ToCallbackPtr<SharpDX.MediaFoundation.PMediaPlayer>(PMediaPlayer);
            @ref.EState = EState;
            @ref.PPropertyStore = SharpDX.CppObject.ToCallbackPtr<SharpDX.ComObject>(PPropertyStore);
        }
    }

    /// <summary>
    /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Event structure for the <strong>MFP_EVENT_TYPE_FRAME_STEP</strong> event. This event is sent when the <strong>IMFPMediaPlayer::FrameStep</strong> method completes.</p>
    /// </summary>
    /// <remarks>
    /// <p>To get a reference to this structure, cast the <em>pEventHeader</em> parameter of the <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong> method.  You can use the <strong>MFP_GET_FRAME_STEP_EVENT</strong> macro for this purpose.</p>
    /// </remarks>
    /// <doc-id>dd375533</doc-id>
    /// <unmanaged>MFP_FRAME_STEP_EVENT</unmanaged>
    /// <unmanaged-short>MFP_FRAME_STEP_EVENT</unmanaged-short>
    public partial struct PFrameStepEvent
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375533</doc-id>
        /// <unmanaged>header</unmanaged>
        /// <unmanaged-short>header</unmanaged-short>
        public SharpDX.MediaFoundation.PEventHeader Header;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375533</doc-id>
        /// <unmanaged>pMediaItem</unmanaged>
        /// <unmanaged-short>pMediaItem</unmanaged-short>
        public SharpDX.MediaFoundation.PMediaItem PMediaItem;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.MediaFoundation.PEventHeader.__Native Header;
            public System.IntPtr PMediaItem;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            Header.__MarshalFree(ref @ref.Header);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Header.__MarshalFrom(ref @ref.Header);
            if (@ref.PMediaItem != System.IntPtr.Zero)
                PMediaItem = new SharpDX.MediaFoundation.PMediaItem(@ref.PMediaItem);
            else
                PMediaItem = null;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            Header.__MarshalTo(ref @ref.Header);
            @ref.PMediaItem = SharpDX.CppObject.ToCallbackPtr<SharpDX.MediaFoundation.PMediaItem>(PMediaItem);
        }
    }

    /// <summary>
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Represents a pinhole camera intrinsic model for a specified resolution.</p>
    /// </summary>
    /// <doc-id>mt740397</doc-id>
    /// <unmanaged>MFPinholeCameraIntrinsic_IntrinsicModel</unmanaged>
    /// <unmanaged-short>MFPinholeCameraIntrinsic_IntrinsicModel</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct PinholeCameraIntrinsicIntrinsicModel
    {
        /// <summary>
        /// <dd> <p>The width for the pinhole camera intrinsic model.</p> </dd>
        /// </summary>
        /// <doc-id>mt740397</doc-id>
        /// <unmanaged>Width</unmanaged>
        /// <unmanaged-short>Width</unmanaged-short>
        public System.Int32 Width;
        /// <summary>
        /// <dd> <p>The height for the pinhole camera intrinsic model.</p> </dd>
        /// </summary>
        /// <doc-id>mt740397</doc-id>
        /// <unmanaged>Height</unmanaged>
        /// <unmanaged-short>Height</unmanaged-short>
        public System.Int32 Height;
        /// <summary>
        /// <dd> <p> The pinhole camera model.</p> </dd>
        /// </summary>
        /// <doc-id>mt740397</doc-id>
        /// <unmanaged>CameraModel</unmanaged>
        /// <unmanaged-short>CameraModel</unmanaged-short>
        public SharpDX.MediaFoundation.CameraIntrinsicPinholeCameraModel CameraModel;
        /// <summary>
        /// <dd> <p> The lens distortion model.</p> </dd>
        /// </summary>
        /// <doc-id>mt740397</doc-id>
        /// <unmanaged>DistortionModel</unmanaged>
        /// <unmanaged-short>DistortionModel</unmanaged-short>
        public SharpDX.MediaFoundation.CameraIntrinsicDistortionModel DistortionModel;
    }

    /// <summary>
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Contains zero or 1 pinhole camera intrinsic models that describe how to project a 3D point in physical world onto the 2D image frame of a camera.</p>
    /// </summary>
    /// <doc-id>mt740396</doc-id>
    /// <unmanaged>MFPinholeCameraIntrinsics</unmanaged>
    /// <unmanaged-short>MFPinholeCameraIntrinsics</unmanaged-short>
    public partial struct PinholeCameraIntrinsics
    {
        /// <summary>
        /// <dd> <p>The number of camera intrinsic models in the <em>IntrinsicModels</em> array.</p> </dd>
        /// </summary>
        /// <doc-id>mt740396</doc-id>
        /// <unmanaged>IntrinsicModelCount</unmanaged>
        /// <unmanaged-short>IntrinsicModelCount</unmanaged-short>
        public System.Int32 IntrinsicModelCount;
        /// <summary>
        /// <dd> <p>The array of camera intrinsic models in the intrinsic data.</p> </dd>
        /// </summary>
        /// <doc-id>mt740396</doc-id>
        /// <unmanaged>IntrinsicModels</unmanaged>
        /// <unmanaged-short>IntrinsicModels</unmanaged-short>
        public SharpDX.MediaFoundation.PinholeCameraIntrinsicIntrinsicModel[] IntrinsicModels
        {
            get => _IntrinsicModels ?? (_IntrinsicModels = new SharpDX.MediaFoundation.PinholeCameraIntrinsicIntrinsicModel[1]);
            private set => _IntrinsicModels = value;
        }

        internal SharpDX.MediaFoundation.PinholeCameraIntrinsicIntrinsicModel[] _IntrinsicModels;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.Int32 IntrinsicModelCount;
            public SharpDX.MediaFoundation.PinholeCameraIntrinsicIntrinsicModel IntrinsicModels;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            IntrinsicModelCount = @ref.IntrinsicModelCount;
            fixed (void *__to = &IntrinsicModels[0], __from = &@ref.IntrinsicModels)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 1 * sizeof (SharpDX.MediaFoundation.PinholeCameraIntrinsicIntrinsicModel));
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.IntrinsicModelCount = IntrinsicModelCount;
            fixed (void *__from = &IntrinsicModels[0], __to = &@ref.IntrinsicModels)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 1 * sizeof (SharpDX.MediaFoundation.PinholeCameraIntrinsicIntrinsicModel));
        }
    }

    /// <summary>
    /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Event structure for the <strong>MFP_EVENT_TYPE_MEDIAITEM_CLEARED</strong> event. This event is sent when the <strong>IMFPMediaPlayer::ClearMediaItem</strong> method completes.</p>
    /// </summary>
    /// <remarks>
    /// <p>To get a reference to this structure, cast the <em>pEventHeader</em> parameter of the <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong> method.  You can use the <strong>MFP_GET_MEDIAITEM_CLEARED_EVENT</strong> macro for this purpose.</p>
    /// </remarks>
    /// <doc-id>dd375549</doc-id>
    /// <unmanaged>MFP_MEDIAITEM_CLEARED_EVENT</unmanaged>
    /// <unmanaged-short>MFP_MEDIAITEM_CLEARED_EVENT</unmanaged-short>
    public partial struct PMediaItemClearedEvent
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375549</doc-id>
        /// <unmanaged>header</unmanaged>
        /// <unmanaged-short>header</unmanaged-short>
        public SharpDX.MediaFoundation.PEventHeader Header;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375549</doc-id>
        /// <unmanaged>pMediaItem</unmanaged>
        /// <unmanaged-short>pMediaItem</unmanaged-short>
        public SharpDX.MediaFoundation.PMediaItem PMediaItem;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.MediaFoundation.PEventHeader.__Native Header;
            public System.IntPtr PMediaItem;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            Header.__MarshalFree(ref @ref.Header);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Header.__MarshalFrom(ref @ref.Header);
            if (@ref.PMediaItem != System.IntPtr.Zero)
                PMediaItem = new SharpDX.MediaFoundation.PMediaItem(@ref.PMediaItem);
            else
                PMediaItem = null;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            Header.__MarshalTo(ref @ref.Header);
            @ref.PMediaItem = SharpDX.CppObject.ToCallbackPtr<SharpDX.MediaFoundation.PMediaItem>(PMediaItem);
        }
    }

    /// <summary>
    /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Event structure for the <strong>MFP_EVENT_TYPE_MEDIAITEM_CREATED</strong> event. This event is sent when the <strong>IMFPMediaPlayer::CreateMediaItemFromURL</strong> or  <strong>IMFPMediaPlayer::CreateMediaItemFromObject</strong> method completes.</p>
    /// </summary>
    /// <remarks>
    /// <p>To get a reference to this structure, cast the <em>pEventHeader</em> parameter of the <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong> method.  You can use the <strong>MFP_GET_MEDIAITEM_CREATED_EVENT</strong> macro for this purpose.</p><p>Media items are created asynchronously. If multiple items are created, the operations can complete in any order, not necessarily in the same order as the method calls. You can use  the <strong>dwUserData</strong> member to identify the items, if you have simultaneous requests pending. </p>
    /// </remarks>
    /// <doc-id>dd375560</doc-id>
    /// <unmanaged>MFP_MEDIAITEM_CREATED_EVENT</unmanaged>
    /// <unmanaged-short>MFP_MEDIAITEM_CREATED_EVENT</unmanaged-short>
    public partial struct PMediaItemCreateDEvent
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375560</doc-id>
        /// <unmanaged>header</unmanaged>
        /// <unmanaged-short>header</unmanaged-short>
        public SharpDX.MediaFoundation.PEventHeader Header;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375560</doc-id>
        /// <unmanaged>pMediaItem</unmanaged>
        /// <unmanaged-short>pMediaItem</unmanaged-short>
        public SharpDX.MediaFoundation.PMediaItem PMediaItem;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375560</doc-id>
        /// <unmanaged>dwUserData</unmanaged>
        /// <unmanaged-short>dwUserData</unmanaged-short>
        public System.IntPtr DwUserData;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.MediaFoundation.PEventHeader.__Native Header;
            public System.IntPtr PMediaItem;
            public System.IntPtr DwUserData;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            Header.__MarshalFree(ref @ref.Header);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Header.__MarshalFrom(ref @ref.Header);
            if (@ref.PMediaItem != System.IntPtr.Zero)
                PMediaItem = new SharpDX.MediaFoundation.PMediaItem(@ref.PMediaItem);
            else
                PMediaItem = null;
            DwUserData = @ref.DwUserData;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            Header.__MarshalTo(ref @ref.Header);
            @ref.PMediaItem = SharpDX.CppObject.ToCallbackPtr<SharpDX.MediaFoundation.PMediaItem>(PMediaItem);
            @ref.DwUserData = DwUserData;
        }
    }

    /// <summary>
    /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Event structure for the <strong>MFP_EVENT_TYPE_MEDIAITEM_SET</strong> event. This event is sent when the <strong>IMFPMediaPlayer::SetMediaItem</strong> method completes.</p>
    /// </summary>
    /// <remarks>
    /// <p>To get a reference to this structure, cast the <em>pEventHeader</em> parameter of the <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong> method.  You can use the <strong>MFP_GET_MEDIAITEM_SET_EVENT</strong> macro for this purpose.</p><p>If one or more streams could not be connected to a media sink, the event property store contains the MFP_PKEY_StreamRenderingResults property. The value of the property is an array of <strong><see cref = "SharpDX.Result"/></strong> values, indicating which streams were connected successfully.  The event property store can be accessed through the <strong>header.pPropertyStore</strong> member.</p>
    /// </remarks>
    /// <doc-id>dd375561</doc-id>
    /// <unmanaged>MFP_MEDIAITEM_SET_EVENT</unmanaged>
    /// <unmanaged-short>MFP_MEDIAITEM_SET_EVENT</unmanaged-short>
    public partial struct PMediaItemSetEvent
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375561</doc-id>
        /// <unmanaged>header</unmanaged>
        /// <unmanaged-short>header</unmanaged-short>
        public SharpDX.MediaFoundation.PEventHeader Header;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375561</doc-id>
        /// <unmanaged>pMediaItem</unmanaged>
        /// <unmanaged-short>pMediaItem</unmanaged-short>
        public SharpDX.MediaFoundation.PMediaItem PMediaItem;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.MediaFoundation.PEventHeader.__Native Header;
            public System.IntPtr PMediaItem;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            Header.__MarshalFree(ref @ref.Header);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Header.__MarshalFrom(ref @ref.Header);
            if (@ref.PMediaItem != System.IntPtr.Zero)
                PMediaItem = new SharpDX.MediaFoundation.PMediaItem(@ref.PMediaItem);
            else
                PMediaItem = null;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            Header.__MarshalTo(ref @ref.Header);
            @ref.PMediaItem = SharpDX.CppObject.ToCallbackPtr<SharpDX.MediaFoundation.PMediaItem>(PMediaItem);
        }
    }

    /// <summary>
    /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Event structure for the <strong>MFP_EVENT_TYPE_MF</strong> event. The MFPlay player object uses this event to forward certain events from the Media Foundation pipeline to the application.</p>
    /// </summary>
    /// <remarks>
    /// <p> To get a reference to this structure, cast the <em>pEventHeader</em> parameter of the <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong> method. You can use the <strong>MFP_GET_MF_EVENT</strong> macro for this purpose.</p><p>If <strong>MFEventType</strong> is MEStreamSinkFormatChanged, the following property may be stored in the event property store, which can be accessed through the <strong>header.pPropertyStore</strong> member.</p><table> <tr><th>Property</th><th>Description</th></tr> <tr><td> MFP_PKEY_StreamIndex </td><td>The index of the stream whose format changed. </td></tr> </table><p>?</p>
    /// </remarks>
    /// <doc-id>dd375563</doc-id>
    /// <unmanaged>MFP_MF_EVENT</unmanaged>
    /// <unmanaged-short>MFP_MF_EVENT</unmanaged-short>
    public partial struct PMfEvent
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375563</doc-id>
        /// <unmanaged>header</unmanaged>
        /// <unmanaged-short>header</unmanaged-short>
        public SharpDX.MediaFoundation.PEventHeader Header;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375563</doc-id>
        /// <unmanaged>MFEventType</unmanaged>
        /// <unmanaged-short>MFEventType</unmanaged-short>
        public System.Int32 MFEventType;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375563</doc-id>
        /// <unmanaged>pMFMediaEvent</unmanaged>
        /// <unmanaged-short>pMFMediaEvent</unmanaged-short>
        public SharpDX.MediaFoundation.MediaEvent PMFMediaEvent;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375563</doc-id>
        /// <unmanaged>pMediaItem</unmanaged>
        /// <unmanaged-short>pMediaItem</unmanaged-short>
        public SharpDX.MediaFoundation.PMediaItem PMediaItem;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.MediaFoundation.PEventHeader.__Native Header;
            public System.Int32 MFEventType;
            public System.IntPtr PMFMediaEvent;
            public System.IntPtr PMediaItem;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            Header.__MarshalFree(ref @ref.Header);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Header.__MarshalFrom(ref @ref.Header);
            MFEventType = @ref.MFEventType;
            if (@ref.PMFMediaEvent != System.IntPtr.Zero)
                PMFMediaEvent = new SharpDX.MediaFoundation.MediaEvent(@ref.PMFMediaEvent);
            else
                PMFMediaEvent = null;
            if (@ref.PMediaItem != System.IntPtr.Zero)
                PMediaItem = new SharpDX.MediaFoundation.PMediaItem(@ref.PMediaItem);
            else
                PMediaItem = null;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            Header.__MarshalTo(ref @ref.Header);
            @ref.MFEventType = MFEventType;
            @ref.PMFMediaEvent = SharpDX.CppObject.ToCallbackPtr<SharpDX.MediaFoundation.MediaEvent>(PMFMediaEvent);
            @ref.PMediaItem = SharpDX.CppObject.ToCallbackPtr<SharpDX.MediaFoundation.PMediaItem>(PMediaItem);
        }
    }

    /// <summary>
    /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Event structure for the <strong>MFP_EVENT_TYPE_PAUSE</strong> event. This event is sent when the <strong>IMFPMediaPlayer::Pause</strong> method completes.</p>
    /// </summary>
    /// <remarks>
    /// <p>To get a reference to this structure, cast the <em>pEventHeader</em> parameter of the <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong> method.  You can use the <strong>MFP_GET_PAUSE_EVENT</strong> macro for this purpose.</p>
    /// </remarks>
    /// <doc-id>dd375564</doc-id>
    /// <unmanaged>MFP_PAUSE_EVENT</unmanaged>
    /// <unmanaged-short>MFP_PAUSE_EVENT</unmanaged-short>
    public partial struct PPauseEvent
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375564</doc-id>
        /// <unmanaged>header</unmanaged>
        /// <unmanaged-short>header</unmanaged-short>
        public SharpDX.MediaFoundation.PEventHeader Header;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375564</doc-id>
        /// <unmanaged>pMediaItem</unmanaged>
        /// <unmanaged-short>pMediaItem</unmanaged-short>
        public SharpDX.MediaFoundation.PMediaItem PMediaItem;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.MediaFoundation.PEventHeader.__Native Header;
            public System.IntPtr PMediaItem;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            Header.__MarshalFree(ref @ref.Header);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Header.__MarshalFrom(ref @ref.Header);
            if (@ref.PMediaItem != System.IntPtr.Zero)
                PMediaItem = new SharpDX.MediaFoundation.PMediaItem(@ref.PMediaItem);
            else
                PMediaItem = null;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            Header.__MarshalTo(ref @ref.Header);
            @ref.PMediaItem = SharpDX.CppObject.ToCallbackPtr<SharpDX.MediaFoundation.PMediaItem>(PMediaItem);
        }
    }

    /// <summary>
    /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Event structure for the <strong>MFP_EVENT_TYPE_PLAYBACK_ENDED</strong> event. This event is sent when the current media item finishes playing.</p>
    /// </summary>
    /// <remarks>
    /// <p>To get a reference to this structure, cast the <em>pEventHeader</em> parameter of the <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong> method.  You can use the <strong>MFP_GET_PLAYBACK_ENDED_EVENT</strong> macro for this purpose.</p>
    /// </remarks>
    /// <doc-id>dd375566</doc-id>
    /// <unmanaged>MFP_PLAYBACK_ENDED_EVENT</unmanaged>
    /// <unmanaged-short>MFP_PLAYBACK_ENDED_EVENT</unmanaged-short>
    public partial struct PPlaybackEndedEvent
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375566</doc-id>
        /// <unmanaged>header</unmanaged>
        /// <unmanaged-short>header</unmanaged-short>
        public SharpDX.MediaFoundation.PEventHeader Header;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375566</doc-id>
        /// <unmanaged>pMediaItem</unmanaged>
        /// <unmanaged-short>pMediaItem</unmanaged-short>
        public SharpDX.MediaFoundation.PMediaItem PMediaItem;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.MediaFoundation.PEventHeader.__Native Header;
            public System.IntPtr PMediaItem;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            Header.__MarshalFree(ref @ref.Header);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Header.__MarshalFrom(ref @ref.Header);
            if (@ref.PMediaItem != System.IntPtr.Zero)
                PMediaItem = new SharpDX.MediaFoundation.PMediaItem(@ref.PMediaItem);
            else
                PMediaItem = null;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            Header.__MarshalTo(ref @ref.Header);
            @ref.PMediaItem = SharpDX.CppObject.ToCallbackPtr<SharpDX.MediaFoundation.PMediaItem>(PMediaItem);
        }
    }

    /// <summary>
    /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Event structure for the <strong>MFP_EVENT_TYPE_PLAY</strong> event. This event is sent when the <strong>IMFPMediaPlayer::Play</strong> method completes.</p>
    /// </summary>
    /// <remarks>
    /// <p>To get a reference to this structure, cast the <em>pEventHeader</em> parameter of the <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong> method.  You can use the <strong>MFP_GET_PLAY_EVENT</strong> macro for this purpose.</p>
    /// </remarks>
    /// <doc-id>dd375567</doc-id>
    /// <unmanaged>MFP_PLAY_EVENT</unmanaged>
    /// <unmanaged-short>MFP_PLAY_EVENT</unmanaged-short>
    public partial struct PPlayEvent
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375567</doc-id>
        /// <unmanaged>header</unmanaged>
        /// <unmanaged-short>header</unmanaged-short>
        public SharpDX.MediaFoundation.PEventHeader Header;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375567</doc-id>
        /// <unmanaged>pMediaItem</unmanaged>
        /// <unmanaged-short>pMediaItem</unmanaged-short>
        public SharpDX.MediaFoundation.PMediaItem PMediaItem;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.MediaFoundation.PEventHeader.__Native Header;
            public System.IntPtr PMediaItem;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            Header.__MarshalFree(ref @ref.Header);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Header.__MarshalFrom(ref @ref.Header);
            if (@ref.PMediaItem != System.IntPtr.Zero)
                PMediaItem = new SharpDX.MediaFoundation.PMediaItem(@ref.PMediaItem);
            else
                PMediaItem = null;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            Header.__MarshalTo(ref @ref.Header);
            @ref.PMediaItem = SharpDX.CppObject.ToCallbackPtr<SharpDX.MediaFoundation.PMediaItem>(PMediaItem);
        }
    }

    /// <summary>
    /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Event structure for the <strong>MFP_EVENT_TYPE_POSITION_SET</strong> event. This event is sent when the <strong>IMFPMediaPlayer::SetPosition</strong> method completes.</p>
    /// </summary>
    /// <remarks>
    /// <p>To get a reference to this structure, cast the <em>pEventHeader</em> parameter of the <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong> method.  You can use the <strong>MFP_GET_POSITION_SET_EVENT</strong> macro for this purpose.</p>
    /// </remarks>
    /// <doc-id>dd375568</doc-id>
    /// <unmanaged>MFP_POSITION_SET_EVENT</unmanaged>
    /// <unmanaged-short>MFP_POSITION_SET_EVENT</unmanaged-short>
    public partial struct PPositionSetEvent
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375568</doc-id>
        /// <unmanaged>header</unmanaged>
        /// <unmanaged-short>header</unmanaged-short>
        public SharpDX.MediaFoundation.PEventHeader Header;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375568</doc-id>
        /// <unmanaged>pMediaItem</unmanaged>
        /// <unmanaged-short>pMediaItem</unmanaged-short>
        public SharpDX.MediaFoundation.PMediaItem PMediaItem;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.MediaFoundation.PEventHeader.__Native Header;
            public System.IntPtr PMediaItem;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            Header.__MarshalFree(ref @ref.Header);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Header.__MarshalFrom(ref @ref.Header);
            if (@ref.PMediaItem != System.IntPtr.Zero)
                PMediaItem = new SharpDX.MediaFoundation.PMediaItem(@ref.PMediaItem);
            else
                PMediaItem = null;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            Header.__MarshalTo(ref @ref.Header);
            @ref.PMediaItem = SharpDX.CppObject.ToCallbackPtr<SharpDX.MediaFoundation.PMediaItem>(PMediaItem);
        }
    }

    /// <summary>
    /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Event structure for the MFP_EVENT_TYPE_RATE_SET event. This event is sent when the <strong>IMFPMediaPlayer::SetRate</strong> method completes.</p>
    /// </summary>
    /// <remarks>
    /// <p>To get a reference to this structure, cast the <em>pEventHeader</em> parameter of the <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong> method.  You can use the <strong>MFP_GET_RATE_SET_EVENT</strong> macro for this purpose.</p>
    /// </remarks>
    /// <doc-id>dd375569</doc-id>
    /// <unmanaged>MFP_RATE_SET_EVENT</unmanaged>
    /// <unmanaged-short>MFP_RATE_SET_EVENT</unmanaged-short>
    public partial struct PRateSetEvent
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375569</doc-id>
        /// <unmanaged>header</unmanaged>
        /// <unmanaged-short>header</unmanaged-short>
        public SharpDX.MediaFoundation.PEventHeader Header;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375569</doc-id>
        /// <unmanaged>pMediaItem</unmanaged>
        /// <unmanaged-short>pMediaItem</unmanaged-short>
        public SharpDX.MediaFoundation.PMediaItem PMediaItem;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375569</doc-id>
        /// <unmanaged>flRate</unmanaged>
        /// <unmanaged-short>flRate</unmanaged-short>
        public System.Single FlRate;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.MediaFoundation.PEventHeader.__Native Header;
            public System.IntPtr PMediaItem;
            public System.Single FlRate;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            Header.__MarshalFree(ref @ref.Header);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Header.__MarshalFrom(ref @ref.Header);
            if (@ref.PMediaItem != System.IntPtr.Zero)
                PMediaItem = new SharpDX.MediaFoundation.PMediaItem(@ref.PMediaItem);
            else
                PMediaItem = null;
            FlRate = @ref.FlRate;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            Header.__MarshalTo(ref @ref.Header);
            @ref.PMediaItem = SharpDX.CppObject.ToCallbackPtr<SharpDX.MediaFoundation.PMediaItem>(PMediaItem);
            @ref.FlRate = FlRate;
        }
    }

    /// <summary>
    /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Event structure for the <strong>MFP_EVENT_TYPE_STOP</strong> event. This event is sent when the <strong>IMFPMediaPlayer::Stop</strong> method completes.</p>
    /// </summary>
    /// <remarks>
    /// <p>To get a reference to this structure, cast the <em>pEventHeader</em> parameter of the <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong> method.  You can use the <strong>MFP_GET_STOP_EVENT</strong> macro for this purpose.</p>
    /// </remarks>
    /// <doc-id>dd375570</doc-id>
    /// <unmanaged>MFP_STOP_EVENT</unmanaged>
    /// <unmanaged-short>MFP_STOP_EVENT</unmanaged-short>
    public partial struct PStopEvent
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375570</doc-id>
        /// <unmanaged>header</unmanaged>
        /// <unmanaged-short>header</unmanaged-short>
        public SharpDX.MediaFoundation.PEventHeader Header;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375570</doc-id>
        /// <unmanaged>pMediaItem</unmanaged>
        /// <unmanaged-short>pMediaItem</unmanaged-short>
        public SharpDX.MediaFoundation.PMediaItem PMediaItem;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.MediaFoundation.PEventHeader.__Native Header;
            public System.IntPtr PMediaItem;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            Header.__MarshalFree(ref @ref.Header);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Header.__MarshalFrom(ref @ref.Header);
            if (@ref.PMediaItem != System.IntPtr.Zero)
                PMediaItem = new SharpDX.MediaFoundation.PMediaItem(@ref.PMediaItem);
            else
                PMediaItem = null;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            Header.__MarshalTo(ref @ref.Header);
            @ref.PMediaItem = SharpDX.CppObject.ToCallbackPtr<SharpDX.MediaFoundation.PMediaItem>(PMediaItem);
        }
    }

    /// <summary>
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>A four dimensional vector, used to represent a rotation.</p>
    /// </summary>
    /// <doc-id>mt740404</doc-id>
    /// <unmanaged>MF_QUATERNION</unmanaged>
    /// <unmanaged-short>MF_QUATERNION</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct Quaternion
    {
        /// <summary>
        /// <dd> <p>X component of the vector.</p> </dd>
        /// </summary>
        /// <doc-id>mt740404</doc-id>
        /// <unmanaged>x</unmanaged>
        /// <unmanaged-short>x</unmanaged-short>
        public System.Single X;
        /// <summary>
        /// <dd> <p>Y component of the vector.</p> </dd>
        /// </summary>
        /// <doc-id>mt740404</doc-id>
        /// <unmanaged>y</unmanaged>
        /// <unmanaged-short>y</unmanaged-short>
        public System.Single Y;
        /// <summary>
        /// <dd> <p>Z component of the vector.</p> </dd>
        /// </summary>
        /// <doc-id>mt740404</doc-id>
        /// <unmanaged>z</unmanaged>
        /// <unmanaged-short>z</unmanaged-short>
        public System.Single Z;
        /// <summary>
        /// <dd> <p>W component of the vector.</p> </dd>
        /// </summary>
        /// <doc-id>mt740404</doc-id>
        /// <unmanaged>w</unmanaged>
        /// <unmanaged-short>w</unmanaged-short>
        public System.Single W;
    }

    /// <summary>
    /// <p> </p><p>Represents a ratio.</p>
    /// </summary>
    /// <doc-id>aa473788</doc-id>
    /// <unmanaged>MFRatio</unmanaged>
    /// <unmanaged-short>MFRatio</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct Ratio
    {
        /// <summary>
        /// <dd> <p>Numerator of the ratio.</p> </dd>
        /// </summary>
        /// <doc-id>aa473788</doc-id>
        /// <unmanaged>Numerator</unmanaged>
        /// <unmanaged-short>Numerator</unmanaged-short>
        public System.Int32 Numerator;
        /// <summary>
        /// <dd> <p>Denominator of the ratio.</p> </dd>
        /// </summary>
        /// <doc-id>aa473788</doc-id>
        /// <unmanaged>Denominator</unmanaged>
        /// <unmanaged-short>Denominator</unmanaged-short>
        public System.Int32 Denominator;
    }

    /// <summary>
    /// <p>Defines a regions of interest. </p>
    /// </summary>
    /// <doc-id>dn302212</doc-id>
    /// <unmanaged>ROI_AREA</unmanaged>
    /// <unmanaged-short>ROI_AREA</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct RoiArea
    {
        /// <summary>
        /// <dd> <p>The bounds of the region.</p> </dd>
        /// </summary>
        /// <doc-id>dn302212</doc-id>
        /// <unmanaged>rect</unmanaged>
        /// <unmanaged-short>rect</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawRectangle Rect;
        /// <summary>
        /// <dd> <p>Specifies the  quantization parameter delta for the specified region from the rest of the frame.</p> </dd>
        /// </summary>
        /// <doc-id>dn302212</doc-id>
        /// <unmanaged>QPDelta</unmanaged>
        /// <unmanaged-short>QPDelta</unmanaged-short>
        public System.Int32 QPDelta;
    }

    /// <summary>
    /// <p> </p><p>Contains information about a revoked component.</p>
    /// </summary>
    /// <doc-id>aa376487</doc-id>
    /// <unmanaged>MFRR_COMPONENT_HASH_INFO</unmanaged>
    /// <unmanaged-short>MFRR_COMPONENT_HASH_INFO</unmanaged-short>
    public partial struct RrComponentHashInformation
    {
        /// <summary>
        /// <dd> <p>Specifies the reason for the revocation. The following values are defined.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>MF_BOOT_DRIVER_VERIFICATION_FAILED</strong></dt> </dl> </td><td> <p>A boot driver could not be verified.</p> </td></tr> <tr><td><dl> <dt><strong>MF_COMPONENT_CERT_REVOKED</strong></dt> </dl> </td><td> <p>A certificate in a trusted component's certificate chain was revoked.</p> </td></tr> <tr><td><dl> <dt><strong>MF_COMPONENT_HS_CERT_REVOKED</strong></dt> </dl> </td><td> <p>The high-security certificate for authenticating the protected environment (PE) was revoked.</p> <p>The high-security certificate is typically used by ITAs that handle high-definition content and next-generation formats such as HD-DVD.</p> </td></tr> <tr><td><dl> <dt><strong>MF_COMPONENT_INVALID_EKU</strong></dt> </dl> </td><td> <p>A certificate's extended key usage (EKU) object is invalid.</p> </td></tr> <tr><td><dl> <dt><strong>MF_COMPONENT_INVALID_ROOT</strong></dt> </dl> </td><td> <p>The root certificate is not valid.</p> </td></tr> <tr><td><dl> <dt><strong>MF_COMPONENT_LS_CERT_REVOKED</strong></dt> </dl> </td><td> <p>The low-security certificate for authenticating the PE was revoked.</p> <p>The low-security certificate is typically used by ITAs that handle standard-definition content and current-generation formats.</p> </td></tr> <tr><td><dl> <dt><strong>MF_COMPONENT_REVOKED</strong></dt> </dl> </td><td> <p>A trusted component was revoked.</p> </td></tr> <tr><td><dl> <dt><strong>MF_GRL_ABSENT</strong></dt> </dl> </td><td> <p>The GRL was not found.</p> </td></tr> <tr><td><dl> <dt><strong>MF_GRL_LOAD_FAILED</strong></dt> </dl> </td><td> <p>Could not load the global revocation list (GRL).</p> </td></tr> <tr><td><dl> <dt><strong>MF_INVALID_GRL_SIGNATURE</strong></dt> </dl> </td><td> <p>The GRL signature is invalid.</p> </td></tr> <tr><td><dl> <dt><strong>MF_MINCRYPT_FAILURE</strong></dt> </dl> </td><td> <p>A certificate chain was not well-formed, or a boot driver is unsigned or is signed with an untrusted certificate.</p> </td></tr> <tr><td><dl> <dt><strong>MF_TEST_SIGNED_COMPONENT_LOADING</strong></dt> </dl> </td><td> <p>A component was signed by a test certificate.</p> </td></tr> </table> <p>?</p> <p>In addition, one of the following flags might be present, indicating the type of component that failed to load.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>MF_USER_MODE_COMPONENT_LOAD</strong></dt> </dl> </td><td> <p>User-mode component.</p> </td></tr> <tr><td><dl> <dt><strong>MF_KERNEL_MODE_COMPONENT_LOAD</strong></dt> </dl> </td><td> <p>Kernel-mode component.</p> </td></tr> </table> <p>?</p> </dd>
        /// </summary>
        /// <doc-id>aa376487</doc-id>
        /// <unmanaged>ulReason</unmanaged>
        /// <unmanaged-short>ulReason</unmanaged-short>
        public System.Int32 UlReason;
        /// <summary>
        /// <dd> <p>Contains a hash of the file header.</p> </dd>
        /// </summary>
        /// <doc-id>aa376487</doc-id>
        /// <unmanaged>rgHeaderHash</unmanaged>
        /// <unmanaged-short>rgHeaderHash</unmanaged-short>
        public System.String RgHeaderHash;
        /// <summary>
        /// <dd> <p>Contains a hash of the public key in the component's certificate.</p> </dd>
        /// </summary>
        /// <doc-id>aa376487</doc-id>
        /// <unmanaged>rgPublicKeyHash</unmanaged>
        /// <unmanaged-short>rgPublicKeyHash</unmanaged-short>
        public System.String RgPublicKeyHash;
        /// <summary>
        /// <dd> <p>File name of the revoked component.</p> </dd>
        /// </summary>
        /// <doc-id>aa376487</doc-id>
        /// <unmanaged>wszName</unmanaged>
        /// <unmanaged-short>wszName</unmanaged-short>
        public System.String WszName;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.Int32 UlReason;
            public System.Char RgHeaderHash;
            public System.Char __RgHeaderHash1;
            public System.Char __RgHeaderHash2;
            public System.Char __RgHeaderHash3;
            public System.Char __RgHeaderHash4;
            public System.Char __RgHeaderHash5;
            public System.Char __RgHeaderHash6;
            public System.Char __RgHeaderHash7;
            public System.Char __RgHeaderHash8;
            public System.Char __RgHeaderHash9;
            public System.Char __RgHeaderHash10;
            public System.Char __RgHeaderHash11;
            public System.Char __RgHeaderHash12;
            public System.Char __RgHeaderHash13;
            public System.Char __RgHeaderHash14;
            public System.Char __RgHeaderHash15;
            public System.Char __RgHeaderHash16;
            public System.Char __RgHeaderHash17;
            public System.Char __RgHeaderHash18;
            public System.Char __RgHeaderHash19;
            public System.Char __RgHeaderHash20;
            public System.Char __RgHeaderHash21;
            public System.Char __RgHeaderHash22;
            public System.Char __RgHeaderHash23;
            public System.Char __RgHeaderHash24;
            public System.Char __RgHeaderHash25;
            public System.Char __RgHeaderHash26;
            public System.Char __RgHeaderHash27;
            public System.Char __RgHeaderHash28;
            public System.Char __RgHeaderHash29;
            public System.Char __RgHeaderHash30;
            public System.Char __RgHeaderHash31;
            public System.Char __RgHeaderHash32;
            public System.Char __RgHeaderHash33;
            public System.Char __RgHeaderHash34;
            public System.Char __RgHeaderHash35;
            public System.Char __RgHeaderHash36;
            public System.Char __RgHeaderHash37;
            public System.Char __RgHeaderHash38;
            public System.Char __RgHeaderHash39;
            public System.Char __RgHeaderHash40;
            public System.Char __RgHeaderHash41;
            public System.Char __RgHeaderHash42;
            public System.Char RgPublicKeyHash;
            public System.Char __RgPublicKeyHash1;
            public System.Char __RgPublicKeyHash2;
            public System.Char __RgPublicKeyHash3;
            public System.Char __RgPublicKeyHash4;
            public System.Char __RgPublicKeyHash5;
            public System.Char __RgPublicKeyHash6;
            public System.Char __RgPublicKeyHash7;
            public System.Char __RgPublicKeyHash8;
            public System.Char __RgPublicKeyHash9;
            public System.Char __RgPublicKeyHash10;
            public System.Char __RgPublicKeyHash11;
            public System.Char __RgPublicKeyHash12;
            public System.Char __RgPublicKeyHash13;
            public System.Char __RgPublicKeyHash14;
            public System.Char __RgPublicKeyHash15;
            public System.Char __RgPublicKeyHash16;
            public System.Char __RgPublicKeyHash17;
            public System.Char __RgPublicKeyHash18;
            public System.Char __RgPublicKeyHash19;
            public System.Char __RgPublicKeyHash20;
            public System.Char __RgPublicKeyHash21;
            public System.Char __RgPublicKeyHash22;
            public System.Char __RgPublicKeyHash23;
            public System.Char __RgPublicKeyHash24;
            public System.Char __RgPublicKeyHash25;
            public System.Char __RgPublicKeyHash26;
            public System.Char __RgPublicKeyHash27;
            public System.Char __RgPublicKeyHash28;
            public System.Char __RgPublicKeyHash29;
            public System.Char __RgPublicKeyHash30;
            public System.Char __RgPublicKeyHash31;
            public System.Char __RgPublicKeyHash32;
            public System.Char __RgPublicKeyHash33;
            public System.Char __RgPublicKeyHash34;
            public System.Char __RgPublicKeyHash35;
            public System.Char __RgPublicKeyHash36;
            public System.Char __RgPublicKeyHash37;
            public System.Char __RgPublicKeyHash38;
            public System.Char __RgPublicKeyHash39;
            public System.Char __RgPublicKeyHash40;
            public System.Char __RgPublicKeyHash41;
            public System.Char __RgPublicKeyHash42;
            public System.Char WszName;
            public System.Char __WszName1;
            public System.Char __WszName2;
            public System.Char __WszName3;
            public System.Char __WszName4;
            public System.Char __WszName5;
            public System.Char __WszName6;
            public System.Char __WszName7;
            public System.Char __WszName8;
            public System.Char __WszName9;
            public System.Char __WszName10;
            public System.Char __WszName11;
            public System.Char __WszName12;
            public System.Char __WszName13;
            public System.Char __WszName14;
            public System.Char __WszName15;
            public System.Char __WszName16;
            public System.Char __WszName17;
            public System.Char __WszName18;
            public System.Char __WszName19;
            public System.Char __WszName20;
            public System.Char __WszName21;
            public System.Char __WszName22;
            public System.Char __WszName23;
            public System.Char __WszName24;
            public System.Char __WszName25;
            public System.Char __WszName26;
            public System.Char __WszName27;
            public System.Char __WszName28;
            public System.Char __WszName29;
            public System.Char __WszName30;
            public System.Char __WszName31;
            public System.Char __WszName32;
            public System.Char __WszName33;
            public System.Char __WszName34;
            public System.Char __WszName35;
            public System.Char __WszName36;
            public System.Char __WszName37;
            public System.Char __WszName38;
            public System.Char __WszName39;
            public System.Char __WszName40;
            public System.Char __WszName41;
            public System.Char __WszName42;
            public System.Char __WszName43;
            public System.Char __WszName44;
            public System.Char __WszName45;
            public System.Char __WszName46;
            public System.Char __WszName47;
            public System.Char __WszName48;
            public System.Char __WszName49;
            public System.Char __WszName50;
            public System.Char __WszName51;
            public System.Char __WszName52;
            public System.Char __WszName53;
            public System.Char __WszName54;
            public System.Char __WszName55;
            public System.Char __WszName56;
            public System.Char __WszName57;
            public System.Char __WszName58;
            public System.Char __WszName59;
            public System.Char __WszName60;
            public System.Char __WszName61;
            public System.Char __WszName62;
            public System.Char __WszName63;
            public System.Char __WszName64;
            public System.Char __WszName65;
            public System.Char __WszName66;
            public System.Char __WszName67;
            public System.Char __WszName68;
            public System.Char __WszName69;
            public System.Char __WszName70;
            public System.Char __WszName71;
            public System.Char __WszName72;
            public System.Char __WszName73;
            public System.Char __WszName74;
            public System.Char __WszName75;
            public System.Char __WszName76;
            public System.Char __WszName77;
            public System.Char __WszName78;
            public System.Char __WszName79;
            public System.Char __WszName80;
            public System.Char __WszName81;
            public System.Char __WszName82;
            public System.Char __WszName83;
            public System.Char __WszName84;
            public System.Char __WszName85;
            public System.Char __WszName86;
            public System.Char __WszName87;
            public System.Char __WszName88;
            public System.Char __WszName89;
            public System.Char __WszName90;
            public System.Char __WszName91;
            public System.Char __WszName92;
            public System.Char __WszName93;
            public System.Char __WszName94;
            public System.Char __WszName95;
            public System.Char __WszName96;
            public System.Char __WszName97;
            public System.Char __WszName98;
            public System.Char __WszName99;
            public System.Char __WszName100;
            public System.Char __WszName101;
            public System.Char __WszName102;
            public System.Char __WszName103;
            public System.Char __WszName104;
            public System.Char __WszName105;
            public System.Char __WszName106;
            public System.Char __WszName107;
            public System.Char __WszName108;
            public System.Char __WszName109;
            public System.Char __WszName110;
            public System.Char __WszName111;
            public System.Char __WszName112;
            public System.Char __WszName113;
            public System.Char __WszName114;
            public System.Char __WszName115;
            public System.Char __WszName116;
            public System.Char __WszName117;
            public System.Char __WszName118;
            public System.Char __WszName119;
            public System.Char __WszName120;
            public System.Char __WszName121;
            public System.Char __WszName122;
            public System.Char __WszName123;
            public System.Char __WszName124;
            public System.Char __WszName125;
            public System.Char __WszName126;
            public System.Char __WszName127;
            public System.Char __WszName128;
            public System.Char __WszName129;
            public System.Char __WszName130;
            public System.Char __WszName131;
            public System.Char __WszName132;
            public System.Char __WszName133;
            public System.Char __WszName134;
            public System.Char __WszName135;
            public System.Char __WszName136;
            public System.Char __WszName137;
            public System.Char __WszName138;
            public System.Char __WszName139;
            public System.Char __WszName140;
            public System.Char __WszName141;
            public System.Char __WszName142;
            public System.Char __WszName143;
            public System.Char __WszName144;
            public System.Char __WszName145;
            public System.Char __WszName146;
            public System.Char __WszName147;
            public System.Char __WszName148;
            public System.Char __WszName149;
            public System.Char __WszName150;
            public System.Char __WszName151;
            public System.Char __WszName152;
            public System.Char __WszName153;
            public System.Char __WszName154;
            public System.Char __WszName155;
            public System.Char __WszName156;
            public System.Char __WszName157;
            public System.Char __WszName158;
            public System.Char __WszName159;
            public System.Char __WszName160;
            public System.Char __WszName161;
            public System.Char __WszName162;
            public System.Char __WszName163;
            public System.Char __WszName164;
            public System.Char __WszName165;
            public System.Char __WszName166;
            public System.Char __WszName167;
            public System.Char __WszName168;
            public System.Char __WszName169;
            public System.Char __WszName170;
            public System.Char __WszName171;
            public System.Char __WszName172;
            public System.Char __WszName173;
            public System.Char __WszName174;
            public System.Char __WszName175;
            public System.Char __WszName176;
            public System.Char __WszName177;
            public System.Char __WszName178;
            public System.Char __WszName179;
            public System.Char __WszName180;
            public System.Char __WszName181;
            public System.Char __WszName182;
            public System.Char __WszName183;
            public System.Char __WszName184;
            public System.Char __WszName185;
            public System.Char __WszName186;
            public System.Char __WszName187;
            public System.Char __WszName188;
            public System.Char __WszName189;
            public System.Char __WszName190;
            public System.Char __WszName191;
            public System.Char __WszName192;
            public System.Char __WszName193;
            public System.Char __WszName194;
            public System.Char __WszName195;
            public System.Char __WszName196;
            public System.Char __WszName197;
            public System.Char __WszName198;
            public System.Char __WszName199;
            public System.Char __WszName200;
            public System.Char __WszName201;
            public System.Char __WszName202;
            public System.Char __WszName203;
            public System.Char __WszName204;
            public System.Char __WszName205;
            public System.Char __WszName206;
            public System.Char __WszName207;
            public System.Char __WszName208;
            public System.Char __WszName209;
            public System.Char __WszName210;
            public System.Char __WszName211;
            public System.Char __WszName212;
            public System.Char __WszName213;
            public System.Char __WszName214;
            public System.Char __WszName215;
            public System.Char __WszName216;
            public System.Char __WszName217;
            public System.Char __WszName218;
            public System.Char __WszName219;
            public System.Char __WszName220;
            public System.Char __WszName221;
            public System.Char __WszName222;
            public System.Char __WszName223;
            public System.Char __WszName224;
            public System.Char __WszName225;
            public System.Char __WszName226;
            public System.Char __WszName227;
            public System.Char __WszName228;
            public System.Char __WszName229;
            public System.Char __WszName230;
            public System.Char __WszName231;
            public System.Char __WszName232;
            public System.Char __WszName233;
            public System.Char __WszName234;
            public System.Char __WszName235;
            public System.Char __WszName236;
            public System.Char __WszName237;
            public System.Char __WszName238;
            public System.Char __WszName239;
            public System.Char __WszName240;
            public System.Char __WszName241;
            public System.Char __WszName242;
            public System.Char __WszName243;
            public System.Char __WszName244;
            public System.Char __WszName245;
            public System.Char __WszName246;
            public System.Char __WszName247;
            public System.Char __WszName248;
            public System.Char __WszName249;
            public System.Char __WszName250;
            public System.Char __WszName251;
            public System.Char __WszName252;
            public System.Char __WszName253;
            public System.Char __WszName254;
            public System.Char __WszName255;
            public System.Char __WszName256;
            public System.Char __WszName257;
            public System.Char __WszName258;
            public System.Char __WszName259;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            UlReason = @ref.UlReason;
            fixed (void *__ptr = &@ref.RgHeaderHash)
                RgHeaderHash = SharpDX.Utilities.PtrToStringUni((System.IntPtr)__ptr, 42);
            fixed (void *__ptr = &@ref.RgPublicKeyHash)
                RgPublicKeyHash = SharpDX.Utilities.PtrToStringUni((System.IntPtr)__ptr, 42);
            fixed (void *__ptr = &@ref.WszName)
                WszName = SharpDX.Utilities.PtrToStringUni((System.IntPtr)__ptr, 259);
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.UlReason = UlReason;
            fixed (char *__from = RgHeaderHash, __to = &@ref.RgHeaderHash)
            {
                int RgHeaderHash_length = System.Math.Min((RgHeaderHash?.Length ?? 0) * 2, 42 * 2);
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, RgHeaderHash_length);
                __to[RgHeaderHash_length] = '\0';
            }

            fixed (char *__from = RgPublicKeyHash, __to = &@ref.RgPublicKeyHash)
            {
                int RgPublicKeyHash_length = System.Math.Min((RgPublicKeyHash?.Length ?? 0) * 2, 42 * 2);
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, RgPublicKeyHash_length);
                __to[RgPublicKeyHash_length] = '\0';
            }

            fixed (char *__from = WszName, __to = &@ref.WszName)
            {
                int WszName_length = System.Math.Min((WszName?.Length ?? 0) * 2, 259 * 2);
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, WszName_length);
                __to[WszName_length] = '\0';
            }
        }
    }

    /// <summary>
    /// <p> </p><p>Contains information about one or more revoked components.</p>
    /// </summary>
    /// <doc-id>aa375568</doc-id>
    /// <unmanaged>MFRR_COMPONENTS</unmanaged>
    /// <unmanaged-short>MFRR_COMPONENTS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct RrComponents
    {
        /// <summary>
        /// <dd> <p>Revocation information version.</p> </dd>
        /// </summary>
        /// <doc-id>aa375568</doc-id>
        /// <unmanaged>dwRRInfoVersion</unmanaged>
        /// <unmanaged-short>dwRRInfoVersion</unmanaged-short>
        public System.Int32 DwRRInfoVersion;
        /// <summary>
        /// <dd> <p>Number of elements in the <strong>pRRComponents</strong> array.</p> </dd>
        /// </summary>
        /// <doc-id>aa375568</doc-id>
        /// <unmanaged>dwRRComponents</unmanaged>
        /// <unmanaged-short>dwRRComponents</unmanaged-short>
        public System.Int32 DwRRComponents;
        /// <summary>
        /// <dd> <p>Array of <strong><see cref = "SharpDX.MediaFoundation.RrComponentHashInformation"/></strong> structures.</p> </dd>
        /// </summary>
        /// <doc-id>aa375568</doc-id>
        /// <unmanaged>pRRComponents</unmanaged>
        /// <unmanaged-short>pRRComponents</unmanaged-short>
        public System.IntPtr PRRComponents;
    }

    /// <summary>
    /// <p>Describes a sensor profile ID.</p>
    /// </summary>
    /// <doc-id>mt845826</doc-id>
    /// <unmanaged>SENSORPROFILEID</unmanaged>
    /// <unmanaged-short>SENSORPROFILEID</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct Sensorprofileid
    {
        /// <summary>
        /// <dd> <p>A <strong>Sensor Profile <see cref = "System.Guid"/></strong> that describes the type of sensor profile. </p> </dd>
        /// </summary>
        /// <doc-id>mt845826</doc-id>
        /// <unmanaged>Type</unmanaged>
        /// <unmanaged-short>Type</unmanaged-short>
        public System.Guid Type;
        /// <summary>
        /// <dd> <p>The index of the sensor profile.</p> </dd>
        /// </summary>
        /// <doc-id>mt845826</doc-id>
        /// <unmanaged>Index</unmanaged>
        /// <unmanaged-short>Index</unmanaged-short>
        public System.Int32 Index;
        /// <summary>
        /// <dd> <p>Not currently used.</p> </dd>
        /// </summary>
        /// <doc-id>mt845826</doc-id>
        /// <unmanaged>Unused</unmanaged>
        /// <unmanaged-short>Unused</unmanaged-short>
        public System.Int32 Unused;
    }

    /// <summary>
    /// <p>Contains statistics about the performance of the sink writer.</p>
    /// </summary>
    /// <doc-id>dd375769</doc-id>
    /// <unmanaged>MF_SINK_WRITER_STATISTICS</unmanaged>
    /// <unmanaged-short>MF_SINK_WRITER_STATISTICS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct SinkWriterStatistics
    {
        /// <summary>
        /// <dd> <p>The size of the structure, in bytes.</p> </dd>
        /// </summary>
        /// <doc-id>dd375769</doc-id>
        /// <unmanaged>cb</unmanaged>
        /// <unmanaged-short>cb</unmanaged-short>
        public System.Int32 Cb;
        /// <summary>
        /// <dd> <p>The time stamp of the most recent sample given to the sink writer. The sink writer updates this value each time the application calls <strong>IMFSinkWriter::WriteSample</strong>.</p> </dd>
        /// </summary>
        /// <doc-id>dd375769</doc-id>
        /// <unmanaged>llLastTimestampReceived</unmanaged>
        /// <unmanaged-short>llLastTimestampReceived</unmanaged-short>
        public System.Int64 LlLastTimestampReceived;
        /// <summary>
        /// <dd> <p>The time stamp of the most recent sample to be encoded. The sink writer updates this value whenever it calls <strong>IMFTransform::ProcessOutput</strong> on the encoder.</p> </dd>
        /// </summary>
        /// <doc-id>dd375769</doc-id>
        /// <unmanaged>llLastTimestampEncoded</unmanaged>
        /// <unmanaged-short>llLastTimestampEncoded</unmanaged-short>
        public System.Int64 LlLastTimestampEncoded;
        /// <summary>
        /// <dd> <p>The time stamp of the most recent sample given to the media sink. The sink writer updates this value whenever it calls <strong>IMFStreamSink::ProcessSample</strong> on the media sink.</p> </dd>
        /// </summary>
        /// <doc-id>dd375769</doc-id>
        /// <unmanaged>llLastTimestampProcessed</unmanaged>
        /// <unmanaged-short>llLastTimestampProcessed</unmanaged-short>
        public System.Int64 LlLastTimestampProcessed;
        /// <summary>
        /// <dd> <p>The time stamp of the most recent stream tick. The sink writer updates this value whenever the application calls <strong>IMFSinkWriter::SendStreamTick</strong>.</p> </dd>
        /// </summary>
        /// <doc-id>dd375769</doc-id>
        /// <unmanaged>llLastStreamTickReceived</unmanaged>
        /// <unmanaged-short>llLastStreamTickReceived</unmanaged-short>
        public System.Int64 LlLastStreamTickReceived;
        /// <summary>
        /// <dd> <p>The system time of the most recent sample request from the media sink. The sink writer updates this value whenever it receives an MEStreamSinkRequestSample event from the media sink. The value is the current system time.</p> </dd>
        /// </summary>
        /// <doc-id>dd375769</doc-id>
        /// <unmanaged>llLastSinkSampleRequest</unmanaged>
        /// <unmanaged-short>llLastSinkSampleRequest</unmanaged-short>
        public System.Int64 LlLastSinkSampleRequest;
        /// <summary>
        /// <dd> <p>The number of samples received.</p> </dd>
        /// </summary>
        /// <doc-id>dd375769</doc-id>
        /// <unmanaged>qwNumSamplesReceived</unmanaged>
        /// <unmanaged-short>qwNumSamplesReceived</unmanaged-short>
        public System.Int64 QwNumSamplesReceived;
        /// <summary>
        /// <dd> <p>The number of samples encoded.</p> </dd>
        /// </summary>
        /// <doc-id>dd375769</doc-id>
        /// <unmanaged>qwNumSamplesEncoded</unmanaged>
        /// <unmanaged-short>qwNumSamplesEncoded</unmanaged-short>
        public System.Int64 QwNumSamplesEncoded;
        /// <summary>
        /// <dd> <p>The number of samples given to the media sink.</p> </dd>
        /// </summary>
        /// <doc-id>dd375769</doc-id>
        /// <unmanaged>qwNumSamplesProcessed</unmanaged>
        /// <unmanaged-short>qwNumSamplesProcessed</unmanaged-short>
        public System.Int64 QwNumSamplesProcessed;
        /// <summary>
        /// <dd> <p>The number of stream ticks received.</p> </dd>
        /// </summary>
        /// <doc-id>dd375769</doc-id>
        /// <unmanaged>qwNumStreamTicksReceived</unmanaged>
        /// <unmanaged-short>qwNumStreamTicksReceived</unmanaged-short>
        public System.Int64 QwNumStreamTicksReceived;
        /// <summary>
        /// <dd> <p>The amount of data, in bytes, currently waiting to be processed. </p> </dd>
        /// </summary>
        /// <doc-id>dd375769</doc-id>
        /// <unmanaged>dwByteCountQueued</unmanaged>
        /// <unmanaged-short>dwByteCountQueued</unmanaged-short>
        public System.Int32 DwByteCountQueued;
        /// <summary>
        /// <dd> <p>The total amount of data, in bytes, that has been sent to the media sink.</p> </dd>
        /// </summary>
        /// <doc-id>dd375769</doc-id>
        /// <unmanaged>qwByteCountProcessed</unmanaged>
        /// <unmanaged-short>qwByteCountProcessed</unmanaged-short>
        public System.Int64 QwByteCountProcessed;
        /// <summary>
        /// <dd> <p>The number of pending sample requests.</p> </dd>
        /// </summary>
        /// <doc-id>dd375769</doc-id>
        /// <unmanaged>dwNumOutstandingSinkSampleRequests</unmanaged>
        /// <unmanaged-short>dwNumOutstandingSinkSampleRequests</unmanaged-short>
        public System.Int32 DwNumOutstandingSinkSampleRequests;
        /// <summary>
        /// <dd> <p>The average rate, in media samples per 100-nanoseconds, at which the application sent samples to the sink writer.</p> </dd>
        /// </summary>
        /// <doc-id>dd375769</doc-id>
        /// <unmanaged>dwAverageSampleRateReceived</unmanaged>
        /// <unmanaged-short>dwAverageSampleRateReceived</unmanaged-short>
        public System.Int32 DwAverageSampleRateReceived;
        /// <summary>
        /// <dd> <p>The average rate, in media samples per 100-nanoseconds, at which the sink writer sent samples to the encoder.</p> </dd>
        /// </summary>
        /// <doc-id>dd375769</doc-id>
        /// <unmanaged>dwAverageSampleRateEncoded</unmanaged>
        /// <unmanaged-short>dwAverageSampleRateEncoded</unmanaged-short>
        public System.Int32 DwAverageSampleRateEncoded;
        /// <summary>
        /// <dd> <p>The average rate, in media samples per 100-nanoseconds, at which the sink writer sent samples to the media sink.</p> </dd>
        /// </summary>
        /// <doc-id>dd375769</doc-id>
        /// <unmanaged>dwAverageSampleRateProcessed</unmanaged>
        /// <unmanaged-short>dwAverageSampleRateProcessed</unmanaged-short>
        public System.Int32 DwAverageSampleRateProcessed;
    }

    /// <summary>
    /// <p>Not for application use.</p>
    /// </summary>
    /// <remarks>
    /// <p>This structure is used internally by the Microsoft Media Foundation AVStream proxy.</p>
    /// </remarks>
    /// <doc-id>dd940437</doc-id>
    /// <unmanaged>STREAM_MEDIUM</unmanaged>
    /// <unmanaged-short>STREAM_MEDIUM</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct StreamMedium
    {
        /// <summary>
        /// <dd> <p>Reserved.</p> </dd>
        /// </summary>
        /// <doc-id>dd940437</doc-id>
        /// <unmanaged>gidMedium</unmanaged>
        /// <unmanaged-short>gidMedium</unmanaged-short>
        public System.Guid GidMedium;
        /// <summary>
        /// <dd> <p>Reserved.</p> </dd>
        /// </summary>
        /// <doc-id>dd940437</doc-id>
        /// <unmanaged>unMediumInstance</unmanaged>
        /// <unmanaged-short>unMediumInstance</unmanaged-short>
        public System.Int32 UnMediumInstance;
    }

    /// <summary>
    /// <p> </p><p>Contains information about an input stream on a Media Foundation transform (MFT). To get these values, call <strong>IMFTransform::GetInputStreamInfo</strong>.</p>
    /// </summary>
    /// <remarks>
    /// <p>Before the media types are set, the only values that should be considered valid are the MFT_INPUT_STREAM_REMOVABLE and MFT_INPUT_STREAM_OPTIONAL flags in the <strong>dwFlags</strong> member.</p><ul> <li> <p>The MFT_INPUT_STREAM_REMOVABLE flag indicates that the stream can be deleted.</p> </li> <li> <p>The MFT_INPUT_STREAM_OPTIONAL flag indicates that the stream is optional and does not require a media type.</p> </li> </ul><p>After you set a media type on all of the input and output streams (not including optional streams), all of the values returned by the <strong>GetInputStreamInfo</strong> method are valid. They might change if you set different media types.</p>
    /// </remarks>
    /// <doc-id>ms704067</doc-id>
    /// <unmanaged>MFT_INPUT_STREAM_INFO</unmanaged>
    /// <unmanaged-short>MFT_INPUT_STREAM_INFO</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct TInputStreamInformation
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms704067</doc-id>
        /// <unmanaged>hnsMaxLatency</unmanaged>
        /// <unmanaged-short>hnsMaxLatency</unmanaged-short>
        public System.Int64 HnsMaxLatency;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms704067</doc-id>
        /// <unmanaged>dwFlags</unmanaged>
        /// <unmanaged-short>dwFlags</unmanaged-short>
        public System.Int32 DwFlags;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms704067</doc-id>
        /// <unmanaged>cbSize</unmanaged>
        /// <unmanaged-short>cbSize</unmanaged-short>
        public System.Int32 CbSize;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms704067</doc-id>
        /// <unmanaged>cbMaxLookahead</unmanaged>
        /// <unmanaged-short>cbMaxLookahead</unmanaged-short>
        public System.Int32 CbMaxLookahead;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms704067</doc-id>
        /// <unmanaged>cbAlignment</unmanaged>
        /// <unmanaged-short>cbAlignment</unmanaged-short>
        public System.Int32 CbAlignment;
    }

    /// <summary>
    /// <p>Specifies a new attribute value for a topology node.</p>
    /// </summary>
    /// <remarks>
    /// <p> Due to an error in the structure declaration, the <strong>u64</strong> member is declared as a 32-bit integer, not a 64-bit integer. Therefore, any 64-bit value passed to the <strong>IMFTopologyNodeAttributeEditor::UpdateNodeAttributes</strong> method is truncated to 32 bits. </p>
    /// </remarks>
    /// <doc-id>aa371336</doc-id>
    /// <unmanaged>MFTOPONODE_ATTRIBUTE_UPDATE</unmanaged>
    /// <unmanaged-short>MFTOPONODE_ATTRIBUTE_UPDATE</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Explicit, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct ToponodeAttributeUpdate
    {
        /// <summary>
        /// <dd> <p> The identifier of the topology node to update. To get the identifier of a topology node, call <strong>IMFTopologyNode::GetTopoNodeID</strong>. </p> </dd>
        /// </summary>
        /// <doc-id>aa371336</doc-id>
        /// <unmanaged>NodeId</unmanaged>
        /// <unmanaged-short>NodeId</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(0)]
        public System.Int64 NodeId;
        /// <summary>
        /// <dd> <p> <see cref = "System.Guid"/> that specifies the attribute to update. </p> </dd>
        /// </summary>
        /// <doc-id>aa371336</doc-id>
        /// <unmanaged>guidAttributeKey</unmanaged>
        /// <unmanaged-short>guidAttributeKey</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public System.Guid GuidAttributeKey;
        /// <summary>
        /// <dd> <p> Attribute type, specified as a member of the <strong><see cref = "SharpDX.MediaFoundation.AttributeType"/></strong> enumeration. </p> </dd>
        /// </summary>
        /// <doc-id>aa371336</doc-id>
        /// <unmanaged>attrType</unmanaged>
        /// <unmanaged-short>attrType</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(24)]
        public SharpDX.MediaFoundation.AttributeType AttrType;
        /// <summary>
        /// <dd> <p> Attribute value (unsigned 32-bit integer). This member is used when <strong>attrType</strong> equals <strong>MF_ATTRIBUTE_UINT32</strong>. </p> </dd>
        /// </summary>
        /// <doc-id>aa371336</doc-id>
        /// <unmanaged>u32</unmanaged>
        /// <unmanaged-short>u32</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(28)]
        public System.Int32 U32;
        /// <summary>
        /// <dd> <p> Attribute value (unsigned 32-bit integer). This member is used when <strong>attrType</strong> equals <strong>MF_ATTRIBUTE_UINT64</strong>. See Remarks. </p> </dd>
        /// </summary>
        /// <doc-id>aa371336</doc-id>
        /// <unmanaged>u64</unmanaged>
        /// <unmanaged-short>u64</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(32)]
        public System.Int64 U64;
        /// <summary>
        /// <dd> <p> Attribute value (floating point). This member is used when <strong>attrType</strong> equals <strong>MF_ATTRIBUTE_DOUBLE</strong>. </p> </dd>
        /// </summary>
        /// <doc-id>aa371336</doc-id>
        /// <unmanaged>d</unmanaged>
        /// <unmanaged-short>d</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(32)]
        public System.Double D;
    }

    /// <summary>
    /// <p> </p><p>Contains information about an output buffer for a Media Foundation transform. This structure is used in the <strong>IMFTransform::ProcessOutput</strong> method.</p>
    /// </summary>
    /// <remarks>
    /// <p>You must provide an <strong><see cref = "SharpDX.MediaFoundation.TOutputDataBuffer"/></strong> structure for each selected output stream.</p><p>MFTs can support two different allocation models for output samples:</p><ul> <li> The MFT allocates the output sample. </li> <li> The client allocates the output sample. </li> </ul><p>To find which model the MFT supports for a given output stream, call <strong>IMFTransform::GetOutputStreamInfo</strong> and check the value of <strong>dwFlags</strong>.</p><table> <tr><th>Flag</th><th>Allocation Model</th></tr> <tr><td>MFT_OUTPUT_STREAM_PROVIDES_SAMPLES</td><td>The MFT allocates the output samples for the stream. Set <strong>pSample</strong> to <strong><c>null</c></strong> for this stream.</td></tr> <tr><td>MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES</td><td>The MFT supports both allocation models.</td></tr> <tr><td>Neither (default)</td><td>The client must allocate the output samples for the stream.</td></tr> </table><p>?</p><p>The behavior of <strong>ProcessOutput</strong> depends on the initial value of <strong>pSample</strong> and the value of the <em>dwFlags</em> parameter in the <strong>ProcessOutput</strong> method.</p><ul> <li> <p>If <strong>pSample</strong> is <strong><c>null</c></strong> and <em>dwFlags</em> contains the MFT_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER flag, the MFT discards the output data.</p> <p>Restriction: This output stream must have the MFT_OUTPUT_STREAM_DISCARDABLE or MFT_OUTPUT_STREAM_LAZY_READ flag. (To get the flags for the output stream, call the <strong>IMFTransform::GetOutputStreamInfo</strong> method.)</p> </li> <li> <p>If <strong>pSample</strong> is <strong><c>null</c></strong> and <em>dwFlags</em> does not contain the MFT_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER, the MFT provides a sample for the output data. The MFT sets <strong>pSample</strong> to point to the sample that it provides. The MFT can either allocate a new sample or re-use an input sample.</p> <p>Restriction: This output stream must have the MFT_OUTPUT_STREAM_PROVIDES_SAMPLES or MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES flag.</p> </li> <li> <p>If <strong>pSample</strong> is non-<strong><c>null</c></strong>, the MFT uses the sample provided by the caller.</p> <p>Restriction: This output stream must not have the MFT_OUTPUT_STREAM_PROVIDES_SAMPLES flag.</p> </li> </ul><p>Any other combinations are invalid and cause <strong>ProcessOutput</strong> to return E_INVALIDARG.</p><p>Each call to <strong>ProcessOutput</strong> can produce zero or more events and up to one sample per output stream.</p>
    /// </remarks>
    /// <doc-id>ms697247</doc-id>
    /// <unmanaged>MFT_OUTPUT_DATA_BUFFER</unmanaged>
    /// <unmanaged-short>MFT_OUTPUT_DATA_BUFFER</unmanaged-short>
    public partial struct TOutputDataBuffer
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697247</doc-id>
        /// <unmanaged>dwStreamID</unmanaged>
        /// <unmanaged-short>dwStreamID</unmanaged-short>
        public System.Int32 DwStreamID;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697247</doc-id>
        /// <unmanaged>pSample</unmanaged>
        /// <unmanaged-short>pSample</unmanaged-short>
        public SharpDX.MediaFoundation.Sample PSample;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697247</doc-id>
        /// <unmanaged>dwStatus</unmanaged>
        /// <unmanaged-short>dwStatus</unmanaged-short>
        public System.Int32 DwStatus;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697247</doc-id>
        /// <unmanaged>pEvents</unmanaged>
        /// <unmanaged-short>pEvents</unmanaged-short>
        public SharpDX.MediaFoundation.Collection PEvents;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.Int32 DwStreamID;
            public System.IntPtr PSample;
            public System.Int32 DwStatus;
            public System.IntPtr PEvents;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            DwStreamID = @ref.DwStreamID;
            if (@ref.PSample != System.IntPtr.Zero)
                PSample = new SharpDX.MediaFoundation.Sample(@ref.PSample);
            else
                PSample = null;
            DwStatus = @ref.DwStatus;
            if (@ref.PEvents != System.IntPtr.Zero)
                PEvents = new SharpDX.MediaFoundation.Collection(@ref.PEvents);
            else
                PEvents = null;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.DwStreamID = DwStreamID;
            @ref.PSample = SharpDX.CppObject.ToCallbackPtr<SharpDX.MediaFoundation.Sample>(PSample);
            @ref.DwStatus = DwStatus;
            @ref.PEvents = SharpDX.CppObject.ToCallbackPtr<SharpDX.MediaFoundation.Collection>(PEvents);
        }
    }

    /// <summary>
    /// <p> </p><p>Contains information about an output stream on a Media Foundation transform (MFT). To get these values, call <strong>IMFTransform::GetOutputStreamInfo</strong>.</p>
    /// </summary>
    /// <remarks>
    /// <p>Before the media types are set, the only values that should be considered valid is the MFT_OUTPUT_STREAM_OPTIONAL flag in the <strong>dwFlags</strong> member. This flag indicates that the stream is optional and does not require a media type.</p><p>After you set a media type on all of the input and output streams (not including optional streams), all of the values returned by the <strong>GetOutputStreamInfo</strong> method are valid. They might change if you set different media types.</p>
    /// </remarks>
    /// <doc-id>ms696974</doc-id>
    /// <unmanaged>MFT_OUTPUT_STREAM_INFO</unmanaged>
    /// <unmanaged-short>MFT_OUTPUT_STREAM_INFO</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct TOutputStreamInformation
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms696974</doc-id>
        /// <unmanaged>dwFlags</unmanaged>
        /// <unmanaged-short>dwFlags</unmanaged-short>
        public System.Int32 DwFlags;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms696974</doc-id>
        /// <unmanaged>cbSize</unmanaged>
        /// <unmanaged-short>cbSize</unmanaged-short>
        public System.Int32 CbSize;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms696974</doc-id>
        /// <unmanaged>cbAlignment</unmanaged>
        /// <unmanaged-short>cbAlignment</unmanaged-short>
        public System.Int32 CbAlignment;
    }

    /// <summary>
    /// <p>Contains information about the audio and video streams for the transcode sink activation object.</p><p>To get the information stored in this structure, call <strong>IMFTranscodeSinkInfoProvider::GetSinkInfo</strong>.</p>
    /// </summary>
    /// <remarks>
    /// <p>The <strong>IMFTranscodeSinkInfoProvider::GetSinkInfo</strong> method assigns <strong><see cref = "SharpDX.MediaFoundation.MediaType"/></strong> references to the <strong>pAudioMediaType</strong> and <strong>pVideoMediaType</strong> members of this structure. The method might set either member to <strong><c>null</c></strong>. If either member is non-<strong><c>null</c></strong> after the method returns, the caller must release the <strong><see cref = "SharpDX.MediaFoundation.MediaType"/></strong> references.</p>
    /// </remarks>
    /// <doc-id>dd388923</doc-id>
    /// <unmanaged>MF_TRANSCODE_SINK_INFO</unmanaged>
    /// <unmanaged-short>MF_TRANSCODE_SINK_INFO</unmanaged-short>
    public partial struct TranscodeSinkInformation
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd388923</doc-id>
        /// <unmanaged>dwVideoStreamID</unmanaged>
        /// <unmanaged-short>dwVideoStreamID</unmanaged-short>
        public System.Int32 DwVideoStreamID;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd388923</doc-id>
        /// <unmanaged>pVideoMediaType</unmanaged>
        /// <unmanaged-short>pVideoMediaType</unmanaged-short>
        public SharpDX.MediaFoundation.MediaType PVideoMediaType;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd388923</doc-id>
        /// <unmanaged>dwAudioStreamID</unmanaged>
        /// <unmanaged-short>dwAudioStreamID</unmanaged-short>
        public System.Int32 DwAudioStreamID;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd388923</doc-id>
        /// <unmanaged>pAudioMediaType</unmanaged>
        /// <unmanaged-short>pAudioMediaType</unmanaged-short>
        public SharpDX.MediaFoundation.MediaType PAudioMediaType;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.Int32 DwVideoStreamID;
            public System.IntPtr PVideoMediaType;
            public System.Int32 DwAudioStreamID;
            public System.IntPtr PAudioMediaType;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            DwVideoStreamID = @ref.DwVideoStreamID;
            if (@ref.PVideoMediaType != System.IntPtr.Zero)
                PVideoMediaType = new SharpDX.MediaFoundation.MediaType(@ref.PVideoMediaType);
            else
                PVideoMediaType = null;
            DwAudioStreamID = @ref.DwAudioStreamID;
            if (@ref.PAudioMediaType != System.IntPtr.Zero)
                PAudioMediaType = new SharpDX.MediaFoundation.MediaType(@ref.PAudioMediaType);
            else
                PAudioMediaType = null;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.DwVideoStreamID = DwVideoStreamID;
            @ref.PVideoMediaType = SharpDX.CppObject.ToCallbackPtr<SharpDX.MediaFoundation.MediaType>(PVideoMediaType);
            @ref.DwAudioStreamID = DwAudioStreamID;
            @ref.PAudioMediaType = SharpDX.CppObject.ToCallbackPtr<SharpDX.MediaFoundation.MediaType>(PAudioMediaType);
        }
    }

    /// <summary>
    /// <p>Contains media type information for registering a Media Foundation transform (MFT). </p>
    /// </summary>
    /// <doc-id>ms694919</doc-id>
    /// <unmanaged>MFT_REGISTER_TYPE_INFO</unmanaged>
    /// <unmanaged-short>MFT_REGISTER_TYPE_INFO</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct TRegisterTypeInformation
    {
        /// <summary>
        /// <dd> <p>The major media type. For a list of possible values, see Major Media Types. </p> </dd>
        /// </summary>
        /// <doc-id>ms694919</doc-id>
        /// <unmanaged>guidMajorType</unmanaged>
        /// <unmanaged-short>guidMajorType</unmanaged-short>
        public System.Guid GuidMajorType;
        /// <summary>
        /// <dd> <p>The media subtype. For a list of possible values, see the following topics:</p> <ul> <li> Audio Subtype GUIDs </li> <li> Video Subtype GUIDs </li> </ul> </dd>
        /// </summary>
        /// <doc-id>ms694919</doc-id>
        /// <unmanaged>guidSubtype</unmanaged>
        /// <unmanaged-short>guidSubtype</unmanaged-short>
        public System.Guid GuidSubtype;
    }

    /// <summary>
    /// <p>Contains parameters for the <strong>IMFLocalMFTRegistration::RegisterMFTs</strong> method.</p>
    /// </summary>
    /// <doc-id>dd388673</doc-id>
    /// <unmanaged>MFT_REGISTRATION_INFO</unmanaged>
    /// <unmanaged-short>MFT_REGISTRATION_INFO</unmanaged-short>
    public partial struct TRegistrationInformation
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd388673</doc-id>
        /// <unmanaged>clsid</unmanaged>
        /// <unmanaged-short>clsid</unmanaged-short>
        public System.Guid Clsid;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd388673</doc-id>
        /// <unmanaged>guidCategory</unmanaged>
        /// <unmanaged-short>guidCategory</unmanaged-short>
        public System.Guid GuidCategory;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd388673</doc-id>
        /// <unmanaged>uiFlags</unmanaged>
        /// <unmanaged-short>uiFlags</unmanaged-short>
        public System.Int32 UiFlags;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd388673</doc-id>
        /// <unmanaged>pszName</unmanaged>
        /// <unmanaged-short>pszName</unmanaged-short>
        public System.String PszName;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd388673</doc-id>
        /// <unmanaged>cInTypes</unmanaged>
        /// <unmanaged-short>cInTypes</unmanaged-short>
        public System.Int32 CInTypes;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd388673</doc-id>
        /// <unmanaged>pInTypes</unmanaged>
        /// <unmanaged-short>pInTypes</unmanaged-short>
        public System.IntPtr PInTypes;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd388673</doc-id>
        /// <unmanaged>cOutTypes</unmanaged>
        /// <unmanaged-short>cOutTypes</unmanaged-short>
        public System.Int32 COutTypes;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd388673</doc-id>
        /// <unmanaged>pOutTypes</unmanaged>
        /// <unmanaged-short>pOutTypes</unmanaged-short>
        public System.IntPtr POutTypes;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.Guid Clsid;
            public System.Guid GuidCategory;
            public System.Int32 UiFlags;
            public System.IntPtr PszName;
            public System.Int32 CInTypes;
            public System.IntPtr PInTypes;
            public System.Int32 COutTypes;
            public System.IntPtr POutTypes;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.PszName);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Clsid = @ref.Clsid;
            GuidCategory = @ref.GuidCategory;
            UiFlags = @ref.UiFlags;
            PszName = System.Runtime.InteropServices.Marshal.PtrToStringUni(@ref.PszName);
            CInTypes = @ref.CInTypes;
            PInTypes = @ref.PInTypes;
            COutTypes = @ref.COutTypes;
            POutTypes = @ref.POutTypes;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Clsid = Clsid;
            @ref.GuidCategory = GuidCategory;
            @ref.UiFlags = UiFlags;
            @ref.PszName = System.Runtime.InteropServices.Marshal.StringToHGlobalUni(PszName);
            @ref.CInTypes = CInTypes;
            @ref.PInTypes = PInTypes;
            @ref.COutTypes = COutTypes;
            @ref.POutTypes = POutTypes;
        }
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>MFT_STREAM_STATE_PARAM</unmanaged>
    /// <unmanaged-short>MFT_STREAM_STATE_PARAM</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct TStreamStateParam
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>StreamId</unmanaged>
        /// <unmanaged-short>StreamId</unmanaged-short>
        public System.Int32 StreamId;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>State</unmanaged>
        /// <unmanaged-short>State</unmanaged-short>
        public SharpDX.MediaFoundation.StreamState State;
    }

    /// <summary>
    /// <p> Specifies a rectangular area within a video frame. </p>
    /// </summary>
    /// <doc-id>ms703850</doc-id>
    /// <unmanaged>MFVideoArea</unmanaged>
    /// <unmanaged-short>MFVideoArea</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct VideoArea
    {
        /// <summary>
        /// <dd> <p> An <strong><see cref = "SharpDX.MediaFoundation.Offset"/></strong> structure that contains the x-coordinate of the upper-left corner of the rectangle. This coordinate might have a fractional value. </p> </dd>
        /// </summary>
        /// <doc-id>ms703850</doc-id>
        /// <unmanaged>OffsetX</unmanaged>
        /// <unmanaged-short>OffsetX</unmanaged-short>
        public SharpDX.MediaFoundation.Offset OffsetX;
        /// <summary>
        /// <dd> <p> An <strong><see cref = "SharpDX.MediaFoundation.Offset"/></strong> structure that contains the y-coordinate of the upper-left corner of the rectangle. This coordinate might have a fractional value. </p> </dd>
        /// </summary>
        /// <doc-id>ms703850</doc-id>
        /// <unmanaged>OffsetY</unmanaged>
        /// <unmanaged-short>OffsetY</unmanaged-short>
        public SharpDX.MediaFoundation.Offset OffsetY;
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Size2"/></strong> structure that contains the width and height of the rectangle. </p> </dd>
        /// </summary>
        /// <doc-id>ms703850</doc-id>
        /// <unmanaged>Area</unmanaged>
        /// <unmanaged-short>Area</unmanaged-short>
        public SharpDX.Size2 Area;
    }

    /// <summary>
    /// <p> </p><p>Contains information about a video compression format. This structure is used in the <strong><see cref = "SharpDX.MediaFoundation.VideoFormat"/></strong> structure.</p>
    /// </summary>
    /// <remarks>
    /// <p>For uncompressed video formats, set the structure members to zero.</p>
    /// </remarks>
    /// <doc-id>aa473839</doc-id>
    /// <unmanaged>MFVideoCompressedInfo</unmanaged>
    /// <unmanaged-short>MFVideoCompressedInfo</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct VideoCompressedInfo
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa473839</doc-id>
        /// <unmanaged>AvgBitrate</unmanaged>
        /// <unmanaged-short>AvgBitrate</unmanaged-short>
        public System.Int64 AvgBitrate;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa473839</doc-id>
        /// <unmanaged>AvgBitErrorRate</unmanaged>
        /// <unmanaged-short>AvgBitErrorRate</unmanaged-short>
        public System.Int64 AvgBitErrorRate;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa473839</doc-id>
        /// <unmanaged>MaxKeyFrameSpacing</unmanaged>
        /// <unmanaged-short>MaxKeyFrameSpacing</unmanaged-short>
        public System.Int32 MaxKeyFrameSpacing;
    }

    /// <summary>
    /// <p> </p><p>Describes a video format.</p>
    /// </summary>
    /// <remarks>
    /// <p>Applications should avoid using this structure. Instead, it is recommended that applications use attributes to describe the video format. For a list of media type attributes, see Media Type Attributes. With attributes, you can set just the format information that you know, which is easier (and more likely to be accurate) than trying to fill in complete format information for the <strong><see cref = "SharpDX.MediaFoundation.VideoFormat"/></strong> structure.</p><p>To initialize a media type object from an <strong><see cref = "SharpDX.MediaFoundation.VideoFormat"/></strong> structure, call <strong>MFInitMediaTypeFromMFVideoFormat</strong>.</p><p>You can use the <strong><see cref = "SharpDX.MediaFoundation.VideoFormat"/></strong> structure as the format block for a DirectShow media type. Set the format <see cref = "System.Guid"/> to FORMAT_MFVideoFormat.</p>
    /// </remarks>
    /// <doc-id>aa473808</doc-id>
    /// <unmanaged>MFVIDEOFORMAT</unmanaged>
    /// <unmanaged-short>MFVIDEOFORMAT</unmanaged-short>
    public partial struct VideoFormat
    {
        /// <summary>
        /// <dd> <p>Size of the structure, in bytes. This value includes the size of the palette entries that may appear after the <strong>surfaceInfo</strong> member.</p> </dd>
        /// </summary>
        /// <doc-id>aa473808</doc-id>
        /// <unmanaged>dwSize</unmanaged>
        /// <unmanaged-short>dwSize</unmanaged-short>
        public System.Int32 DwSize;
        /// <summary>
        /// <dd> <p> <strong><see cref = "SharpDX.MediaFoundation.VideoInfo"/></strong> structure. This structure contains information that applies to both compressed and uncompressed formats.</p> </dd>
        /// </summary>
        /// <doc-id>aa473808</doc-id>
        /// <unmanaged>videoInfo</unmanaged>
        /// <unmanaged-short>videoInfo</unmanaged-short>
        public SharpDX.MediaFoundation.VideoInfo VideoInfo;
        /// <summary>
        /// <dd> <p>Video subtype. See Video Subtype GUIDs.</p> </dd>
        /// </summary>
        /// <doc-id>aa473808</doc-id>
        /// <unmanaged>guidFormat</unmanaged>
        /// <unmanaged-short>guidFormat</unmanaged-short>
        public System.Guid GuidFormat;
        /// <summary>
        /// <dd> <p> <strong><see cref = "SharpDX.MediaFoundation.VideoCompressedInfo"/></strong> structure. This structure contains information that applies only to compressed formats.</p> </dd>
        /// </summary>
        /// <doc-id>aa473808</doc-id>
        /// <unmanaged>compressedInfo</unmanaged>
        /// <unmanaged-short>compressedInfo</unmanaged-short>
        public SharpDX.MediaFoundation.VideoCompressedInfo CompressedInfo;
        /// <summary>
        /// <dd> <p> <strong><see cref = "SharpDX.MediaFoundation.VideoSurfaceInfo"/></strong> structure. This structure contains information that applies only to uncompressed formats.</p> </dd>
        /// </summary>
        /// <doc-id>aa473808</doc-id>
        /// <unmanaged>surfaceInfo</unmanaged>
        /// <unmanaged-short>surfaceInfo</unmanaged-short>
        public SharpDX.MediaFoundation.VideoSurfaceInfo SurfaceInfo;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.Int32 DwSize;
            public SharpDX.MediaFoundation.VideoInfo VideoInfo;
            public System.Guid GuidFormat;
            public SharpDX.MediaFoundation.VideoCompressedInfo CompressedInfo;
            public SharpDX.MediaFoundation.VideoSurfaceInfo.__Native SurfaceInfo;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            SurfaceInfo.__MarshalFree(ref @ref.SurfaceInfo);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            DwSize = @ref.DwSize;
            VideoInfo = @ref.VideoInfo;
            GuidFormat = @ref.GuidFormat;
            CompressedInfo = @ref.CompressedInfo;
            SurfaceInfo.__MarshalFrom(ref @ref.SurfaceInfo);
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.DwSize = DwSize;
            @ref.VideoInfo = VideoInfo;
            @ref.GuidFormat = GuidFormat;
            @ref.CompressedInfo = CompressedInfo;
            SurfaceInfo.__MarshalTo(ref @ref.SurfaceInfo);
        }
    }

    /// <summary>
    /// <p> </p><p>Contains video format information that applies to both compressed and uncompressed formats.</p><p>This structure is used in the <strong><see cref = "SharpDX.MediaFoundation.VideoFormat"/></strong> structure.</p>
    /// </summary>
    /// <remarks>
    /// <p>Developers are encouraged to use media type attributes instead of using the <strong><see cref = "SharpDX.MediaFoundation.VideoInfo"/></strong> structure. The following table lists the attributes that correspond to the members of this structure.</p><table> <tr><th>Structure Member</th><th>Media Type Attribute</th></tr> <tr><td><strong>dwWidth</strong>, <strong>dwHeight</strong></td><td> <strong><see cref = "FrameSize"/></strong> </td></tr> <tr><td><strong>PixelAspectRatio</strong></td><td> <strong><see cref = "PixelAspectRatio"/></strong> </td></tr> <tr><td><strong>SourceChromaSubsampling</strong></td><td> <strong><see cref = "VideoChromaSiting"/></strong> </td></tr> <tr><td><strong>InterlaceMode</strong></td><td> <strong><see cref = "InterlaceMode"/></strong> </td></tr> <tr><td><strong>TransferFunction</strong></td><td> <strong><see cref = "TransferFunction"/></strong> </td></tr> <tr><td><strong>ColorPrimaries</strong></td><td> <strong><see cref = "VideoPrimaries"/></strong> </td></tr> <tr><td><strong>TransferMatrix</strong></td><td> <strong><see cref = "YuvMatrix"/></strong> </td></tr> <tr><td><strong>SourceLighting</strong></td><td> <strong><see cref = "VideoLighting"/></strong> </td></tr> <tr><td><strong>FramesPerSecond</strong></td><td> <strong><see cref = "FrameRate"/></strong> </td></tr> <tr><td><strong>NominalRange</strong></td><td> <strong><see cref = "VideoNominalRange"/></strong> </td></tr> <tr><td><strong>GeometricAperture</strong></td><td> <strong><see cref = "GeometricAperture"/></strong> </td></tr> <tr><td><strong>MinimumDisplayAperture</strong></td><td> <strong><see cref = "MinimumDisplayAperture"/></strong> </td></tr> <tr><td><strong>PanScanAperture</strong></td><td> <strong><see cref = "PanScanAperture"/></strong> </td></tr> <tr><td><strong>VideoFlags</strong></td><td>See <strong><see cref = "SharpDX.MediaFoundation.VideoFlags"/></strong>.</td></tr> </table><p>?</p>
    /// </remarks>
    /// <doc-id>aa473804</doc-id>
    /// <unmanaged>MFVideoInfo</unmanaged>
    /// <unmanaged-short>MFVideoInfo</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct VideoInfo
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa473804</doc-id>
        /// <unmanaged>dwWidth</unmanaged>
        /// <unmanaged-short>dwWidth</unmanaged-short>
        public System.Int32 DwWidth;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa473804</doc-id>
        /// <unmanaged>dwHeight</unmanaged>
        /// <unmanaged-short>dwHeight</unmanaged-short>
        public System.Int32 DwHeight;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa473804</doc-id>
        /// <unmanaged>PixelAspectRatio</unmanaged>
        /// <unmanaged-short>PixelAspectRatio</unmanaged-short>
        public SharpDX.MediaFoundation.Ratio PixelAspectRatio;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa473804</doc-id>
        /// <unmanaged>SourceChromaSubsampling</unmanaged>
        /// <unmanaged-short>SourceChromaSubsampling</unmanaged-short>
        public SharpDX.MediaFoundation.VideoChromaSubsampling SourceChromaSubsampling;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa473804</doc-id>
        /// <unmanaged>InterlaceMode</unmanaged>
        /// <unmanaged-short>InterlaceMode</unmanaged-short>
        public SharpDX.MediaFoundation.VideoInterlaceMode InterlaceMode;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa473804</doc-id>
        /// <unmanaged>TransferFunction</unmanaged>
        /// <unmanaged-short>TransferFunction</unmanaged-short>
        public SharpDX.MediaFoundation.VideoTransferFunction TransferFunction;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa473804</doc-id>
        /// <unmanaged>ColorPrimaries</unmanaged>
        /// <unmanaged-short>ColorPrimaries</unmanaged-short>
        public SharpDX.MediaFoundation.VideoPrimaries ColorPrimaries;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa473804</doc-id>
        /// <unmanaged>TransferMatrix</unmanaged>
        /// <unmanaged-short>TransferMatrix</unmanaged-short>
        public SharpDX.MediaFoundation.VideoTransferMatrix TransferMatrix;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa473804</doc-id>
        /// <unmanaged>SourceLighting</unmanaged>
        /// <unmanaged-short>SourceLighting</unmanaged-short>
        public SharpDX.MediaFoundation.VideoLighting SourceLighting;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa473804</doc-id>
        /// <unmanaged>FramesPerSecond</unmanaged>
        /// <unmanaged-short>FramesPerSecond</unmanaged-short>
        public SharpDX.MediaFoundation.Ratio FramesPerSecond;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa473804</doc-id>
        /// <unmanaged>NominalRange</unmanaged>
        /// <unmanaged-short>NominalRange</unmanaged-short>
        public SharpDX.MediaFoundation.NominalRange NominalRange;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa473804</doc-id>
        /// <unmanaged>GeometricAperture</unmanaged>
        /// <unmanaged-short>GeometricAperture</unmanaged-short>
        public SharpDX.MediaFoundation.VideoArea GeometricAperture;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa473804</doc-id>
        /// <unmanaged>MinimumDisplayAperture</unmanaged>
        /// <unmanaged-short>MinimumDisplayAperture</unmanaged-short>
        public SharpDX.MediaFoundation.VideoArea MinimumDisplayAperture;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa473804</doc-id>
        /// <unmanaged>PanScanAperture</unmanaged>
        /// <unmanaged-short>PanScanAperture</unmanaged-short>
        public SharpDX.MediaFoundation.VideoArea PanScanAperture;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa473804</doc-id>
        /// <unmanaged>VideoFlags</unmanaged>
        /// <unmanaged-short>VideoFlags</unmanaged-short>
        public System.Int64 VideoFlags;
    }

    /// <summary>
    /// <p> </p><p>Defines a normalized rectangle, which is used to specify sub-rectangles in a video rectangle. When a rectangle N is <em>normalized</em> relative to some other rectangle R, it means the following:</p><ul> <li> <p>The coordinate (0.0, 0.0) on N is mapped to the upper-left corner of R.</p> </li> <li> <p>The coordinate (1.0, 1.0) on N is mapped to the lower-right corner of R.</p> </li> </ul><p>Any coordinates of N that fall outside the range [0...1] are mapped to positions outside the rectangle R. A normalized rectangle can be used to specify a region within a video rectangle without knowing the resolution or even the aspect ratio of the video. For example, the upper-left quadrant is defined as {0.0, 0.0, 0.5, 0.5}.</p>
    /// </summary>
    /// <doc-id>ms703049</doc-id>
    /// <unmanaged>MFVideoNormalizedRect</unmanaged>
    /// <unmanaged-short>MFVideoNormalizedRect</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct VideoNormalizedRect
    {
        /// <summary>
        /// <dd> <p>X-coordinate of the upper-left corner of the rectangle.</p> </dd>
        /// </summary>
        /// <doc-id>ms703049</doc-id>
        /// <unmanaged>left</unmanaged>
        /// <unmanaged-short>left</unmanaged-short>
        public System.Single Left;
        /// <summary>
        /// <dd> <p>Y-coordinate of the upper-left corner of the rectangle.</p> </dd>
        /// </summary>
        /// <doc-id>ms703049</doc-id>
        /// <unmanaged>top</unmanaged>
        /// <unmanaged-short>top</unmanaged-short>
        public System.Single Top;
        /// <summary>
        /// <dd> <p>X-coordinate of the lower-right corner of the rectangle.</p> </dd>
        /// </summary>
        /// <doc-id>ms703049</doc-id>
        /// <unmanaged>right</unmanaged>
        /// <unmanaged-short>right</unmanaged-short>
        public System.Single Right;
        /// <summary>
        /// <dd> <p>Y-coordinate of the lower-right corner of the rectangle.</p> </dd>
        /// </summary>
        /// <doc-id>ms703049</doc-id>
        /// <unmanaged>bottom</unmanaged>
        /// <unmanaged-short>bottom</unmanaged-short>
        public System.Single Bottom;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>MF_VIDEO_SPHERICAL_VIEWDIRECTION</unmanaged>
    /// <unmanaged-short>MF_VIDEO_SPHERICAL_VIEWDIRECTION</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct VideoSphericalViewDirection
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>iHeading</unmanaged>
        /// <unmanaged-short>iHeading</unmanaged-short>
        public System.Int32 IHeading;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>iPitch</unmanaged>
        /// <unmanaged-short>iPitch</unmanaged-short>
        public System.Int32 IPitch;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>iRoll</unmanaged>
        /// <unmanaged-short>iRoll</unmanaged-short>
        public System.Int32 IRoll;
    }

    /// <summary>
    /// <p> </p><p>Contains information about an uncompressed video format. This structure is used in the <strong><see cref = "SharpDX.MediaFoundation.VideoFormat"/></strong> structure.</p>
    /// </summary>
    /// <doc-id>aa473817</doc-id>
    /// <unmanaged>MFVideoSurfaceInfo</unmanaged>
    /// <unmanaged-short>MFVideoSurfaceInfo</unmanaged-short>
    public partial struct VideoSurfaceInfo
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa473817</doc-id>
        /// <unmanaged>Format</unmanaged>
        /// <unmanaged-short>Format</unmanaged-short>
        public System.Int32 Format;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa473817</doc-id>
        /// <unmanaged>PaletteEntries</unmanaged>
        /// <unmanaged-short>PaletteEntries</unmanaged-short>
        public System.Int32 PaletteEntries;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa473817</doc-id>
        /// <unmanaged>Palette</unmanaged>
        /// <unmanaged-short>Palette</unmanaged-short>
        public SharpDX.MediaFoundation.PaletteEntry[] Palette
        {
            get => _Palette ?? (_Palette = new SharpDX.MediaFoundation.PaletteEntry[1]);
            private set => _Palette = value;
        }

        internal SharpDX.MediaFoundation.PaletteEntry[] _Palette;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.Int32 Format;
            public System.Int32 PaletteEntries;
            public SharpDX.MediaFoundation.PaletteEntry Palette;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Format = @ref.Format;
            PaletteEntries = @ref.PaletteEntries;
            fixed (void *__to = &Palette[0], __from = &@ref.Palette)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 1 * sizeof (SharpDX.MediaFoundation.PaletteEntry));
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Format = Format;
            @ref.PaletteEntries = PaletteEntries;
            fixed (void *__from = &Palette[0], __to = &@ref.Palette)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 1 * sizeof (SharpDX.MediaFoundation.PaletteEntry));
        }
    }
}
// <auto-generated/>

namespace SharpDX.MediaFoundation
{
    [System.FlagsAttribute]
    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>__MIDL___MIDL_itf_mfidl_0000_0028_0001</unmanaged>
    /// <unmanaged-short>__MIDL___MIDL_itf_mfidl_0000_0028_0001</unmanaged-short>
    public enum ActivateCustomMixerFlags : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_ACTIVATE_CUSTOM_MIXER_ALLOWFAIL</unmanaged>
        /// <unmanaged-short>MF_ACTIVATE_CUSTOM_MIXER_ALLOWFAIL</unmanaged-short>
        AllowFail = unchecked ((System.Int32)(1)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    [System.FlagsAttribute]
    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>__MIDL___MIDL_itf_mfidl_0000_0028_0002</unmanaged>
    /// <unmanaged-short>__MIDL___MIDL_itf_mfidl_0000_0028_0002</unmanaged-short>
    public enum ActivateCustomPresenterFlags : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_ACTIVATE_CUSTOM_PRESENTER_ALLOWFAIL</unmanaged>
        /// <unmanaged-short>MF_ACTIVATE_CUSTOM_PRESENTER_ALLOWFAIL</unmanaged-short>
        AllowFail = unchecked ((System.Int32)(1)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    [System.FlagsAttribute]
    /// <summary>
    /// <p> </p><p>Defines the ASF indexer options.</p>
    /// </summary>
    /// <doc-id>ms704695</doc-id>
    /// <unmanaged>MFASF_INDEXERFLAGS</unmanaged>
    /// <unmanaged-short>MFASF_INDEXERFLAGS</unmanaged-short>
    public enum AsfIndexerFlags : System.Int32
    {
        /// <summary>
        /// <dd> <p>The indexer creates a new index object.</p> </dd>
        /// </summary>
        /// <doc-id>ms704695</doc-id>
        /// <unmanaged>MFASF_INDEXER_WRITE_NEW_INDEX</unmanaged>
        /// <unmanaged-short>MFASF_INDEXER_WRITE_NEW_INDEX</unmanaged-short>
        WriteNewIndex = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>The indexer returns values for reverse playback.</p> </dd>
        /// </summary>
        /// <doc-id>ms704695</doc-id>
        /// <unmanaged>MFASF_INDEXER_READ_FOR_REVERSEPLAYBACK</unmanaged>
        /// <unmanaged-short>MFASF_INDEXER_READ_FOR_REVERSEPLAYBACK</unmanaged-short>
        ReadForReversePlayback = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>The indexer creates an index object for a live ASF stream.</p> </dd>
        /// </summary>
        /// <doc-id>ms704695</doc-id>
        /// <unmanaged>MFASF_INDEXER_WRITE_FOR_LIVEREAD</unmanaged>
        /// <unmanaged-short>MFASF_INDEXER_WRITE_FOR_LIVEREAD</unmanaged-short>
        WriteForLiveread = unchecked ((System.Int32)(4)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    [System.FlagsAttribute]
    /// <summary>
    /// <p> </p><p>Defines the ASF multiplexer options.</p>
    /// </summary>
    /// <doc-id>ms698843</doc-id>
    /// <unmanaged>MFASF_MULTIPLEXERFLAGS</unmanaged>
    /// <unmanaged-short>MFASF_MULTIPLEXERFLAGS</unmanaged-short>
    public enum AsfMultiplexerflags : System.Int32
    {
        /// <summary>
        /// <dd> <p>The multiplexer automatically adjusts the bit rate of the ASF content in response to the characteristics of the streams being multiplexed.</p> </dd>
        /// </summary>
        /// <doc-id>ms698843</doc-id>
        /// <unmanaged>MFASF_MULTIPLEXER_AUTOADJUST_BITRATE</unmanaged>
        /// <unmanaged-short>MFASF_MULTIPLEXER_AUTOADJUST_BITRATE</unmanaged-short>
        AutoadjustBitRate = unchecked ((System.Int32)(1)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    /// <summary>
    /// <p> </p><p>Defines the selection options for an ASF stream.</p>
    /// </summary>
    /// <doc-id>ms694827</doc-id>
    /// <unmanaged>ASF_SELECTION_STATUS</unmanaged>
    /// <unmanaged-short>ASF_SELECTION_STATUS</unmanaged-short>
    public enum AsfSelectionStatus : System.Int32
    {
        /// <summary>
        /// <dd> <p>No samples from the stream are delivered.</p> </dd>
        /// </summary>
        /// <doc-id>ms694827</doc-id>
        /// <unmanaged>ASF_STATUS_NOTSELECTED</unmanaged>
        /// <unmanaged-short>ASF_STATUS_NOTSELECTED</unmanaged-short>
        NotSelected = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>Only samples from the stream that are clean points are delivered.</p> </dd>
        /// </summary>
        /// <doc-id>ms694827</doc-id>
        /// <unmanaged>ASF_STATUS_CLEANPOINTSONLY</unmanaged>
        /// <unmanaged-short>ASF_STATUS_CLEANPOINTSONLY</unmanaged-short>
        CleanPointsOnly = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>All samples from the stream are delivered.</p> </dd>
        /// </summary>
        /// <doc-id>ms694827</doc-id>
        /// <unmanaged>ASF_STATUS_ALLDATAUNITS</unmanaged>
        /// <unmanaged-short>ASF_STATUS_ALLDATAUNITS</unmanaged-short>
        AllDataUnits = unchecked ((System.Int32)(2))}

    [System.FlagsAttribute]
    /// <summary>
    /// <p> </p><p>Defines the ASF splitter options.</p>
    /// </summary>
    /// <doc-id>ms700211</doc-id>
    /// <unmanaged>MFASF_SPLITTERFLAGS</unmanaged>
    /// <unmanaged-short>MFASF_SPLITTERFLAGS</unmanaged-short>
    public enum AsfSplitterflags : System.Int32
    {
        /// <summary>
        /// <dd> <p>The splitter delivers samples for the ASF content in reverse order to accommodate reverse playback.</p> </dd>
        /// </summary>
        /// <doc-id>ms700211</doc-id>
        /// <unmanaged>MFASF_SPLITTER_REVERSE</unmanaged>
        /// <unmanaged-short>MFASF_SPLITTER_REVERSE</unmanaged-short>
        Reverse = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>The splitter delivers samples for streams that are protected with Windows Media Digital Rights Management.</p> </dd>
        /// </summary>
        /// <doc-id>ms700211</doc-id>
        /// <unmanaged>MFASF_SPLITTER_WMDRM</unmanaged>
        /// <unmanaged-short>MFASF_SPLITTER_WMDRM</unmanaged-short>
        Wmdrm = unchecked ((System.Int32)(2)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    [System.FlagsAttribute]
    /// <summary>
    /// <p> </p><p>Defines status conditions for the <strong>IMFASFSplitter::GetNextSample</strong> method.</p>
    /// </summary>
    /// <doc-id>ms703127</doc-id>
    /// <unmanaged>ASF_STATUSFLAGS</unmanaged>
    /// <unmanaged-short>ASF_STATUSFLAGS</unmanaged-short>
    public enum AsfStatusflags : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms703127</doc-id>
        /// <unmanaged>ASF_STATUSFLAGS_INCOMPLETE</unmanaged>
        /// <unmanaged-short>ASF_STATUSFLAGS_INCOMPLETE</unmanaged-short>
        Incomplete = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms703127</doc-id>
        /// <unmanaged>ASF_STATUSFLAGS_NONFATAL_ERROR</unmanaged>
        /// <unmanaged-short>ASF_STATUSFLAGS_NONFATAL_ERROR</unmanaged-short>
        NonfatalError = unchecked ((System.Int32)(2)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    [System.FlagsAttribute]
    /// <summary>
    /// <p> </p><p>Defines the ASF stream selector options.</p>
    /// </summary>
    /// <doc-id>ms696200</doc-id>
    /// <unmanaged>MFASF_STREAMSELECTORFLAGS</unmanaged>
    /// <unmanaged-short>MFASF_STREAMSELECTORFLAGS</unmanaged-short>
    public enum AsfStreamSelectorFlags : System.Int32
    {
        /// <summary>
        /// <dd> <p>The stream selector will not set thinning. Thinning is the process of removing samples from a stream to reduce the bit rate.</p> </dd>
        /// </summary>
        /// <doc-id>ms696200</doc-id>
        /// <unmanaged>MFASF_STREAMSELECTOR_DISABLE_THINNING</unmanaged>
        /// <unmanaged-short>MFASF_STREAMSELECTOR_DISABLE_THINNING</unmanaged-short>
        DisableThinning = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>The stream selector will use the average bit rate of streams when selecting streams.</p> </dd>
        /// </summary>
        /// <doc-id>ms696200</doc-id>
        /// <unmanaged>MFASF_STREAMSELECTOR_USE_AVERAGE_BITRATE</unmanaged>
        /// <unmanaged-short>MFASF_STREAMSELECTOR_USE_AVERAGE_BITRATE</unmanaged-short>
        UseAverageBitRate = unchecked ((System.Int32)(2)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    [System.FlagsAttribute]
    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>MFASYNC_CALLBACK_FLAGS</unmanaged>
    /// <unmanaged-short>MFASYNC_CALLBACK_FLAGS</unmanaged-short>
    public enum AsyncCallbackFlags : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MFASYNC_FAST_IO_PROCESSING_CALLBACK</unmanaged>
        /// <unmanaged-short>MFASYNC_FAST_IO_PROCESSING_CALLBACK</unmanaged-short>
        FastIoProcessing = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MFASYNC_SIGNAL_CALLBACK</unmanaged>
        /// <unmanaged-short>MFASYNC_SIGNAL_CALLBACK</unmanaged-short>
        Signal = unchecked ((System.Int32)(2)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MFASYNC_BLOCKING_CALLBACK</unmanaged>
        /// <unmanaged-short>MFASYNC_BLOCKING_CALLBACK</unmanaged-short>
        Blocking = unchecked ((System.Int32)(4)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MFASYNC_REPLY_CALLBACK</unmanaged>
        /// <unmanaged-short>MFASYNC_REPLY_CALLBACK</unmanaged-short>
        Reply = unchecked ((System.Int32)(8)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MFASYNC_LOCALIZE_REMOTE_CALLBACK</unmanaged>
        /// <unmanaged-short>MFASYNC_LOCALIZE_REMOTE_CALLBACK</unmanaged-short>
        LocalizeRemote = unchecked ((System.Int32)(16)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    /// <summary>
    /// <p>Specifies the type of work queue for the <strong>MFAllocateWorkQueueEx</strong> function to create.</p>
    /// </summary>
    /// <doc-id>dd388081</doc-id>
    /// <unmanaged>MFASYNC_WORKQUEUE_TYPE</unmanaged>
    /// <unmanaged-short>MFASYNC_WORKQUEUE_TYPE</unmanaged-short>
    public enum AsyncWorkqueueType : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd388081</doc-id>
        /// <unmanaged>MF_STANDARD_WORKQUEUE</unmanaged>
        /// <unmanaged-short>MF_STANDARD_WORKQUEUE</unmanaged-short>
        MfStandardWorkqueue = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd388081</doc-id>
        /// <unmanaged>MF_WINDOW_WORKQUEUE</unmanaged>
        /// <unmanaged-short>MF_WINDOW_WORKQUEUE</unmanaged-short>
        MfWindowWorkqueue = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd388081</doc-id>
        /// <unmanaged>MF_MULTITHREADED_WORKQUEUE</unmanaged>
        /// <unmanaged-short>MF_MULTITHREADED_WORKQUEUE</unmanaged-short>
        MfMultithreadedWorkqueue = unchecked ((System.Int32)(2))}

    /// <summary>
    /// <p> </p><p>Defines flags for serializing and deserializing attribute stores.</p>
    /// </summary>
    /// <doc-id>ms704675</doc-id>
    /// <unmanaged>MF_ATTRIBUTE_SERIALIZE_OPTIONS</unmanaged>
    /// <unmanaged-short>MF_ATTRIBUTE_SERIALIZE_OPTIONS</unmanaged-short>
    public enum AttributeSerializeOptions : System.Int32
    {
        /// <summary>
        /// <dd> <p>If this flag is set, <strong><see cref = "SharpDX.IUnknown"/></strong> references in the attribute store are marshaled to and from the stream. If this flag is absent, <strong><see cref = "SharpDX.IUnknown"/></strong> references in the attribute store are not marshaled or serialized.</p> </dd>
        /// </summary>
        /// <doc-id>ms704675</doc-id>
        /// <unmanaged>MF_ATTRIBUTE_SERIALIZE_UNKNOWN_BYREF</unmanaged>
        /// <unmanaged-short>MF_ATTRIBUTE_SERIALIZE_UNKNOWN_BYREF</unmanaged-short>
        UnknownByref = unchecked ((System.Int32)(1))}

    /// <summary>
    /// <p> </p><p>Specifies how to compare the attributes on two objects.</p>
    /// </summary>
    /// <doc-id>ms703793</doc-id>
    /// <unmanaged>MF_ATTRIBUTES_MATCH_TYPE</unmanaged>
    /// <unmanaged-short>MF_ATTRIBUTES_MATCH_TYPE</unmanaged-short>
    public enum AttributesMatchType : System.Int32
    {
        /// <summary>
        /// <dd> <p>Check whether all the attributes in <em>pThis</em> exist in <em>pTheirs</em> and have the same data, where <em>pThis</em> is the object whose <strong>Compare</strong> method is being called and <em>pTheirs</em> is the object given in the <em>pTheirs</em> parameter.</p> </dd>
        /// </summary>
        /// <doc-id>ms703793</doc-id>
        /// <unmanaged>MF_ATTRIBUTES_MATCH_OUR_ITEMS</unmanaged>
        /// <unmanaged-short>MF_ATTRIBUTES_MATCH_OUR_ITEMS</unmanaged-short>
        OurItems = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>Check whether all the attributes in <em>pTheirs</em> exist in <em>pThis</em> and have the same data, where <em>pThis</em> is the object whose <strong>Compare</strong> method is being called and <em>pTheirs</em> is the object given in the <em>pTheirs</em> parameter.</p> </dd>
        /// </summary>
        /// <doc-id>ms703793</doc-id>
        /// <unmanaged>MF_ATTRIBUTES_MATCH_THEIR_ITEMS</unmanaged>
        /// <unmanaged-short>MF_ATTRIBUTES_MATCH_THEIR_ITEMS</unmanaged-short>
        TheirItems = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>Check whether both objects have identical attributes with the same data.</p> </dd>
        /// </summary>
        /// <doc-id>ms703793</doc-id>
        /// <unmanaged>MF_ATTRIBUTES_MATCH_ALL_ITEMS</unmanaged>
        /// <unmanaged-short>MF_ATTRIBUTES_MATCH_ALL_ITEMS</unmanaged-short>
        AllItems = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>Check whether the attributes that exist in both objects have the same data.</p> </dd>
        /// </summary>
        /// <doc-id>ms703793</doc-id>
        /// <unmanaged>MF_ATTRIBUTES_MATCH_INTERSECTION</unmanaged>
        /// <unmanaged-short>MF_ATTRIBUTES_MATCH_INTERSECTION</unmanaged-short>
        Intersection = unchecked ((System.Int32)(3)),
        /// <summary>
        /// <dd> <p>Find the object with the fewest number of attributes, and check if those attributes exist in the other object and have the same data.</p> </dd>
        /// </summary>
        /// <doc-id>ms703793</doc-id>
        /// <unmanaged>MF_ATTRIBUTES_MATCH_SMALLER</unmanaged>
        /// <unmanaged-short>MF_ATTRIBUTES_MATCH_SMALLER</unmanaged-short>
        Smaller = unchecked ((System.Int32)(4))}

    /// <summary>
    /// <p> </p><p>Defines the data type for a key/value pair.</p>
    /// </summary>
    /// <doc-id>ms694854</doc-id>
    /// <unmanaged>MF_ATTRIBUTE_TYPE</unmanaged>
    /// <unmanaged-short>MF_ATTRIBUTE_TYPE</unmanaged-short>
    public enum AttributeType : System.Int32
    {
        /// <summary>
        /// <dd> <p>Unsigned 32-bit integer.</p> </dd>
        /// </summary>
        /// <doc-id>ms694854</doc-id>
        /// <unmanaged>MF_ATTRIBUTE_UINT32</unmanaged>
        /// <unmanaged-short>MF_ATTRIBUTE_UINT32</unmanaged-short>
        UInt32 = unchecked ((System.Int32)(19)),
        /// <summary>
        /// <dd> <p>Unsigned 64-bit integer.</p> </dd>
        /// </summary>
        /// <doc-id>ms694854</doc-id>
        /// <unmanaged>MF_ATTRIBUTE_UINT64</unmanaged>
        /// <unmanaged-short>MF_ATTRIBUTE_UINT64</unmanaged-short>
        UInt64 = unchecked ((System.Int32)(21)),
        /// <summary>
        /// <dd> <p>Floating-point number.</p> </dd>
        /// </summary>
        /// <doc-id>ms694854</doc-id>
        /// <unmanaged>MF_ATTRIBUTE_DOUBLE</unmanaged>
        /// <unmanaged-short>MF_ATTRIBUTE_DOUBLE</unmanaged-short>
        Double = unchecked ((System.Int32)(5)),
        /// <summary>
        /// <dd> <p><strong><see cref = "System.Guid"/></strong> value.</p> </dd>
        /// </summary>
        /// <doc-id>ms694854</doc-id>
        /// <unmanaged>MF_ATTRIBUTE_GUID</unmanaged>
        /// <unmanaged-short>MF_ATTRIBUTE_GUID</unmanaged-short>
        Guid = unchecked ((System.Int32)(72)),
        /// <summary>
        /// <dd> <p><c>null</c>-terminated wide-character string.</p> </dd>
        /// </summary>
        /// <doc-id>ms694854</doc-id>
        /// <unmanaged>MF_ATTRIBUTE_STRING</unmanaged>
        /// <unmanaged-short>MF_ATTRIBUTE_STRING</unmanaged-short>
        String = unchecked ((System.Int32)(31)),
        /// <summary>
        /// <dd> <p>Byte array.</p> </dd>
        /// </summary>
        /// <doc-id>ms694854</doc-id>
        /// <unmanaged>MF_ATTRIBUTE_BLOB</unmanaged>
        /// <unmanaged-short>MF_ATTRIBUTE_BLOB</unmanaged-short>
        Blob = unchecked ((System.Int32)(4113)),
        /// <summary>
        /// <dd> <p><strong><see cref = "SharpDX.IUnknown"/></strong> reference.</p> </dd>
        /// </summary>
        /// <doc-id>ms694854</doc-id>
        /// <unmanaged>MF_ATTRIBUTE_IUNKNOWN</unmanaged>
        /// <unmanaged-short>MF_ATTRIBUTE_IUNKNOWN</unmanaged-short>
        IUnknown = unchecked ((System.Int32)(13))}

    /// <summary>
    /// <p>Specifies values for audio constriction.</p>
    /// </summary>
    /// <remarks>
    /// <p>Values defined by the <strong><see cref = "SharpDX.MediaFoundation.AudioConstriction"/></strong> enumeration matches the <strong>EAudioConstriction</strong> enumeration defined <strong>audioenginebaseapo.h</strong>.</p>
    /// </remarks>
    /// <doc-id>jj128334</doc-id>
    /// <unmanaged>MFAudioConstriction</unmanaged>
    /// <unmanaged-short>MFAudioConstriction</unmanaged-short>
    public enum AudioConstriction : System.Int32
    {
        /// <summary>
        /// <dd> <p>Audio is not constricted. </p> </dd>
        /// </summary>
        /// <doc-id>jj128334</doc-id>
        /// <unmanaged>MFaudioConstrictionOff</unmanaged>
        /// <unmanaged-short>MFaudioConstrictionOff</unmanaged-short>
        MFaudioConstrictionOff = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>Audio is down sampled to 48 kHz/16-bit.</p> </dd>
        /// </summary>
        /// <doc-id>jj128334</doc-id>
        /// <unmanaged>MFaudioConstriction48_16</unmanaged>
        /// <unmanaged-short>MFaudioConstriction48_16</unmanaged-short>
        MFaudioConstriction4816 = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>Audio is down sampled to 44 kHz/16-bit.</p> </dd>
        /// </summary>
        /// <doc-id>jj128334</doc-id>
        /// <unmanaged>MFaudioConstriction44_16</unmanaged>
        /// <unmanaged-short>MFaudioConstriction44_16</unmanaged-short>
        MFaudioConstriction4416 = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>Audio is down sampled to 14hKz/16-bit.</p> </dd>
        /// </summary>
        /// <doc-id>jj128334</doc-id>
        /// <unmanaged>MFaudioConstriction14_14</unmanaged>
        /// <unmanaged-short>MFaudioConstriction14_14</unmanaged-short>
        MFaudioConstriction1414 = unchecked ((System.Int32)(3)),
        /// <summary>
        /// <dd> <p>Audio is muted.</p> </dd>
        /// </summary>
        /// <doc-id>jj128334</doc-id>
        /// <unmanaged>MFaudioConstrictionMute</unmanaged>
        /// <unmanaged-short>MFaudioConstrictionMute</unmanaged-short>
        MFaudioConstrictionMute = unchecked ((System.Int32)(4))}

    /// <summary>
    /// <p>Contains flags for the <strong>IMF2DBuffer2::Lock2DSize</strong> method.</p>
    /// </summary>
    /// <doc-id>hh162742</doc-id>
    /// <unmanaged>MF2DBuffer_LockFlags</unmanaged>
    /// <unmanaged-short>MF2DBuffer_LockFlags</unmanaged-short>
    public enum Buffer2DLockFlags : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh162742</doc-id>
        /// <unmanaged>MF2DBuffer_LockFlags_LockTypeMask</unmanaged>
        /// <unmanaged-short>MF2DBuffer_LockFlags_LockTypeMask</unmanaged-short>
        LockTypeMask = unchecked ((System.Int32)(3)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh162742</doc-id>
        /// <unmanaged>MF2DBuffer_LockFlags_Read</unmanaged>
        /// <unmanaged-short>MF2DBuffer_LockFlags_Read</unmanaged-short>
        Read = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh162742</doc-id>
        /// <unmanaged>MF2DBuffer_LockFlags_Write</unmanaged>
        /// <unmanaged-short>MF2DBuffer_LockFlags_Write</unmanaged-short>
        Write = unchecked ((System.Int32)(2)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh162742</doc-id>
        /// <unmanaged>MF2DBuffer_LockFlags_ReadWrite</unmanaged>
        /// <unmanaged-short>MF2DBuffer_LockFlags_ReadWrite</unmanaged-short>
        ReadWrite = unchecked ((System.Int32)(3))}

    /// <summary>
    /// <p> </p><p>Specifies the origin for a seek request.</p>
    /// </summary>
    /// <doc-id>ms702091</doc-id>
    /// <unmanaged>MFBYTESTREAM_SEEK_ORIGIN</unmanaged>
    /// <unmanaged-short>MFBYTESTREAM_SEEK_ORIGIN</unmanaged-short>
    public enum ByteStreamSeekOrigin : System.Int32
    {
        /// <summary>
        /// <dd> <p>The seek position is specified relative to the start of the stream.</p> </dd>
        /// </summary>
        /// <doc-id>ms702091</doc-id>
        /// <unmanaged>msoBegin</unmanaged>
        /// <unmanaged-short>msoBegin</unmanaged-short>
        MsoBegin = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>The seek position is specified relative to the current read/write position in the stream.</p> </dd>
        /// </summary>
        /// <doc-id>ms702091</doc-id>
        /// <unmanaged>msoCurrent</unmanaged>
        /// <unmanaged-short>msoCurrent</unmanaged-short>
        MsoCurrent = unchecked ((System.Int32)(1))}

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>MFCameraIntrinsic_DistortionModelType</unmanaged>
    /// <unmanaged-short>MFCameraIntrinsic_DistortionModelType</unmanaged-short>
    public enum CameraIntrinsicDistortionModelType : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MFCameraIntrinsic_DistortionModelType_6KT</unmanaged>
        /// <unmanaged-short>MFCameraIntrinsic_DistortionModelType_6KT</unmanaged-short>
        SixKT = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MFCameraIntrinsic_DistortionModelType_ArcTan</unmanaged>
        /// <unmanaged-short>MFCameraIntrinsic_DistortionModelType_ArcTan</unmanaged-short>
        ArcTan = unchecked ((System.Int32)(1))}

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>MF_CAPTURE_ENGINE_AUDIO_PROCESSING_MODE</unmanaged>
    /// <unmanaged-short>MF_CAPTURE_ENGINE_AUDIO_PROCESSING_MODE</unmanaged-short>
    public enum CaptureEngineAudioProcessingMode : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_CAPTURE_ENGINE_AUDIO_PROCESSING_DEFAULT</unmanaged>
        /// <unmanaged-short>MF_CAPTURE_ENGINE_AUDIO_PROCESSING_DEFAULT</unmanaged-short>
        Default = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_CAPTURE_ENGINE_AUDIO_PROCESSING_RAW</unmanaged>
        /// <unmanaged-short>MF_CAPTURE_ENGINE_AUDIO_PROCESSING_RAW</unmanaged-short>
        Raw = unchecked ((System.Int32)(1))}

    /// <summary>
    /// <p>Specifies a type of capture device.</p>
    /// </summary>
    /// <doc-id>hh162811</doc-id>
    /// <unmanaged>MF_CAPTURE_ENGINE_DEVICE_TYPE</unmanaged>
    /// <unmanaged-short>MF_CAPTURE_ENGINE_DEVICE_TYPE</unmanaged-short>
    public enum CaptureEngineDeviceType : System.Int32
    {
        /// <summary>
        /// <dd> <p>An audio capture device, such as a microphone.</p> </dd>
        /// </summary>
        /// <doc-id>hh162811</doc-id>
        /// <unmanaged>MF_CAPTURE_ENGINE_DEVICE_TYPE_AUDIO</unmanaged>
        /// <unmanaged-short>MF_CAPTURE_ENGINE_DEVICE_TYPE_AUDIO</unmanaged-short>
        Audio = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>A video capture device, such as a webcam.</p> </dd>
        /// </summary>
        /// <doc-id>hh162811</doc-id>
        /// <unmanaged>MF_CAPTURE_ENGINE_DEVICE_TYPE_VIDEO</unmanaged>
        /// <unmanaged-short>MF_CAPTURE_ENGINE_DEVICE_TYPE_VIDEO</unmanaged-short>
        Video = unchecked ((System.Int32)(1))}

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE</unmanaged>
    /// <unmanaged-short>MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE</unmanaged-short>
    public enum CaptureEngineMediaCategoryType : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_OTHER</unmanaged>
        /// <unmanaged-short>MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_OTHER</unmanaged-short>
        Other = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_COMMUNICATIONS</unmanaged>
        /// <unmanaged-short>MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_COMMUNICATIONS</unmanaged-short>
        Communications = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_MEDIA</unmanaged>
        /// <unmanaged-short>MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_MEDIA</unmanaged-short>
        Media = unchecked ((System.Int32)(2)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_GAMECHAT</unmanaged>
        /// <unmanaged-short>MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_GAMECHAT</unmanaged-short>
        Gamechat = unchecked ((System.Int32)(3)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_SPEECH</unmanaged>
        /// <unmanaged-short>MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_SPEECH</unmanaged-short>
        Speech = unchecked ((System.Int32)(4))}

    /// <summary>
    /// <p>Specifies a type of capture sink.</p>
    /// </summary>
    /// <doc-id>hh162824</doc-id>
    /// <unmanaged>MF_CAPTURE_ENGINE_SINK_TYPE</unmanaged>
    /// <unmanaged-short>MF_CAPTURE_ENGINE_SINK_TYPE</unmanaged-short>
    public enum CaptureEngineSinkType : System.Int32
    {
        /// <summary>
        /// <dd> <p>A recording sink, for capturing audio and video to a file.</p> </dd>
        /// </summary>
        /// <doc-id>hh162824</doc-id>
        /// <unmanaged>MF_CAPTURE_ENGINE_SINK_TYPE_RECORD</unmanaged>
        /// <unmanaged-short>MF_CAPTURE_ENGINE_SINK_TYPE_RECORD</unmanaged-short>
        Record = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>A preview sink, for previewing live audio or video.</p> </dd>
        /// </summary>
        /// <doc-id>hh162824</doc-id>
        /// <unmanaged>MF_CAPTURE_ENGINE_SINK_TYPE_PREVIEW</unmanaged>
        /// <unmanaged-short>MF_CAPTURE_ENGINE_SINK_TYPE_PREVIEW</unmanaged-short>
        Preview = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>A photo sink, for capturing still images.</p> </dd>
        /// </summary>
        /// <doc-id>hh162824</doc-id>
        /// <unmanaged>MF_CAPTURE_ENGINE_SINK_TYPE_PHOTO</unmanaged>
        /// <unmanaged-short>MF_CAPTURE_ENGINE_SINK_TYPE_PHOTO</unmanaged-short>
        Photo = unchecked ((System.Int32)(2))}

    /// <summary>
    /// <p>Defines the values for the source stream category.</p>
    /// </summary>
    /// <doc-id>jj159898</doc-id>
    /// <unmanaged>MF_CAPTURE_ENGINE_STREAM_CATEGORY</unmanaged>
    /// <unmanaged-short>MF_CAPTURE_ENGINE_STREAM_CATEGORY</unmanaged-short>
    public enum CaptureEngineStreamCategory : System.Int32
    {
        /// <summary>
        /// <dd> <p>Specifies a video preview stream.</p> </dd>
        /// </summary>
        /// <doc-id>jj159898</doc-id>
        /// <unmanaged>MF_CAPTURE_ENGINE_STREAM_CATEGORY_VIDEO_PREVIEW</unmanaged>
        /// <unmanaged-short>MF_CAPTURE_ENGINE_STREAM_CATEGORY_VIDEO_PREVIEW</unmanaged-short>
        VideoPreview = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>Specifies a video capture stream.</p> </dd>
        /// </summary>
        /// <doc-id>jj159898</doc-id>
        /// <unmanaged>MF_CAPTURE_ENGINE_STREAM_CATEGORY_VIDEO_CAPTURE</unmanaged>
        /// <unmanaged-short>MF_CAPTURE_ENGINE_STREAM_CATEGORY_VIDEO_CAPTURE</unmanaged-short>
        VideoCapture = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>Specifies an independent photo stream.</p> </dd>
        /// </summary>
        /// <doc-id>jj159898</doc-id>
        /// <unmanaged>MF_CAPTURE_ENGINE_STREAM_CATEGORY_PHOTO_INDEPENDENT</unmanaged>
        /// <unmanaged-short>MF_CAPTURE_ENGINE_STREAM_CATEGORY_PHOTO_INDEPENDENT</unmanaged-short>
        PhotoIndependent = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>Specifies a dependent photo stream.</p> </dd>
        /// </summary>
        /// <doc-id>jj159898</doc-id>
        /// <unmanaged>MF_CAPTURE_ENGINE_STREAM_CATEGORY_PHOTO_DEPENDENT</unmanaged>
        /// <unmanaged-short>MF_CAPTURE_ENGINE_STREAM_CATEGORY_PHOTO_DEPENDENT</unmanaged-short>
        PhotoDependent = unchecked ((System.Int32)(3)),
        /// <summary>
        /// <dd> <p>Specifies an audio stream.</p> </dd>
        /// </summary>
        /// <doc-id>jj159898</doc-id>
        /// <unmanaged>MF_CAPTURE_ENGINE_STREAM_CATEGORY_AUDIO</unmanaged>
        /// <unmanaged-short>MF_CAPTURE_ENGINE_STREAM_CATEGORY_AUDIO</unmanaged-short>
        Audio = unchecked ((System.Int32)(4)),
        /// <summary>
        /// <dd> <p>Specifies an unsupported stream.</p> </dd>
        /// </summary>
        /// <doc-id>jj159898</doc-id>
        /// <unmanaged>MF_CAPTURE_ENGINE_STREAM_CATEGORY_UNSUPPORTED</unmanaged>
        /// <unmanaged-short>MF_CAPTURE_ENGINE_STREAM_CATEGORY_UNSUPPORTED</unmanaged-short>
        Unsupported = unchecked ((System.Int32)(5))}

    [System.FlagsAttribute]
    /// <summary>
    /// <p>Contains flags that describe the characteristics of a clock. These flags are returned by the <strong>IMFClock::GetClockCharacteristics</strong> method.</p>
    /// </summary>
    /// <doc-id>ms699872</doc-id>
    /// <unmanaged>MFCLOCK_CHARACTERISTICS_FLAGS</unmanaged>
    /// <unmanaged-short>MFCLOCK_CHARACTERISTICS_FLAGS</unmanaged-short>
    public enum ClockCharacteristicsFlags : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms699872</doc-id>
        /// <unmanaged>MFCLOCK_CHARACTERISTICS_FLAG_FREQUENCY_10MHZ</unmanaged>
        /// <unmanaged-short>MFCLOCK_CHARACTERISTICS_FLAG_FREQUENCY_10MHZ</unmanaged-short>
        Frequency10mhz = unchecked ((System.Int32)(2)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms699872</doc-id>
        /// <unmanaged>MFCLOCK_CHARACTERISTICS_FLAG_ALWAYS_RUNNING</unmanaged>
        /// <unmanaged-short>MFCLOCK_CHARACTERISTICS_FLAG_ALWAYS_RUNNING</unmanaged-short>
        AlwaysRunning = unchecked ((System.Int32)(4)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms699872</doc-id>
        /// <unmanaged>MFCLOCK_CHARACTERISTICS_FLAG_IS_SYSTEM_CLOCK</unmanaged>
        /// <unmanaged-short>MFCLOCK_CHARACTERISTICS_FLAG_IS_SYSTEM_CLOCK</unmanaged-short>
        IsSystemClock = unchecked ((System.Int32)(8)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    [System.FlagsAttribute]
    /// <summary>
    /// <p> </p><p>Defines properties of a clock.</p>
    /// </summary>
    /// <doc-id>ms703927</doc-id>
    /// <unmanaged>MFCLOCK_RELATIONAL_FLAGS</unmanaged>
    /// <unmanaged-short>MFCLOCK_RELATIONAL_FLAGS</unmanaged-short>
    public enum ClockRelationalFlags : System.Int32
    {
        /// <summary>
        /// <dd> <p>Jitter values are always negative. In other words, the time returned by <strong>IMFClock::GetCorrelatedTime</strong> might jitter behind the actual clock time, but will never jitter ahead of the actual time. If this flag is not present, the clock might jitter in either direction.</p> </dd>
        /// </summary>
        /// <doc-id>ms703927</doc-id>
        /// <unmanaged>MFCLOCK_RELATIONAL_FLAG_JITTER_NEVER_AHEAD</unmanaged>
        /// <unmanaged-short>MFCLOCK_RELATIONAL_FLAG_JITTER_NEVER_AHEAD</unmanaged-short>
        JitterNeverAhead = unchecked ((System.Int32)(1)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    /// <summary>
    /// <p> </p><p>Defines the state of a clock.</p>
    /// </summary>
    /// <doc-id>ms700794</doc-id>
    /// <unmanaged>MFCLOCK_STATE</unmanaged>
    /// <unmanaged-short>MFCLOCK_STATE</unmanaged-short>
    public enum ClockState : System.Int32
    {
        /// <summary>
        /// <dd> <p>The clock is invalid. A clock might be invalid for several reasons. Some clocks return this state before the first start. This state can also occur if the underlying device is lost.</p> </dd>
        /// </summary>
        /// <doc-id>ms700794</doc-id>
        /// <unmanaged>MFCLOCK_STATE_INVALID</unmanaged>
        /// <unmanaged-short>MFCLOCK_STATE_INVALID</unmanaged-short>
        Invalid = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>The clock is running. While the clock is running, the time advances at the clock's frequency and current rate.</p> </dd>
        /// </summary>
        /// <doc-id>ms700794</doc-id>
        /// <unmanaged>MFCLOCK_STATE_RUNNING</unmanaged>
        /// <unmanaged-short>MFCLOCK_STATE_RUNNING</unmanaged-short>
        Running = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>The clock is stopped. While stopped, the clock reports a time of 0.</p> </dd>
        /// </summary>
        /// <doc-id>ms700794</doc-id>
        /// <unmanaged>MFCLOCK_STATE_STOPPED</unmanaged>
        /// <unmanaged-short>MFCLOCK_STATE_STOPPED</unmanaged-short>
        Stopped = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>The clock is paused. While paused, the clock reports the time it was paused.</p> </dd>
        /// </summary>
        /// <doc-id>ms700794</doc-id>
        /// <unmanaged>MFCLOCK_STATE_PAUSED</unmanaged>
        /// <unmanaged-short>MFCLOCK_STATE_PAUSED</unmanaged-short>
        Paused = unchecked ((System.Int32)(3))}

    /// <summary>
    /// <p>Specifies how the topology loader connects a topology node. This enumeration is used with the <strong><see cref = "ConnectMethod"/></strong> attribute. </p>
    /// </summary>
    /// <doc-id>ms700178</doc-id>
    /// <unmanaged>MF_CONNECT_METHOD</unmanaged>
    /// <unmanaged-short>MF_CONNECT_METHOD</unmanaged-short>
    public enum ConnectMethod : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms700178</doc-id>
        /// <unmanaged>MF_CONNECT_DIRECT</unmanaged>
        /// <unmanaged-short>MF_CONNECT_DIRECT</unmanaged-short>
        Direct = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms700178</doc-id>
        /// <unmanaged>MF_CONNECT_ALLOW_CONVERTER</unmanaged>
        /// <unmanaged-short>MF_CONNECT_ALLOW_CONVERTER</unmanaged-short>
        AllowConverter = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms700178</doc-id>
        /// <unmanaged>MF_CONNECT_ALLOW_DECODER</unmanaged>
        /// <unmanaged-short>MF_CONNECT_ALLOW_DECODER</unmanaged-short>
        AllowDecoder = unchecked ((System.Int32)(3)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms700178</doc-id>
        /// <unmanaged>MF_CONNECT_RESOLVE_INDEPENDENT_OUTPUTTYPES</unmanaged>
        /// <unmanaged-short>MF_CONNECT_RESOLVE_INDEPENDENT_OUTPUTTYPES</unmanaged-short>
        ResolveIndependentOutputTypes = unchecked ((System.Int32)(4)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms700178</doc-id>
        /// <unmanaged>MF_CONNECT_AS_OPTIONAL</unmanaged>
        /// <unmanaged-short>MF_CONNECT_AS_OPTIONAL</unmanaged-short>
        AsOptional = unchecked ((System.Int32)(65536)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms700178</doc-id>
        /// <unmanaged>MF_CONNECT_AS_OPTIONAL_BRANCH</unmanaged>
        /// <unmanaged-short>MF_CONNECT_AS_OPTIONAL_BRANCH</unmanaged-short>
        AsOptionalBranch = unchecked ((System.Int32)(131072))}

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>MF_CROSS_ORIGIN_POLICY</unmanaged>
    /// <unmanaged-short>MF_CROSS_ORIGIN_POLICY</unmanaged-short>
    public enum CrossOriginPolicy : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_CROSS_ORIGIN_POLICY_NONE</unmanaged>
        /// <unmanaged-short>MF_CROSS_ORIGIN_POLICY_NONE</unmanaged-short>
        None = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_CROSS_ORIGIN_POLICY_ANONYMOUS</unmanaged>
        /// <unmanaged-short>MF_CROSS_ORIGIN_POLICY_ANONYMOUS</unmanaged-short>
        Anonymous = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_CROSS_ORIGIN_POLICY_USE_CREDENTIALS</unmanaged>
        /// <unmanaged-short>MF_CROSS_ORIGIN_POLICY_USE_CREDENTIALS</unmanaged-short>
        UseCredentials = unchecked ((System.Int32)(2))}

    /// <summary>
    /// <p>Specifies the type of unit contained in an <strong><see cref = "SharpDX.MediaFoundation.Sample"/></strong> in a MFSampleExtension_ForwardedDecodeUnits collection.</p>
    /// </summary>
    /// <doc-id>mt493447</doc-id>
    /// <unmanaged>MF_CUSTOM_DECODE_UNIT_TYPE</unmanaged>
    /// <unmanaged-short>MF_CUSTOM_DECODE_UNIT_TYPE</unmanaged-short>
    public enum CustomDecodeUnitType : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>mt493447</doc-id>
        /// <unmanaged>MF_DECODE_UNIT_NAL</unmanaged>
        /// <unmanaged-short>MF_DECODE_UNIT_NAL</unmanaged-short>
        MfDecodeUnitNal = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>mt493447</doc-id>
        /// <unmanaged>MF_DECODE_UNIT_SEI</unmanaged>
        /// <unmanaged-short>MF_DECODE_UNIT_SEI</unmanaged-short>
        MfDecodeUnitSei = unchecked ((System.Int32)(1))}

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>MFDepthMeasurement</unmanaged>
    /// <unmanaged-short>MFDepthMeasurement</unmanaged-short>
    public enum DepthMeasurement : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>DistanceToFocalPlane</unmanaged>
        /// <unmanaged-short>DistanceToFocalPlane</unmanaged-short>
        DistanceToFocalPlane = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>DistanceToOpticalCenter</unmanaged>
        /// <unmanaged-short>DistanceToOpticalCenter</unmanaged-short>
        DistanceToOpticalCenter = unchecked ((System.Int32)(1))}

    /// <summary>
    /// <p>The <strong>SetOutputStreamState</strong> method sets the Device MFT output stream state and media type.</p>
    /// </summary>
    /// <remarks>
    /// <p>This interface method helps to transition the output stream to a specified state with specified media type set on the output stream. This will be used by the DTM when the Device Source requests a specific output stream?s state and media type to be changed. Device MFT should change the specified output stream?s media type and state to the requested media type.</p><p>If the incoming media type and stream state are same as the current media type and stream state the method return <strong><see cref = "SharpDX.Result.Ok"/></strong>.</p><p>If the incoming media type and current media type of the stream are the same, Device MFT must change the stream?s state to the requested value and return the appropriate <strong><see cref = "SharpDX.Result"/></strong>.</p><p>When a change in the output stream?s media type requires a corresponding change in the input then Device MFT must post the METransformInputStreamStateChanged event  to DTM to change the relevant input stream. The call must return only after changing the input stream?s media type and the appropriate <strong><see cref = "SharpDX.Result"/></strong>.</p><p>As an  example, consider a Device MFT that has two input streams and three output streams. Let  Output 1 and Output 2 source from Input 1 and  stream at 720p. Now, let us say Output 2?s media type changes to 1080p. To satisfy this request, Device MFT must  change the Input 1 media type to 1080p, by posting METransformInputStreamStateChanged event to the DTM. DTM would call <strong>SetInputStreamState</strong> to change the input stream? media type and state. After this call, the <strong>SetOutputStreamState</strong> must return.</p>
    /// </remarks>
    /// <doc-id>mt797684</doc-id>
    /// <unmanaged>DeviceStreamState</unmanaged>
    /// <unmanaged-short>DeviceStreamState</unmanaged-short>
    public enum DeviceStreamState : System.Int32
    {
        /// <summary>
        /// <dd> <p>Stream ID of the input stream where the state and media type needs to be changed.</p> </dd>
        /// </summary>
        /// <doc-id>mt797684</doc-id>
        /// <unmanaged>DeviceStreamState_Stop</unmanaged>
        /// <unmanaged-short>DeviceStreamState_Stop</unmanaged-short>
        Stop = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>Preferred media type for the input stream is passed in through this parameter. Device MFT should change the media type only if the incoming media type is different from the current media type.</p> </dd>
        /// </summary>
        /// <doc-id>mt797684</doc-id>
        /// <unmanaged>DeviceStreamState_Pause</unmanaged>
        /// <unmanaged-short>DeviceStreamState_Pause</unmanaged-short>
        Pause = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>Specifies the  <strong>DeviceStreamState</strong> which the input stream should transition to.</p> </dd>
        /// </summary>
        /// <doc-id>mt797684</doc-id>
        /// <unmanaged>DeviceStreamState_Run</unmanaged>
        /// <unmanaged-short>DeviceStreamState_Run</unmanaged-short>
        Run = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>Must be zero.</p> </dd>
        /// </summary>
        /// <doc-id>mt797684</doc-id>
        /// <unmanaged>DeviceStreamState_Disabled</unmanaged>
        /// <unmanaged-short>DeviceStreamState_Disabled</unmanaged-short>
        Disabled = unchecked ((System.Int32)(3))}

    [System.FlagsAttribute]
    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>_DMO_INPLACE_PROCESS_FLAGS</unmanaged>
    /// <unmanaged-short>_DMO_INPLACE_PROCESS_FLAGS</unmanaged-short>
    public enum DmoInplaceProcessFlags : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>DMO_INPLACE_NORMAL</unmanaged>
        /// <unmanaged-short>DMO_INPLACE_NORMAL</unmanaged-short>
        DmoInplaceNormal = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>DMO_INPLACE_ZERO</unmanaged>
        /// <unmanaged-short>DMO_INPLACE_ZERO</unmanaged-short>
        DmoInplaceZero = unchecked ((System.Int32)(1)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    [System.FlagsAttribute]
    /// <summary>
    /// <p> </p><p>The <code>DMO_INPUT_DATA_BUFFER_FLAGS</code> enumeration defines flags that describe an input buffer.</p>
    /// </summary>
    /// <doc-id>dd375501</doc-id>
    /// <unmanaged>_DMO_INPUT_DATA_BUFFER_FLAGS</unmanaged>
    /// <unmanaged-short>_DMO_INPUT_DATA_BUFFER_FLAGS</unmanaged-short>
    public enum DmoInputDataBufferFlags : System.Int32
    {
        /// <summary>
        /// <dd> <p>The beginning of the data is a synchronization point.</p> </dd>
        /// </summary>
        /// <doc-id>dd375501</doc-id>
        /// <unmanaged>DMO_INPUT_DATA_BUFFERF_SYNCPOINT</unmanaged>
        /// <unmanaged-short>DMO_INPUT_DATA_BUFFERF_SYNCPOINT</unmanaged-short>
        DmoInputDataBufferFSyncpoint = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>The buffer's time stamp is valid.</p> <p>The buffer's indicated time length is valid.</p> </dd>
        /// </summary>
        /// <doc-id>dd375501</doc-id>
        /// <unmanaged>DMO_INPUT_DATA_BUFFERF_TIME</unmanaged>
        /// <unmanaged-short>DMO_INPUT_DATA_BUFFERF_TIME</unmanaged-short>
        DmoInputDataBufferFTime = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>The buffer's indicated time length is valid.</p> </dd>
        /// </summary>
        /// <doc-id>dd375501</doc-id>
        /// <unmanaged>DMO_INPUT_DATA_BUFFERF_TIMELENGTH</unmanaged>
        /// <unmanaged-short>DMO_INPUT_DATA_BUFFERF_TIMELENGTH</unmanaged-short>
        DmoInputDataBufferFTimelength = unchecked ((System.Int32)(4)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375501</doc-id>
        /// <unmanaged>DMO_INPUT_DATA_BUFFERF_DISCONTINUITY</unmanaged>
        /// <unmanaged-short>DMO_INPUT_DATA_BUFFERF_DISCONTINUITY</unmanaged-short>
        DmoInputDataBufferFDiscontinuity = unchecked ((System.Int32)(8)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    [System.FlagsAttribute]
    /// <summary>
    /// <p>Media Foundation transforms (MFTs) are an evolution of the transform model first introduced with DirectX Media Objects (DMOs). This topic summarizes the main ways in which MFTs differ from DMOs. Read this topic if you are already familiar with the DMO interfaces, or if you want to convert an existing DMO into an MFT.</p><p>This topic contains the following sections:</p><p> </p><ul> <li>Number</li> <li>Format</li> <li>Streaming<ul> <li>Allocating</li> <li>Processing</li> <li>Flushing</li> <li>Stream</li> </ul> </li> <li>Miscellaneous</li> <li>Flags<ul> <li>ProcessInput</li> <li>ProcessOutput</li> <li>GetInputStatus</li> <li>GetOutputStatus</li> <li>GetInputStreamInfo</li> <li>GetOutputStreamInfo</li> <li>SetInputType/SetOutputType</li> </ul> </li> <li>Error</li> <li>Creating</li> <li>Related</li> </ul>
    /// </summary>
    /// <doc-id>bb250374</doc-id>
    /// <unmanaged>_DMO_INPUT_STATUS_FLAGS</unmanaged>
    /// <unmanaged-short>_DMO_INPUT_STATUS_FLAGS</unmanaged-short>
    public enum DmoInputStatusFlags : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>bb250374</doc-id>
        /// <unmanaged>DMO_INPUT_STATUSF_ACCEPT_DATA</unmanaged>
        /// <unmanaged-short>DMO_INPUT_STATUSF_ACCEPT_DATA</unmanaged-short>
        DmoInputStatusfAcceptData = unchecked ((System.Int32)(1)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    [System.FlagsAttribute]
    /// <summary>
    /// <p> </p><p>The <code>DMO_INPUT_STREAM_INFO_FLAGS</code> enumeration defines flags that describe an input stream.</p>
    /// </summary>
    /// <doc-id>dd375502</doc-id>
    /// <unmanaged>_DMO_INPUT_STREAM_INFO_FLAGS</unmanaged>
    /// <unmanaged-short>_DMO_INPUT_STREAM_INFO_FLAGS</unmanaged-short>
    public enum DmoInputStreamInformationFlags : System.Int32
    {
        /// <summary>
        /// <dd> <p>The stream requires whole samples. Samples must not span multiple buffers, and buffers must not contain partial samples.</p> </dd>
        /// </summary>
        /// <doc-id>dd375502</doc-id>
        /// <unmanaged>DMO_INPUT_STREAMF_WHOLE_SAMPLES</unmanaged>
        /// <unmanaged-short>DMO_INPUT_STREAMF_WHOLE_SAMPLES</unmanaged-short>
        DmoInputStreamFWholeSamples = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>Each buffer must contain exactly one sample.</p> </dd>
        /// </summary>
        /// <doc-id>dd375502</doc-id>
        /// <unmanaged>DMO_INPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER</unmanaged>
        /// <unmanaged-short>DMO_INPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER</unmanaged-short>
        DmoInputStreamFSingleSamplePerBuffer = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>All the samples in this stream must be the same size.</p> </dd>
        /// </summary>
        /// <doc-id>dd375502</doc-id>
        /// <unmanaged>DMO_INPUT_STREAMF_FIXED_SAMPLE_SIZE</unmanaged>
        /// <unmanaged-short>DMO_INPUT_STREAMF_FIXED_SAMPLE_SIZE</unmanaged-short>
        DmoInputStreamFFixedSampleSize = unchecked ((System.Int32)(4)),
        /// <summary>
        /// <dd> <p>The DMO performs lookahead on the incoming data, and may hold multiple input buffers for this stream.</p> </dd>
        /// </summary>
        /// <doc-id>dd375502</doc-id>
        /// <unmanaged>DMO_INPUT_STREAMF_HOLDS_BUFFERS</unmanaged>
        /// <unmanaged-short>DMO_INPUT_STREAMF_HOLDS_BUFFERS</unmanaged-short>
        DmoInputStreamFHoldsBuffers = unchecked ((System.Int32)(8)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    [System.FlagsAttribute]
    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>_DMO_OUTPUT_DATA_BUFFER_FLAGS</unmanaged>
    /// <unmanaged-short>_DMO_OUTPUT_DATA_BUFFER_FLAGS</unmanaged-short>
    public enum DmoOutputDataBufferFlags : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>DMO_OUTPUT_DATA_BUFFERF_SYNCPOINT</unmanaged>
        /// <unmanaged-short>DMO_OUTPUT_DATA_BUFFERF_SYNCPOINT</unmanaged-short>
        DmoOutputDataBufferFSyncpoint = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>DMO_OUTPUT_DATA_BUFFERF_TIME</unmanaged>
        /// <unmanaged-short>DMO_OUTPUT_DATA_BUFFERF_TIME</unmanaged-short>
        DmoOutputDataBufferFTime = unchecked ((System.Int32)(2)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>DMO_OUTPUT_DATA_BUFFERF_TIMELENGTH</unmanaged>
        /// <unmanaged-short>DMO_OUTPUT_DATA_BUFFERF_TIMELENGTH</unmanaged-short>
        DmoOutputDataBufferFTimelength = unchecked ((System.Int32)(4)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>DMO_OUTPUT_DATA_BUFFERF_DISCONTINUITY</unmanaged>
        /// <unmanaged-short>DMO_OUTPUT_DATA_BUFFERF_DISCONTINUITY</unmanaged-short>
        DmoOutputDataBufferFDiscontinuity = unchecked ((System.Int32)(8)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE</unmanaged>
        /// <unmanaged-short>DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE</unmanaged-short>
        DmoOutputDataBufferFIncomplete = unchecked ((System.Int32)(16777216)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    [System.FlagsAttribute]
    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>_DMO_OUTPUT_STREAM_INFO_FLAGS</unmanaged>
    /// <unmanaged-short>_DMO_OUTPUT_STREAM_INFO_FLAGS</unmanaged-short>
    public enum DmoOutputStreamInformationFlags : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>DMO_OUTPUT_STREAMF_WHOLE_SAMPLES</unmanaged>
        /// <unmanaged-short>DMO_OUTPUT_STREAMF_WHOLE_SAMPLES</unmanaged-short>
        DmoOutputStreamFWholeSamples = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>DMO_OUTPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER</unmanaged>
        /// <unmanaged-short>DMO_OUTPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER</unmanaged-short>
        DmoOutputStreamFSingleSamplePerBuffer = unchecked ((System.Int32)(2)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>DMO_OUTPUT_STREAMF_FIXED_SAMPLE_SIZE</unmanaged>
        /// <unmanaged-short>DMO_OUTPUT_STREAMF_FIXED_SAMPLE_SIZE</unmanaged-short>
        DmoOutputStreamFFixedSampleSize = unchecked ((System.Int32)(4)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>DMO_OUTPUT_STREAMF_DISCARDABLE</unmanaged>
        /// <unmanaged-short>DMO_OUTPUT_STREAMF_DISCARDABLE</unmanaged-short>
        DmoOutputStreamFDiscardable = unchecked ((System.Int32)(8)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>DMO_OUTPUT_STREAMF_OPTIONAL</unmanaged>
        /// <unmanaged-short>DMO_OUTPUT_STREAMF_OPTIONAL</unmanaged-short>
        DmoOutputStreamFOptional = unchecked ((System.Int32)(16)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    [System.FlagsAttribute]
    /// <summary>
    /// <p> </p><p>The <code>DMO_PROCESS_OUTPUT_FLAGS</code> enumeration defines flags that specify output processing requests.</p>
    /// </summary>
    /// <doc-id>dd375511</doc-id>
    /// <unmanaged>_DMO_PROCESS_OUTPUT_FLAGS</unmanaged>
    /// <unmanaged-short>_DMO_PROCESS_OUTPUT_FLAGS</unmanaged-short>
    public enum DmoProcessOutputFlags : System.Int32
    {
        /// <summary>
        /// <dd> <p>Discard the output when the reference to the output buffer is <strong><c>null</c></strong>.</p> </dd>
        /// </summary>
        /// <doc-id>dd375511</doc-id>
        /// <unmanaged>DMO_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER</unmanaged>
        /// <unmanaged-short>DMO_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER</unmanaged-short>
        DmoProcessOutputDiscardWhenNoBuffer = unchecked ((System.Int32)(1)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    [System.FlagsAttribute]
    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>_DMO_QUALITY_STATUS_FLAGS</unmanaged>
    /// <unmanaged-short>_DMO_QUALITY_STATUS_FLAGS</unmanaged-short>
    public enum DmoQualityStatusFlags : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>DMO_QUALITY_STATUS_ENABLED</unmanaged>
        /// <unmanaged-short>DMO_QUALITY_STATUS_ENABLED</unmanaged-short>
        DmoQualityStatusEnabled = unchecked ((System.Int32)(1)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    [System.FlagsAttribute]
    /// <summary>
    /// <p> </p><p>The <code>DMO_SET_TYPE_FLAGS</code> enumeration defines flags for setting the media type on a stream.</p>
    /// </summary>
    /// <remarks>
    /// <p>The DMO_SET_TYPEF_TEST_ONLY and DMO_SET_TYPEF_CLEAR flags are mutually exclusive. Do not set both flags.</p>
    /// </remarks>
    /// <doc-id>dd375514</doc-id>
    /// <unmanaged>_DMO_SET_TYPE_FLAGS</unmanaged>
    /// <unmanaged-short>_DMO_SET_TYPE_FLAGS</unmanaged-short>
    public enum DmoSetTypeFlags : System.Int32
    {
        /// <summary>
        /// <dd> <p>Test the media type but do not set it.</p> </dd>
        /// </summary>
        /// <doc-id>dd375514</doc-id>
        /// <unmanaged>DMO_SET_TYPEF_TEST_ONLY</unmanaged>
        /// <unmanaged-short>DMO_SET_TYPEF_TEST_ONLY</unmanaged-short>
        DmoSetTypefTestOnly = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>Clear the media type that was set for the stream.</p> </dd>
        /// </summary>
        /// <doc-id>dd375514</doc-id>
        /// <unmanaged>DMO_SET_TYPEF_CLEAR</unmanaged>
        /// <unmanaged-short>DMO_SET_TYPEF_CLEAR</unmanaged-short>
        DmoSetTypefClear = unchecked ((System.Int32)(2)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    [System.FlagsAttribute]
    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>_DMO_VIDEO_OUTPUT_STREAM_FLAGS</unmanaged>
    /// <unmanaged-short>_DMO_VIDEO_OUTPUT_STREAM_FLAGS</unmanaged-short>
    public enum DmoVideoOutputStreamFlags : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>DMO_VOSF_NEEDS_PREVIOUS_SAMPLE</unmanaged>
        /// <unmanaged-short>DMO_VOSF_NEEDS_PREVIOUS_SAMPLE</unmanaged-short>
        DmoVosfNeedsPreviousSample = unchecked ((System.Int32)(1)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>EAllocationType</unmanaged>
    /// <unmanaged-short>EAllocationType</unmanaged-short>
    public enum EAllocationType : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>eAllocationTypeDynamic</unmanaged>
        /// <unmanaged-short>eAllocationTypeDynamic</unmanaged-short>
        EAllocationTypeDynamic = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>eAllocationTypeRT</unmanaged>
        /// <unmanaged-short>eAllocationTypeRT</unmanaged-short>
        EAllocationTypeRT = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>eAllocationTypePageable</unmanaged>
        /// <unmanaged-short>eAllocationTypePageable</unmanaged-short>
        EAllocationTypePageable = unchecked ((System.Int32)(2)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>eAllocationTypeIgnore</unmanaged>
        /// <unmanaged-short>eAllocationTypeIgnore</unmanaged-short>
        EAllocationTypeIgnore = unchecked ((System.Int32)(3))}

    /// <summary>
    /// <p>Contains flags that are used to configure the Microsoft DirectShow enhanced video renderer (EVR) filter.</p>
    /// </summary>
    /// <doc-id>dd318789</doc-id>
    /// <unmanaged>EVRFilterConfigPrefs</unmanaged>
    /// <unmanaged-short>EVRFilterConfigPrefs</unmanaged-short>
    public enum EVRFilterConfigPrefs : System.Int32
    {
        /// <summary>
        /// <dd> <p>Enables dynamic adjustments to video quality during playback.</p> </dd>
        /// </summary>
        /// <doc-id>dd318789</doc-id>
        /// <unmanaged>EVRFilterConfigPrefs_EnableQoS</unmanaged>
        /// <unmanaged-short>EVRFilterConfigPrefs_EnableQoS</unmanaged-short>
        EnableQoS = unchecked ((System.Int32)(1))}

    /// <summary>
    /// <p> </p><p>Specifies the requested access mode for opening a file.</p>
    /// </summary>
    /// <doc-id>ms696239</doc-id>
    /// <unmanaged>MF_FILE_ACCESSMODE</unmanaged>
    /// <unmanaged-short>MF_FILE_ACCESSMODE</unmanaged-short>
    public enum FileAccessMode : System.Int32
    {
        /// <summary>
        /// <dd> <p>Read mode.</p> </dd>
        /// </summary>
        /// <doc-id>ms696239</doc-id>
        /// <unmanaged>MF_ACCESSMODE_READ</unmanaged>
        /// <unmanaged-short>MF_ACCESSMODE_READ</unmanaged-short>
        MfAccessModeRead = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>Write mode.</p> </dd>
        /// </summary>
        /// <doc-id>ms696239</doc-id>
        /// <unmanaged>MF_ACCESSMODE_WRITE</unmanaged>
        /// <unmanaged-short>MF_ACCESSMODE_WRITE</unmanaged-short>
        MfAccessModeWrite = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>Read and write mode.</p> </dd>
        /// </summary>
        /// <doc-id>ms696239</doc-id>
        /// <unmanaged>MF_ACCESSMODE_READWRITE</unmanaged>
        /// <unmanaged-short>MF_ACCESSMODE_READWRITE</unmanaged-short>
        MfAccessModeReadwrite = unchecked ((System.Int32)(3))}

    [System.FlagsAttribute]
    /// <summary>
    /// <p> Specifies the behavior when opening a file. </p>
    /// </summary>
    /// <doc-id>ms694926</doc-id>
    /// <unmanaged>MF_FILE_FLAGS</unmanaged>
    /// <unmanaged-short>MF_FILE_FLAGS</unmanaged-short>
    public enum FileFlags : System.Int32
    {
        /// <summary>
        /// <dd> <p> Use the default behavior. </p> </dd>
        /// </summary>
        /// <doc-id>ms694926</doc-id>
        /// <unmanaged>MF_FILEFLAGS_NONE</unmanaged>
        /// <unmanaged-short>MF_FILEFLAGS_NONE</unmanaged-short>
        FlagsNone = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p> Open the file with no system caching. </p> </dd>
        /// </summary>
        /// <doc-id>ms694926</doc-id>
        /// <unmanaged>MF_FILEFLAGS_NOBUFFERING</unmanaged>
        /// <unmanaged-short>MF_FILEFLAGS_NOBUFFERING</unmanaged-short>
        FlagsNobuffering = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>Subsequent open operations can have write access to the file. </p> <strong>Note</strong>??Requires Windows?7 or later. ? </dd>
        /// </summary>
        /// <doc-id>ms694926</doc-id>
        /// <unmanaged>MF_FILEFLAGS_ALLOW_WRITE_SHARING</unmanaged>
        /// <unmanaged-short>MF_FILEFLAGS_ALLOW_WRITE_SHARING</unmanaged-short>
        FlagsAllowWriteSharing = unchecked ((System.Int32)(2)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    /// <summary>
    /// <p> </p><p>Specifies how to open or create a file.</p>
    /// </summary>
    /// <doc-id>ms694164</doc-id>
    /// <unmanaged>MF_FILE_OPENMODE</unmanaged>
    /// <unmanaged-short>MF_FILE_OPENMODE</unmanaged-short>
    public enum FileOpenMode : System.Int32
    {
        /// <summary>
        /// <dd> <p>Open an existing file. Fail if the file does not exist.</p> </dd>
        /// </summary>
        /// <doc-id>ms694164</doc-id>
        /// <unmanaged>MF_OPENMODE_FAIL_IF_NOT_EXIST</unmanaged>
        /// <unmanaged-short>MF_OPENMODE_FAIL_IF_NOT_EXIST</unmanaged-short>
        MfOpenModeFailIfNotExist = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>Create a new file. Fail if the file already exists.</p> </dd>
        /// </summary>
        /// <doc-id>ms694164</doc-id>
        /// <unmanaged>MF_OPENMODE_FAIL_IF_EXIST</unmanaged>
        /// <unmanaged-short>MF_OPENMODE_FAIL_IF_EXIST</unmanaged-short>
        MfOpenModeFailIfExist = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>Open an existing file and truncate it, so that the size is zero bytes. Fail if the file does not already exist.</p> </dd>
        /// </summary>
        /// <doc-id>ms694164</doc-id>
        /// <unmanaged>MF_OPENMODE_RESET_IF_EXIST</unmanaged>
        /// <unmanaged-short>MF_OPENMODE_RESET_IF_EXIST</unmanaged-short>
        MfOpenModeResetIfExist = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>If the file does not exist, create a new file. If the file exists, open it.</p> </dd>
        /// </summary>
        /// <doc-id>ms694164</doc-id>
        /// <unmanaged>MF_OPENMODE_APPEND_IF_EXIST</unmanaged>
        /// <unmanaged-short>MF_OPENMODE_APPEND_IF_EXIST</unmanaged-short>
        MfOpenModeAppendIfExist = unchecked ((System.Int32)(3)),
        /// <summary>
        /// <dd> <p>Create a new file. If the file exists, overwrite the file.</p> </dd>
        /// </summary>
        /// <doc-id>ms694164</doc-id>
        /// <unmanaged>MF_OPENMODE_DELETE_IF_EXIST</unmanaged>
        /// <unmanaged-short>MF_OPENMODE_DELETE_IF_EXIST</unmanaged-short>
        MfOpenModeDeleteIfExist = unchecked ((System.Int32)(4))}

    /// <summary>
    /// <p>Describes the type of data provided by a frame source.</p>
    /// </summary>
    /// <remarks>
    /// <p>The values of this enumeration are used with the MF_DEVICESTREAM_ATTRIBUTE_FRAMESOURCE_TYPES attribute.</p>
    /// </remarks>
    /// <doc-id>mt764279</doc-id>
    /// <unmanaged>MFFrameSourceTypes</unmanaged>
    /// <unmanaged-short>MFFrameSourceTypes</unmanaged-short>
    public enum FrameSourceTypes : System.Int32
    {
        /// <summary>
        /// <dd> <p>The frame source provides color data.</p> </dd>
        /// </summary>
        /// <doc-id>mt764279</doc-id>
        /// <unmanaged>MFFrameSourceTypes_Color</unmanaged>
        /// <unmanaged-short>MFFrameSourceTypes_Color</unmanaged-short>
        Color = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>The frame source provides infrared data.</p> </dd>
        /// </summary>
        /// <doc-id>mt764279</doc-id>
        /// <unmanaged>MFFrameSourceTypes_Infrared</unmanaged>
        /// <unmanaged-short>MFFrameSourceTypes_Infrared</unmanaged-short>
        Infrared = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>The frame source provides depth data.</p> </dd>
        /// </summary>
        /// <doc-id>mt764279</doc-id>
        /// <unmanaged>MFFrameSourceTypes_Depth</unmanaged>
        /// <unmanaged-short>MFFrameSourceTypes_Depth</unmanaged-short>
        Depth = unchecked ((System.Int32)(4)),
        /// <summary>
        /// <dd> <p>The frame source provides custom data.</p> </dd>
        /// </summary>
        /// <doc-id>mt764279</doc-id>
        /// <unmanaged>MFFrameSourceTypes_Image</unmanaged>
        /// <unmanaged-short>MFFrameSourceTypes_Image</unmanaged-short>
        Image = unchecked ((System.Int32)(8)),
        /// <summary>
        /// <dd> <p>The frame source provides custom data.</p> </dd>
        /// </summary>
        /// <doc-id>mt764279</doc-id>
        /// <unmanaged>MFFrameSourceTypes_Custom</unmanaged>
        /// <unmanaged-short>MFFrameSourceTypes_Custom</unmanaged-short>
        Custom = unchecked ((System.Int32)(128))}

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>MF_HDCP_STATUS</unmanaged>
    /// <unmanaged-short>MF_HDCP_STATUS</unmanaged-short>
    public enum HdcpStatus : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_HDCP_STATUS_ON</unmanaged>
        /// <unmanaged-short>MF_HDCP_STATUS_ON</unmanaged-short>
        On = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_HDCP_STATUS_OFF</unmanaged>
        /// <unmanaged-short>MF_HDCP_STATUS_OFF</unmanaged-short>
        Off = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_HDCP_STATUS_ON_WITH_TYPE_ENFORCEMENT</unmanaged>
        /// <unmanaged-short>MF_HDCP_STATUS_ON_WITH_TYPE_ENFORCEMENT</unmanaged-short>
        OnWithTypeEnforcement = unchecked ((System.Int32)(2))}

    /// <summary>
    /// <p>Specifies the likelihood that the Media Engine can play a specified type of media resource.</p>
    /// </summary>
    /// <doc-id>hh162836</doc-id>
    /// <unmanaged>MF_MEDIA_ENGINE_CANPLAY</unmanaged>
    /// <unmanaged-short>MF_MEDIA_ENGINE_CANPLAY</unmanaged-short>
    public enum MediaEngineCanPlay : System.Int32
    {
        /// <summary>
        /// <dd> <p>The Media Engine cannot play the resource.</p> </dd>
        /// </summary>
        /// <doc-id>hh162836</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_CANPLAY_NOT_SUPPORTED</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_CANPLAY_NOT_SUPPORTED</unmanaged-short>
        NotSupported = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>The Media Engine might be able to play the resource.</p> </dd>
        /// </summary>
        /// <doc-id>hh162836</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_CANPLAY_MAYBE</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_CANPLAY_MAYBE</unmanaged-short>
        Maybe = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>The Media Engine can probably play the resource.</p> </dd>
        /// </summary>
        /// <doc-id>hh162836</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_CANPLAY_PROBABLY</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_CANPLAY_PROBABLY</unmanaged-short>
        Probably = unchecked ((System.Int32)(2))}

    [System.FlagsAttribute]
    /// <summary>
    /// <p>Contains flags for the <strong>IMFMediaEngineClassFactory::CreateInstance</strong> method.</p>
    /// </summary>
    /// <doc-id>hh162839</doc-id>
    /// <unmanaged>MF_MEDIA_ENGINE_CREATEFLAGS</unmanaged>
    /// <unmanaged-short>MF_MEDIA_ENGINE_CREATEFLAGS</unmanaged-short>
    public enum MediaEngineCreateFlags : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh162839</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_AUDIOONLY</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_AUDIOONLY</unmanaged-short>
        AudioOnly = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh162839</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_WAITFORSTABLE_STATE</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_WAITFORSTABLE_STATE</unmanaged-short>
        WaitForStableState = unchecked ((System.Int32)(2)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh162839</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_FORCEMUTE</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_FORCEMUTE</unmanaged-short>
        ForceMute = unchecked ((System.Int32)(4)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh162839</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_REAL_TIME_MODE</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_REAL_TIME_MODE</unmanaged-short>
        RealTimeMode = unchecked ((System.Int32)(8)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh162839</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_DISABLE_LOCAL_PLUGINS</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_DISABLE_LOCAL_PLUGINS</unmanaged-short>
        DisableLocalPlugins = unchecked ((System.Int32)(16)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh162839</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_CREATEFLAGS_MASK</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_CREATEFLAGS_MASK</unmanaged-short>
        CreateFlagsMask = unchecked ((System.Int32)(31)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    /// <summary>
    /// <p>Defines error status codes for the Media Engine.</p>
    /// </summary>
    /// <remarks>
    /// <p>The values greater than zero correspond to error codes defined for the <strong>MediaError</strong> object  in HTML5.</p>
    /// </remarks>
    /// <doc-id>hh162841</doc-id>
    /// <unmanaged>MF_MEDIA_ENGINE_ERR</unmanaged>
    /// <unmanaged-short>MF_MEDIA_ENGINE_ERR</unmanaged-short>
    public enum MediaEngineErr : System.Int32
    {
        /// <summary>
        /// <dd> <p>No error.</p> </dd>
        /// </summary>
        /// <doc-id>hh162841</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_ERR_NOERROR</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_ERR_NOERROR</unmanaged-short>
        Noerror = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>The process of fetching the media resource was stopped at the user's request. </p> </dd>
        /// </summary>
        /// <doc-id>hh162841</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_ERR_ABORTED</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_ERR_ABORTED</unmanaged-short>
        Aborted = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>A network error occurred while fetching the media resource. </p> </dd>
        /// </summary>
        /// <doc-id>hh162841</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_ERR_NETWORK</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_ERR_NETWORK</unmanaged-short>
        Network = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>An error occurred while decoding the media resource. </p> </dd>
        /// </summary>
        /// <doc-id>hh162841</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_ERR_DECODE</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_ERR_DECODE</unmanaged-short>
        Decode = unchecked ((System.Int32)(3)),
        /// <summary>
        /// <dd> <p>The media resource is not supported. </p> </dd>
        /// </summary>
        /// <doc-id>hh162841</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_ERR_SRC_NOT_SUPPORTED</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_ERR_SRC_NOT_SUPPORTED</unmanaged-short>
        SourceNotSupported = unchecked ((System.Int32)(4)),
        /// <summary>
        /// <dd> <p>An error occurred while encrypting the media resource.</p> <p>Supported in Windows?8.1 and later.</p> </dd>
        /// </summary>
        /// <doc-id>hh162841</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_ERR_ENCRYPTED</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_ERR_ENCRYPTED</unmanaged-short>
        Encrypted = unchecked ((System.Int32)(5))}

    /// <summary>
    /// <p>Defines event codes for the Media Engine. </p>
    /// </summary>
    /// <remarks>
    /// <p>The application receives Media Engine events through the <strong>IMFMediaEngineNotify::EventNotify</strong> method. The <strong>EventNotify</strong> method includes two event parameters, <em>param1</em> and <em>param2</em>. The meaning of the parameters depends on the event code. If the event description does not list any parameters, ignore the values of <em>param1</em> and <em>param2</em>.</p><p>Values below 1000 correspond to events defined in HTML 5 for media elements.</p>
    /// </remarks>
    /// <doc-id>hh162842</doc-id>
    /// <unmanaged>MF_MEDIA_ENGINE_EVENT</unmanaged>
    /// <unmanaged-short>MF_MEDIA_ENGINE_EVENT</unmanaged-short>
    public enum MediaEngineEvent : System.Int32
    {
        /// <summary>
        /// <dd> <p>The Media Engine has started to load the source. See <strong>IMFMediaEngine::Load</strong>.</p> </dd>
        /// </summary>
        /// <doc-id>hh162842</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_EVENT_LOADSTART</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_EVENT_LOADSTART</unmanaged-short>
        LoadStart = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>The Media Engine is loading the source.</p> </dd>
        /// </summary>
        /// <doc-id>hh162842</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_EVENT_PROGRESS</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_EVENT_PROGRESS</unmanaged-short>
        Progress = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>The Media Engine has suspended a load operation.</p> </dd>
        /// </summary>
        /// <doc-id>hh162842</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_EVENT_SUSPEND</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_EVENT_SUSPEND</unmanaged-short>
        Suspend = unchecked ((System.Int32)(3)),
        /// <summary>
        /// <dd> <p>The Media Engine cancelled a load operation that was in progress. </p> </dd>
        /// </summary>
        /// <doc-id>hh162842</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_EVENT_ABORT</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_EVENT_ABORT</unmanaged-short>
        Abort = unchecked ((System.Int32)(4)),
        /// <summary>
        /// <dd> <p>An error occurred.</p> <table> <tr><th>Event Parameter</th><th>Description</th></tr> <tr><td><em>param1</em></td><td>A member of the <strong><see cref = "SharpDX.MediaFoundation.MediaEngineErr"/></strong> enumeration.</td></tr> <tr><td><em>param2</em></td><td>An <strong><see cref = "SharpDX.Result"/></strong> error code, or zero.</td></tr> </table> <p>?</p> </dd>
        /// </summary>
        /// <doc-id>hh162842</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_EVENT_ERROR</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_EVENT_ERROR</unmanaged-short>
        Error = unchecked ((System.Int32)(5)),
        /// <summary>
        /// <dd> <p>The Media Engine has switched to the <strong>MF_MEDIA_ENGINE_NETWORK_EMPTY</strong> state. This can occur when the <strong>IMFMediaEngine::Load</strong> method is called, or if an error occurs during the <strong>Load</strong> method. See <strong>IMFMediaEngine::GetNetworkState</strong>.</p> </dd>
        /// </summary>
        /// <doc-id>hh162842</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_EVENT_EMPTIED</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_EVENT_EMPTIED</unmanaged-short>
        Emptied = unchecked ((System.Int32)(6)),
        /// <summary>
        /// <dd> <p>The <strong>Load</strong> algorithm is stalled, waiting for data.</p> </dd>
        /// </summary>
        /// <doc-id>hh162842</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_EVENT_STALLED</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_EVENT_STALLED</unmanaged-short>
        Stalled = unchecked ((System.Int32)(7)),
        /// <summary>
        /// <dd> <p>The Media Engine is switching to the playing state. See <strong>IMFMediaEngine::Play</strong>.</p> </dd>
        /// </summary>
        /// <doc-id>hh162842</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_EVENT_PLAY</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_EVENT_PLAY</unmanaged-short>
        Play = unchecked ((System.Int32)(8)),
        /// <summary>
        /// <dd> <p>The media engine has paused. See <strong>IMFMediaEngine::Pause</strong>.</p> </dd>
        /// </summary>
        /// <doc-id>hh162842</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_EVENT_PAUSE</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_EVENT_PAUSE</unmanaged-short>
        Pause = unchecked ((System.Int32)(9)),
        /// <summary>
        /// <dd> <p>The Media Engine has loaded enough source data to determine the duration and dimensions  of the source.</p> </dd>
        /// </summary>
        /// <doc-id>hh162842</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_EVENT_LOADEDMETADATA</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_EVENT_LOADEDMETADATA</unmanaged-short>
        LoadedMetadata = unchecked ((System.Int32)(10)),
        /// <summary>
        /// <dd> <p>The Media Engine has loaded enough data to render some content (for example, a video frame).</p> </dd>
        /// </summary>
        /// <doc-id>hh162842</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_EVENT_LOADEDDATA</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_EVENT_LOADEDDATA</unmanaged-short>
        LoadedData = unchecked ((System.Int32)(11)),
        /// <summary>
        /// <dd> <p>Playback has stopped because the next frame is not available.</p> </dd>
        /// </summary>
        /// <doc-id>hh162842</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_EVENT_WAITING</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_EVENT_WAITING</unmanaged-short>
        Waiting = unchecked ((System.Int32)(12)),
        /// <summary>
        /// <dd> <p>Playback has started. See <strong>IMFMediaEngine::Play</strong>.</p> </dd>
        /// </summary>
        /// <doc-id>hh162842</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_EVENT_PLAYING</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_EVENT_PLAYING</unmanaged-short>
        Playing = unchecked ((System.Int32)(13)),
        /// <summary>
        /// <dd> <p>Playback can start, but the Media Engine might need to stop to buffer more data.</p> </dd>
        /// </summary>
        /// <doc-id>hh162842</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_EVENT_CANPLAY</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_EVENT_CANPLAY</unmanaged-short>
        CanPlay = unchecked ((System.Int32)(14)),
        /// <summary>
        /// <dd> <p>The Media Engine can probably play through to the end of the resource, without stopping to buffer data.</p> </dd>
        /// </summary>
        /// <doc-id>hh162842</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_EVENT_CANPLAYTHROUGH</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_EVENT_CANPLAYTHROUGH</unmanaged-short>
        CanPlayThrough = unchecked ((System.Int32)(15)),
        /// <summary>
        /// <dd> <p>The Media Engine has started seeking to a new playback position. See <strong>IMFMediaEngine::SetCurrentTime</strong>.</p> </dd>
        /// </summary>
        /// <doc-id>hh162842</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_EVENT_SEEKING</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_EVENT_SEEKING</unmanaged-short>
        Seeking = unchecked ((System.Int32)(16)),
        /// <summary>
        /// <dd> <p>The Media Engine has seeked to a new playback position. See <strong>IMFMediaEngine::SetCurrentTime</strong>.</p> </dd>
        /// </summary>
        /// <doc-id>hh162842</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_EVENT_SEEKED</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_EVENT_SEEKED</unmanaged-short>
        Seeked = unchecked ((System.Int32)(17)),
        /// <summary>
        /// <dd> <p>The playback position has changed. See <strong>IMFMediaEngine::GetCurrentTime</strong>.</p> </dd>
        /// </summary>
        /// <doc-id>hh162842</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_EVENT_TIMEUPDATE</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_EVENT_TIMEUPDATE</unmanaged-short>
        TimeUpdate = unchecked ((System.Int32)(18)),
        /// <summary>
        /// <dd> <p>Playback has reached the end of the source. This event is not sent if the <strong>GetLoop</strong>is <strong>TRUE</strong>.</p> </dd>
        /// </summary>
        /// <doc-id>hh162842</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_EVENT_ENDED</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_EVENT_ENDED</unmanaged-short>
        Ended = unchecked ((System.Int32)(19)),
        /// <summary>
        /// <dd> <p>The playback rate has changed. See <strong>IMFMediaEngine::SetPlaybackRate</strong>.</p> </dd>
        /// </summary>
        /// <doc-id>hh162842</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_EVENT_RATECHANGE</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_EVENT_RATECHANGE</unmanaged-short>
        RateChange = unchecked ((System.Int32)(20)),
        /// <summary>
        /// <dd> <p>The duration of the media source has changed. See <strong>IMFMediaEngine::GetDuration</strong>.</p> </dd>
        /// </summary>
        /// <doc-id>hh162842</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_EVENT_DURATIONCHANGE</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_EVENT_DURATIONCHANGE</unmanaged-short>
        DurationChange = unchecked ((System.Int32)(21)),
        /// <summary>
        /// <dd> <p>The audio volume changed. See <strong>IMFMediaEngine::SetVolume</strong>.</p> </dd>
        /// </summary>
        /// <doc-id>hh162842</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_EVENT_VOLUMECHANGE</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_EVENT_VOLUMECHANGE</unmanaged-short>
        VolumeChange = unchecked ((System.Int32)(22)),
        /// <summary>
        /// <dd> <p>The output format of the media source has changed.</p> <table> <tr><th>Event Parameter</th><th>Description</th></tr> <tr><td><em>param1</em></td><td>Zero if the video format changed, 1 if the audio format changed.</td></tr> <tr><td><em>param2</em></td><td>Zero.</td></tr> </table> <p>?</p> </dd>
        /// </summary>
        /// <doc-id>hh162842</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_EVENT_FORMATCHANGE</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_EVENT_FORMATCHANGE</unmanaged-short>
        FormatChange = unchecked ((System.Int32)(1000)),
        /// <summary>
        /// <dd> <p>The Media Engine flushed any pending events from its 	queue.</p> </dd>
        /// </summary>
        /// <doc-id>hh162842</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_EVENT_PURGEQUEUEDEVENTS</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_EVENT_PURGEQUEUEDEVENTS</unmanaged-short>
        PurgeQueuedEvents = unchecked ((System.Int32)(1001)),
        /// <summary>
        /// <dd> <p>The playback position reached a timeline marker. See <strong>IMFMediaEngineEx::SetTimelineMarkerTimer</strong>.</p> </dd>
        /// </summary>
        /// <doc-id>hh162842</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_EVENT_TIMELINE_MARKER</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_EVENT_TIMELINE_MARKER</unmanaged-short>
        TimelineMarker = unchecked ((System.Int32)(1002)),
        /// <summary>
        /// <dd> <p>The audio balance changed. See <strong>IMFMediaEngineEx::SetBalance</strong>.</p> </dd>
        /// </summary>
        /// <doc-id>hh162842</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_EVENT_BALANCECHANGE</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_EVENT_BALANCECHANGE</unmanaged-short>
        BalanceChange = unchecked ((System.Int32)(1003)),
        /// <summary>
        /// <dd> <p>The Media Engine has finished downloading the source data.</p> </dd>
        /// </summary>
        /// <doc-id>hh162842</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_EVENT_DOWNLOADCOMPLETE</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_EVENT_DOWNLOADCOMPLETE</unmanaged-short>
        DownloadComplete = unchecked ((System.Int32)(1004)),
        /// <summary>
        /// <dd> <p>The media source has started to buffer data.</p> </dd>
        /// </summary>
        /// <doc-id>hh162842</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_EVENT_BUFFERINGSTARTED</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_EVENT_BUFFERINGSTARTED</unmanaged-short>
        BufferingStarted = unchecked ((System.Int32)(1005)),
        /// <summary>
        /// <dd> <p>The media source has stopped buffering data.</p> </dd>
        /// </summary>
        /// <doc-id>hh162842</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_EVENT_BUFFERINGENDED</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_EVENT_BUFFERINGENDED</unmanaged-short>
        BufferingEnded = unchecked ((System.Int32)(1006)),
        /// <summary>
        /// <dd> <p>The <strong>IMFMediaEngineEx::FrameStep</strong> method completed.</p> </dd>
        /// </summary>
        /// <doc-id>hh162842</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_EVENT_FRAMESTEPCOMPLETED</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_EVENT_FRAMESTEPCOMPLETED</unmanaged-short>
        FrameStepCompleted = unchecked ((System.Int32)(1007)),
        /// <summary>
        /// <dd> <p>The Media Engine's <strong>Load</strong> algorithm is waiting to start.</p> <table> <tr><th>Event Parameter</th><th>Description</th></tr> <tr><td><em>param1</em></td><td>A handle to a waitable event, of type <strong>HANDLE</strong>.</td></tr> <tr><td><em>param2</em></td><td>Zero.</td></tr> </table> <p>?</p> <p>If Media Engine is created with the <strong>MF_MEDIA_ENGINE_WAITFORSTABLE_STATE</strong> flag, the Media Engine sends the <strong>MF_MEDIA_ENGINE_EVENT_NOTIFYSTABLESTATE</strong> event at the start of the <strong>Load</strong> algorithm. The <em>param1</em> parameter is a handle to a waitable event. The <strong>Load</strong> thread waits for the application to signal the event by calling <strong>SetEvent</strong>.</p> <p>If the Media Engine is not created with the <strong>MF_MEDIA_ENGINE_WAITFORSTABLE_STATE</strong>, it does not send this event, and the <strong>Load</strong> thread does not wait to be signalled.</p> </dd>
        /// </summary>
        /// <doc-id>hh162842</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_EVENT_NOTIFYSTABLESTATE</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_EVENT_NOTIFYSTABLESTATE</unmanaged-short>
        NotifyStableState = unchecked ((System.Int32)(1008)),
        /// <summary>
        /// <dd> <p>The first frame of the media source is ready to render.</p> </dd>
        /// </summary>
        /// <doc-id>hh162842</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_EVENT_FIRSTFRAMEREADY</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_EVENT_FIRSTFRAMEREADY</unmanaged-short>
        FirstFrameReady = unchecked ((System.Int32)(1009)),
        /// <summary>
        /// <dd> <p>Raised when a new track is added or removed.</p> <p>Supported in Windows?8.1 and later.</p> </dd>
        /// </summary>
        /// <doc-id>hh162842</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_EVENT_TRACKSCHANGE</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_EVENT_TRACKSCHANGE</unmanaged-short>
        Trackschange = unchecked ((System.Int32)(1010)),
        /// <summary>
        /// <dd> <p>Raised when there is new information about the Output Protection Manager (OPM). </p> <p>This event will be raised when an OPM failure occurs, but ITA allows fallback without the OPM. In this case, constriction can be applied. </p> <p>This event will not be raised when there is an OPM failure and the fallback also fails. For example, if ITA blocks playback entirely when OPM cannot be established.</p> <p>Supported in Windows?8.1 and later.</p> </dd>
        /// </summary>
        /// <doc-id>hh162842</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_EVENT_OPMINFO</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_EVENT_OPMINFO</unmanaged-short>
        OpmInformation = unchecked ((System.Int32)(1011)),
        /// <summary>
        /// <dd> <p>Raised when one of the component streams of a media stream fails. This event is only raised if the media stream contains other component streams that did not fail.</p> </dd>
        /// </summary>
        /// <doc-id>hh162842</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_EVENT_RESOURCELOST</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_EVENT_RESOURCELOST</unmanaged-short>
        ResourceLost = unchecked ((System.Int32)(1012)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh162842</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_EVENT_DELAYLOADEVENT_CHANGED</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_EVENT_DELAYLOADEVENT_CHANGED</unmanaged-short>
        DelayloadeventChanged = unchecked ((System.Int32)(1013)),
        /// <summary>
        /// <dd> <p>Raised when one of the component streams of a media stream fails. This event is only raised if the media stream contains other component streams that did not fail.</p> </dd>
        /// </summary>
        /// <doc-id>hh162842</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_EVENT_STREAMRENDERINGERROR</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_EVENT_STREAMRENDERINGERROR</unmanaged-short>
        StreamRenderingerror = unchecked ((System.Int32)(1014)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh162842</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_EVENT_SUPPORTEDRATES_CHANGED</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_EVENT_SUPPORTEDRATES_CHANGED</unmanaged-short>
        SupportedRateSChanged = unchecked ((System.Int32)(1015)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh162842</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_EVENT_AUDIOENDPOINTCHANGE</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_EVENT_AUDIOENDPOINTCHANGE</unmanaged-short>
        AudioEndpointchange = unchecked ((System.Int32)(1016))}

    /// <summary>
    /// <p>Specifies media engine extension types.</p>
    /// </summary>
    /// <doc-id>hh162844</doc-id>
    /// <unmanaged>MF_MEDIA_ENGINE_EXTENSION_TYPE</unmanaged>
    /// <unmanaged-short>MF_MEDIA_ENGINE_EXTENSION_TYPE</unmanaged-short>
    public enum MediaEngineExtensionType : System.Int32
    {
        /// <summary>
        /// <dd></dd>
        /// </summary>
        /// <doc-id>hh162844</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_EXTENSION_TYPE_MEDIASOURCE</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_EXTENSION_TYPE_MEDIASOURCE</unmanaged-short>
        MediaSource = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd></dd>
        /// </summary>
        /// <doc-id>hh162844</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_EXTENSION_TYPE_BYTESTREAM</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_EXTENSION_TYPE_BYTESTREAM</unmanaged-short>
        ByteStream = unchecked ((System.Int32)(1))}

    [System.FlagsAttribute]
    /// <summary>
    /// <p>Specifies the content protection requirements for a video frame.</p>
    /// </summary>
    /// <doc-id>hh162845</doc-id>
    /// <unmanaged>MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAGS</unmanaged>
    /// <unmanaged-short>MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAGS</unmanaged-short>
    public enum MediaEngineFrameProtectionFlags : System.Int32
    {
        /// <summary>
        /// <dd> <p>The video frame should be protected.</p> </dd>
        /// </summary>
        /// <doc-id>hh162845</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAG_PROTECTED</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAG_PROTECTED</unmanaged-short>
        Protected = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>Direct3D surface protection must be applied to any surface that contains the frame.</p> </dd>
        /// </summary>
        /// <doc-id>hh162845</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAG_REQUIRES_SURFACE_PROTECTION</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAG_REQUIRES_SURFACE_PROTECTION</unmanaged-short>
        RequiresSurfaceProtection = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>Direct3D anti-screen-scrape protection must be applied to any surface that contains the frame.</p> </dd>
        /// </summary>
        /// <doc-id>hh162845</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAG_REQUIRES_ANTI_SCREEN_SCRAPE_PROTECTION</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAG_REQUIRES_ANTI_SCREEN_SCRAPE_PROTECTION</unmanaged-short>
        RequiresAntiScreenScrapeProtection = unchecked ((System.Int32)(4)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    /// <summary>
    /// <p>Defines media key error codes for the media engine.</p>
    /// </summary>
    /// <remarks>
    /// <p><strong><see cref = "SharpDX.MediaFoundation.MediaEngineKeyerr"/></strong> is used with the <em>code</em> parameter of  <strong>IMFMediaKeySessionNotify::KeyError</strong> and the <em>code</em> value returned from <strong>IMFMediaKeySession::GetError</strong>.</p>
    /// </remarks>
    /// <doc-id>dn302188</doc-id>
    /// <unmanaged>MF_MEDIA_ENGINE_KEYERR</unmanaged>
    /// <unmanaged-short>MF_MEDIA_ENGINE_KEYERR</unmanaged-short>
    public enum MediaEngineKeyerr : System.Int32
    {
        /// <summary>
        /// <dd> <p>Unknown error occurred.</p> </dd>
        /// </summary>
        /// <doc-id>dn302188</doc-id>
        /// <unmanaged>MF_MEDIAENGINE_KEYERR_UNKNOWN</unmanaged>
        /// <unmanaged-short>MF_MEDIAENGINE_KEYERR_UNKNOWN</unmanaged-short>
        EngineKeyerrUnknown = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>An error with the client occurred.</p> </dd>
        /// </summary>
        /// <doc-id>dn302188</doc-id>
        /// <unmanaged>MF_MEDIAENGINE_KEYERR_CLIENT</unmanaged>
        /// <unmanaged-short>MF_MEDIAENGINE_KEYERR_CLIENT</unmanaged-short>
        EngineKeyerrClient = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>An error with the service occurred.</p> </dd>
        /// </summary>
        /// <doc-id>dn302188</doc-id>
        /// <unmanaged>MF_MEDIAENGINE_KEYERR_SERVICE</unmanaged>
        /// <unmanaged-short>MF_MEDIAENGINE_KEYERR_SERVICE</unmanaged-short>
        EngineKeyerrService = unchecked ((System.Int32)(3)),
        /// <summary>
        /// <dd> <p>An error with the output occurred.</p> </dd>
        /// </summary>
        /// <doc-id>dn302188</doc-id>
        /// <unmanaged>MF_MEDIAENGINE_KEYERR_OUTPUT</unmanaged>
        /// <unmanaged-short>MF_MEDIAENGINE_KEYERR_OUTPUT</unmanaged-short>
        EngineKeyerrOutput = unchecked ((System.Int32)(4)),
        /// <summary>
        /// <dd> <p>An error occurred related to a hardware change.</p> </dd>
        /// </summary>
        /// <doc-id>dn302188</doc-id>
        /// <unmanaged>MF_MEDIAENGINE_KEYERR_HARDWARECHANGE</unmanaged>
        /// <unmanaged-short>MF_MEDIAENGINE_KEYERR_HARDWARECHANGE</unmanaged-short>
        EngineKeyerrHardwarechange = unchecked ((System.Int32)(5)),
        /// <summary>
        /// <dd> <p>An error with the domain occurred.</p> </dd>
        /// </summary>
        /// <doc-id>dn302188</doc-id>
        /// <unmanaged>MF_MEDIAENGINE_KEYERR_DOMAIN</unmanaged>
        /// <unmanaged-short>MF_MEDIAENGINE_KEYERR_DOMAIN</unmanaged-short>
        EngineKeyerrDomain = unchecked ((System.Int32)(6))}

    /// <summary>
    /// <p>Defines network status codes for the Media Engine.</p>
    /// </summary>
    /// <doc-id>hh162846</doc-id>
    /// <unmanaged>MF_MEDIA_ENGINE_NETWORK</unmanaged>
    /// <unmanaged-short>MF_MEDIA_ENGINE_NETWORK</unmanaged-short>
    public enum MediaEngineNetwork : System.Int32
    {
        /// <summary>
        /// <dd> <p>The initial state.</p> </dd>
        /// </summary>
        /// <doc-id>hh162846</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_NETWORK_EMPTY</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_NETWORK_EMPTY</unmanaged-short>
        Empty = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>The Media Engine has started the resource selection algorithm, and has selected a media resource, but is not using the network.</p> </dd>
        /// </summary>
        /// <doc-id>hh162846</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_NETWORK_IDLE</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_NETWORK_IDLE</unmanaged-short>
        Idle = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>The Media Engine is loading a media resource.</p> </dd>
        /// </summary>
        /// <doc-id>hh162846</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_NETWORK_LOADING</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_NETWORK_LOADING</unmanaged-short>
        Loading = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>The Media Engine has started the resource selection algorithm, but has not selected a media resource.</p> </dd>
        /// </summary>
        /// <doc-id>hh162846</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_NETWORK_NO_SOURCE</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_NETWORK_NO_SOURCE</unmanaged-short>
        NoSource = unchecked ((System.Int32)(3))}

    /// <summary>
    /// <p>Defines the status of the Output Protection Manager (OPM).</p>
    /// </summary>
    /// <doc-id>dn302190</doc-id>
    /// <unmanaged>MF_MEDIA_ENGINE_OPM_STATUS</unmanaged>
    /// <unmanaged-short>MF_MEDIA_ENGINE_OPM_STATUS</unmanaged-short>
    public enum MediaEngineOpmStatus : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn302190</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_OPM_NOT_REQUESTED</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_OPM_NOT_REQUESTED</unmanaged-short>
        NotRequested = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn302190</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_OPM_ESTABLISHED</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_OPM_ESTABLISHED</unmanaged-short>
        Established = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn302190</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_OPM_FAILED_VM</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_OPM_FAILED_VM</unmanaged-short>
        FailedVm = unchecked ((System.Int32)(2)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn302190</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_OPM_FAILED_BDA</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_OPM_FAILED_BDA</unmanaged-short>
        FailedBda = unchecked ((System.Int32)(3)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn302190</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_OPM_FAILED_UNSIGNED_DRIVER</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_OPM_FAILED_UNSIGNED_DRIVER</unmanaged-short>
        FailedUnsignedDriver = unchecked ((System.Int32)(4)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn302190</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_OPM_FAILED</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_OPM_FAILED</unmanaged-short>
        Failed = unchecked ((System.Int32)(5))}

    /// <summary>
    /// <p>Defines preload hints for the Media Engine. These values correspond to the <strong>preload</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>
    /// </summary>
    /// <doc-id>hh162851</doc-id>
    /// <unmanaged>MF_MEDIA_ENGINE_PRELOAD</unmanaged>
    /// <unmanaged-short>MF_MEDIA_ENGINE_PRELOAD</unmanaged-short>
    public enum MediaEnginePreload : System.Int32
    {
        /// <summary>
        /// <dd> <p>The <strong>preload</strong> attribute is missing. </p> </dd>
        /// </summary>
        /// <doc-id>hh162851</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_PRELOAD_MISSING</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_PRELOAD_MISSING</unmanaged-short>
        Missing = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>The <strong>preload</strong> attribute is an empty string. This value is equivalent to <strong>MF_MEDIA_ENGINE_PRELOAD_AUTOMATIC</strong>.</p> </dd>
        /// </summary>
        /// <doc-id>hh162851</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_PRELOAD_EMPTY</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_PRELOAD_EMPTY</unmanaged-short>
        Empty = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>The <strong>preload</strong> attribute is "none". This value is a hint to the user agent not to preload the resource.</p> </dd>
        /// </summary>
        /// <doc-id>hh162851</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_PRELOAD_NONE</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_PRELOAD_NONE</unmanaged-short>
        None = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>The <strong>preload</strong> attribute is "metadata". This value is a hint to the user agent to fetch the resource metadata.</p> </dd>
        /// </summary>
        /// <doc-id>hh162851</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_PRELOAD_METADATA</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_PRELOAD_METADATA</unmanaged-short>
        Metadata = unchecked ((System.Int32)(3)),
        /// <summary>
        /// <dd> <p>The <strong>preload</strong> attribute is "auto". This value is a hint to the user agent to preload the entire resource.</p> </dd>
        /// </summary>
        /// <doc-id>hh162851</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_PRELOAD_AUTOMATIC</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_PRELOAD_AUTOMATIC</unmanaged-short>
        Automatic = unchecked ((System.Int32)(4))}

    [System.FlagsAttribute]
    /// <summary>
    /// <p>Contains flags that specify whether the Media Engine will play protected content, and whether the Media Engine will use the Protected Media Path (PMP).</p>
    /// </summary>
    /// <remarks>
    /// <p>These flags are used with the <see cref = "ContentProtectionFlags"/> attribute.</p>
    /// </remarks>
    /// <doc-id>hh162852</doc-id>
    /// <unmanaged>MF_MEDIA_ENGINE_PROTECTION_FLAGS</unmanaged>
    /// <unmanaged-short>MF_MEDIA_ENGINE_PROTECTION_FLAGS</unmanaged-short>
    public enum MediaEngineProtectionFlags : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh162852</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_ENABLE_PROTECTED_CONTENT</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_ENABLE_PROTECTED_CONTENT</unmanaged-short>
        EnableProtectedContent = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh162852</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_USE_PMP_FOR_ALL_CONTENT</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_USE_PMP_FOR_ALL_CONTENT</unmanaged-short>
        UsePmpForAllContent = unchecked ((System.Int32)(2)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh162852</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_USE_UNPROTECTED_PMP</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_USE_UNPROTECTED_PMP</unmanaged-short>
        UseUnprotectedPmp = unchecked ((System.Int32)(4)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    /// <summary>
    /// <p>Defines ready-state values for the Media Engine.</p>
    /// </summary>
    /// <remarks>
    /// <p>These values correspond to constants defined for the  <strong>HTMLMediaElement.readyState</strong> attribute  in HTML5.</p>
    /// </remarks>
    /// <doc-id>hh162853</doc-id>
    /// <unmanaged>MF_MEDIA_ENGINE_READY</unmanaged>
    /// <unmanaged-short>MF_MEDIA_ENGINE_READY</unmanaged-short>
    public enum MediaEngineReady : System.Int32
    {
        /// <summary>
        /// <dd> <p>No data is available.</p> </dd>
        /// </summary>
        /// <doc-id>hh162853</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_READY_HAVE_NOTHING</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_READY_HAVE_NOTHING</unmanaged-short>
        HaveNothing = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>Some metadata is available, including the duration and, for video files, the video dimensions. No media data is available.</p> </dd>
        /// </summary>
        /// <doc-id>hh162853</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_READY_HAVE_METADATA</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_READY_HAVE_METADATA</unmanaged-short>
        HaveMetadata = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>There is media data  for the current playback position, but not enough data for playback or seeking.</p> </dd>
        /// </summary>
        /// <doc-id>hh162853</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_READY_HAVE_CURRENT_DATA</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_READY_HAVE_CURRENT_DATA</unmanaged-short>
        HaveCurrentData = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>There is enough media data to enable some playback or seeking. The amount of data might be a little as the next video frame.</p> </dd>
        /// </summary>
        /// <doc-id>hh162853</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_READY_HAVE_FUTURE_DATA</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_READY_HAVE_FUTURE_DATA</unmanaged-short>
        HaveFutureData = unchecked ((System.Int32)(3)),
        /// <summary>
        /// <dd> <p>There is enough data to play the resource, based on the current rate at which the resource is being fetched. </p> </dd>
        /// </summary>
        /// <doc-id>hh162853</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_READY_HAVE_ENOUGH_DATA</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_READY_HAVE_ENOUGH_DATA</unmanaged-short>
        HaveEnoughData = unchecked ((System.Int32)(4))}

    /// <summary>
    /// <p>Specifies the layout for a packed 3D video frame.</p>
    /// </summary>
    /// <doc-id>hh162854</doc-id>
    /// <unmanaged>MF_MEDIA_ENGINE_S3D_PACKING_MODE</unmanaged>
    /// <unmanaged-short>MF_MEDIA_ENGINE_S3D_PACKING_MODE</unmanaged-short>
    public enum MediaEngineS3DPackingMode : System.Int32
    {
        /// <summary>
        /// <dd> <p>None.</p> </dd>
        /// </summary>
        /// <doc-id>hh162854</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_S3D_PACKING_MODE_NONE</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_S3D_PACKING_MODE_NONE</unmanaged-short>
        None = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>The views are packed side-by-side in a single frame.</p> </dd>
        /// </summary>
        /// <doc-id>hh162854</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_S3D_PACKING_MODE_SIDE_BY_SIDE</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_S3D_PACKING_MODE_SIDE_BY_SIDE</unmanaged-short>
        SideBySide = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>The views are packed top-to-bottom in a single frame.</p> </dd>
        /// </summary>
        /// <doc-id>hh162854</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_S3D_PACKING_MODE_TOP_BOTTOM</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_S3D_PACKING_MODE_TOP_BOTTOM</unmanaged-short>
        TopBottom = unchecked ((System.Int32)(2))}

    /// <summary>
    /// <p>Defines values for the media engine seek mode.</p>
    /// </summary>
    /// <remarks>
    /// <p>This enumeration is used with the <strong>MediaEngineEx::SetCurrentTimeEx</strong>.</p>
    /// </remarks>
    /// <doc-id>jj128345</doc-id>
    /// <unmanaged>MF_MEDIA_ENGINE_SEEK_MODE</unmanaged>
    /// <unmanaged-short>MF_MEDIA_ENGINE_SEEK_MODE</unmanaged-short>
    public enum MediaEngineSeekMode : System.Int32
    {
        /// <summary>
        /// <dd> <p>Specifies normal seek.</p> </dd>
        /// </summary>
        /// <doc-id>jj128345</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_SEEK_MODE_NORMAL</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_SEEK_MODE_NORMAL</unmanaged-short>
        Normal = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>Specifies an approximate seek. </p> </dd>
        /// </summary>
        /// <doc-id>jj128345</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_SEEK_MODE_APPROXIMATE</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_SEEK_MODE_APPROXIMATE</unmanaged-short>
        Approximate = unchecked ((System.Int32)(1))}

    /// <summary>
    /// <p>Identifies statistics that the Media Engine tracks during playback. To get a playback statistic from the Media Engine, call <strong>IMFMediaEngineEx::GetStatistics</strong>.</p><p>In the descriptions that follow, the data type and value-type tag for the <strong><see cref = "SharpDX.Win32.Variant"/></strong> are listed in parentheses.</p>
    /// </summary>
    /// <doc-id>hh162855</doc-id>
    /// <unmanaged>MF_MEDIA_ENGINE_STATISTIC</unmanaged>
    /// <unmanaged-short>MF_MEDIA_ENGINE_STATISTIC</unmanaged-short>
    public enum MediaEngineStatistic : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh162855</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_STATISTIC_FRAMES_RENDERED</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_STATISTIC_FRAMES_RENDERED</unmanaged-short>
        FramesRendered = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh162855</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_STATISTIC_FRAMES_DROPPED</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_STATISTIC_FRAMES_DROPPED</unmanaged-short>
        FramesDropped = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh162855</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_STATISTIC_BYTES_DOWNLOADED</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_STATISTIC_BYTES_DOWNLOADED</unmanaged-short>
        BytesDownloaded = unchecked ((System.Int32)(2)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh162855</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_STATISTIC_BUFFER_PROGRESS</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_STATISTIC_BUFFER_PROGRESS</unmanaged-short>
        BufferProgress = unchecked ((System.Int32)(3)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh162855</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_STATISTIC_FRAMES_PER_SECOND</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_STATISTIC_FRAMES_PER_SECOND</unmanaged-short>
        FramesPerSecond = unchecked ((System.Int32)(4)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh162855</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_STATISTIC_PLAYBACK_JITTER</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_STATISTIC_PLAYBACK_JITTER</unmanaged-short>
        PlaybackJitter = unchecked ((System.Int32)(5)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh162855</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_STATISTIC_FRAMES_CORRUPTED</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_STATISTIC_FRAMES_CORRUPTED</unmanaged-short>
        FramesCorrupted = unchecked ((System.Int32)(6)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh162855</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_STATISTIC_TOTAL_FRAME_DELAY</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_STATISTIC_TOTAL_FRAME_DELAY</unmanaged-short>
        TotalFrameDelay = unchecked ((System.Int32)(7))}

    /// <summary>
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Identifies the kind of media stream that failed.</p>
    /// </summary>
    /// <doc-id>dn879054</doc-id>
    /// <unmanaged>MF_MEDIA_ENGINE_STREAMTYPE_FAILED</unmanaged>
    /// <unmanaged-short>MF_MEDIA_ENGINE_STREAMTYPE_FAILED</unmanaged-short>
    public enum MediaEngineStreamTypeFailed : System.Int32
    {
        /// <summary>
        /// <dd> <p>The stream type is unknown.</p> </dd>
        /// </summary>
        /// <doc-id>dn879054</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_STREAMTYPE_FAILED_UNKNOWN</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_STREAMTYPE_FAILED_UNKNOWN</unmanaged-short>
        Unknown = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>The stream is an audio stream.</p> </dd>
        /// </summary>
        /// <doc-id>dn879054</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_STREAMTYPE_FAILED_AUDIO</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_STREAMTYPE_FAILED_AUDIO</unmanaged-short>
        Audio = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>The stream is a video stream.</p> </dd>
        /// </summary>
        /// <doc-id>dn879054</doc-id>
        /// <unmanaged>MF_MEDIA_ENGINE_STREAMTYPE_FAILED_VIDEO</unmanaged>
        /// <unmanaged-short>MF_MEDIA_ENGINE_STREAMTYPE_FAILED_VIDEO</unmanaged-short>
        Video = unchecked ((System.Int32)(2))}

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>__MIDL___MIDL_itf_mfobjects_0000_0012_0001</unmanaged>
    /// <unmanaged-short>__MIDL___MIDL_itf_mfobjects_0000_0012_0001</unmanaged-short>
    public enum MediaEventTypes : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEUnknown</unmanaged>
        /// <unmanaged-short>MEUnknown</unmanaged-short>
        Unknown = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEError</unmanaged>
        /// <unmanaged-short>MEError</unmanaged-short>
        Error = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEExtendedType</unmanaged>
        /// <unmanaged-short>MEExtendedType</unmanaged-short>
        ExtendedType = unchecked ((System.Int32)(2)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MENonFatalError</unmanaged>
        /// <unmanaged-short>MENonFatalError</unmanaged-short>
        NonFatalError = unchecked ((System.Int32)(3)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEGenericV1Anchor</unmanaged>
        /// <unmanaged-short>MEGenericV1Anchor</unmanaged-short>
        GenericV1Anchor = unchecked ((System.Int32)(3)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MESessionUnknown</unmanaged>
        /// <unmanaged-short>MESessionUnknown</unmanaged-short>
        SessionUnknown = unchecked ((System.Int32)(100)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MESessionTopologySet</unmanaged>
        /// <unmanaged-short>MESessionTopologySet</unmanaged-short>
        SessionTopologySet = unchecked ((System.Int32)(101)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MESessionTopologiesCleared</unmanaged>
        /// <unmanaged-short>MESessionTopologiesCleared</unmanaged-short>
        SessionTopologiesCleared = unchecked ((System.Int32)(102)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MESessionStarted</unmanaged>
        /// <unmanaged-short>MESessionStarted</unmanaged-short>
        SessionStarted = unchecked ((System.Int32)(103)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MESessionPaused</unmanaged>
        /// <unmanaged-short>MESessionPaused</unmanaged-short>
        SessionPaused = unchecked ((System.Int32)(104)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MESessionStopped</unmanaged>
        /// <unmanaged-short>MESessionStopped</unmanaged-short>
        SessionStopped = unchecked ((System.Int32)(105)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MESessionClosed</unmanaged>
        /// <unmanaged-short>MESessionClosed</unmanaged-short>
        SessionClosed = unchecked ((System.Int32)(106)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MESessionEnded</unmanaged>
        /// <unmanaged-short>MESessionEnded</unmanaged-short>
        SessionEnded = unchecked ((System.Int32)(107)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MESessionRateChanged</unmanaged>
        /// <unmanaged-short>MESessionRateChanged</unmanaged-short>
        SessionRateChanged = unchecked ((System.Int32)(108)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MESessionScrubSampleComplete</unmanaged>
        /// <unmanaged-short>MESessionScrubSampleComplete</unmanaged-short>
        SessionScrubSampleComplete = unchecked ((System.Int32)(109)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MESessionCapabilitiesChanged</unmanaged>
        /// <unmanaged-short>MESessionCapabilitiesChanged</unmanaged-short>
        SessionCapabilitiesChanged = unchecked ((System.Int32)(110)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MESessionTopologyStatus</unmanaged>
        /// <unmanaged-short>MESessionTopologyStatus</unmanaged-short>
        SessionTopologyStatus = unchecked ((System.Int32)(111)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MESessionNotifyPresentationTime</unmanaged>
        /// <unmanaged-short>MESessionNotifyPresentationTime</unmanaged-short>
        SessionNotifyPresentationTime = unchecked ((System.Int32)(112)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MENewPresentation</unmanaged>
        /// <unmanaged-short>MENewPresentation</unmanaged-short>
        NewPresentation = unchecked ((System.Int32)(113)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MELicenseAcquisitionStart</unmanaged>
        /// <unmanaged-short>MELicenseAcquisitionStart</unmanaged-short>
        LicenseAcquisitionStart = unchecked ((System.Int32)(114)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MELicenseAcquisitionCompleted</unmanaged>
        /// <unmanaged-short>MELicenseAcquisitionCompleted</unmanaged-short>
        LicenseAcquisitionCompleted = unchecked ((System.Int32)(115)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEIndividualizationStart</unmanaged>
        /// <unmanaged-short>MEIndividualizationStart</unmanaged-short>
        IndividualizationStart = unchecked ((System.Int32)(116)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEIndividualizationCompleted</unmanaged>
        /// <unmanaged-short>MEIndividualizationCompleted</unmanaged-short>
        IndividualizationCompleted = unchecked ((System.Int32)(117)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEEnablerProgress</unmanaged>
        /// <unmanaged-short>MEEnablerProgress</unmanaged-short>
        EnablerProgress = unchecked ((System.Int32)(118)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEEnablerCompleted</unmanaged>
        /// <unmanaged-short>MEEnablerCompleted</unmanaged-short>
        EnablerCompleted = unchecked ((System.Int32)(119)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEPolicyError</unmanaged>
        /// <unmanaged-short>MEPolicyError</unmanaged-short>
        PolicyError = unchecked ((System.Int32)(120)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEPolicyReport</unmanaged>
        /// <unmanaged-short>MEPolicyReport</unmanaged-short>
        PolicyReport = unchecked ((System.Int32)(121)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEBufferingStarted</unmanaged>
        /// <unmanaged-short>MEBufferingStarted</unmanaged-short>
        BufferingStarted = unchecked ((System.Int32)(122)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEBufferingStopped</unmanaged>
        /// <unmanaged-short>MEBufferingStopped</unmanaged-short>
        BufferingStopped = unchecked ((System.Int32)(123)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEConnectStart</unmanaged>
        /// <unmanaged-short>MEConnectStart</unmanaged-short>
        ConnectStart = unchecked ((System.Int32)(124)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEConnectEnd</unmanaged>
        /// <unmanaged-short>MEConnectEnd</unmanaged-short>
        ConnectEnd = unchecked ((System.Int32)(125)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEReconnectStart</unmanaged>
        /// <unmanaged-short>MEReconnectStart</unmanaged-short>
        ReconnectStart = unchecked ((System.Int32)(126)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEReconnectEnd</unmanaged>
        /// <unmanaged-short>MEReconnectEnd</unmanaged-short>
        ReconnectEnd = unchecked ((System.Int32)(127)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MERendererEvent</unmanaged>
        /// <unmanaged-short>MERendererEvent</unmanaged-short>
        RendererEvent = unchecked ((System.Int32)(128)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MESessionStreamSinkFormatChanged</unmanaged>
        /// <unmanaged-short>MESessionStreamSinkFormatChanged</unmanaged-short>
        SessionStreamSinkFormatChanged = unchecked ((System.Int32)(129)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MESessionV1Anchor</unmanaged>
        /// <unmanaged-short>MESessionV1Anchor</unmanaged-short>
        SessionV1Anchor = unchecked ((System.Int32)(129)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MESourceUnknown</unmanaged>
        /// <unmanaged-short>MESourceUnknown</unmanaged-short>
        SourceUnknown = unchecked ((System.Int32)(200)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MESourceStarted</unmanaged>
        /// <unmanaged-short>MESourceStarted</unmanaged-short>
        SourceStarted = unchecked ((System.Int32)(201)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEStreamStarted</unmanaged>
        /// <unmanaged-short>MEStreamStarted</unmanaged-short>
        StreamStarted = unchecked ((System.Int32)(202)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MESourceSeeked</unmanaged>
        /// <unmanaged-short>MESourceSeeked</unmanaged-short>
        SourceSeeked = unchecked ((System.Int32)(203)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEStreamSeeked</unmanaged>
        /// <unmanaged-short>MEStreamSeeked</unmanaged-short>
        StreamSeeked = unchecked ((System.Int32)(204)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MENewStream</unmanaged>
        /// <unmanaged-short>MENewStream</unmanaged-short>
        NewStream = unchecked ((System.Int32)(205)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEUpdatedStream</unmanaged>
        /// <unmanaged-short>MEUpdatedStream</unmanaged-short>
        UpdatedStream = unchecked ((System.Int32)(206)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MESourceStopped</unmanaged>
        /// <unmanaged-short>MESourceStopped</unmanaged-short>
        SourceStopped = unchecked ((System.Int32)(207)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEStreamStopped</unmanaged>
        /// <unmanaged-short>MEStreamStopped</unmanaged-short>
        StreamStopped = unchecked ((System.Int32)(208)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MESourcePaused</unmanaged>
        /// <unmanaged-short>MESourcePaused</unmanaged-short>
        SourcePaused = unchecked ((System.Int32)(209)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEStreamPaused</unmanaged>
        /// <unmanaged-short>MEStreamPaused</unmanaged-short>
        StreamPaused = unchecked ((System.Int32)(210)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEEndOfPresentation</unmanaged>
        /// <unmanaged-short>MEEndOfPresentation</unmanaged-short>
        EndOfPresentation = unchecked ((System.Int32)(211)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEEndOfStream</unmanaged>
        /// <unmanaged-short>MEEndOfStream</unmanaged-short>
        EndOfStream = unchecked ((System.Int32)(212)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEMediaSample</unmanaged>
        /// <unmanaged-short>MEMediaSample</unmanaged-short>
        MediaSample = unchecked ((System.Int32)(213)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEStreamTick</unmanaged>
        /// <unmanaged-short>MEStreamTick</unmanaged-short>
        StreamTick = unchecked ((System.Int32)(214)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEStreamThinMode</unmanaged>
        /// <unmanaged-short>MEStreamThinMode</unmanaged-short>
        StreamThinMode = unchecked ((System.Int32)(215)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEStreamFormatChanged</unmanaged>
        /// <unmanaged-short>MEStreamFormatChanged</unmanaged-short>
        StreamFormatChanged = unchecked ((System.Int32)(216)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MESourceRateChanged</unmanaged>
        /// <unmanaged-short>MESourceRateChanged</unmanaged-short>
        SourceRateChanged = unchecked ((System.Int32)(217)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEEndOfPresentationSegment</unmanaged>
        /// <unmanaged-short>MEEndOfPresentationSegment</unmanaged-short>
        EndOfPresentationSegment = unchecked ((System.Int32)(218)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MESourceCharacteristicsChanged</unmanaged>
        /// <unmanaged-short>MESourceCharacteristicsChanged</unmanaged-short>
        SourceCharacteristicsChanged = unchecked ((System.Int32)(219)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MESourceRateChangeRequested</unmanaged>
        /// <unmanaged-short>MESourceRateChangeRequested</unmanaged-short>
        SourceRateChangeRequested = unchecked ((System.Int32)(220)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MESourceMetadataChanged</unmanaged>
        /// <unmanaged-short>MESourceMetadataChanged</unmanaged-short>
        SourceMetadataChanged = unchecked ((System.Int32)(221)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MESequencerSourceTopologyUpdated</unmanaged>
        /// <unmanaged-short>MESequencerSourceTopologyUpdated</unmanaged-short>
        SequencerSourceTopologyUpdated = unchecked ((System.Int32)(222)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MESourceV1Anchor</unmanaged>
        /// <unmanaged-short>MESourceV1Anchor</unmanaged-short>
        SourceV1Anchor = unchecked ((System.Int32)(222)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MESinkUnknown</unmanaged>
        /// <unmanaged-short>MESinkUnknown</unmanaged-short>
        SinkUnknown = unchecked ((System.Int32)(300)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEStreamSinkStarted</unmanaged>
        /// <unmanaged-short>MEStreamSinkStarted</unmanaged-short>
        StreamSinkStarted = unchecked ((System.Int32)(301)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEStreamSinkStopped</unmanaged>
        /// <unmanaged-short>MEStreamSinkStopped</unmanaged-short>
        StreamSinkStopped = unchecked ((System.Int32)(302)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEStreamSinkPaused</unmanaged>
        /// <unmanaged-short>MEStreamSinkPaused</unmanaged-short>
        StreamSinkPaused = unchecked ((System.Int32)(303)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEStreamSinkRateChanged</unmanaged>
        /// <unmanaged-short>MEStreamSinkRateChanged</unmanaged-short>
        StreamSinkRateChanged = unchecked ((System.Int32)(304)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEStreamSinkRequestSample</unmanaged>
        /// <unmanaged-short>MEStreamSinkRequestSample</unmanaged-short>
        StreamSinkRequestSample = unchecked ((System.Int32)(305)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEStreamSinkMarker</unmanaged>
        /// <unmanaged-short>MEStreamSinkMarker</unmanaged-short>
        StreamSinkMarker = unchecked ((System.Int32)(306)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEStreamSinkPrerolled</unmanaged>
        /// <unmanaged-short>MEStreamSinkPrerolled</unmanaged-short>
        StreamSinkPrerolled = unchecked ((System.Int32)(307)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEStreamSinkScrubSampleComplete</unmanaged>
        /// <unmanaged-short>MEStreamSinkScrubSampleComplete</unmanaged-short>
        StreamSinkScrubSampleComplete = unchecked ((System.Int32)(308)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEStreamSinkFormatChanged</unmanaged>
        /// <unmanaged-short>MEStreamSinkFormatChanged</unmanaged-short>
        StreamSinkFormatChanged = unchecked ((System.Int32)(309)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEStreamSinkDeviceChanged</unmanaged>
        /// <unmanaged-short>MEStreamSinkDeviceChanged</unmanaged-short>
        StreamSinkDeviceChanged = unchecked ((System.Int32)(310)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEQualityNotify</unmanaged>
        /// <unmanaged-short>MEQualityNotify</unmanaged-short>
        QualityNotify = unchecked ((System.Int32)(311)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MESinkInvalidated</unmanaged>
        /// <unmanaged-short>MESinkInvalidated</unmanaged-short>
        SinkInvalidated = unchecked ((System.Int32)(312)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEAudioSessionNameChanged</unmanaged>
        /// <unmanaged-short>MEAudioSessionNameChanged</unmanaged-short>
        AudioSessionNameChanged = unchecked ((System.Int32)(313)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEAudioSessionVolumeChanged</unmanaged>
        /// <unmanaged-short>MEAudioSessionVolumeChanged</unmanaged-short>
        AudioSessionVolumeChanged = unchecked ((System.Int32)(314)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEAudioSessionDeviceRemoved</unmanaged>
        /// <unmanaged-short>MEAudioSessionDeviceRemoved</unmanaged-short>
        AudioSessionDeviceRemoved = unchecked ((System.Int32)(315)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEAudioSessionServerShutdown</unmanaged>
        /// <unmanaged-short>MEAudioSessionServerShutdown</unmanaged-short>
        AudioSessionServerShutdown = unchecked ((System.Int32)(316)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEAudioSessionGroupingParamChanged</unmanaged>
        /// <unmanaged-short>MEAudioSessionGroupingParamChanged</unmanaged-short>
        AudioSessionGroupingParamChanged = unchecked ((System.Int32)(317)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEAudioSessionIconChanged</unmanaged>
        /// <unmanaged-short>MEAudioSessionIconChanged</unmanaged-short>
        AudioSessionIconChanged = unchecked ((System.Int32)(318)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEAudioSessionFormatChanged</unmanaged>
        /// <unmanaged-short>MEAudioSessionFormatChanged</unmanaged-short>
        AudioSessionFormatChanged = unchecked ((System.Int32)(319)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEAudioSessionDisconnected</unmanaged>
        /// <unmanaged-short>MEAudioSessionDisconnected</unmanaged-short>
        AudioSessionDisconnected = unchecked ((System.Int32)(320)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEAudioSessionExclusiveModeOverride</unmanaged>
        /// <unmanaged-short>MEAudioSessionExclusiveModeOverride</unmanaged-short>
        AudioSessionExclusiveModeOverride = unchecked ((System.Int32)(321)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MESinkV1Anchor</unmanaged>
        /// <unmanaged-short>MESinkV1Anchor</unmanaged-short>
        SinkV1Anchor = unchecked ((System.Int32)(321)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MECaptureAudioSessionVolumeChanged</unmanaged>
        /// <unmanaged-short>MECaptureAudioSessionVolumeChanged</unmanaged-short>
        CaptureAudioSessionVolumeChanged = unchecked ((System.Int32)(322)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MECaptureAudioSessionDeviceRemoved</unmanaged>
        /// <unmanaged-short>MECaptureAudioSessionDeviceRemoved</unmanaged-short>
        CaptureAudioSessionDeviceRemoved = unchecked ((System.Int32)(323)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MECaptureAudioSessionFormatChanged</unmanaged>
        /// <unmanaged-short>MECaptureAudioSessionFormatChanged</unmanaged-short>
        CaptureAudioSessionFormatChanged = unchecked ((System.Int32)(324)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MECaptureAudioSessionDisconnected</unmanaged>
        /// <unmanaged-short>MECaptureAudioSessionDisconnected</unmanaged-short>
        CaptureAudioSessionDisconnected = unchecked ((System.Int32)(325)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MECaptureAudioSessionExclusiveModeOverride</unmanaged>
        /// <unmanaged-short>MECaptureAudioSessionExclusiveModeOverride</unmanaged-short>
        CaptureAudioSessionExclusiveModeOverride = unchecked ((System.Int32)(326)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MECaptureAudioSessionServerShutdown</unmanaged>
        /// <unmanaged-short>MECaptureAudioSessionServerShutdown</unmanaged-short>
        CaptureAudioSessionServerShutdown = unchecked ((System.Int32)(327)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MESinkV2Anchor</unmanaged>
        /// <unmanaged-short>MESinkV2Anchor</unmanaged-short>
        SinkV2Anchor = unchecked ((System.Int32)(327)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>METrustUnknown</unmanaged>
        /// <unmanaged-short>METrustUnknown</unmanaged-short>
        TrustUnknown = unchecked ((System.Int32)(400)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEPolicyChanged</unmanaged>
        /// <unmanaged-short>MEPolicyChanged</unmanaged-short>
        PolicyChanged = unchecked ((System.Int32)(401)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEContentProtectionMessage</unmanaged>
        /// <unmanaged-short>MEContentProtectionMessage</unmanaged-short>
        ContentProtectionMessage = unchecked ((System.Int32)(402)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEPolicySet</unmanaged>
        /// <unmanaged-short>MEPolicySet</unmanaged-short>
        PolicySet = unchecked ((System.Int32)(403)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>METrustV1Anchor</unmanaged>
        /// <unmanaged-short>METrustV1Anchor</unmanaged-short>
        TrustV1Anchor = unchecked ((System.Int32)(403)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEWMDRMLicenseBackupCompleted</unmanaged>
        /// <unmanaged-short>MEWMDRMLicenseBackupCompleted</unmanaged-short>
        WindowsMediaDRMLicenseBackupCompleted = unchecked ((System.Int32)(500)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEWMDRMLicenseBackupProgress</unmanaged>
        /// <unmanaged-short>MEWMDRMLicenseBackupProgress</unmanaged-short>
        WindowsMediaDRMLicenseBackupProgress = unchecked ((System.Int32)(501)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEWMDRMLicenseRestoreCompleted</unmanaged>
        /// <unmanaged-short>MEWMDRMLicenseRestoreCompleted</unmanaged-short>
        WindowsMediaDRMLicenseRestoreCompleted = unchecked ((System.Int32)(502)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEWMDRMLicenseRestoreProgress</unmanaged>
        /// <unmanaged-short>MEWMDRMLicenseRestoreProgress</unmanaged-short>
        WindowsMediaDRMLicenseRestoreProgress = unchecked ((System.Int32)(503)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEWMDRMLicenseAcquisitionCompleted</unmanaged>
        /// <unmanaged-short>MEWMDRMLicenseAcquisitionCompleted</unmanaged-short>
        WindowsMediaDRMLicenseAcquisitionCompleted = unchecked ((System.Int32)(506)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEWMDRMIndividualizationCompleted</unmanaged>
        /// <unmanaged-short>MEWMDRMIndividualizationCompleted</unmanaged-short>
        WindowsMediaDRMIndividualizationCompleted = unchecked ((System.Int32)(508)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEWMDRMIndividualizationProgress</unmanaged>
        /// <unmanaged-short>MEWMDRMIndividualizationProgress</unmanaged-short>
        WindowsMediaDRMIndividualizationProgress = unchecked ((System.Int32)(513)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEWMDRMProximityCompleted</unmanaged>
        /// <unmanaged-short>MEWMDRMProximityCompleted</unmanaged-short>
        WindowsMediaDRMProximityCompleted = unchecked ((System.Int32)(514)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEWMDRMLicenseStoreCleaned</unmanaged>
        /// <unmanaged-short>MEWMDRMLicenseStoreCleaned</unmanaged-short>
        WindowsMediaDRMLicenseStoreCleaned = unchecked ((System.Int32)(515)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEWMDRMRevocationDownloadCompleted</unmanaged>
        /// <unmanaged-short>MEWMDRMRevocationDownloadCompleted</unmanaged-short>
        WindowsMediaDRMRevocationDownloadCompleted = unchecked ((System.Int32)(516)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEWMDRMV1Anchor</unmanaged>
        /// <unmanaged-short>MEWMDRMV1Anchor</unmanaged-short>
        WindowsMediaDRMV1Anchor = unchecked ((System.Int32)(516)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>METransformUnknown</unmanaged>
        /// <unmanaged-short>METransformUnknown</unmanaged-short>
        TransformUnknown = unchecked ((System.Int32)(600)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>METransformNeedInput</unmanaged>
        /// <unmanaged-short>METransformNeedInput</unmanaged-short>
        TransformNeedInput = unchecked ((System.Int32)(601)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>METransformHaveOutput</unmanaged>
        /// <unmanaged-short>METransformHaveOutput</unmanaged-short>
        TransformHaveOutput = unchecked ((System.Int32)(602)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>METransformDrainComplete</unmanaged>
        /// <unmanaged-short>METransformDrainComplete</unmanaged-short>
        TransformDrainComplete = unchecked ((System.Int32)(603)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>METransformMarker</unmanaged>
        /// <unmanaged-short>METransformMarker</unmanaged-short>
        TransformMarker = unchecked ((System.Int32)(604)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>METransformInputStreamStateChanged</unmanaged>
        /// <unmanaged-short>METransformInputStreamStateChanged</unmanaged-short>
        TransformInputStreamStateChanged = unchecked ((System.Int32)(605)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEByteStreamCharacteristicsChanged</unmanaged>
        /// <unmanaged-short>MEByteStreamCharacteristicsChanged</unmanaged-short>
        ByteStreamCharacteristicsChanged = unchecked ((System.Int32)(700)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEVideoCaptureDeviceRemoved</unmanaged>
        /// <unmanaged-short>MEVideoCaptureDeviceRemoved</unmanaged-short>
        VideoCaptureDeviceRemoved = unchecked ((System.Int32)(800)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEVideoCaptureDevicePreempted</unmanaged>
        /// <unmanaged-short>MEVideoCaptureDevicePreempted</unmanaged-short>
        VideoCaptureDevicePreempted = unchecked ((System.Int32)(801)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEStreamSinkFormatInvalidated</unmanaged>
        /// <unmanaged-short>MEStreamSinkFormatInvalidated</unmanaged-short>
        StreamSinkFormatInvalidated = unchecked ((System.Int32)(802)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEEncodingParameters</unmanaged>
        /// <unmanaged-short>MEEncodingParameters</unmanaged-short>
        EncodingParameters = unchecked ((System.Int32)(803)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEContentProtectionMetadata</unmanaged>
        /// <unmanaged-short>MEContentProtectionMetadata</unmanaged-short>
        ContentProtectionMetadata = unchecked ((System.Int32)(900)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEDeviceThermalStateChanged</unmanaged>
        /// <unmanaged-short>MEDeviceThermalStateChanged</unmanaged-short>
        DeviceThermalStateChanged = unchecked ((System.Int32)(950)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MEReservedMax</unmanaged>
        /// <unmanaged-short>MEReservedMax</unmanaged-short>
        ReservedMax = unchecked ((System.Int32)(10000))}

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>MF_MEDIAKEYSESSION_MESSAGETYPE</unmanaged>
    /// <unmanaged-short>MF_MEDIAKEYSESSION_MESSAGETYPE</unmanaged-short>
    public enum MediaKeysessionMessagetype : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_MEDIAKEYSESSION_MESSAGETYPE_LICENSE_REQUEST</unmanaged>
        /// <unmanaged-short>MF_MEDIAKEYSESSION_MESSAGETYPE_LICENSE_REQUEST</unmanaged-short>
        LicenseRequest = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_MEDIAKEYSESSION_MESSAGETYPE_LICENSE_RENEWAL</unmanaged>
        /// <unmanaged-short>MF_MEDIAKEYSESSION_MESSAGETYPE_LICENSE_RENEWAL</unmanaged-short>
        LicenseRenewal = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_MEDIAKEYSESSION_MESSAGETYPE_LICENSE_RELEASE</unmanaged>
        /// <unmanaged-short>MF_MEDIAKEYSESSION_MESSAGETYPE_LICENSE_RELEASE</unmanaged-short>
        LicenseRelease = unchecked ((System.Int32)(2)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_MEDIAKEYSESSION_MESSAGETYPE_INDIVIDUALIZATION_REQUEST</unmanaged>
        /// <unmanaged-short>MF_MEDIAKEYSESSION_MESSAGETYPE_INDIVIDUALIZATION_REQUEST</unmanaged-short>
        IndividualizationRequest = unchecked ((System.Int32)(3))}

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>MF_MEDIAKEYSESSION_TYPE</unmanaged>
    /// <unmanaged-short>MF_MEDIAKEYSESSION_TYPE</unmanaged-short>
    public enum MediaKeysessionType : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_MEDIAKEYSESSION_TYPE_TEMPORARY</unmanaged>
        /// <unmanaged-short>MF_MEDIAKEYSESSION_TYPE_TEMPORARY</unmanaged-short>
        Temporary = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_MEDIAKEYSESSION_TYPE_PERSISTENT_LICENSE</unmanaged>
        /// <unmanaged-short>MF_MEDIAKEYSESSION_TYPE_PERSISTENT_LICENSE</unmanaged-short>
        PersistentLicense = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_MEDIAKEYSESSION_TYPE_PERSISTENT_RELEASE_MESSAGE</unmanaged>
        /// <unmanaged-short>MF_MEDIAKEYSESSION_TYPE_PERSISTENT_RELEASE_MESSAGE</unmanaged-short>
        PersistentReleaseMessage = unchecked ((System.Int32)(2)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_MEDIAKEYSESSION_TYPE_PERSISTENT_USAGE_RECORD</unmanaged>
        /// <unmanaged-short>MF_MEDIAKEYSESSION_TYPE_PERSISTENT_USAGE_RECORD</unmanaged-short>
        PersistentUsageRecord = unchecked ((System.Int32)(3))}

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>MF_MEDIAKEYS_REQUIREMENT</unmanaged>
    /// <unmanaged-short>MF_MEDIAKEYS_REQUIREMENT</unmanaged-short>
    public enum MediaKeysRequirement : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_MEDIAKEYS_REQUIREMENT_REQUIRED</unmanaged>
        /// <unmanaged-short>MF_MEDIAKEYS_REQUIREMENT_REQUIRED</unmanaged-short>
        Required = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_MEDIAKEYS_REQUIREMENT_OPTIONAL</unmanaged>
        /// <unmanaged-short>MF_MEDIAKEYS_REQUIREMENT_OPTIONAL</unmanaged-short>
        Optional = unchecked ((System.Int32)(2)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_MEDIAKEYS_REQUIREMENT_NOT_ALLOWED</unmanaged>
        /// <unmanaged-short>MF_MEDIAKEYS_REQUIREMENT_NOT_ALLOWED</unmanaged-short>
        NotAllowEd = unchecked ((System.Int32)(3))}

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>MF_MEDIAKEY_STATUS</unmanaged>
    /// <unmanaged-short>MF_MEDIAKEY_STATUS</unmanaged-short>
    public enum MediaKeyStatusState : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_MEDIAKEY_STATUS_USABLE</unmanaged>
        /// <unmanaged-short>MF_MEDIAKEY_STATUS_USABLE</unmanaged-short>
        Usable = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_MEDIAKEY_STATUS_EXPIRED</unmanaged>
        /// <unmanaged-short>MF_MEDIAKEY_STATUS_EXPIRED</unmanaged-short>
        Expired = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_MEDIAKEY_STATUS_OUTPUT_DOWNSCALED</unmanaged>
        /// <unmanaged-short>MF_MEDIAKEY_STATUS_OUTPUT_DOWNSCALED</unmanaged-short>
        OutputDownscaled = unchecked ((System.Int32)(2)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_MEDIAKEY_STATUS_OUTPUT_NOT_ALLOWED</unmanaged>
        /// <unmanaged-short>MF_MEDIAKEY_STATUS_OUTPUT_NOT_ALLOWED</unmanaged-short>
        OutputNotAllowEd = unchecked ((System.Int32)(3)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_MEDIAKEY_STATUS_STATUS_PENDING</unmanaged>
        /// <unmanaged-short>MF_MEDIAKEY_STATUS_STATUS_PENDING</unmanaged-short>
        StatusPending = unchecked ((System.Int32)(4)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_MEDIAKEY_STATUS_INTERNAL_ERROR</unmanaged>
        /// <unmanaged-short>MF_MEDIAKEY_STATUS_INTERNAL_ERROR</unmanaged-short>
        InternalError = unchecked ((System.Int32)(5)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_MEDIAKEY_STATUS_RELEASED</unmanaged>
        /// <unmanaged-short>MF_MEDIAKEY_STATUS_RELEASED</unmanaged-short>
        Released = unchecked ((System.Int32)(6)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_MEDIAKEY_STATUS_OUTPUT_RESTRICTED</unmanaged>
        /// <unmanaged-short>MF_MEDIAKEY_STATUS_OUTPUT_RESTRICTED</unmanaged-short>
        OutputRestricted = unchecked ((System.Int32)(7))}

    /// <summary>
    /// <p>Defines the characteristics of a media source. These flags are retrieved by the <strong>IMFMediaSource::GetCharacteristics</strong> method.</p>
    /// </summary>
    /// <remarks>
    /// <p>To skip forward or backward in a playlist, call <strong>IMFMediaSource::Start</strong> or <strong>IMFMediaSession::Start</strong> with the <strong>MF_TIME_FORMAT_ENTRY_RELATIVE</strong> time-format <see cref = "System.Guid"/>. This capability applies only when the <strong>MFMEDIASOURCE_HAS_MULTIPLE_PRESENTATIONS</strong> flag is present.</p>
    /// </remarks>
    /// <doc-id>ms694277</doc-id>
    /// <unmanaged>MFMEDIASOURCE_CHARACTERISTICS</unmanaged>
    /// <unmanaged-short>MFMEDIASOURCE_CHARACTERISTICS</unmanaged-short>
    public enum MediaSourceCharacteristics : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms694277</doc-id>
        /// <unmanaged>MFMEDIASOURCE_IS_LIVE</unmanaged>
        /// <unmanaged-short>MFMEDIASOURCE_IS_LIVE</unmanaged-short>
        IsLive = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms694277</doc-id>
        /// <unmanaged>MFMEDIASOURCE_CAN_SEEK</unmanaged>
        /// <unmanaged-short>MFMEDIASOURCE_CAN_SEEK</unmanaged-short>
        CanSeek = unchecked ((System.Int32)(2)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms694277</doc-id>
        /// <unmanaged>MFMEDIASOURCE_CAN_PAUSE</unmanaged>
        /// <unmanaged-short>MFMEDIASOURCE_CAN_PAUSE</unmanaged-short>
        CanPause = unchecked ((System.Int32)(4)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms694277</doc-id>
        /// <unmanaged>MFMEDIASOURCE_HAS_SLOW_SEEK</unmanaged>
        /// <unmanaged-short>MFMEDIASOURCE_HAS_SLOW_SEEK</unmanaged-short>
        HasSlowSeek = unchecked ((System.Int32)(8)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms694277</doc-id>
        /// <unmanaged>MFMEDIASOURCE_HAS_MULTIPLE_PRESENTATIONS</unmanaged>
        /// <unmanaged-short>MFMEDIASOURCE_HAS_MULTIPLE_PRESENTATIONS</unmanaged-short>
        HasMultiplePresentations = unchecked ((System.Int32)(16)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms694277</doc-id>
        /// <unmanaged>MFMEDIASOURCE_CAN_SKIPFORWARD</unmanaged>
        /// <unmanaged-short>MFMEDIASOURCE_CAN_SKIPFORWARD</unmanaged-short>
        CanSkipforward = unchecked ((System.Int32)(32)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms694277</doc-id>
        /// <unmanaged>MFMEDIASOURCE_CAN_SKIPBACKWARD</unmanaged>
        /// <unmanaged-short>MFMEDIASOURCE_CAN_SKIPBACKWARD</unmanaged-short>
        CanSkipbackward = unchecked ((System.Int32)(64)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms694277</doc-id>
        /// <unmanaged>MFMEDIASOURCE_DOES_NOT_USE_NETWORK</unmanaged>
        /// <unmanaged-short>MFMEDIASOURCE_DOES_NOT_USE_NETWORK</unmanaged-short>
        DoesNotUseNetwork = unchecked ((System.Int32)(128))}

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>MF_MEDIASOURCE_STATUS_INFO</unmanaged>
    /// <unmanaged-short>MF_MEDIASOURCE_STATUS_INFO</unmanaged-short>
    public enum MediaSourceStatusInformation : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_MEDIASOURCE_STATUS_INFO_FULLYSUPPORTED</unmanaged>
        /// <unmanaged-short>MF_MEDIASOURCE_STATUS_INFO_FULLYSUPPORTED</unmanaged-short>
        FullySupported = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_MEDIASOURCE_STATUS_INFO_UNKNOWN</unmanaged>
        /// <unmanaged-short>MF_MEDIASOURCE_STATUS_INFO_UNKNOWN</unmanaged-short>
        Unknown = unchecked ((System.Int32)(1))}

    /// <summary>
    /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Specifies options for the <strong>MFPCreateMediaPlayer</strong> function.</p>
    /// </summary>
    /// <remarks>
    /// <p>The following <strong>typedef</strong> is defined for combining flags from this enumeration.</p><code>typedef UINT32 MFP_CREATION_OPTIONS;</code>
    /// </remarks>
    /// <doc-id>dd757934</doc-id>
    /// <unmanaged>_MFP_CREATION_OPTIONS</unmanaged>
    /// <unmanaged-short>_MFP_CREATION_OPTIONS</unmanaged-short>
    public enum MfpCreationOptions : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd757934</doc-id>
        /// <unmanaged>MFP_OPTION_NONE</unmanaged>
        /// <unmanaged-short>MFP_OPTION_NONE</unmanaged-short>
        MfpOptionNone = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd757934</doc-id>
        /// <unmanaged>MFP_OPTION_FREE_THREADED_CALLBACK</unmanaged>
        /// <unmanaged-short>MFP_OPTION_FREE_THREADED_CALLBACK</unmanaged-short>
        MfpOptionFreeThreadedCallback = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd757934</doc-id>
        /// <unmanaged>MFP_OPTION_NO_MMCSS</unmanaged>
        /// <unmanaged-short>MFP_OPTION_NO_MMCSS</unmanaged-short>
        MfpOptionNoMmcss = unchecked ((System.Int32)(2)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd757934</doc-id>
        /// <unmanaged>MFP_OPTION_NO_REMOTE_DESKTOP_OPTIMIZATION</unmanaged>
        /// <unmanaged-short>MFP_OPTION_NO_REMOTE_DESKTOP_OPTIMIZATION</unmanaged-short>
        MfpOptionNoRemoteDesktopOptimization = unchecked ((System.Int32)(4))}

    [System.FlagsAttribute]
    /// <summary>
    /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Contains flags for the <strong><see cref = "SharpDX.MediaFoundation.PAcquireUserCredentialEvent"/></strong> structure.</p><p>Some of these flags, marked [out], convey information back to the MFPlay player object. The application should set or clear these flags as appropriate, before returning from the <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong> callback method.</p>
    /// </summary>
    /// <doc-id>dd757935</doc-id>
    /// <unmanaged>_MFP_CREDENTIAL_FLAGS</unmanaged>
    /// <unmanaged-short>_MFP_CREDENTIAL_FLAGS</unmanaged-short>
    public enum MfpCredentialFlags : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd757935</doc-id>
        /// <unmanaged>MFP_CREDENTIAL_PROMPT</unmanaged>
        /// <unmanaged-short>MFP_CREDENTIAL_PROMPT</unmanaged-short>
        MfpCredentialPrompt = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd757935</doc-id>
        /// <unmanaged>MFP_CREDENTIAL_SAVE</unmanaged>
        /// <unmanaged-short>MFP_CREDENTIAL_SAVE</unmanaged-short>
        MfpCredentialSave = unchecked ((System.Int32)(2)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd757935</doc-id>
        /// <unmanaged>MFP_CREDENTIAL_DO_NOT_CACHE</unmanaged>
        /// <unmanaged-short>MFP_CREDENTIAL_DO_NOT_CACHE</unmanaged-short>
        MfpCredentialDoNotCache = unchecked ((System.Int32)(4)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd757935</doc-id>
        /// <unmanaged>MFP_CREDENTIAL_CLEAR_TEXT</unmanaged>
        /// <unmanaged-short>MFP_CREDENTIAL_CLEAR_TEXT</unmanaged-short>
        MfpCredentialClearText = unchecked ((System.Int32)(8)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd757935</doc-id>
        /// <unmanaged>MFP_CREDENTIAL_PROXY</unmanaged>
        /// <unmanaged-short>MFP_CREDENTIAL_PROXY</unmanaged-short>
        MfpCredentialProxy = unchecked ((System.Int32)(16)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd757935</doc-id>
        /// <unmanaged>MFP_CREDENTIAL_LOGGED_ON_USER</unmanaged>
        /// <unmanaged-short>MFP_CREDENTIAL_LOGGED_ON_USER</unmanaged-short>
        MfpCredentialLoggedOnUser = unchecked ((System.Int32)(32)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    /// <summary>
    /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Contains flags that describe a media item.</p>
    /// </summary>
    /// <remarks>
    /// <p>The following <strong>typedef</strong> is defined for combining flags from this enumeration.</p><code>typedef UINT32 MFP_MEDIAITEM_CHARACTERISTICS;</code>
    /// </remarks>
    /// <doc-id>dd757936</doc-id>
    /// <unmanaged>_MFP_MEDIAITEM_CHARACTERISTICS</unmanaged>
    /// <unmanaged-short>_MFP_MEDIAITEM_CHARACTERISTICS</unmanaged-short>
    public enum MfpMediaItemCharacteristics : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd757936</doc-id>
        /// <unmanaged>MFP_MEDIAITEM_IS_LIVE</unmanaged>
        /// <unmanaged-short>MFP_MEDIAITEM_IS_LIVE</unmanaged-short>
        MfpMediaItemIsLive = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd757936</doc-id>
        /// <unmanaged>MFP_MEDIAITEM_CAN_SEEK</unmanaged>
        /// <unmanaged-short>MFP_MEDIAITEM_CAN_SEEK</unmanaged-short>
        MfpMediaItemCanSeek = unchecked ((System.Int32)(2)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd757936</doc-id>
        /// <unmanaged>MFP_MEDIAITEM_CAN_PAUSE</unmanaged>
        /// <unmanaged-short>MFP_MEDIAITEM_CAN_PAUSE</unmanaged-short>
        MfpMediaItemCanPause = unchecked ((System.Int32)(4)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd757936</doc-id>
        /// <unmanaged>MFP_MEDIAITEM_HAS_SLOW_SEEK</unmanaged>
        /// <unmanaged-short>MFP_MEDIAITEM_HAS_SLOW_SEEK</unmanaged-short>
        MfpMediaItemHasSlowSeek = unchecked ((System.Int32)(8))}

    /// <summary>
    /// <p> </p><p>Not supported.</p><strong>Note</strong>??Earlier versions of this documentation described the <strong>_MFT_DRAIN_TYPE</strong> enumeration incorrectly. The enumeration is not supported. For more information, see <strong><see cref = "SharpDX.MediaFoundation.TMessageType"/></strong>.?
    /// </summary>
    /// <doc-id>ms700116</doc-id>
    /// <unmanaged>_MFT_DRAIN_TYPE</unmanaged>
    /// <unmanaged-short>_MFT_DRAIN_TYPE</unmanaged-short>
    public enum MftDrainType : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms700116</doc-id>
        /// <unmanaged>MFT_DRAIN_PRODUCE_TAILS</unmanaged>
        /// <unmanaged-short>MFT_DRAIN_PRODUCE_TAILS</unmanaged-short>
        MftDrainProduceTails = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms700116</doc-id>
        /// <unmanaged>MFT_DRAIN_NO_TAILS</unmanaged>
        /// <unmanaged-short>MFT_DRAIN_NO_TAILS</unmanaged-short>
        MftDrainNoTails = unchecked ((System.Int32)(1))}

    [System.FlagsAttribute]
    /// <summary>
    /// <p> </p><p>Defines flags for the <strong>IMFTransform::ProcessInput</strong> method. Currently no flags are defined.</p>
    /// </summary>
    /// <doc-id>ms694836</doc-id>
    /// <unmanaged>_MFT_INPUT_DATA_BUFFER_FLAGS</unmanaged>
    /// <unmanaged-short>_MFT_INPUT_DATA_BUFFER_FLAGS</unmanaged-short>
    public enum MftInputDataBufferFlags : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms694836</doc-id>
        /// <unmanaged>MFT_INPUT_DATA_BUFFER_PLACEHOLDER</unmanaged>
        /// <unmanaged-short>MFT_INPUT_DATA_BUFFER_PLACEHOLDER</unmanaged-short>
        MftInputDataBufferPlaceholder = unchecked ((System.Int32)(-1)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    [System.FlagsAttribute]
    /// <summary>
    /// <p> </p><p>Indicates the status of an input stream on a Media Foundation transform (MFT).</p>
    /// </summary>
    /// <doc-id>ms703084</doc-id>
    /// <unmanaged>_MFT_INPUT_STATUS_FLAGS</unmanaged>
    /// <unmanaged-short>_MFT_INPUT_STATUS_FLAGS</unmanaged-short>
    public enum MftInputStatusFlags : System.Int32
    {
        /// <summary>
        /// <dd> <p>The input stream can receive more data at this time. To deliver more input data, call <strong>IMFTransform::ProcessInput</strong>.</p> </dd>
        /// </summary>
        /// <doc-id>ms703084</doc-id>
        /// <unmanaged>MFT_INPUT_STATUS_ACCEPT_DATA</unmanaged>
        /// <unmanaged-short>MFT_INPUT_STATUS_ACCEPT_DATA</unmanaged-short>
        MftInputStatusAcceptData = unchecked ((System.Int32)(1)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    [System.FlagsAttribute]
    /// <summary>
    /// <p> </p><p>Describes an input stream on a Media Foundation transform (MFT).</p>
    /// </summary>
    /// <remarks>
    /// <p>Before the client sets the media types on the transform, the only flags guaranteed to be accurate are the MFT_INPUT_STREAM_REMOVABLE and MFT_INPUT_STREAM_OPTIONAL flags. For all other flags, the client should first set the media type on every non-optional stream.</p><p>In the default processing model, an MFT holds a reference count on the sample that it receives in <strong>ProcessInput</strong>. It does not process the sample immediately inside <strong>ProcessInput</strong>. When <strong>ProcessOutput</strong> is called, the MFT produces output data and then discards the input sample. The following variations on this model are defined:</p><ul> <li> <p>If an MFT never holds onto input samples between <strong>ProcessInput</strong> and <strong>ProcessOutput</strong>, it can set the MFT_INPUT_STREAM_DOES_NOT_ADDREF.</p> </li> <li> <p>If an MFT holds some input samples beyond the next call to <strong>ProcessOutput</strong>, it can set the MFT_INPUT_STREAM_HOLDS_BUFFERS.</p> </li> </ul>
    /// </remarks>
    /// <doc-id>ms703975</doc-id>
    /// <unmanaged>_MFT_INPUT_STREAM_INFO_FLAGS</unmanaged>
    /// <unmanaged-short>_MFT_INPUT_STREAM_INFO_FLAGS</unmanaged-short>
    public enum MftInputStreamInformationFlags : System.Int32
    {
        /// <summary>
        /// <dd> <p>Each media sample (<strong><see cref = "SharpDX.MediaFoundation.Sample"/></strong> interface) of input data must contain complete, unbroken units of data. The definition of a <em>unit of data</em> depends on the media type: For uncompressed video, a video frame; for compressed data, a compressed packet; for uncompressed audio, a single audio frame.</p> <p>For uncompressed audio formats, this flag is always implied. (It is valid to set the flag, but not required.) An uncompressed audio frame should never span more than one media sample.</p> </dd>
        /// </summary>
        /// <doc-id>ms703975</doc-id>
        /// <unmanaged>MFT_INPUT_STREAM_WHOLE_SAMPLES</unmanaged>
        /// <unmanaged-short>MFT_INPUT_STREAM_WHOLE_SAMPLES</unmanaged-short>
        MftInputStreamWholeSamples = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>Each media sample that the client provides as input must contain exactly one unit of data, as defined for the MFT_INPUT_STREAM_WHOLE_SAMPLES flag.</p> <p>If this flag is present, the MFT_INPUT_STREAM_WHOLE_SAMPLES flag must also be present.</p> <p>An MFT that processes uncompressed audio should not set this flag. The MFT should accept buffers that contain more than a single audio frame, for efficiency.</p> </dd>
        /// </summary>
        /// <doc-id>ms703975</doc-id>
        /// <unmanaged>MFT_INPUT_STREAM_SINGLE_SAMPLE_PER_BUFFER</unmanaged>
        /// <unmanaged-short>MFT_INPUT_STREAM_SINGLE_SAMPLE_PER_BUFFER</unmanaged-short>
        MftInputStreamSingleSamplePerBuffer = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p> All input samples must be the same size. The size is given in the <strong>cbSize</strong> member of the <strong><see cref = "SharpDX.MediaFoundation.TInputStreamInformation"/></strong> structure. The MFT must provide this value. During processing, the MFT should verify the size of input samples, and may drop samples with incorrect size.</p> </dd>
        /// </summary>
        /// <doc-id>ms703975</doc-id>
        /// <unmanaged>MFT_INPUT_STREAM_FIXED_SAMPLE_SIZE</unmanaged>
        /// <unmanaged-short>MFT_INPUT_STREAM_FIXED_SAMPLE_SIZE</unmanaged-short>
        MftInputStreamFixedSampleSize = unchecked ((System.Int32)(4)),
        /// <summary>
        /// <dd> <p>The MFT might hold one or more input samples after <strong>IMFTransform::ProcessOutput</strong> is called. If this flag is present, the <strong>hnsMaxLatency</strong> member of the <strong><see cref = "SharpDX.MediaFoundation.TInputStreamInformation"/></strong> structure gives the maximum latency, and the <strong>cbMaxLookahead</strong> member gives the maximum number of bytes of lookahead.</p> </dd>
        /// </summary>
        /// <doc-id>ms703975</doc-id>
        /// <unmanaged>MFT_INPUT_STREAM_HOLDS_BUFFERS</unmanaged>
        /// <unmanaged-short>MFT_INPUT_STREAM_HOLDS_BUFFERS</unmanaged-short>
        MftInputStreamHoldsBuffers = unchecked ((System.Int32)(8)),
        /// <summary>
        /// <dd> <p>The MFT does not hold input samples after the <strong>IMFTransform::ProcessInput</strong> method returns. It releases the sample before the <strong>ProcessInput</strong> method returns.</p> <p>If this flag is absent, the MFT might hold a reference count on the samples that are passed to the <strong>ProcessInput</strong> method. The client must not re-use or delete the buffer memory until the MFT releases the sample's <strong><see cref = "SharpDX.MediaFoundation.Sample"/></strong> reference.</p> <p>If this flag is absent, it does not guarantee that the MFT holds a reference count on the input samples. It is valid for an MFT to release input samples in <strong>ProcessInput</strong> even if the MFT does not set this flag. However, setting this flag might enable to client to optimize how it re-uses buffers.</p> <p>An MFT should not set this flag if it ever holds onto an input sample after returning from <strong>ProcessInput</strong>.</p> </dd>
        /// </summary>
        /// <doc-id>ms703975</doc-id>
        /// <unmanaged>MFT_INPUT_STREAM_DOES_NOT_ADDREF</unmanaged>
        /// <unmanaged-short>MFT_INPUT_STREAM_DOES_NOT_ADDREF</unmanaged-short>
        MftInputStreamDoesNotAddref = unchecked ((System.Int32)(256)),
        /// <summary>
        /// <dd> <p>This input stream can be removed by calling <strong>IMFTransform::DeleteInputStream</strong>.</p> </dd>
        /// </summary>
        /// <doc-id>ms703975</doc-id>
        /// <unmanaged>MFT_INPUT_STREAM_REMOVABLE</unmanaged>
        /// <unmanaged-short>MFT_INPUT_STREAM_REMOVABLE</unmanaged-short>
        MftInputStreamRemovable = unchecked ((System.Int32)(512)),
        /// <summary>
        /// <dd> <p>This input stream is optional. The transform can produce output without receiving input from this stream. The caller can deselect the stream by not setting a media type or by setting a <strong><c>null</c></strong> media type. It is possible for every input stream on a transform to be optional, but at least one input must be selected in order to produce output.</p> </dd>
        /// </summary>
        /// <doc-id>ms703975</doc-id>
        /// <unmanaged>MFT_INPUT_STREAM_OPTIONAL</unmanaged>
        /// <unmanaged-short>MFT_INPUT_STREAM_OPTIONAL</unmanaged-short>
        MftInputStreamOptional = unchecked ((System.Int32)(1024)),
        /// <summary>
        /// <dd> <p>The MFT can perform in-place processing. In this mode, the MFT directly modifies the input buffer. When the client calls <strong>ProcessOutput</strong>, the same sample that was delivered to this stream is returned in the output stream that has a matching stream identifier. This flag implies that the MFT holds onto the input buffer, so this flag cannot combined with the MFT_INPUT_STREAM_DOES_NOT_ADDREF flag.</p> <p>If this flag is present, the MFT must set the MFT_OUTPUT_STREAM_PROVIDES_SAMPLES or MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES flag for the output stream that corresponds to this input stream. (See <strong>IMFTransform::GetOutputStreamInfo</strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ms703975</doc-id>
        /// <unmanaged>MFT_INPUT_STREAM_PROCESSES_IN_PLACE</unmanaged>
        /// <unmanaged-short>MFT_INPUT_STREAM_PROCESSES_IN_PLACE</unmanaged-short>
        MftInputStreamProcessesInPlace = unchecked ((System.Int32)(2048)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    [System.FlagsAttribute]
    /// <summary>
    /// <p> Defines flags for the <strong>IMFTransform::ProcessOutput</strong> method. </p>
    /// </summary>
    /// <remarks>
    /// <p>The values in this enumeration are not bit flags, so they should not be combined with a bitwise <strong>OR</strong>. Also, the caller should test for these flags with the equality operator, not a bitwise <strong>AND</strong>:</p><code>// Correct.
    /// if (Buffer.dwStatus == MFT_OUTPUT_DATA_BUFFER_STREAM_END)
    /// { ...
    /// } // Incorrect.
    /// if ((Buffer.dwStatus &amp; MFT_OUTPUT_DATA_BUFFER_STREAM_END) != 0)
    /// { ...
    /// }
    /// </code>
    /// </remarks>
    /// <doc-id>ms702281</doc-id>
    /// <unmanaged>_MFT_OUTPUT_DATA_BUFFER_FLAGS</unmanaged>
    /// <unmanaged-short>_MFT_OUTPUT_DATA_BUFFER_FLAGS</unmanaged-short>
    public enum MftOutputDataBufferFlags : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms702281</doc-id>
        /// <unmanaged>MFT_OUTPUT_DATA_BUFFER_INCOMPLETE</unmanaged>
        /// <unmanaged-short>MFT_OUTPUT_DATA_BUFFER_INCOMPLETE</unmanaged-short>
        MftOutputDataBufferIncomplete = unchecked ((System.Int32)(16777216)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms702281</doc-id>
        /// <unmanaged>MFT_OUTPUT_DATA_BUFFER_FORMAT_CHANGE</unmanaged>
        /// <unmanaged-short>MFT_OUTPUT_DATA_BUFFER_FORMAT_CHANGE</unmanaged-short>
        MftOutputDataBufferFormatChange = unchecked ((System.Int32)(256)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms702281</doc-id>
        /// <unmanaged>MFT_OUTPUT_DATA_BUFFER_STREAM_END</unmanaged>
        /// <unmanaged-short>MFT_OUTPUT_DATA_BUFFER_STREAM_END</unmanaged-short>
        MftOutputDataBufferStreamEnd = unchecked ((System.Int32)(512)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms702281</doc-id>
        /// <unmanaged>MFT_OUTPUT_DATA_BUFFER_NO_SAMPLE</unmanaged>
        /// <unmanaged-short>MFT_OUTPUT_DATA_BUFFER_NO_SAMPLE</unmanaged-short>
        MftOutputDataBufferNoSample = unchecked ((System.Int32)(768)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    [System.FlagsAttribute]
    /// <summary>
    /// <p> </p><p>Indicates whether a Media Foundation transform (MFT) can produce output data.</p>
    /// </summary>
    /// <doc-id>ms701553</doc-id>
    /// <unmanaged>_MFT_OUTPUT_STATUS_FLAGS</unmanaged>
    /// <unmanaged-short>_MFT_OUTPUT_STATUS_FLAGS</unmanaged-short>
    public enum MftOutputStatusFlags : System.Int32
    {
        /// <summary>
        /// <dd> <p>There is a sample available for at least one output stream. To retrieve the available output samples, call <strong>IMFTransform::ProcessOutput</strong>.</p> </dd>
        /// </summary>
        /// <doc-id>ms701553</doc-id>
        /// <unmanaged>MFT_OUTPUT_STATUS_SAMPLE_READY</unmanaged>
        /// <unmanaged-short>MFT_OUTPUT_STATUS_SAMPLE_READY</unmanaged-short>
        MftOutputStatusSampleReady = unchecked ((System.Int32)(1)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    [System.FlagsAttribute]
    /// <summary>
    /// <p> </p><p>Describes an output stream on a Media Foundation transform (MFT).</p>
    /// </summary>
    /// <remarks>
    /// <p>Before the client sets the media types on the MFT, the only flag guaranteed to be accurate is the MFT_OUTPUT_STREAM_OPTIONAL flag. For all other flags, the client should first set the media type on every non-optional stream.</p><p>The MFT_OUTPUT_STREAM_DISCARDABLE and MFT_OUTPUT_STREAM_LAZY_READ flags define different behaviors for how the MFT can discard output data.</p><ul> <li> <p>MFT_OUTPUT_STREAM_DISCARDABLE: The MFT discards output data only if the client calls <strong>ProcessOutput</strong> with the MFT_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER flag. The MFT never discards data when the client calls <strong>ProcessInput</strong>.</p> </li> <li> <p>MFT_OUTPUT_STREAM_LAZY_READ: If the client continues to call <strong>ProcessInput</strong> without collecting the output from this stream, the MFT eventually discards the output. If all output streams have the MFT_OUTPUT_STREAM_LAZY_READ flag, the MFT never refuses more input data.</p> </li> </ul><p>If neither of these flags is set, the MFT never discards output data.</p>
    /// </remarks>
    /// <doc-id>ms705618</doc-id>
    /// <unmanaged>_MFT_OUTPUT_STREAM_INFO_FLAGS</unmanaged>
    /// <unmanaged-short>_MFT_OUTPUT_STREAM_INFO_FLAGS</unmanaged-short>
    public enum MftOutputStreamInformationFlags : System.Int32
    {
        /// <summary>
        /// <dd> <p>Each media sample (<strong><see cref = "SharpDX.MediaFoundation.Sample"/></strong> interface) of output data from the MFT contains complete, unbroken units of data. The definition of a <em>unit of data</em> depends on the media type: For uncompressed video, a video frame; for compressed data, a compressed packet; for uncompressed audio, a single audio frame.</p> <p>For uncompressed audio formats, this flag is always implied. (It is valid to set the flag, but not required.) An uncompressed audio frame should never span more than one media sample.</p> </dd>
        /// </summary>
        /// <doc-id>ms705618</doc-id>
        /// <unmanaged>MFT_OUTPUT_STREAM_WHOLE_SAMPLES</unmanaged>
        /// <unmanaged-short>MFT_OUTPUT_STREAM_WHOLE_SAMPLES</unmanaged-short>
        MftOutputStreamWholeSamples = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>Each output sample contains exactly one unit of data, as defined for the MFT_OUTPUT_STREAM_WHOLE_SAMPLES flag.</p> <p>If this flag is present, the MFT_OUTPUT_STREAM_WHOLE_SAMPLES flag must also be present.</p> <p>An MFT that outputs uncompressed audio should not set this flag. For efficiency, it should output more than one audio frame at a time.</p> </dd>
        /// </summary>
        /// <doc-id>ms705618</doc-id>
        /// <unmanaged>MFT_OUTPUT_STREAM_SINGLE_SAMPLE_PER_BUFFER</unmanaged>
        /// <unmanaged-short>MFT_OUTPUT_STREAM_SINGLE_SAMPLE_PER_BUFFER</unmanaged-short>
        MftOutputStreamSingleSamplePerBuffer = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>All output samples are the same size.</p> </dd>
        /// </summary>
        /// <doc-id>ms705618</doc-id>
        /// <unmanaged>MFT_OUTPUT_STREAM_FIXED_SAMPLE_SIZE</unmanaged>
        /// <unmanaged-short>MFT_OUTPUT_STREAM_FIXED_SAMPLE_SIZE</unmanaged-short>
        MftOutputStreamFixedSampleSize = unchecked ((System.Int32)(4)),
        /// <summary>
        /// <dd> <p>The MFT can discard the output data from this output stream, if requested by the client. To discard the output, set the MFT_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER flag in the <strong>IMFTransform::ProcessOutput</strong> method.</p> </dd>
        /// </summary>
        /// <doc-id>ms705618</doc-id>
        /// <unmanaged>MFT_OUTPUT_STREAM_DISCARDABLE</unmanaged>
        /// <unmanaged-short>MFT_OUTPUT_STREAM_DISCARDABLE</unmanaged-short>
        MftOutputStreamDiscardable = unchecked ((System.Int32)(8)),
        /// <summary>
        /// <dd> <p>This output stream is optional. The client can deselect the stream by not setting a media type or by setting a <strong><c>null</c></strong> media type. When an optional stream is deselected, it does not produce any output data.</p> </dd>
        /// </summary>
        /// <doc-id>ms705618</doc-id>
        /// <unmanaged>MFT_OUTPUT_STREAM_OPTIONAL</unmanaged>
        /// <unmanaged-short>MFT_OUTPUT_STREAM_OPTIONAL</unmanaged-short>
        MftOutputStreamOptional = unchecked ((System.Int32)(16)),
        /// <summary>
        /// <dd> <p>The MFT provides the output samples for this stream, either by allocating them internally or by operating directly on the input samples. The MFT cannot use output samples provided by the client for this stream.</p> <p>If this flag is not set, the MFT must set <strong>cbSize</strong> to a nonzero value in the <strong><see cref = "SharpDX.MediaFoundation.TOutputStreamInformation"/></strong> structure, so that the client can allocate the correct buffer size. For more information, see <strong>IMFTransform::GetOutputStreamInfo</strong>. This flag cannot be combined with the MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES flag.</p> </dd>
        /// </summary>
        /// <doc-id>ms705618</doc-id>
        /// <unmanaged>MFT_OUTPUT_STREAM_PROVIDES_SAMPLES</unmanaged>
        /// <unmanaged-short>MFT_OUTPUT_STREAM_PROVIDES_SAMPLES</unmanaged-short>
        MftOutputStreamProvidesSamples = unchecked ((System.Int32)(256)),
        /// <summary>
        /// <dd> <p>The MFT can either provide output samples for this stream or it can use samples that the client allocates. This flag cannot be combined with the MFT_OUTPUT_STREAM_PROVIDES_SAMPLES flag.</p> <p>If the MFT does not set this flag or the MFT_OUTPUT_STREAM_PROVIDES_SAMPLES flag, the client must allocate the samples for this output stream. The MFT will not provide its own samples.</p> </dd>
        /// </summary>
        /// <doc-id>ms705618</doc-id>
        /// <unmanaged>MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES</unmanaged>
        /// <unmanaged-short>MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES</unmanaged-short>
        MftOutputStreamCanProvideSamples = unchecked ((System.Int32)(512)),
        /// <summary>
        /// <dd> <p>The MFT does not require the client to process the output for this stream. If the client continues to send input data without getting the output from this stream, the MFT simply discards the previous input.</p> </dd>
        /// </summary>
        /// <doc-id>ms705618</doc-id>
        /// <unmanaged>MFT_OUTPUT_STREAM_LAZY_READ</unmanaged>
        /// <unmanaged-short>MFT_OUTPUT_STREAM_LAZY_READ</unmanaged-short>
        MftOutputStreamLazyRead = unchecked ((System.Int32)(1024)),
        /// <summary>
        /// <dd> <p>The MFT might remove this output stream during streaming. This flag typically applies to demultiplexers, where the input data contains multiple streams that can start and stop during streaming. For more information, see <strong>IMFTransform::ProcessOutput</strong>.</p> </dd>
        /// </summary>
        /// <doc-id>ms705618</doc-id>
        /// <unmanaged>MFT_OUTPUT_STREAM_REMOVABLE</unmanaged>
        /// <unmanaged-short>MFT_OUTPUT_STREAM_REMOVABLE</unmanaged-short>
        MftOutputStreamRemovable = unchecked ((System.Int32)(2048)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    [System.FlagsAttribute]
    /// <summary>
    /// <p> </p><p>Defines flags for the setting or testing the media type on a Media Foundation transform (MFT).</p>
    /// </summary>
    /// <doc-id>ms704051</doc-id>
    /// <unmanaged>_MFT_SET_TYPE_FLAGS</unmanaged>
    /// <unmanaged-short>_MFT_SET_TYPE_FLAGS</unmanaged-short>
    public enum MftSetTypeFlags : System.Int32
    {
        /// <summary>
        /// <dd> <p>Test the proposed media type, but do not set it.</p> </dd>
        /// </summary>
        /// <doc-id>ms704051</doc-id>
        /// <unmanaged>MFT_SET_TYPE_TEST_ONLY</unmanaged>
        /// <unmanaged-short>MFT_SET_TYPE_TEST_ONLY</unmanaged-short>
        MftSetTypeTestOnly = unchecked ((System.Int32)(1)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>__MIDL___MIDL_itf_mfreadwrite_0000_0001_0002</unmanaged>
    /// <unmanaged-short>__MIDL___MIDL_itf_mfreadwrite_0000_0001_0002</unmanaged-short>
    public enum MidlMidlItfMfreadwrite000000010002 : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_SOURCE_READER_CURRENT_TYPE_INDEX</unmanaged>
        /// <unmanaged-short>MF_SOURCE_READER_CURRENT_TYPE_INDEX</unmanaged-short>
        CurrentTypeIndex = unchecked ((System.Int32)(-1))}

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>MF_MSE_APPEND_MODE</unmanaged>
    /// <unmanaged-short>MF_MSE_APPEND_MODE</unmanaged-short>
    public enum MultisampledEAppendMode : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_MSE_APPEND_MODE_SEGMENTS</unmanaged>
        /// <unmanaged-short>MF_MSE_APPEND_MODE_SEGMENTS</unmanaged-short>
        Segments = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_MSE_APPEND_MODE_SEQUENCE</unmanaged>
        /// <unmanaged-short>MF_MSE_APPEND_MODE_SEQUENCE</unmanaged-short>
        Sequence = unchecked ((System.Int32)(1))}

    /// <summary>
    /// <p>Defines the different error states of the Media Source Extension.</p>
    /// </summary>
    /// <doc-id>dn302195</doc-id>
    /// <unmanaged>MF_MSE_ERROR</unmanaged>
    /// <unmanaged-short>MF_MSE_ERROR</unmanaged-short>
    public enum MultisampledEError : System.Int32
    {
        /// <summary>
        /// <dd> <p>Specifies no error.</p> </dd>
        /// </summary>
        /// <doc-id>dn302195</doc-id>
        /// <unmanaged>MF_MSE_ERROR_NOERROR</unmanaged>
        /// <unmanaged-short>MF_MSE_ERROR_NOERROR</unmanaged-short>
        Noerror = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>Specifies an error with the network.</p> </dd>
        /// </summary>
        /// <doc-id>dn302195</doc-id>
        /// <unmanaged>MF_MSE_ERROR_NETWORK</unmanaged>
        /// <unmanaged-short>MF_MSE_ERROR_NETWORK</unmanaged-short>
        Network = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>Specifies an error with decoding.</p> </dd>
        /// </summary>
        /// <doc-id>dn302195</doc-id>
        /// <unmanaged>MF_MSE_ERROR_DECODE</unmanaged>
        /// <unmanaged-short>MF_MSE_ERROR_DECODE</unmanaged-short>
        Decode = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>Specifies an unknown error.</p> </dd>
        /// </summary>
        /// <doc-id>dn302195</doc-id>
        /// <unmanaged>MF_MSE_ERROR_UNKNOWN_ERROR</unmanaged>
        /// <unmanaged-short>MF_MSE_ERROR_UNKNOWN_ERROR</unmanaged-short>
        UnknownError = unchecked ((System.Int32)(3))}

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>MF_MSE_OPUS_SUPPORT_TYPE</unmanaged>
    /// <unmanaged-short>MF_MSE_OPUS_SUPPORT_TYPE</unmanaged-short>
    public enum MultisampledEOperationUsSupportType : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_MSE_OPUS_SUPPORT_ON</unmanaged>
        /// <unmanaged-short>MF_MSE_OPUS_SUPPORT_ON</unmanaged-short>
        On = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_MSE_OPUS_SUPPORT_OFF</unmanaged>
        /// <unmanaged-short>MF_MSE_OPUS_SUPPORT_OFF</unmanaged-short>
        Off = unchecked ((System.Int32)(1))}

    /// <summary>
    /// <p>Defines the different ready states of the Media Source Extension.</p>
    /// </summary>
    /// <doc-id>dn302196</doc-id>
    /// <unmanaged>MF_MSE_READY</unmanaged>
    /// <unmanaged-short>MF_MSE_READY</unmanaged-short>
    public enum MultisampledEReady : System.Int32
    {
        /// <summary>
        /// <dd> <p>The media source is closed.</p> </dd>
        /// </summary>
        /// <doc-id>dn302196</doc-id>
        /// <unmanaged>MF_MSE_READY_CLOSED</unmanaged>
        /// <unmanaged-short>MF_MSE_READY_CLOSED</unmanaged-short>
        Closed = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>The media source is open.</p> </dd>
        /// </summary>
        /// <doc-id>dn302196</doc-id>
        /// <unmanaged>MF_MSE_READY_OPEN</unmanaged>
        /// <unmanaged-short>MF_MSE_READY_OPEN</unmanaged-short>
        Open = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>The media source is ended.</p> </dd>
        /// </summary>
        /// <doc-id>dn302196</doc-id>
        /// <unmanaged>MF_MSE_READY_ENDED</unmanaged>
        /// <unmanaged-short>MF_MSE_READY_ENDED</unmanaged-short>
        Ended = unchecked ((System.Int32)(3))}

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>MF_MSE_VP9_SUPPORT_TYPE</unmanaged>
    /// <unmanaged-short>MF_MSE_VP9_SUPPORT_TYPE</unmanaged-short>
    public enum MultisampledEVp9SupportType : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_MSE_VP9_SUPPORT_DEFAULT</unmanaged>
        /// <unmanaged-short>MF_MSE_VP9_SUPPORT_DEFAULT</unmanaged-short>
        Default = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_MSE_VP9_SUPPORT_ON</unmanaged>
        /// <unmanaged-short>MF_MSE_VP9_SUPPORT_ON</unmanaged-short>
        On = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_MSE_VP9_SUPPORT_OFF</unmanaged>
        /// <unmanaged-short>MF_MSE_VP9_SUPPORT_OFF</unmanaged-short>
        Off = unchecked ((System.Int32)(2))}

    /// <summary>
    /// <p> </p><p>Specifies how the user's credentials will be used.</p>
    /// </summary>
    /// <doc-id>ms697023</doc-id>
    /// <unmanaged>MFNetAuthenticationFlags</unmanaged>
    /// <unmanaged-short>MFNetAuthenticationFlags</unmanaged-short>
    public enum NetAuthenticationFlags : System.Int32
    {
        /// <summary>
        /// <dd> <p>The credentials will be used to authenticate with a proxy.</p> </dd>
        /// </summary>
        /// <doc-id>ms697023</doc-id>
        /// <unmanaged>MFNET_AUTHENTICATION_PROXY</unmanaged>
        /// <unmanaged-short>MFNET_AUTHENTICATION_PROXY</unmanaged-short>
        MfnetAuthenticationProxy = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>The credentials will be sent over the network unencrypted.</p> </dd>
        /// </summary>
        /// <doc-id>ms697023</doc-id>
        /// <unmanaged>MFNET_AUTHENTICATION_CLEAR_TEXT</unmanaged>
        /// <unmanaged-short>MFNET_AUTHENTICATION_CLEAR_TEXT</unmanaged-short>
        MfnetAuthenticationClearText = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>The credentials must be from a user who is currently logged on.</p> </dd>
        /// </summary>
        /// <doc-id>ms697023</doc-id>
        /// <unmanaged>MFNET_AUTHENTICATION_LOGGED_ON_USER</unmanaged>
        /// <unmanaged-short>MFNET_AUTHENTICATION_LOGGED_ON_USER</unmanaged-short>
        MfnetAuthenticationLoggedOnUser = unchecked ((System.Int32)(4))}

    /// <summary>
    /// <p> </p><p>Describes options for the caching network credentials.</p>
    /// </summary>
    /// <doc-id>ms697386</doc-id>
    /// <unmanaged>MFNetCredentialOptions</unmanaged>
    /// <unmanaged-short>MFNetCredentialOptions</unmanaged-short>
    public enum NetCredentialOptions : System.Int32
    {
        /// <summary>
        /// <dd> <p>Allow the credential cache object to save  credentials in persistant storage.</p> </dd>
        /// </summary>
        /// <doc-id>ms697386</doc-id>
        /// <unmanaged>MFNET_CREDENTIAL_SAVE</unmanaged>
        /// <unmanaged-short>MFNET_CREDENTIAL_SAVE</unmanaged-short>
        MfnetCredentialSave = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>Do not allow the credential cache object to cache the credentials in memory. This flag cannot be combined with the MFNET_CREDENTIAL_SAVE flag.</p> </dd>
        /// </summary>
        /// <doc-id>ms697386</doc-id>
        /// <unmanaged>MFNET_CREDENTIAL_DONT_CACHE</unmanaged>
        /// <unmanaged-short>MFNET_CREDENTIAL_DONT_CACHE</unmanaged-short>
        MfnetCredentialDontCache = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>The user allows credentials to be sent over the network in clear text.</p> <p> By default, <strong>IMFNetCredentialCache::GetCredential</strong> always returns the REQUIRE_PROMPT flag when the authentication flags include MFNET_AUTHENTICATION_CLEAR_TEXT, even if cached credentials are available. If you set the MFNET_CREDENTIAL_ALLOW_CLEAR_TEXT option, the <strong>GetCredential</strong> method will not return  REQUIRE_PROMPT for clear text, if cached credentials are available.</p> <p>Do not set this flag without notifying the user that credentials might be sent in clear text.</p> </dd>
        /// </summary>
        /// <doc-id>ms697386</doc-id>
        /// <unmanaged>MFNET_CREDENTIAL_ALLOW_CLEAR_TEXT</unmanaged>
        /// <unmanaged-short>MFNET_CREDENTIAL_ALLOW_CLEAR_TEXT</unmanaged-short>
        MfnetCredentialAllowClearText = unchecked ((System.Int32)(4))}

    /// <summary>
    /// <p> Specifies how the credential manager should obtain user credentials. </p>
    /// </summary>
    /// <remarks>
    /// <p>The application implements the credential manager, which must expose the <strong><see cref = "SharpDX.MediaFoundation.NetCredentialManager"/></strong> interface. If the <strong>REQUIRE_PROMPT</strong> flag is set, the credential manager should prompt the user for his or her name and password.</p><p>The credential cache object sets the <strong>REQUIRE_PROMPT</strong> flag if the cache does not yet contain valid credentials. It also sets this flag if the credentials will be sent as plain text, unless the credential manager previously set the <strong>MFNET_CREDENTIAL_ALLOW_CLEAR_TEXT</strong> option. (See <strong>IMFNetCredentialCache::SetUserOptions</strong>.)</p>
    /// </remarks>
    /// <doc-id>ms700813</doc-id>
    /// <unmanaged>MFNetCredentialRequirements</unmanaged>
    /// <unmanaged-short>MFNetCredentialRequirements</unmanaged-short>
    public enum NetCredentialRequirements : System.Int32
    {
        /// <summary>
        /// <dd> <p> The credential manager should prompt the user to provide the credentials. </p> </dd>
        /// </summary>
        /// <doc-id>ms700813</doc-id>
        /// <unmanaged>REQUIRE_PROMPT</unmanaged>
        /// <unmanaged-short>REQUIRE_PROMPT</unmanaged-short>
        RequirePrompt = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p> </p><strong>Note</strong>??Requires Windows?7 or later. ? <p>The credentials are saved to persistent storage. This flag acts as a hint for the application's UI. If the application prompts the user for credentials, the UI can indicate that the credentials have already been saved.</p> </dd>
        /// </summary>
        /// <doc-id>ms700813</doc-id>
        /// <unmanaged>REQUIRE_SAVE_SELECTED</unmanaged>
        /// <unmanaged-short>REQUIRE_SAVE_SELECTED</unmanaged-short>
        RequireSaveSelected = unchecked ((System.Int32)(2))}

    /// <summary>
    /// <p>Specifies how the default proxy locator will specify the connection settings to a proxy server. The application must set these values in the <strong>MFNETSOURCE_PROXYSETTINGS</strong> property.</p>
    /// </summary>
    /// <doc-id>aa372538</doc-id>
    /// <unmanaged>MFNET_PROXYSETTINGS</unmanaged>
    /// <unmanaged-short>MFNET_PROXYSETTINGS</unmanaged-short>
    public enum NetProxysettings : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa372538</doc-id>
        /// <unmanaged>MFNET_PROXYSETTING_NONE</unmanaged>
        /// <unmanaged-short>MFNET_PROXYSETTING_NONE</unmanaged-short>
        None = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa372538</doc-id>
        /// <unmanaged>MFNET_PROXYSETTING_MANUAL</unmanaged>
        /// <unmanaged-short>MFNET_PROXYSETTING_MANUAL</unmanaged-short>
        Manual = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa372538</doc-id>
        /// <unmanaged>MFNET_PROXYSETTING_AUTO</unmanaged>
        /// <unmanaged-short>MFNET_PROXYSETTING_AUTO</unmanaged-short>
        Auto = unchecked ((System.Int32)(2)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa372538</doc-id>
        /// <unmanaged>MFNET_PROXYSETTING_BROWSER</unmanaged>
        /// <unmanaged-short>MFNET_PROXYSETTING_BROWSER</unmanaged-short>
        Browser = unchecked ((System.Int32)(3))}

    /// <summary>
    /// <p> </p><p>Defines the status of the cache for a media file or entry.</p>
    /// </summary>
    /// <doc-id>ms705647</doc-id>
    /// <unmanaged>MFNETSOURCE_CACHE_STATE</unmanaged>
    /// <unmanaged-short>MFNETSOURCE_CACHE_STATE</unmanaged-short>
    public enum NetsourceCacheState : System.Int32
    {
        /// <summary>
        /// <dd> <p>The cache for a file or entry does not exist.</p> </dd>
        /// </summary>
        /// <doc-id>ms705647</doc-id>
        /// <unmanaged>MFNETSOURCE_CACHE_UNAVAILABLE</unmanaged>
        /// <unmanaged-short>MFNETSOURCE_CACHE_UNAVAILABLE</unmanaged-short>
        Unavailable = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>The cache for a file or entry is growing.</p> </dd>
        /// </summary>
        /// <doc-id>ms705647</doc-id>
        /// <unmanaged>MFNETSOURCE_CACHE_ACTIVE_WRITING</unmanaged>
        /// <unmanaged-short>MFNETSOURCE_CACHE_ACTIVE_WRITING</unmanaged-short>
        ActiveWriting = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>The cache for a file or entry is completed.</p> </dd>
        /// </summary>
        /// <doc-id>ms705647</doc-id>
        /// <unmanaged>MFNETSOURCE_CACHE_ACTIVE_COMPLETE</unmanaged>
        /// <unmanaged-short>MFNETSOURCE_CACHE_ACTIVE_COMPLETE</unmanaged-short>
        ActiveComplete = unchecked ((System.Int32)(2))}

    /// <summary>
    /// <p> Indicates the type of control protocol that is used in streaming or downloading. </p>
    /// </summary>
    /// <doc-id>ms704031</doc-id>
    /// <unmanaged>MFNETSOURCE_PROTOCOL_TYPE</unmanaged>
    /// <unmanaged-short>MFNETSOURCE_PROTOCOL_TYPE</unmanaged-short>
    public enum NetsourceProtocolType : System.Int32
    {
        /// <summary>
        /// <dd> <p> The protocol type has not yet been determined. </p> </dd>
        /// </summary>
        /// <doc-id>ms704031</doc-id>
        /// <unmanaged>MFNETSOURCE_UNDEFINED</unmanaged>
        /// <unmanaged-short>MFNETSOURCE_UNDEFINED</unmanaged-short>
        Undefined = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p> The protocol type is HTTP. This includes HTTPv9, WMSP, and HTTP download. </p> </dd>
        /// </summary>
        /// <doc-id>ms704031</doc-id>
        /// <unmanaged>MFNETSOURCE_HTTP</unmanaged>
        /// <unmanaged-short>MFNETSOURCE_HTTP</unmanaged-short>
        Http = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p> The protocol type is Real Time Streaming Protocol (RTSP). </p> </dd>
        /// </summary>
        /// <doc-id>ms704031</doc-id>
        /// <unmanaged>MFNETSOURCE_RTSP</unmanaged>
        /// <unmanaged-short>MFNETSOURCE_RTSP</unmanaged-short>
        Rtsp = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p> The content is read from a file. The file might be local or on a remote share. </p> </dd>
        /// </summary>
        /// <doc-id>ms704031</doc-id>
        /// <unmanaged>MFNETSOURCE_FILE</unmanaged>
        /// <unmanaged-short>MFNETSOURCE_FILE</unmanaged-short>
        File = unchecked ((System.Int32)(3)),
        /// <summary>
        /// <dd> <p>The protocol type is multicast.</p> <strong>Note</strong>??Requires Windows?7 or later. ? </dd>
        /// </summary>
        /// <doc-id>ms704031</doc-id>
        /// <unmanaged>MFNETSOURCE_MULTICAST</unmanaged>
        /// <unmanaged-short>MFNETSOURCE_MULTICAST</unmanaged-short>
        Multicast = unchecked ((System.Int32)(4))}

    /// <summary>
    /// <p>Defines statistics collected by the network source. The values in this enumeration define property identifiers (PIDs) for the <strong>MFNETSOURCE_STATISTICS</strong> property.</p><p>To retrieve statistics from the network source, call <strong>IMFGetService::GetService</strong> with the service identifier <strong><see cref = "NetworkSourceStatistics"/></strong> and the interface identifier IID_IPropertyStore. The retrieved reference is an <strong><see cref = "SharpDX.ComObject"/></strong> reference. To get the value of a network statistic, construct a <strong>PROPERTYKEY</strong> with <strong>fmtid</strong> equal to <strong>MFNETSOURCE_STATISTICS</strong> and <strong>pid</strong> equal to a value from this enumeration. Then call <strong>IPropertyStore::GetValue</strong> with the property key to retrieve the value of the statistic as a <strong><see cref = "SharpDX.Win32.Variant"/></strong>. </p><p>In the descriptions that follow, the data type and value-type tag for the <strong><see cref = "SharpDX.Win32.Variant"/></strong> are listed in parentheses.</p>
    /// </summary>
    /// <doc-id>ms697019</doc-id>
    /// <unmanaged>MFNETSOURCE_STATISTICS_IDS</unmanaged>
    /// <unmanaged-short>MFNETSOURCE_STATISTICS_IDS</unmanaged-short>
    public enum NetsourceStatisticsIds : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697019</doc-id>
        /// <unmanaged>MFNETSOURCE_RECVPACKETS_ID</unmanaged>
        /// <unmanaged-short>MFNETSOURCE_RECVPACKETS_ID</unmanaged-short>
        RecvpacketsId = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697019</doc-id>
        /// <unmanaged>MFNETSOURCE_LOSTPACKETS_ID</unmanaged>
        /// <unmanaged-short>MFNETSOURCE_LOSTPACKETS_ID</unmanaged-short>
        LostpacketsId = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697019</doc-id>
        /// <unmanaged>MFNETSOURCE_RESENDSREQUESTED_ID</unmanaged>
        /// <unmanaged-short>MFNETSOURCE_RESENDSREQUESTED_ID</unmanaged-short>
        ResendsrequestedId = unchecked ((System.Int32)(2)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697019</doc-id>
        /// <unmanaged>MFNETSOURCE_RESENDSRECEIVED_ID</unmanaged>
        /// <unmanaged-short>MFNETSOURCE_RESENDSRECEIVED_ID</unmanaged-short>
        ResendsreceivedId = unchecked ((System.Int32)(3)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697019</doc-id>
        /// <unmanaged>MFNETSOURCE_RECOVEREDBYECCPACKETS_ID</unmanaged>
        /// <unmanaged-short>MFNETSOURCE_RECOVEREDBYECCPACKETS_ID</unmanaged-short>
        RecoveredbyeccpacketsId = unchecked ((System.Int32)(4)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697019</doc-id>
        /// <unmanaged>MFNETSOURCE_RECOVEREDBYRTXPACKETS_ID</unmanaged>
        /// <unmanaged-short>MFNETSOURCE_RECOVEREDBYRTXPACKETS_ID</unmanaged-short>
        RecoveredbyrtxpacketsId = unchecked ((System.Int32)(5)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697019</doc-id>
        /// <unmanaged>MFNETSOURCE_OUTPACKETS_ID</unmanaged>
        /// <unmanaged-short>MFNETSOURCE_OUTPACKETS_ID</unmanaged-short>
        OutpacketsId = unchecked ((System.Int32)(6)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697019</doc-id>
        /// <unmanaged>MFNETSOURCE_RECVRATE_ID</unmanaged>
        /// <unmanaged-short>MFNETSOURCE_RECVRATE_ID</unmanaged-short>
        RecvrateId = unchecked ((System.Int32)(7)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697019</doc-id>
        /// <unmanaged>MFNETSOURCE_AVGBANDWIDTHBPS_ID</unmanaged>
        /// <unmanaged-short>MFNETSOURCE_AVGBANDWIDTHBPS_ID</unmanaged-short>
        AvgbandwidthbpsId = unchecked ((System.Int32)(8)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697019</doc-id>
        /// <unmanaged>MFNETSOURCE_BYTESRECEIVED_ID</unmanaged>
        /// <unmanaged-short>MFNETSOURCE_BYTESRECEIVED_ID</unmanaged-short>
        BytesReceivedId = unchecked ((System.Int32)(9)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697019</doc-id>
        /// <unmanaged>MFNETSOURCE_PROTOCOL_ID</unmanaged>
        /// <unmanaged-short>MFNETSOURCE_PROTOCOL_ID</unmanaged-short>
        ProtocolId = unchecked ((System.Int32)(10)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697019</doc-id>
        /// <unmanaged>MFNETSOURCE_TRANSPORT_ID</unmanaged>
        /// <unmanaged-short>MFNETSOURCE_TRANSPORT_ID</unmanaged-short>
        TransportId = unchecked ((System.Int32)(11)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697019</doc-id>
        /// <unmanaged>MFNETSOURCE_CACHE_STATE_ID</unmanaged>
        /// <unmanaged-short>MFNETSOURCE_CACHE_STATE_ID</unmanaged-short>
        CacheStateId = unchecked ((System.Int32)(12)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697019</doc-id>
        /// <unmanaged>MFNETSOURCE_LINKBANDWIDTH_ID</unmanaged>
        /// <unmanaged-short>MFNETSOURCE_LINKBANDWIDTH_ID</unmanaged-short>
        LinkbandwidthId = unchecked ((System.Int32)(13)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697019</doc-id>
        /// <unmanaged>MFNETSOURCE_CONTENTBITRATE_ID</unmanaged>
        /// <unmanaged-short>MFNETSOURCE_CONTENTBITRATE_ID</unmanaged-short>
        ContentbitrateId = unchecked ((System.Int32)(14)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697019</doc-id>
        /// <unmanaged>MFNETSOURCE_SPEEDFACTOR_ID</unmanaged>
        /// <unmanaged-short>MFNETSOURCE_SPEEDFACTOR_ID</unmanaged-short>
        SpeedfactorId = unchecked ((System.Int32)(15)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697019</doc-id>
        /// <unmanaged>MFNETSOURCE_BUFFERSIZE_ID</unmanaged>
        /// <unmanaged-short>MFNETSOURCE_BUFFERSIZE_ID</unmanaged-short>
        BufferSizeId = unchecked ((System.Int32)(16)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697019</doc-id>
        /// <unmanaged>MFNETSOURCE_BUFFERPROGRESS_ID</unmanaged>
        /// <unmanaged-short>MFNETSOURCE_BUFFERPROGRESS_ID</unmanaged-short>
        BufferProgressId = unchecked ((System.Int32)(17)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697019</doc-id>
        /// <unmanaged>MFNETSOURCE_LASTBWSWITCHTS_ID</unmanaged>
        /// <unmanaged-short>MFNETSOURCE_LASTBWSWITCHTS_ID</unmanaged-short>
        LastBwswitchtsId = unchecked ((System.Int32)(18)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697019</doc-id>
        /// <unmanaged>MFNETSOURCE_SEEKRANGESTART_ID</unmanaged>
        /// <unmanaged-short>MFNETSOURCE_SEEKRANGESTART_ID</unmanaged-short>
        SeekrangestartId = unchecked ((System.Int32)(19)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697019</doc-id>
        /// <unmanaged>MFNETSOURCE_SEEKRANGEEND_ID</unmanaged>
        /// <unmanaged-short>MFNETSOURCE_SEEKRANGEEND_ID</unmanaged-short>
        SeekrangeendId = unchecked ((System.Int32)(20)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697019</doc-id>
        /// <unmanaged>MFNETSOURCE_BUFFERINGCOUNT_ID</unmanaged>
        /// <unmanaged-short>MFNETSOURCE_BUFFERINGCOUNT_ID</unmanaged-short>
        BufferingCountId = unchecked ((System.Int32)(21)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697019</doc-id>
        /// <unmanaged>MFNETSOURCE_INCORRECTLYSIGNEDPACKETS_ID</unmanaged>
        /// <unmanaged-short>MFNETSOURCE_INCORRECTLYSIGNEDPACKETS_ID</unmanaged-short>
        IncorrectlysignedpacketsId = unchecked ((System.Int32)(22)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697019</doc-id>
        /// <unmanaged>MFNETSOURCE_SIGNEDSESSION_ID</unmanaged>
        /// <unmanaged-short>MFNETSOURCE_SIGNEDSESSION_ID</unmanaged-short>
        SignedsessionId = unchecked ((System.Int32)(23)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697019</doc-id>
        /// <unmanaged>MFNETSOURCE_MAXBITRATE_ID</unmanaged>
        /// <unmanaged-short>MFNETSOURCE_MAXBITRATE_ID</unmanaged-short>
        MaximumBitRateId = unchecked ((System.Int32)(24)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697019</doc-id>
        /// <unmanaged>MFNETSOURCE_RECEPTION_QUALITY_ID</unmanaged>
        /// <unmanaged-short>MFNETSOURCE_RECEPTION_QUALITY_ID</unmanaged-short>
        ReceptionQualityId = unchecked ((System.Int32)(25)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697019</doc-id>
        /// <unmanaged>MFNETSOURCE_RECOVEREDPACKETS_ID</unmanaged>
        /// <unmanaged-short>MFNETSOURCE_RECOVEREDPACKETS_ID</unmanaged-short>
        RecoveredpacketsId = unchecked ((System.Int32)(26)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697019</doc-id>
        /// <unmanaged>MFNETSOURCE_VBR_ID</unmanaged>
        /// <unmanaged-short>MFNETSOURCE_VBR_ID</unmanaged-short>
        VariableBitRateId = unchecked ((System.Int32)(27)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697019</doc-id>
        /// <unmanaged>MFNETSOURCE_DOWNLOADPROGRESS_ID</unmanaged>
        /// <unmanaged-short>MFNETSOURCE_DOWNLOADPROGRESS_ID</unmanaged-short>
        DownloadProgressId = unchecked ((System.Int32)(28)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697019</doc-id>
        /// <unmanaged>MFNETSOURCE_UNPREDEFINEDPROTOCOLNAME_ID</unmanaged>
        /// <unmanaged-short>MFNETSOURCE_UNPREDEFINEDPROTOCOLNAME_ID</unmanaged-short>
        UnpredefinedprotocolnameId = unchecked ((System.Int32)(29))}

    /// <summary>
    /// <p> </p><p>Describes the type of transport used in streaming or downloading data (TCP or UDP).</p>
    /// </summary>
    /// <doc-id>ms702233</doc-id>
    /// <unmanaged>MFNETSOURCE_TRANSPORT_TYPE</unmanaged>
    /// <unmanaged-short>MFNETSOURCE_TRANSPORT_TYPE</unmanaged-short>
    public enum NetsourceTransportType : System.Int32
    {
        /// <summary>
        /// <dd> <p>The data transport type is UDP.</p> </dd>
        /// </summary>
        /// <doc-id>ms702233</doc-id>
        /// <unmanaged>MFNETSOURCE_UDP</unmanaged>
        /// <unmanaged-short>MFNETSOURCE_UDP</unmanaged-short>
        Udp = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>The data transport type is TCP.</p> </dd>
        /// </summary>
        /// <doc-id>ms702233</doc-id>
        /// <unmanaged>MFNETSOURCE_TCP</unmanaged>
        /// <unmanaged-short>MFNETSOURCE_TCP</unmanaged-short>
        Tcp = unchecked ((System.Int32)(1))}

    /// <summary>
    /// <p>Specifies whether color data includes headroom and toeroom. Headroom allows for values beyond 1.0 white ("whiter than white"), and toeroom allows for values below reference 0.0 black ("blacker than black"). </p>
    /// </summary>
    /// <remarks>
    /// <p> This enumeration is used with the <strong><see cref = "VideoNominalRange"/></strong> attribute. </p><p> For more information about these values, see the remarks for the <strong>DXVA2_NominalRange</strong> enumeration, which is the DirectX Video Acceleration (DXVA) equivalent of this enumeration. </p>
    /// </remarks>
    /// <doc-id>ms705659</doc-id>
    /// <unmanaged>MFNominalRange</unmanaged>
    /// <unmanaged-short>MFNominalRange</unmanaged-short>
    public enum NominalRange : System.Int32
    {
        /// <summary>
        /// <dd> <p> Unknown nominal range. </p> </dd>
        /// </summary>
        /// <doc-id>ms705659</doc-id>
        /// <unmanaged>MFNominalRange_Unknown</unmanaged>
        /// <unmanaged-short>MFNominalRange_Unknown</unmanaged-short>
        Unknown = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p> Equivalent to MFNominalRange_0_255. </p> </dd>
        /// </summary>
        /// <doc-id>ms705659</doc-id>
        /// <unmanaged>MFNominalRange_Normal</unmanaged>
        /// <unmanaged-short>MFNominalRange_Normal</unmanaged-short>
        Normal = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p> Equivalent to MFNominalRange_16_235. </p> </dd>
        /// </summary>
        /// <doc-id>ms705659</doc-id>
        /// <unmanaged>MFNominalRange_Wide</unmanaged>
        /// <unmanaged-short>MFNominalRange_Wide</unmanaged-short>
        Wide = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p> The normalized range [0...1] maps to [0...255] for 8-bit samples or [0...1023] for 10-bit samples. </p> </dd>
        /// </summary>
        /// <doc-id>ms705659</doc-id>
        /// <unmanaged>MFNominalRange_0_255</unmanaged>
        /// <unmanaged-short>MFNominalRange_0_255</unmanaged-short>
        Range0_255 = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p> The normalized range [0...1] maps to [16...235] for 8-bit samples or [64...940] for 10-bit samples. </p> </dd>
        /// </summary>
        /// <doc-id>ms705659</doc-id>
        /// <unmanaged>MFNominalRange_16_235</unmanaged>
        /// <unmanaged-short>MFNominalRange_16_235</unmanaged-short>
        Range16_235 = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p> The normalized range [0..1] maps to [48...208] for 8-bit samples or [64...940] for 10-bit samples. </p> </dd>
        /// </summary>
        /// <doc-id>ms705659</doc-id>
        /// <unmanaged>MFNominalRange_48_208</unmanaged>
        /// <unmanaged-short>MFNominalRange_48_208</unmanaged-short>
        Range48_208 = unchecked ((System.Int32)(3)),
        /// <summary>
        /// <dd> <p>The normalized range [0..1] maps to [64...127] for 8-bit samples or [256...508] for 10-bit samples. This range is used in the xRGB color space.</p> <strong>Note</strong>??Requires Windows?7 or later. ? </dd>
        /// </summary>
        /// <doc-id>ms705659</doc-id>
        /// <unmanaged>MFNominalRange_64_127</unmanaged>
        /// <unmanaged-short>MFNominalRange_64_127</unmanaged-short>
        Range64_127 = unchecked ((System.Int32)(4)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms705659</doc-id>
        /// <unmanaged>MFNominalRange_Last</unmanaged>
        /// <unmanaged-short>MFNominalRange_Last</unmanaged-short>
        Last = unchecked ((System.Int32)(5)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms705659</doc-id>
        /// <unmanaged>MFNominalRange_ForceDWORD</unmanaged>
        /// <unmanaged-short>MFNominalRange_ForceDWORD</unmanaged-short>
        ForceDWORD = unchecked ((System.Int32)(2147483647))}

    /// <summary>
    /// <p> </p><p>Defines the object types that are created by the source resolver.</p>
    /// </summary>
    /// <doc-id>ms704771</doc-id>
    /// <unmanaged>MF_OBJECT_TYPE</unmanaged>
    /// <unmanaged-short>MF_OBJECT_TYPE</unmanaged-short>
    public enum ObjectType : System.Int32
    {
        /// <summary>
        /// <dd> <p>Media source. You can query the object for the <strong><see cref = "SharpDX.MediaFoundation.MediaSource"/></strong> interface.</p> </dd>
        /// </summary>
        /// <doc-id>ms704771</doc-id>
        /// <unmanaged>MF_OBJECT_MEDIASOURCE</unmanaged>
        /// <unmanaged-short>MF_OBJECT_MEDIASOURCE</unmanaged-short>
        MediaSource = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>Byte stream. You can query the object for the <strong><see cref = "SharpDX.MediaFoundation.IByteStream"/></strong> interface.</p> </dd>
        /// </summary>
        /// <doc-id>ms704771</doc-id>
        /// <unmanaged>MF_OBJECT_BYTESTREAM</unmanaged>
        /// <unmanaged-short>MF_OBJECT_BYTESTREAM</unmanaged-short>
        ByteStream = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>Invalid type.</p> </dd>
        /// </summary>
        /// <doc-id>ms704771</doc-id>
        /// <unmanaged>MF_OBJECT_INVALID</unmanaged>
        /// <unmanaged-short>MF_OBJECT_INVALID</unmanaged-short>
        Invalid = unchecked ((System.Int32)(2))}

    /// <summary>
    /// <p>Defines protection levels for <strong>MFPROTECTION_ACP</strong>.</p>
    /// </summary>
    /// <doc-id>jj128346</doc-id>
    /// <unmanaged>MF_OPM_ACP_PROTECTION_LEVEL</unmanaged>
    /// <unmanaged-short>MF_OPM_ACP_PROTECTION_LEVEL</unmanaged-short>
    public enum OpmAcpProtectionLevel : System.Int32
    {
        /// <summary>
        /// <dd> <p>Specifies ACP is disabled.</p> </dd>
        /// </summary>
        /// <doc-id>jj128346</doc-id>
        /// <unmanaged>MF_OPM_ACP_OFF</unmanaged>
        /// <unmanaged-short>MF_OPM_ACP_OFF</unmanaged-short>
        Off = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>Specifies ACP is level one.</p> </dd>
        /// </summary>
        /// <doc-id>jj128346</doc-id>
        /// <unmanaged>MF_OPM_ACP_LEVEL_ONE</unmanaged>
        /// <unmanaged-short>MF_OPM_ACP_LEVEL_ONE</unmanaged-short>
        LevelOne = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>Specifies ACP is level two.</p> </dd>
        /// </summary>
        /// <doc-id>jj128346</doc-id>
        /// <unmanaged>MF_OPM_ACP_LEVEL_TWO</unmanaged>
        /// <unmanaged-short>MF_OPM_ACP_LEVEL_TWO</unmanaged-short>
        LevelTwo = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>Specifies ACP is level three.</p> </dd>
        /// </summary>
        /// <doc-id>jj128346</doc-id>
        /// <unmanaged>MF_OPM_ACP_LEVEL_THREE</unmanaged>
        /// <unmanaged-short>MF_OPM_ACP_LEVEL_THREE</unmanaged-short>
        LevelThree = unchecked ((System.Int32)(3)),
        /// <summary>
        /// <dd> <p>Reserved.</p> </dd>
        /// </summary>
        /// <doc-id>jj128346</doc-id>
        /// <unmanaged>MF_OPM_ACP_FORCE_ULONG</unmanaged>
        /// <unmanaged-short>MF_OPM_ACP_FORCE_ULONG</unmanaged-short>
        ForceUlong = unchecked ((System.Int32)(2147483647))}

    /// <summary>
    /// <p>Defines protection levels for <strong>MFPROTECTION_CGMSA</strong>.</p>
    /// </summary>
    /// <remarks>
    /// <p>These flags are equivalent to the OPM_CGMSA_Protection_Level enumeration constants used in the Output Protection Protocol (OPM). </p>
    /// </remarks>
    /// <doc-id>jj128347</doc-id>
    /// <unmanaged>MF_OPM_CGMSA_PROTECTION_LEVEL</unmanaged>
    /// <unmanaged-short>MF_OPM_CGMSA_PROTECTION_LEVEL</unmanaged-short>
    public enum OpmCgmsaProtectionLevel : System.Int32
    {
        /// <summary>
        /// <dd> <p>CGMS-A is disabled.</p> </dd>
        /// </summary>
        /// <doc-id>jj128347</doc-id>
        /// <unmanaged>MF_OPM_CGMSA_OFF</unmanaged>
        /// <unmanaged-short>MF_OPM_CGMSA_OFF</unmanaged-short>
        Off = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>The protection level is Copy Freely.</p> </dd>
        /// </summary>
        /// <doc-id>jj128347</doc-id>
        /// <unmanaged>MF_OPM_CGMSA_COPY_FREELY</unmanaged>
        /// <unmanaged-short>MF_OPM_CGMSA_COPY_FREELY</unmanaged-short>
        CopyFreely = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>The protection level is Copy No More.</p> </dd>
        /// </summary>
        /// <doc-id>jj128347</doc-id>
        /// <unmanaged>MF_OPM_CGMSA_COPY_NO_MORE</unmanaged>
        /// <unmanaged-short>MF_OPM_CGMSA_COPY_NO_MORE</unmanaged-short>
        CopyNoMore = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>The protection level is Copy One Generation.</p> </dd>
        /// </summary>
        /// <doc-id>jj128347</doc-id>
        /// <unmanaged>MF_OPM_CGMSA_COPY_ONE_GENERATION</unmanaged>
        /// <unmanaged-short>MF_OPM_CGMSA_COPY_ONE_GENERATION</unmanaged-short>
        CopyOneGeneration = unchecked ((System.Int32)(3)),
        /// <summary>
        /// <dd> <p>The protection level is Copy Never.</p> </dd>
        /// </summary>
        /// <doc-id>jj128347</doc-id>
        /// <unmanaged>MF_OPM_CGMSA_COPY_NEVER</unmanaged>
        /// <unmanaged-short>MF_OPM_CGMSA_COPY_NEVER</unmanaged-short>
        CopyNever = unchecked ((System.Int32)(4)),
        /// <summary>
        /// <dd> <p>Redistribution control (also called the broadcast flag) is required. This flag can be combined with the other flags.</p> </dd>
        /// </summary>
        /// <doc-id>jj128347</doc-id>
        /// <unmanaged>MF_OPM_CGMSA_REDISTRIBUTION_CONTROL_REQUIRED</unmanaged>
        /// <unmanaged-short>MF_OPM_CGMSA_REDISTRIBUTION_CONTROL_REQUIRED</unmanaged-short>
        RedistributionControlRequired = unchecked ((System.Int32)(8))}

    /// <summary>
    /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Defines event types for the <strong><see cref = "SharpDX.MediaFoundation.PMediaPlayerCallback"/></strong> interface.</p>
    /// </summary>
    /// <remarks>
    /// <p>For each event type, the <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong> callback receives a reference to a data structure. The first part of the data structure is always an <strong><see cref = "SharpDX.MediaFoundation.PEventHeader"/></strong> structure. The following table lists the data structure for each event type.</p><p>In your implementation of <strong>OnMediaPlayerEvent</strong>, you must cast the <em>pEventHeader</em> parameter to the correct structure type. A set of macros is defined for this purpose. These macros check the value of the event type and return <strong><c>null</c></strong> if there is a mismatch; otherwise they return a reference to the correct structure type.</p><table> <tr><td><strong>Event type</strong></td><td> <p><strong>Event structure</strong></p> <p><strong>Pointer cast macro</strong></p> </td></tr> <tr><td>MFP_EVENT_TYPE_PLAY</td><td> <p> <strong><see cref = "SharpDX.MediaFoundation.PPlayEvent"/></strong> </p> <p> <strong>MFP_GET_PLAY_EVENT</strong> </p> </td></tr> <tr><td>MFP_EVENT_TYPE_PAUSE</td><td> <p> <strong><see cref = "SharpDX.MediaFoundation.PPauseEvent"/></strong> </p> <p> <strong>MFP_GET_PAUSE_EVENT</strong> </p> </td></tr> <tr><td>MFP_EVENT_TYPE_STOP</td><td> <p> <strong><see cref = "SharpDX.MediaFoundation.PStopEvent"/></strong> </p> <p> <strong>MFP_GET_STOP_EVENT</strong> </p> </td></tr> <tr><td>MFP_EVENT_TYPE_POSITION_SET</td><td> <p> <strong><see cref = "SharpDX.MediaFoundation.PPositionSetEvent"/></strong> </p> <p> <strong>MFP_GET_POSITION_SET_EVENT</strong> </p> </td></tr> <tr><td>MFP_EVENT_TYPE_RATE_SET</td><td> <p> <strong><see cref = "SharpDX.MediaFoundation.PRateSetEvent"/></strong> </p> <p> <strong>MFP_GET_RATE_SET_EVENT</strong> </p> </td></tr> <tr><td>MFP_EVENT_TYPE_MEDIAITEM_CREATED</td><td> <p> <strong><see cref = "SharpDX.MediaFoundation.PMediaItemCreateDEvent"/></strong> </p> <p> <strong>MFP_GET_MEDIAITEM_CREATED_EVENT</strong> </p> </td></tr> <tr><td>MFP_EVENT_TYPE_MEDIAITEM_SET</td><td> <p> <strong><see cref = "SharpDX.MediaFoundation.PMediaItemSetEvent"/></strong> </p> <p> <strong>MFP_GET_MEDIAITEM_SET_EVENT</strong> </p> </td></tr> <tr><td>MFP_EVENT_TYPE_FRAME_STEP</td><td> <p> <strong><see cref = "SharpDX.MediaFoundation.PFrameStepEvent"/></strong> </p> <p> <strong>MFP_GET_FRAME_STEP_EVENT</strong> </p> </td></tr> <tr><td>MFP_EVENT_TYPE_MEDIAITEM_CLEARED</td><td> <p> <strong><see cref = "SharpDX.MediaFoundation.PMediaItemClearedEvent"/></strong> </p> <p> <strong>MFP_GET_MEDIAITEM_CLEARED_EVENT</strong> </p> </td></tr> <tr><td>MFP_EVENT_TYPE_MF</td><td> <p> <strong><see cref = "SharpDX.MediaFoundation.PMfEvent"/></strong> </p> <p> <strong>MFP_GET_MF_EVENT</strong> </p> </td></tr> <tr><td>MFP_EVENT_TYPE_ERROR</td><td> <p> <strong><see cref = "SharpDX.MediaFoundation.PErrorEvent"/></strong> </p> <p> <strong>MFP_GET_ERROR_EVENT</strong> </p> </td></tr> <tr><td>MFP_EVENT_TYPE_PLAYBACK_ENDED</td><td> <p> <strong><see cref = "SharpDX.MediaFoundation.PPlaybackEndedEvent"/></strong> </p> <p> <strong>MFP_GET_PLAYBACK_ENDED_EVENT</strong> </p> </td></tr> <tr><td>MFP_EVENT_TYPE_ACQUIRE_USER_CREDENTIAL</td><td> <p> <strong><see cref = "SharpDX.MediaFoundation.PAcquireUserCredentialEvent"/></strong> </p> <p> <strong>MFP_GET_ACQUIRE_USER_CREDENTIAL_EVENT</strong> </p> </td></tr> </table><p>?</p>
    /// </remarks>
    /// <doc-id>dd375532</doc-id>
    /// <unmanaged>MFP_EVENT_TYPE</unmanaged>
    /// <unmanaged-short>MFP_EVENT_TYPE</unmanaged-short>
    public enum PEventType : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375532</doc-id>
        /// <unmanaged>MFP_EVENT_TYPE_PLAY</unmanaged>
        /// <unmanaged-short>MFP_EVENT_TYPE_PLAY</unmanaged-short>
        Play = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375532</doc-id>
        /// <unmanaged>MFP_EVENT_TYPE_PAUSE</unmanaged>
        /// <unmanaged-short>MFP_EVENT_TYPE_PAUSE</unmanaged-short>
        Pause = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375532</doc-id>
        /// <unmanaged>MFP_EVENT_TYPE_STOP</unmanaged>
        /// <unmanaged-short>MFP_EVENT_TYPE_STOP</unmanaged-short>
        Stop = unchecked ((System.Int32)(2)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375532</doc-id>
        /// <unmanaged>MFP_EVENT_TYPE_POSITION_SET</unmanaged>
        /// <unmanaged-short>MFP_EVENT_TYPE_POSITION_SET</unmanaged-short>
        PositionSet = unchecked ((System.Int32)(3)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375532</doc-id>
        /// <unmanaged>MFP_EVENT_TYPE_RATE_SET</unmanaged>
        /// <unmanaged-short>MFP_EVENT_TYPE_RATE_SET</unmanaged-short>
        RateSet = unchecked ((System.Int32)(4)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375532</doc-id>
        /// <unmanaged>MFP_EVENT_TYPE_MEDIAITEM_CREATED</unmanaged>
        /// <unmanaged-short>MFP_EVENT_TYPE_MEDIAITEM_CREATED</unmanaged-short>
        MediaItemCreateD = unchecked ((System.Int32)(5)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375532</doc-id>
        /// <unmanaged>MFP_EVENT_TYPE_MEDIAITEM_SET</unmanaged>
        /// <unmanaged-short>MFP_EVENT_TYPE_MEDIAITEM_SET</unmanaged-short>
        MediaItemSet = unchecked ((System.Int32)(6)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375532</doc-id>
        /// <unmanaged>MFP_EVENT_TYPE_FRAME_STEP</unmanaged>
        /// <unmanaged-short>MFP_EVENT_TYPE_FRAME_STEP</unmanaged-short>
        FrameStep = unchecked ((System.Int32)(7)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375532</doc-id>
        /// <unmanaged>MFP_EVENT_TYPE_MEDIAITEM_CLEARED</unmanaged>
        /// <unmanaged-short>MFP_EVENT_TYPE_MEDIAITEM_CLEARED</unmanaged-short>
        MediaItemCleared = unchecked ((System.Int32)(8)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375532</doc-id>
        /// <unmanaged>MFP_EVENT_TYPE_MF</unmanaged>
        /// <unmanaged-short>MFP_EVENT_TYPE_MF</unmanaged-short>
        Mf = unchecked ((System.Int32)(9)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375532</doc-id>
        /// <unmanaged>MFP_EVENT_TYPE_ERROR</unmanaged>
        /// <unmanaged-short>MFP_EVENT_TYPE_ERROR</unmanaged-short>
        Error = unchecked ((System.Int32)(10)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375532</doc-id>
        /// <unmanaged>MFP_EVENT_TYPE_PLAYBACK_ENDED</unmanaged>
        /// <unmanaged-short>MFP_EVENT_TYPE_PLAYBACK_ENDED</unmanaged-short>
        PlaybackEnded = unchecked ((System.Int32)(11)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375532</doc-id>
        /// <unmanaged>MFP_EVENT_TYPE_ACQUIRE_USER_CREDENTIAL</unmanaged>
        /// <unmanaged-short>MFP_EVENT_TYPE_ACQUIRE_USER_CREDENTIAL</unmanaged-short>
        AcquireUserCredential = unchecked ((System.Int32)(12))}

    /// <summary>
    /// <p>Defines policy settings for the <strong>IMFPluginControl2::SetPolicy</strong> method.</p>
    /// </summary>
    /// <doc-id>hh162881</doc-id>
    /// <unmanaged>MF_PLUGIN_CONTROL_POLICY</unmanaged>
    /// <unmanaged-short>MF_PLUGIN_CONTROL_POLICY</unmanaged-short>
    public enum PluginControlPolicy : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh162881</doc-id>
        /// <unmanaged>MF_PLUGIN_CONTROL_POLICY_USE_ALL_PLUGINS</unmanaged>
        /// <unmanaged-short>MF_PLUGIN_CONTROL_POLICY_USE_ALL_PLUGINS</unmanaged-short>
        UseAllPlugins = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh162881</doc-id>
        /// <unmanaged>MF_PLUGIN_CONTROL_POLICY_USE_APPROVED_PLUGINS</unmanaged>
        /// <unmanaged-short>MF_PLUGIN_CONTROL_POLICY_USE_APPROVED_PLUGINS</unmanaged-short>
        UseApprovedPlugins = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh162881</doc-id>
        /// <unmanaged>MF_PLUGIN_CONTROL_POLICY_USE_WEB_PLUGINS</unmanaged>
        /// <unmanaged-short>MF_PLUGIN_CONTROL_POLICY_USE_WEB_PLUGINS</unmanaged-short>
        UseWebPlugins = unchecked ((System.Int32)(2)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh162881</doc-id>
        /// <unmanaged>MF_PLUGIN_CONTROL_POLICY_USE_WEB_PLUGINS_EDGEMODE</unmanaged>
        /// <unmanaged-short>MF_PLUGIN_CONTROL_POLICY_USE_WEB_PLUGINS_EDGEMODE</unmanaged-short>
        UseWebPluginsEdgemode = unchecked ((System.Int32)(3))}

    /// <summary>
    /// <p>Specifies the object type for the <strong><see cref = "SharpDX.MediaFoundation.PluginControl"/></strong> interface.</p>
    /// </summary>
    /// <doc-id>dd375763</doc-id>
    /// <unmanaged>MF_Plugin_Type</unmanaged>
    /// <unmanaged-short>MF_Plugin_Type</unmanaged-short>
    public enum PluginType : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375763</doc-id>
        /// <unmanaged>MF_Plugin_Type_MFT</unmanaged>
        /// <unmanaged-short>MF_Plugin_Type_MFT</unmanaged-short>
        Mft = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375763</doc-id>
        /// <unmanaged>MF_Plugin_Type_MediaSource</unmanaged>
        /// <unmanaged-short>MF_Plugin_Type_MediaSource</unmanaged-short>
        MediaSource = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375763</doc-id>
        /// <unmanaged>MF_Plugin_Type_MFT_MatchOutputType</unmanaged>
        /// <unmanaged-short>MF_Plugin_Type_MFT_MatchOutputType</unmanaged-short>
        MftMatchOutputType = unchecked ((System.Int32)(2)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375763</doc-id>
        /// <unmanaged>MF_Plugin_Type_Other</unmanaged>
        /// <unmanaged-short>MF_Plugin_Type_Other</unmanaged-short>
        Other = unchecked ((System.Int32)(-1))}

    /// <summary>
    /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Specifies the current playback state.</p>
    /// </summary>
    /// <doc-id>dd375562</doc-id>
    /// <unmanaged>MFP_MEDIAPLAYER_STATE</unmanaged>
    /// <unmanaged-short>MFP_MEDIAPLAYER_STATE</unmanaged-short>
    public enum PMediaPlayerState : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375562</doc-id>
        /// <unmanaged>MFP_MEDIAPLAYER_STATE_EMPTY</unmanaged>
        /// <unmanaged-short>MFP_MEDIAPLAYER_STATE_EMPTY</unmanaged-short>
        Empty = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375562</doc-id>
        /// <unmanaged>MFP_MEDIAPLAYER_STATE_STOPPED</unmanaged>
        /// <unmanaged-short>MFP_MEDIAPLAYER_STATE_STOPPED</unmanaged-short>
        Stopped = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375562</doc-id>
        /// <unmanaged>MFP_MEDIAPLAYER_STATE_PLAYING</unmanaged>
        /// <unmanaged-short>MFP_MEDIAPLAYER_STATE_PLAYING</unmanaged-short>
        Playing = unchecked ((System.Int32)(2)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375562</doc-id>
        /// <unmanaged>MFP_MEDIAPLAYER_STATE_PAUSED</unmanaged>
        /// <unmanaged-short>MFP_MEDIAPLAYER_STATE_PAUSED</unmanaged-short>
        Paused = unchecked ((System.Int32)(3)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375562</doc-id>
        /// <unmanaged>MFP_MEDIAPLAYER_STATE_SHUTDOWN</unmanaged>
        /// <unmanaged-short>MFP_MEDIAPLAYER_STATE_SHUTDOWN</unmanaged-short>
        Shutdown = unchecked ((System.Int32)(4))}

    [System.FlagsAttribute]
    /// <summary>
    /// <p> Contains flags that define the behavior of the <strong>MFCreatePMPMediaSession</strong> function. </p>
    /// </summary>
    /// <doc-id>ms697495</doc-id>
    /// <unmanaged>MFPMPSESSION_CREATION_FLAGS</unmanaged>
    /// <unmanaged-short>MFPMPSESSION_CREATION_FLAGS</unmanaged-short>
    public enum PmpsessionCreationFlags : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697495</doc-id>
        /// <unmanaged>MFPMPSESSION_UNPROTECTED_PROCESS</unmanaged>
        /// <unmanaged-short>MFPMPSESSION_UNPROTECTED_PROCESS</unmanaged-short>
        UnprotectedProcess = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697495</doc-id>
        /// <unmanaged>MFPMPSESSION_IN_PROCESS</unmanaged>
        /// <unmanaged-short>MFPMPSESSION_IN_PROCESS</unmanaged-short>
        InProcess = unchecked ((System.Int32)(2)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    /// <summary>
    /// <p> </p><p>Defines actions that can be performed on a stream.</p>
    /// </summary>
    /// <doc-id>ms698977</doc-id>
    /// <unmanaged>MFPOLICYMANAGER_ACTION</unmanaged>
    /// <unmanaged-short>MFPOLICYMANAGER_ACTION</unmanaged-short>
    public enum PolicymanagerAction : System.Int32
    {
        /// <summary>
        /// <dd> <p>No action.</p> </dd>
        /// </summary>
        /// <doc-id>ms698977</doc-id>
        /// <unmanaged>PEACTION_NO</unmanaged>
        /// <unmanaged-short>PEACTION_NO</unmanaged-short>
        PeactionNo = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>Play the stream.</p> </dd>
        /// </summary>
        /// <doc-id>ms698977</doc-id>
        /// <unmanaged>PEACTION_PLAY</unmanaged>
        /// <unmanaged-short>PEACTION_PLAY</unmanaged-short>
        PeactionPlay = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>Copy the stream.</p> </dd>
        /// </summary>
        /// <doc-id>ms698977</doc-id>
        /// <unmanaged>PEACTION_COPY</unmanaged>
        /// <unmanaged-short>PEACTION_COPY</unmanaged-short>
        PeactionCopy = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>Export the stream to another format.</p> </dd>
        /// </summary>
        /// <doc-id>ms698977</doc-id>
        /// <unmanaged>PEACTION_EXPORT</unmanaged>
        /// <unmanaged-short>PEACTION_EXPORT</unmanaged-short>
        PeactionExport = unchecked ((System.Int32)(3)),
        /// <summary>
        /// <dd> <p>Extract the data from the stream and pass it to the application. For example, acoustic echo cancellation requires this action.</p> </dd>
        /// </summary>
        /// <doc-id>ms698977</doc-id>
        /// <unmanaged>PEACTION_EXTRACT</unmanaged>
        /// <unmanaged-short>PEACTION_EXTRACT</unmanaged-short>
        PeactionExtract = unchecked ((System.Int32)(4)),
        /// <summary>
        /// <dd> <p>Reserved.</p> </dd>
        /// </summary>
        /// <doc-id>ms698977</doc-id>
        /// <unmanaged>PEACTION_RESERVED1</unmanaged>
        /// <unmanaged-short>PEACTION_RESERVED1</unmanaged-short>
        PeactionReserved1 = unchecked ((System.Int32)(5)),
        /// <summary>
        /// <dd> <p>Reserved.</p> </dd>
        /// </summary>
        /// <doc-id>ms698977</doc-id>
        /// <unmanaged>PEACTION_RESERVED2</unmanaged>
        /// <unmanaged-short>PEACTION_RESERVED2</unmanaged-short>
        PeactionReserved2 = unchecked ((System.Int32)(6)),
        /// <summary>
        /// <dd> <p>Reserved.</p> </dd>
        /// </summary>
        /// <doc-id>ms698977</doc-id>
        /// <unmanaged>PEACTION_RESERVED3</unmanaged>
        /// <unmanaged-short>PEACTION_RESERVED3</unmanaged-short>
        PeactionReserved3 = unchecked ((System.Int32)(7)),
        /// <summary>
        /// <dd> <p>Last member of the enumeration.</p> </dd>
        /// </summary>
        /// <doc-id>ms698977</doc-id>
        /// <unmanaged>PEACTION_LAST</unmanaged>
        /// <unmanaged-short>PEACTION_LAST</unmanaged-short>
        PeactionLast = unchecked ((System.Int32)(7))}

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>__MIDL___MIDL_itf_mfcaptureengine_0000_0000_0001</unmanaged>
    /// <unmanaged-short>__MIDL___MIDL_itf_mfcaptureengine_0000_0000_0001</unmanaged-short>
    public enum PreferredMediaStream : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_VIDEO_PREVIEW</unmanaged>
        /// <unmanaged-short>MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_VIDEO_PREVIEW</unmanaged-short>
        VIDEO_PREVIEW = unchecked ((System.Int32)(-6)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_VIDEO_RECORD</unmanaged>
        /// <unmanaged-short>MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_VIDEO_RECORD</unmanaged-short>
        VIDEO_RECORD = unchecked ((System.Int32)(-7)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_PHOTO</unmanaged>
        /// <unmanaged-short>MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_PHOTO</unmanaged-short>
        PHOTO = unchecked ((System.Int32)(-8)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_AUDIO</unmanaged>
        /// <unmanaged-short>MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_AUDIO</unmanaged-short>
        AUDIO = unchecked ((System.Int32)(-9)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_CAPTURE_ENGINE_MEDIASOURCE</unmanaged>
        /// <unmanaged-short>MF_CAPTURE_ENGINE_MEDIASOURCE</unmanaged-short>
        MfCaptureEngineMediaSource = unchecked ((System.Int32)(-1))}

    [System.FlagsAttribute]
    /// <summary>
    /// <p>Contains flags for the <strong>IMFQualityAdvise2::NotifyQualityEvent</strong> method.</p>
    /// </summary>
    /// <remarks>
    /// <p>If the decoder sets the <strong>MF_QUALITY_CANNOT_KEEP_UP</strong> flag, the quality manager tries to reduce latency through the media source and the media sink. For example, it might request the Enhanced Video Renderer (EVR) to drop frames. During this period, the quality manager stops calling the decoder's <strong>IMFQualityAdvise2::NotifyQualityEvent</strong> method, until samples are no longer arriving late at the sink. At that point, the quality manager resumes calling <strong>NotifyQualityEvent</strong> on the decoder.</p>
    /// </remarks>
    /// <doc-id>dd743824</doc-id>
    /// <unmanaged>MF_QUALITY_ADVISE_FLAGS</unmanaged>
    /// <unmanaged-short>MF_QUALITY_ADVISE_FLAGS</unmanaged-short>
    public enum QualityAdviseFlags : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd743824</doc-id>
        /// <unmanaged>MF_QUALITY_CANNOT_KEEP_UP</unmanaged>
        /// <unmanaged-short>MF_QUALITY_CANNOT_KEEP_UP</unmanaged-short>
        CannotKeepUp = unchecked ((System.Int32)(1)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    /// <summary>
    /// <p> </p><p>Specifies how aggressively a pipeline component should drop samples.</p>
    /// </summary>
    /// <remarks>
    /// <p>In drop mode, a component drops samples, more or less aggressively depending on the level of the drop mode. The specific algorithm used depends on the component. Mode 1 is the least aggressive mode, and mode 5 is the most aggressive. A component is not required to implement all five levels.</p><p>For example, suppose an encoded video stream has three B-frames between each pair of P-frames. A decoder might implement the following drop modes:</p><ul> <li> <p>Mode 1: Drop one out of every three B frames.</p> </li> <li> <p>Mode 2: Drop one out of every two B frames.</p> </li> <li> <p>Mode 3: Drop all delta frames.</p> </li> <li> <p>Modes 4 and 5: Unsupported.</p> </li> </ul><p>The enhanced video renderer (EVR) can drop video frames before sending them to the EVR mixer.</p>
    /// </remarks>
    /// <doc-id>ms704659</doc-id>
    /// <unmanaged>MF_QUALITY_DROP_MODE</unmanaged>
    /// <unmanaged-short>MF_QUALITY_DROP_MODE</unmanaged-short>
    public enum QualityDropMode : System.Int32
    {
        /// <summary>
        /// <dd> <p>Normal processing of samples. Drop mode is disabled.</p> </dd>
        /// </summary>
        /// <doc-id>ms704659</doc-id>
        /// <unmanaged>MF_DROP_MODE_NONE</unmanaged>
        /// <unmanaged-short>MF_DROP_MODE_NONE</unmanaged-short>
        MfDropModeNone = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>First drop mode (least aggressive).</p> </dd>
        /// </summary>
        /// <doc-id>ms704659</doc-id>
        /// <unmanaged>MF_DROP_MODE_1</unmanaged>
        /// <unmanaged-short>MF_DROP_MODE_1</unmanaged-short>
        MfDropMode1 = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>Second drop mode.</p> </dd>
        /// </summary>
        /// <doc-id>ms704659</doc-id>
        /// <unmanaged>MF_DROP_MODE_2</unmanaged>
        /// <unmanaged-short>MF_DROP_MODE_2</unmanaged-short>
        MfDropMode2 = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>Third drop mode.</p> </dd>
        /// </summary>
        /// <doc-id>ms704659</doc-id>
        /// <unmanaged>MF_DROP_MODE_3</unmanaged>
        /// <unmanaged-short>MF_DROP_MODE_3</unmanaged-short>
        MfDropMode3 = unchecked ((System.Int32)(3)),
        /// <summary>
        /// <dd> <p>Fourth drop mode.</p> </dd>
        /// </summary>
        /// <doc-id>ms704659</doc-id>
        /// <unmanaged>MF_DROP_MODE_4</unmanaged>
        /// <unmanaged-short>MF_DROP_MODE_4</unmanaged-short>
        MfDropMode4 = unchecked ((System.Int32)(4)),
        /// <summary>
        /// <dd> <p>Fifth drop mode (most aggressive, if it is supported; see Remarks).</p> </dd>
        /// </summary>
        /// <doc-id>ms704659</doc-id>
        /// <unmanaged>MF_DROP_MODE_5</unmanaged>
        /// <unmanaged-short>MF_DROP_MODE_5</unmanaged-short>
        MfDropMode5 = unchecked ((System.Int32)(5)),
        /// <summary>
        /// <dd> <p>Maximum number of drop modes. This value is not a valid flag.</p> </dd>
        /// </summary>
        /// <doc-id>ms704659</doc-id>
        /// <unmanaged>MF_NUM_DROP_MODES</unmanaged>
        /// <unmanaged-short>MF_NUM_DROP_MODES</unmanaged-short>
        MfNumDropModes = unchecked ((System.Int32)(6))}

    /// <summary>
    /// <p>Specifies the quality level for a pipeline component. The quality level determines how the component consumes or produces samples.</p>
    /// </summary>
    /// <remarks>
    /// <p> Each successive quality level decreases the amount of processing that is needed, while also reducing the resulting quality of the audio or video. The specific algorithm used to reduce quality depends on the component. Mode 1 is the least aggressive mode, and mode 5 is the most aggressive. A component is not required to implement all five levels. Also, the same quality level might not be comparable between two different components. </p><p> Video decoders can often reduce quality by leaving out certain post-processing steps. The enhanced video renderer (EVR) can sometimes reduce quality by switching to a different deinterlacing mode. </p>
    /// </remarks>
    /// <doc-id>ms698949</doc-id>
    /// <unmanaged>MF_QUALITY_LEVEL</unmanaged>
    /// <unmanaged-short>MF_QUALITY_LEVEL</unmanaged-short>
    public enum QualityLevel : System.Int32
    {
        /// <summary>
        /// <dd> <p> Normal quality. </p> </dd>
        /// </summary>
        /// <doc-id>ms698949</doc-id>
        /// <unmanaged>MF_QUALITY_NORMAL</unmanaged>
        /// <unmanaged-short>MF_QUALITY_NORMAL</unmanaged-short>
        MfQualityNormal = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p> One level below normal quality. </p> </dd>
        /// </summary>
        /// <doc-id>ms698949</doc-id>
        /// <unmanaged>MF_QUALITY_NORMAL_MINUS_1</unmanaged>
        /// <unmanaged-short>MF_QUALITY_NORMAL_MINUS_1</unmanaged-short>
        MfQualityNormalMinus1 = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p> Two levels below normal quality. </p> </dd>
        /// </summary>
        /// <doc-id>ms698949</doc-id>
        /// <unmanaged>MF_QUALITY_NORMAL_MINUS_2</unmanaged>
        /// <unmanaged-short>MF_QUALITY_NORMAL_MINUS_2</unmanaged-short>
        MfQualityNormalMinus2 = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p> Three levels below normal quality. </p> </dd>
        /// </summary>
        /// <doc-id>ms698949</doc-id>
        /// <unmanaged>MF_QUALITY_NORMAL_MINUS_3</unmanaged>
        /// <unmanaged-short>MF_QUALITY_NORMAL_MINUS_3</unmanaged-short>
        MfQualityNormalMinus3 = unchecked ((System.Int32)(3)),
        /// <summary>
        /// <dd> <p> Four levels below normal quality. </p> </dd>
        /// </summary>
        /// <doc-id>ms698949</doc-id>
        /// <unmanaged>MF_QUALITY_NORMAL_MINUS_4</unmanaged>
        /// <unmanaged-short>MF_QUALITY_NORMAL_MINUS_4</unmanaged-short>
        MfQualityNormalMinus4 = unchecked ((System.Int32)(4)),
        /// <summary>
        /// <dd> <p> Five levels below normal quality. </p> </dd>
        /// </summary>
        /// <doc-id>ms698949</doc-id>
        /// <unmanaged>MF_QUALITY_NORMAL_MINUS_5</unmanaged>
        /// <unmanaged-short>MF_QUALITY_NORMAL_MINUS_5</unmanaged-short>
        MfQualityNormalMinus5 = unchecked ((System.Int32)(5)),
        /// <summary>
        /// <dd> <p> Maximum number of quality levels. This value is not a valid flag. </p> </dd>
        /// </summary>
        /// <doc-id>ms698949</doc-id>
        /// <unmanaged>MF_NUM_QUALITY_LEVELS</unmanaged>
        /// <unmanaged-short>MF_NUM_QUALITY_LEVELS</unmanaged-short>
        MfNumQualityLevels = unchecked ((System.Int32)(6))}

    /// <summary>
    /// <p> </p><p>Specifies the direction of playback (forward or reverse).</p>
    /// </summary>
    /// <doc-id>ms696225</doc-id>
    /// <unmanaged>MFRATE_DIRECTION</unmanaged>
    /// <unmanaged-short>MFRATE_DIRECTION</unmanaged-short>
    public enum RateDirection : System.Int32
    {
        /// <summary>
        /// <dd> <p>Forward playback.</p> </dd>
        /// </summary>
        /// <doc-id>ms696225</doc-id>
        /// <unmanaged>MFRATE_FORWARD</unmanaged>
        /// <unmanaged-short>MFRATE_FORWARD</unmanaged-short>
        Forward = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>Reverse playback.</p> </dd>
        /// </summary>
        /// <doc-id>ms696225</doc-id>
        /// <unmanaged>MFRATE_REVERSE</unmanaged>
        /// <unmanaged-short>MFRATE_REVERSE</unmanaged-short>
        Reverse = unchecked ((System.Int32)(1))}

    /// <summary>
    /// <p>Specifies the supported protection schemes for encrypted samples.</p>
    /// </summary>
    /// <remarks>
    /// <p>The encryption scheme for a sample is specified using the MFSampleExtension_Encryption_ProtectionScheme attribute.</p>
    /// </remarks>
    /// <doc-id>mt804350</doc-id>
    /// <unmanaged>MFSampleEncryptionProtectionScheme</unmanaged>
    /// <unmanaged-short>MFSampleEncryptionProtectionScheme</unmanaged-short>
    public enum SampleEncryptionProtectionScheme : System.Int32
    {
        /// <summary>
        /// <dd> <p>No encryption scheme.</p> </dd>
        /// </summary>
        /// <doc-id>mt804350</doc-id>
        /// <unmanaged>MF_SAMPLE_ENCRYPTION_PROTECTION_SCHEME_NONE</unmanaged>
        /// <unmanaged-short>MF_SAMPLE_ENCRYPTION_PROTECTION_SCHEME_NONE</unmanaged-short>
        MfSampleEncryptionProtectionSchemeNone = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>The encryption scheme is AES counter mode (CTR).</p> </dd>
        /// </summary>
        /// <doc-id>mt804350</doc-id>
        /// <unmanaged>MF_SAMPLE_ENCRYPTION_PROTECTION_SCHEME_AES_CTR</unmanaged>
        /// <unmanaged-short>MF_SAMPLE_ENCRYPTION_PROTECTION_SCHEME_AES_CTR</unmanaged-short>
        MfSampleEncryptionProtectionSchemeAesCtr = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>The encryption scheme is Cipher Block Chaining (CBC).</p> </dd>
        /// </summary>
        /// <doc-id>mt804350</doc-id>
        /// <unmanaged>MF_SAMPLE_ENCRYPTION_PROTECTION_SCHEME_AES_CBC</unmanaged>
        /// <unmanaged-short>MF_SAMPLE_ENCRYPTION_PROTECTION_SCHEME_AES_CBC</unmanaged-short>
        MfSampleEncryptionProtectionSchemeAesCbc = unchecked ((System.Int32)(2))}

    /// <summary>
    /// <p> </p><p>Defines the version number for sample protection.</p>
    /// </summary>
    /// <doc-id>ms697061</doc-id>
    /// <unmanaged>SAMPLE_PROTECTION_VERSION</unmanaged>
    /// <unmanaged-short>SAMPLE_PROTECTION_VERSION</unmanaged-short>
    public enum SampleProtectionVersion : System.Int32
    {
        /// <summary>
        /// <dd> <p>No sample protection.</p> </dd>
        /// </summary>
        /// <doc-id>ms697061</doc-id>
        /// <unmanaged>SAMPLE_PROTECTION_VERSION_NO</unmanaged>
        /// <unmanaged-short>SAMPLE_PROTECTION_VERSION_NO</unmanaged-short>
        No = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>Version 1.</p> </dd>
        /// </summary>
        /// <doc-id>ms697061</doc-id>
        /// <unmanaged>SAMPLE_PROTECTION_VERSION_BASIC_LOKI</unmanaged>
        /// <unmanaged-short>SAMPLE_PROTECTION_VERSION_BASIC_LOKI</unmanaged-short>
        BasicLoki = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>Version 2.</p> </dd>
        /// </summary>
        /// <doc-id>ms697061</doc-id>
        /// <unmanaged>SAMPLE_PROTECTION_VERSION_SCATTER</unmanaged>
        /// <unmanaged-short>SAMPLE_PROTECTION_VERSION_SCATTER</unmanaged-short>
        Scatter = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>Version 3.</p> </dd>
        /// </summary>
        /// <doc-id>ms697061</doc-id>
        /// <unmanaged>SAMPLE_PROTECTION_VERSION_RC4</unmanaged>
        /// <unmanaged-short>SAMPLE_PROTECTION_VERSION_RC4</unmanaged-short>
        Rc4 = unchecked ((System.Int32)(3)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697061</doc-id>
        /// <unmanaged>SAMPLE_PROTECTION_VERSION_AES128CTR</unmanaged>
        /// <unmanaged-short>SAMPLE_PROTECTION_VERSION_AES128CTR</unmanaged-short>
        Aes128ctr = unchecked ((System.Int32)(4))}

    /// <summary>
    /// <p>Specifies how a video stream is interlaced.</p><p>In the descriptions that follow, upper field refers to the field that contains the leading half scan line. Lower field refers to the field that contains the first full scan line.</p>
    /// </summary>
    /// <remarks>
    /// <p>Scan lines in the lower field are 0.5 scan line lower than those in the upper field. In NTSC television, a frame consists of a lower field followed by an upper field. In PAL television, a frame consists of an upper field followed by a lower field.</p><p>The upper field is also called the even field, the top field, or field 2. The lower field is also called the odd field, the bottom field, or field 1.</p><p>If the interlace mode is MFVideoInterlace_FieldSingleUpper or MFVideoInterlace_FieldSingleLower, each sample contains a single field, so each buffer contains only half the number of field lines given in the media type.</p>
    /// </remarks>
    /// <doc-id>ms694269</doc-id>
    /// <unmanaged>MFSensorDeviceMode</unmanaged>
    /// <unmanaged-short>MFSensorDeviceMode</unmanaged-short>
    public enum SensorDeviceMode : System.Int32
    {
        /// <summary>
        /// <dd> <p> The type of interlacing is not known. </p> </dd>
        /// </summary>
        /// <doc-id>ms694269</doc-id>
        /// <unmanaged>MFSensorDeviceMode_Controller</unmanaged>
        /// <unmanaged-short>MFSensorDeviceMode_Controller</unmanaged-short>
        Controller = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p> Progressive frames. </p> </dd>
        /// </summary>
        /// <doc-id>ms694269</doc-id>
        /// <unmanaged>MFSensorDeviceMode_Shared</unmanaged>
        /// <unmanaged-short>MFSensorDeviceMode_Shared</unmanaged-short>
        Shared = unchecked ((System.Int32)(1))}

    /// <summary>
    /// <p> </p><p>Specifies how to open or create a file.</p>
    /// </summary>
    /// <doc-id>ms694164</doc-id>
    /// <unmanaged>MFSensorDeviceType</unmanaged>
    /// <unmanaged-short>MFSensorDeviceType</unmanaged-short>
    public enum SensorDeviceType : System.Int32
    {
        /// <summary>
        /// <dd> <p>Open an existing file. Fail if the file does not exist.</p> </dd>
        /// </summary>
        /// <doc-id>ms694164</doc-id>
        /// <unmanaged>MFSensorDeviceType_Unknown</unmanaged>
        /// <unmanaged-short>MFSensorDeviceType_Unknown</unmanaged-short>
        Unknown = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>Create a new file. Fail if the file already exists.</p> </dd>
        /// </summary>
        /// <doc-id>ms694164</doc-id>
        /// <unmanaged>MFSensorDeviceType_Device</unmanaged>
        /// <unmanaged-short>MFSensorDeviceType_Device</unmanaged-short>
        Device = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>Open an existing file and truncate it, so that the size is zero bytes. Fail if the file does not already exist.</p> </dd>
        /// </summary>
        /// <doc-id>ms694164</doc-id>
        /// <unmanaged>MFSensorDeviceType_MediaSource</unmanaged>
        /// <unmanaged-short>MFSensorDeviceType_MediaSource</unmanaged-short>
        MediaSource = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>If the file does not exist, create a new file. If the file exists, open it.</p> </dd>
        /// </summary>
        /// <doc-id>ms694164</doc-id>
        /// <unmanaged>MFSensorDeviceType_FrameProvider</unmanaged>
        /// <unmanaged-short>MFSensorDeviceType_FrameProvider</unmanaged-short>
        FrameProvider = unchecked ((System.Int32)(3)),
        /// <summary>
        /// <dd> <p>Create a new file. If the file exists, overwrite the file.</p> </dd>
        /// </summary>
        /// <doc-id>ms694164</doc-id>
        /// <unmanaged>MFSensorDeviceType_SensorTransform</unmanaged>
        /// <unmanaged-short>MFSensorDeviceType_SensorTransform</unmanaged-short>
        SensorTransform = unchecked ((System.Int32)(4))}

    /// <summary>
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Specifies whether a stream associated with an <strong><see cref = "SharpDX.MediaFoundation.SensorDevice"/></strong> is an input or an output stream.</p>
    /// </summary>
    /// <doc-id>mt797984</doc-id>
    /// <unmanaged>MFSensorStreamType</unmanaged>
    /// <unmanaged-short>MFSensorStreamType</unmanaged-short>
    public enum SensorStreamType : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>mt797984</doc-id>
        /// <unmanaged>MFSensorStreamType_Unknown</unmanaged>
        /// <unmanaged-short>MFSensorStreamType_Unknown</unmanaged-short>
        Unknown = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>mt797984</doc-id>
        /// <unmanaged>MFSensorStreamType_Input</unmanaged>
        /// <unmanaged-short>MFSensorStreamType_Input</unmanaged-short>
        Input = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>mt797984</doc-id>
        /// <unmanaged>MFSensorStreamType_Output</unmanaged>
        /// <unmanaged-short>MFSensorStreamType_Output</unmanaged-short>
        Output = unchecked ((System.Int32)(2))}

    /// <summary>
    /// <p> </p><p>Contains flags for adding a topology to the sequencer source, or updating a topology already in the queue.</p>
    /// </summary>
    /// <doc-id>ms703884</doc-id>
    /// <unmanaged>MFSequencerTopologyFlags</unmanaged>
    /// <unmanaged-short>MFSequencerTopologyFlags</unmanaged-short>
    public enum SequencerTopologyFlags : System.Int32
    {
        /// <summary>
        /// <dd> <p>This topology is the last topology in the sequence.</p> </dd>
        /// </summary>
        /// <doc-id>ms703884</doc-id>
        /// <unmanaged>SequencerTopologyFlags_Last</unmanaged>
        /// <unmanaged-short>SequencerTopologyFlags_Last</unmanaged-short>
        SequencerTopologyFlagsLast = unchecked ((System.Int32)(1))}

    /// <summary>
    /// <p> </p><p>Retrieves an interface from the enhanced video renderer (EVR), or from the video mixer or video presenter.</p>
    /// </summary>
    /// <remarks>
    /// <p>This method can be called only from inside the <strong>IMFTopologyServiceLookupClient::InitServicePointers</strong> method. At any other time, the method returns <see cref = "NotAccepting"/>.</p><p>The presenter can use this method to query the EVR and the mixer. The mixer can use it to query the EVR and the presenter. Which objects are queried depends on the caller and the service <see cref = "System.Guid"/>, as shown in the following table.</p><table> <tr><th>Caller</th><th>Service <see cref = "System.Guid"/></th><th>Objects queried</th></tr> <tr><td>Presenter</td><td>MR_VIDEO_RENDER_SERVICE</td><td>EVR</td></tr> <tr><td>Presenter</td><td>MR_VIDEO_MIXER_SERVICE</td><td>Mixer</td></tr> <tr><td>Mixer</td><td>MR_VIDEO_RENDER_SERVICE</td><td>Presenter and EVR</td></tr> </table><p>?</p><p>The following interfaces are available from the EVR:</p><ul> <li> <p><strong>IMediaEventSink</strong>. This interface is documented in the DirectShow SDK documentation.</p> </li> <li> <p> <strong><see cref = "SharpDX.MediaFoundation.Clock"/></strong> interface. This interface is available if the EVR has access to a clock (reference clock in DirectShow or presentation clock in Media Foundation). This interface might not be available. Presenter and mixers must be able to process data without a clock. If the <strong><see cref = "SharpDX.MediaFoundation.Clock"/></strong> interface is available, you can also get these related interfaces:</p> <ul> <li> <p> <strong><see cref = "SharpDX.MediaFoundation.Timer"/></strong> </p> </li> <li> <p> <strong><see cref = "SharpDX.MediaFoundation.PresentationClock"/></strong> (Media Foundation EVR only)</p> </li> </ul> </li> </ul><p>The following interfaces are available from the mixer:</p><ul> <li> <p> <strong><see cref = "SharpDX.MediaFoundation.Transform"/></strong> </p> </li> <li> <p> <strong><see cref = "SharpDX.MediaFoundation.VideoDeviceID"/></strong> </p> </li> </ul>
    /// </remarks>
    /// <doc-id>bb970504</doc-id>
    /// <unmanaged>MF_SERVICE_LOOKUP_TYPE</unmanaged>
    /// <unmanaged-short>MF_SERVICE_LOOKUP_TYPE</unmanaged-short>
    public enum ServiceLookupType : System.Int32
    {
        /// <summary>
        /// <dd> <p>Specifies the scope of the search. Currently this parameter is ignored. Use the value MF_SERVICE_LOOKUP_GLOBAL.</p> </dd>
        /// </summary>
        /// <doc-id>bb970504</doc-id>
        /// <unmanaged>MF_SERVICE_LOOKUP_UPSTREAM</unmanaged>
        /// <unmanaged-short>MF_SERVICE_LOOKUP_UPSTREAM</unmanaged-short>
        Upstream = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>Reserved, must be zero.</p> </dd>
        /// </summary>
        /// <doc-id>bb970504</doc-id>
        /// <unmanaged>MF_SERVICE_LOOKUP_UPSTREAM_DIRECT</unmanaged>
        /// <unmanaged-short>MF_SERVICE_LOOKUP_UPSTREAM_DIRECT</unmanaged-short>
        UpstreamDirect = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>Service <see cref = "System.Guid"/> of the requested interface.</p> </dd>
        /// </summary>
        /// <doc-id>bb970504</doc-id>
        /// <unmanaged>MF_SERVICE_LOOKUP_DOWNSTREAM</unmanaged>
        /// <unmanaged-short>MF_SERVICE_LOOKUP_DOWNSTREAM</unmanaged-short>
        Downstream = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>Interface identifier of the requested interface.</p> </dd>
        /// </summary>
        /// <doc-id>bb970504</doc-id>
        /// <unmanaged>MF_SERVICE_LOOKUP_DOWNSTREAM_DIRECT</unmanaged>
        /// <unmanaged-short>MF_SERVICE_LOOKUP_DOWNSTREAM_DIRECT</unmanaged-short>
        DownstreamDirect = unchecked ((System.Int32)(3)),
        /// <summary>
        /// <dd> <p>Array of interface references. If the method succeeds, each member of the array contains either a valid interface reference or <strong><c>null</c></strong>. The caller must release the interface references when the EVR calls <strong>IMFTopologyServiceLookupClient::ReleaseServicePointers</strong> (or earlier). If the method fails, every member of the array is <strong><c>null</c></strong>.</p> </dd>
        /// </summary>
        /// <doc-id>bb970504</doc-id>
        /// <unmanaged>MF_SERVICE_LOOKUP_ALL</unmanaged>
        /// <unmanaged-short>MF_SERVICE_LOOKUP_ALL</unmanaged-short>
        All = unchecked ((System.Int32)(4)),
        /// <summary>
        /// <dd> <p>Pointer to a value that specifies the size of the <em>ppvObjects</em> array. The value must be at least 1. In the current implementation, there is no reason to specify an array size larger than one element. The value is not changed on output.</p> </dd>
        /// </summary>
        /// <doc-id>bb970504</doc-id>
        /// <unmanaged>MF_SERVICE_LOOKUP_GLOBAL</unmanaged>
        /// <unmanaged-short>MF_SERVICE_LOOKUP_GLOBAL</unmanaged-short>
        Global = unchecked ((System.Int32)(5))}

    [System.FlagsAttribute]
    /// <summary>
    /// <p> Defines flags for the <strong>IMFMediaSession::GetFullTopology</strong> method. </p>
    /// </summary>
    /// <doc-id>ms701845</doc-id>
    /// <unmanaged>MFSESSION_GETFULLTOPOLOGY_FLAGS</unmanaged>
    /// <unmanaged-short>MFSESSION_GETFULLTOPOLOGY_FLAGS</unmanaged-short>
    public enum SessionGetFullTopologyFlags : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms701845</doc-id>
        /// <unmanaged>MFSESSION_GETFULLTOPOLOGY_CURRENT</unmanaged>
        /// <unmanaged-short>MFSESSION_GETFULLTOPOLOGY_CURRENT</unmanaged-short>
        Current = unchecked ((System.Int32)(1)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    [System.FlagsAttribute]
    /// <summary>
    /// <p> </p><p>Defines the behavior of the <strong>IMFMediaSession::SetTopology</strong> method.</p>
    /// </summary>
    /// <remarks>
    /// <p> These flags are optional, and are not mutually exclusive. If no flags are set, the Media Session resolves the topology and then adds it to the queue of pending presentations. </p>
    /// </remarks>
    /// <doc-id>ms696169</doc-id>
    /// <unmanaged>MFSESSION_SETTOPOLOGY_FLAGS</unmanaged>
    /// <unmanaged-short>MFSESSION_SETTOPOLOGY_FLAGS</unmanaged-short>
    public enum SessionSetTopologyFlags : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms696169</doc-id>
        /// <unmanaged>MFSESSION_SETTOPOLOGY_IMMEDIATE</unmanaged>
        /// <unmanaged-short>MFSESSION_SETTOPOLOGY_IMMEDIATE</unmanaged-short>
        Immediate = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms696169</doc-id>
        /// <unmanaged>MFSESSION_SETTOPOLOGY_NORESOLUTION</unmanaged>
        /// <unmanaged-short>MFSESSION_SETTOPOLOGY_NORESOLUTION</unmanaged-short>
        Noresolution = unchecked ((System.Int32)(2)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms696169</doc-id>
        /// <unmanaged>MFSESSION_SETTOPOLOGY_CLEAR_CURRENT</unmanaged>
        /// <unmanaged-short>MFSESSION_SETTOPOLOGY_CLEAR_CURRENT</unmanaged-short>
        ClearCurrent = unchecked ((System.Int32)(4)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    /// <summary>
    /// <p> Describes the current status of a call to the <strong>IMFShutdown::Shutdown</strong> method.</p>
    /// </summary>
    /// <doc-id>ms701630</doc-id>
    /// <unmanaged>MFSHUTDOWN_STATUS</unmanaged>
    /// <unmanaged-short>MFSHUTDOWN_STATUS</unmanaged-short>
    public enum ShutdownStatus : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms701630</doc-id>
        /// <unmanaged>MFSHUTDOWN_INITIATED</unmanaged>
        /// <unmanaged-short>MFSHUTDOWN_INITIATED</unmanaged-short>
        Initiated = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms701630</doc-id>
        /// <unmanaged>MFSHUTDOWN_COMPLETED</unmanaged>
        /// <unmanaged-short>MFSHUTDOWN_COMPLETED</unmanaged-short>
        Completed = unchecked ((System.Int32)(1))}

    /// <summary>
    /// <p> </p><p>Specifies how the ASF file sink should apply Windows Media DRM.</p>
    /// </summary>
    /// <doc-id>ms703949</doc-id>
    /// <unmanaged>MFSINK_WMDRMACTION</unmanaged>
    /// <unmanaged-short>MFSINK_WMDRMACTION</unmanaged-short>
    public enum SinkWmdrmaction : System.Int32
    {
        /// <summary>
        /// <dd> <p>Undefined action.</p> </dd>
        /// </summary>
        /// <doc-id>ms703949</doc-id>
        /// <unmanaged>MFSINK_WMDRMACTION_UNDEFINED</unmanaged>
        /// <unmanaged-short>MFSINK_WMDRMACTION_UNDEFINED</unmanaged-short>
        Undefined = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>Encode the content using Windows Media DRM. Use this flag if the source content does not have DRM protection.</p> </dd>
        /// </summary>
        /// <doc-id>ms703949</doc-id>
        /// <unmanaged>MFSINK_WMDRMACTION_ENCODE</unmanaged>
        /// <unmanaged-short>MFSINK_WMDRMACTION_ENCODE</unmanaged-short>
        Encode = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>Transcode the content using Windows Media DRM. Use this flag if the source content has Windows Media DRM protection and you want to change the encoding parameters but not the DRM protection.</p> </dd>
        /// </summary>
        /// <doc-id>ms703949</doc-id>
        /// <unmanaged>MFSINK_WMDRMACTION_TRANSCODE</unmanaged>
        /// <unmanaged-short>MFSINK_WMDRMACTION_TRANSCODE</unmanaged-short>
        Transcode = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>Transcrypt the content. Use this flag if the source content has DRM protection and you want to change the DRM protection; for example, if you want to convert from Windows Media DRM version 1 to Windows Media DRM version 7 or later.</p> </dd>
        /// </summary>
        /// <doc-id>ms703949</doc-id>
        /// <unmanaged>MFSINK_WMDRMACTION_TRANSCRYPT</unmanaged>
        /// <unmanaged-short>MFSINK_WMDRMACTION_TRANSCRYPT</unmanaged-short>
        Transcrypt = unchecked ((System.Int32)(3)),
        /// <summary>
        /// <dd> <p>Reserved. Do not use.</p> </dd>
        /// </summary>
        /// <doc-id>ms703949</doc-id>
        /// <unmanaged>MFSINK_WMDRMACTION_LAST</unmanaged>
        /// <unmanaged-short>MFSINK_WMDRMACTION_LAST</unmanaged-short>
        Last = unchecked ((System.Int32)(3))}

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>__MIDL___MIDL_itf_mfreadwrite_0000_0005_0001</unmanaged>
    /// <unmanaged-short>__MIDL___MIDL_itf_mfreadwrite_0000_0005_0001</unmanaged-short>
    public enum SinkWriterIndex : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_SINK_WRITER_INVALID_STREAM_INDEX</unmanaged>
        /// <unmanaged-short>MF_SINK_WRITER_INVALID_STREAM_INDEX</unmanaged-short>
        InvalidStreamIndex = unchecked ((System.Int32)(-1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_SINK_WRITER_ALL_STREAMS</unmanaged>
        /// <unmanaged-short>MF_SINK_WRITER_ALL_STREAMS</unmanaged-short>
        AllStreams = unchecked ((System.Int32)(-2)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_SINK_WRITER_MEDIASINK</unmanaged>
        /// <unmanaged-short>MF_SINK_WRITER_MEDIASINK</unmanaged-short>
        MediaSink = unchecked ((System.Int32)(-1))}

    [System.FlagsAttribute]
    /// <summary>
    /// <p>Contains flags for the <strong>IMFSourceReader::ReadSample</strong> method.</p>
    /// </summary>
    /// <doc-id>dd375771</doc-id>
    /// <unmanaged>MF_SOURCE_READER_CONTROL_FLAG</unmanaged>
    /// <unmanaged-short>MF_SOURCE_READER_CONTROL_FLAG</unmanaged-short>
    public enum SourceReaderControlFlags : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375771</doc-id>
        /// <unmanaged>MF_SOURCE_READER_CONTROLF_DRAIN</unmanaged>
        /// <unmanaged-short>MF_SOURCE_READER_CONTROLF_DRAIN</unmanaged-short>
        ControlfDrain = unchecked ((System.Int32)(1)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    [System.FlagsAttribute]
    /// <summary>
    /// <p>Contains flags that indicate the status of the <strong>IMFSourceReader::ReadSample</strong> method.</p>
    /// </summary>
    /// <doc-id>dd375773</doc-id>
    /// <unmanaged>MF_SOURCE_READER_FLAG</unmanaged>
    /// <unmanaged-short>MF_SOURCE_READER_FLAG</unmanaged-short>
    public enum SourceReaderFlags : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375773</doc-id>
        /// <unmanaged>MF_SOURCE_READERF_ERROR</unmanaged>
        /// <unmanaged-short>MF_SOURCE_READERF_ERROR</unmanaged-short>
        Error = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375773</doc-id>
        /// <unmanaged>MF_SOURCE_READERF_ENDOFSTREAM</unmanaged>
        /// <unmanaged-short>MF_SOURCE_READERF_ENDOFSTREAM</unmanaged-short>
        Endofstream = unchecked ((System.Int32)(2)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375773</doc-id>
        /// <unmanaged>MF_SOURCE_READERF_NEWSTREAM</unmanaged>
        /// <unmanaged-short>MF_SOURCE_READERF_NEWSTREAM</unmanaged-short>
        Newstream = unchecked ((System.Int32)(4)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375773</doc-id>
        /// <unmanaged>MF_SOURCE_READERF_NATIVEMEDIATYPECHANGED</unmanaged>
        /// <unmanaged-short>MF_SOURCE_READERF_NATIVEMEDIATYPECHANGED</unmanaged-short>
        Nativemediatypechanged = unchecked ((System.Int32)(16)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375773</doc-id>
        /// <unmanaged>MF_SOURCE_READERF_CURRENTMEDIATYPECHANGED</unmanaged>
        /// <unmanaged-short>MF_SOURCE_READERF_CURRENTMEDIATYPECHANGED</unmanaged-short>
        Currentmediatypechanged = unchecked ((System.Int32)(32)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375773</doc-id>
        /// <unmanaged>MF_SOURCE_READERF_STREAMTICK</unmanaged>
        /// <unmanaged-short>MF_SOURCE_READERF_STREAMTICK</unmanaged-short>
        StreamTick = unchecked ((System.Int32)(256)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd375773</doc-id>
        /// <unmanaged>MF_SOURCE_READERF_ALLEFFECTSREMOVED</unmanaged>
        /// <unmanaged-short>MF_SOURCE_READERF_ALLEFFECTSREMOVED</unmanaged-short>
        AllEffectsremoved = unchecked ((System.Int32)(512)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>__MIDL___MIDL_itf_mfreadwrite_0000_0001_0001</unmanaged>
    /// <unmanaged-short>__MIDL___MIDL_itf_mfreadwrite_0000_0001_0001</unmanaged-short>
    public enum SourceReaderIndex : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_SOURCE_READER_INVALID_STREAM_INDEX</unmanaged>
        /// <unmanaged-short>MF_SOURCE_READER_INVALID_STREAM_INDEX</unmanaged-short>
        InvalidStreamIndex = unchecked ((System.Int32)(-1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_SOURCE_READER_ALL_STREAMS</unmanaged>
        /// <unmanaged-short>MF_SOURCE_READER_ALL_STREAMS</unmanaged-short>
        AllStreams = unchecked ((System.Int32)(-2)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_SOURCE_READER_ANY_STREAM</unmanaged>
        /// <unmanaged-short>MF_SOURCE_READER_ANY_STREAM</unmanaged-short>
        AnyStream = unchecked ((System.Int32)(-2)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_SOURCE_READER_FIRST_AUDIO_STREAM</unmanaged>
        /// <unmanaged-short>MF_SOURCE_READER_FIRST_AUDIO_STREAM</unmanaged-short>
        FirstAudioStream = unchecked ((System.Int32)(-3)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_SOURCE_READER_FIRST_VIDEO_STREAM</unmanaged>
        /// <unmanaged-short>MF_SOURCE_READER_FIRST_VIDEO_STREAM</unmanaged-short>
        FirstVideoStream = unchecked ((System.Int32)(-4)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_SOURCE_READER_MEDIASOURCE</unmanaged>
        /// <unmanaged-short>MF_SOURCE_READER_MEDIASOURCE</unmanaged-short>
        MediaSource = unchecked ((System.Int32)(-1))}

    [System.FlagsAttribute]
    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>__MIDL___MIDL_itf_mfidl_0000_0001_0001</unmanaged>
    /// <unmanaged-short>__MIDL___MIDL_itf_mfidl_0000_0001_0001</unmanaged-short>
    public enum SourceResolverFlags : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_RESOLUTION_MEDIASOURCE</unmanaged>
        /// <unmanaged-short>MF_RESOLUTION_MEDIASOURCE</unmanaged-short>
        MediaSource = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_RESOLUTION_BYTESTREAM</unmanaged>
        /// <unmanaged-short>MF_RESOLUTION_BYTESTREAM</unmanaged-short>
        ByteStream = unchecked ((System.Int32)(2)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_RESOLUTION_CONTENT_DOES_NOT_HAVE_TO_MATCH_EXTENSION_OR_MIME_TYPE</unmanaged>
        /// <unmanaged-short>MF_RESOLUTION_CONTENT_DOES_NOT_HAVE_TO_MATCH_EXTENSION_OR_MIME_TYPE</unmanaged-short>
        ContentDoesNotHaveToMatchExtensionOrMimeType = unchecked ((System.Int32)(16)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_RESOLUTION_KEEP_BYTE_STREAM_ALIVE_ON_FAIL</unmanaged>
        /// <unmanaged-short>MF_RESOLUTION_KEEP_BYTE_STREAM_ALIVE_ON_FAIL</unmanaged-short>
        KeepByteStreamAliveOnFail = unchecked ((System.Int32)(32)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_RESOLUTION_DISABLE_LOCAL_PLUGINS</unmanaged>
        /// <unmanaged-short>MF_RESOLUTION_DISABLE_LOCAL_PLUGINS</unmanaged-short>
        DisableLocalPlugins = unchecked ((System.Int32)(64)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_RESOLUTION_PLUGIN_CONTROL_POLICY_APPROVED_ONLY</unmanaged>
        /// <unmanaged-short>MF_RESOLUTION_PLUGIN_CONTROL_POLICY_APPROVED_ONLY</unmanaged-short>
        PluginControlPolicyApprovedOnly = unchecked ((System.Int32)(128)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_RESOLUTION_PLUGIN_CONTROL_POLICY_WEB_ONLY</unmanaged>
        /// <unmanaged-short>MF_RESOLUTION_PLUGIN_CONTROL_POLICY_WEB_ONLY</unmanaged-short>
        PluginControlPolicyWebOnly = unchecked ((System.Int32)(256)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_RESOLUTION_PLUGIN_CONTROL_POLICY_WEB_ONLY_EDGEMODE</unmanaged>
        /// <unmanaged-short>MF_RESOLUTION_PLUGIN_CONTROL_POLICY_WEB_ONLY_EDGEMODE</unmanaged-short>
        PluginControlPolicyWebOnlyEdgemode = unchecked ((System.Int32)(512)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_RESOLUTION_ENABLE_STORE_PLUGINS</unmanaged>
        /// <unmanaged-short>MF_RESOLUTION_ENABLE_STORE_PLUGINS</unmanaged-short>
        EnableStorePlugins = unchecked ((System.Int32)(1024)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_RESOLUTION_READ</unmanaged>
        /// <unmanaged-short>MF_RESOLUTION_READ</unmanaged-short>
        Read = unchecked ((System.Int32)(65536)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_RESOLUTION_WRITE</unmanaged>
        /// <unmanaged-short>MF_RESOLUTION_WRITE</unmanaged-short>
        Write = unchecked ((System.Int32)(131072)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    /// <summary>
    /// <p> </p><p>Contains values that specify common video formats.</p>
    /// </summary>
    /// <doc-id>aa473799</doc-id>
    /// <unmanaged>MFStandardVideoFormat</unmanaged>
    /// <unmanaged-short>MFStandardVideoFormat</unmanaged-short>
    public enum StandardVideoFormat : System.Int32
    {
        /// <summary>
        /// <dd> <p>Reserved; do not use.</p> </dd>
        /// </summary>
        /// <doc-id>aa473799</doc-id>
        /// <unmanaged>MFStdVideoFormat_reserved</unmanaged>
        /// <unmanaged-short>MFStdVideoFormat_reserved</unmanaged-short>
        DVideoFormatReserved = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>NTSC television (720 x 480i).</p> </dd>
        /// </summary>
        /// <doc-id>aa473799</doc-id>
        /// <unmanaged>MFStdVideoFormat_NTSC</unmanaged>
        /// <unmanaged-short>MFStdVideoFormat_NTSC</unmanaged-short>
        DVideoFormatNtsc = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>PAL television (720 x 576i).</p> </dd>
        /// </summary>
        /// <doc-id>aa473799</doc-id>
        /// <unmanaged>MFStdVideoFormat_PAL</unmanaged>
        /// <unmanaged-short>MFStdVideoFormat_PAL</unmanaged-short>
        DVideoFormatPal = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>DVD, NTSC standard (720 x 480).</p> </dd>
        /// </summary>
        /// <doc-id>aa473799</doc-id>
        /// <unmanaged>MFStdVideoFormat_DVD_NTSC</unmanaged>
        /// <unmanaged-short>MFStdVideoFormat_DVD_NTSC</unmanaged-short>
        DVideoFormatDvdNtsc = unchecked ((System.Int32)(3)),
        /// <summary>
        /// <dd> <p>DVD, PAL standard (720 x 576).</p> </dd>
        /// </summary>
        /// <doc-id>aa473799</doc-id>
        /// <unmanaged>MFStdVideoFormat_DVD_PAL</unmanaged>
        /// <unmanaged-short>MFStdVideoFormat_DVD_PAL</unmanaged-short>
        DVideoFormatDvdPal = unchecked ((System.Int32)(4)),
        /// <summary>
        /// <dd> <p>DV video, PAL standard.</p> </dd>
        /// </summary>
        /// <doc-id>aa473799</doc-id>
        /// <unmanaged>MFStdVideoFormat_DV_PAL</unmanaged>
        /// <unmanaged-short>MFStdVideoFormat_DV_PAL</unmanaged-short>
        DVideoFormatDvPal = unchecked ((System.Int32)(5)),
        /// <summary>
        /// <dd> <p>DV video, NTSC standard.</p> </dd>
        /// </summary>
        /// <doc-id>aa473799</doc-id>
        /// <unmanaged>MFStdVideoFormat_DV_NTSC</unmanaged>
        /// <unmanaged-short>MFStdVideoFormat_DV_NTSC</unmanaged-short>
        DVideoFormatDvNtsc = unchecked ((System.Int32)(6)),
        /// <summary>
        /// <dd> <p>ATSC digital television, SD (480i).</p> </dd>
        /// </summary>
        /// <doc-id>aa473799</doc-id>
        /// <unmanaged>MFStdVideoFormat_ATSC_SD480i</unmanaged>
        /// <unmanaged-short>MFStdVideoFormat_ATSC_SD480i</unmanaged-short>
        DVideoFormatAtscSD480i = unchecked ((System.Int32)(7)),
        /// <summary>
        /// <dd> <p>ATSC digital television, HD interlaced (1080i)</p> </dd>
        /// </summary>
        /// <doc-id>aa473799</doc-id>
        /// <unmanaged>MFStdVideoFormat_ATSC_HD1080i</unmanaged>
        /// <unmanaged-short>MFStdVideoFormat_ATSC_HD1080i</unmanaged-short>
        DVideoFormatAtscHD1080i = unchecked ((System.Int32)(8)),
        /// <summary>
        /// <dd> <p>ATSC digital television, HD progressive (720p)</p> </dd>
        /// </summary>
        /// <doc-id>aa473799</doc-id>
        /// <unmanaged>MFStdVideoFormat_ATSC_HD720p</unmanaged>
        /// <unmanaged-short>MFStdVideoFormat_ATSC_HD720p</unmanaged-short>
        DVideoFormatAtscHD720p = unchecked ((System.Int32)(9))}

    /// <summary>
    /// <p>Defines stream marker information for the <strong>IMFStreamSink::PlaceMarker</strong> method. The <strong>PlaceMarker</strong> method places a marker on the stream between samples. The <strong><see cref = "SharpDX.MediaFoundation.StreamsInkMarkerType"/></strong> enumeration defines the marker type and the type of information associated with the marker.</p>
    /// </summary>
    /// <remarks>
    /// <p>If the Streaming Audio Renderer receives an <strong>MFSTREAMSINK_MARKER_TICK</strong> marker, it inserts silence to cover the gap in the data. </p>
    /// </remarks>
    /// <doc-id>ms703837</doc-id>
    /// <unmanaged>MFSTREAMSINK_MARKER_TYPE</unmanaged>
    /// <unmanaged-short>MFSTREAMSINK_MARKER_TYPE</unmanaged-short>
    public enum StreamsInkMarkerType : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms703837</doc-id>
        /// <unmanaged>MFSTREAMSINK_MARKER_DEFAULT</unmanaged>
        /// <unmanaged-short>MFSTREAMSINK_MARKER_DEFAULT</unmanaged-short>
        Default = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms703837</doc-id>
        /// <unmanaged>MFSTREAMSINK_MARKER_ENDOFSEGMENT</unmanaged>
        /// <unmanaged-short>MFSTREAMSINK_MARKER_ENDOFSEGMENT</unmanaged-short>
        Endofsegment = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms703837</doc-id>
        /// <unmanaged>MFSTREAMSINK_MARKER_TICK</unmanaged>
        /// <unmanaged-short>MFSTREAMSINK_MARKER_TICK</unmanaged-short>
        Tick = unchecked ((System.Int32)(2)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms703837</doc-id>
        /// <unmanaged>MFSTREAMSINK_MARKER_EVENT</unmanaged>
        /// <unmanaged-short>MFSTREAMSINK_MARKER_EVENT</unmanaged-short>
        Event = unchecked ((System.Int32)(3))}

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>MF_STREAM_STATE</unmanaged>
    /// <unmanaged-short>MF_STREAM_STATE</unmanaged-short>
    public enum StreamState : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_STREAM_STATE_STOPPED</unmanaged>
        /// <unmanaged-short>MF_STREAM_STATE_STOPPED</unmanaged-short>
        Stopped = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_STREAM_STATE_PAUSED</unmanaged>
        /// <unmanaged-short>MF_STREAM_STATE_PAUSED</unmanaged-short>
        Paused = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_STREAM_STATE_RUNNING</unmanaged>
        /// <unmanaged-short>MF_STREAM_STATE_RUNNING</unmanaged-short>
        Running = unchecked ((System.Int32)(2))}

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>MFT_AUDIO_DECODER_DEGRADATION_REASON</unmanaged>
    /// <unmanaged-short>MFT_AUDIO_DECODER_DEGRADATION_REASON</unmanaged-short>
    public enum TAudioDecoderDegradationReason : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MFT_AUDIO_DECODER_DEGRADATION_REASON_NONE</unmanaged>
        /// <unmanaged-short>MFT_AUDIO_DECODER_DEGRADATION_REASON_NONE</unmanaged-short>
        None = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MFT_AUDIO_DECODER_DEGRADATION_REASON_LICENSING_REQUIREMENT</unmanaged>
        /// <unmanaged-short>MFT_AUDIO_DECODER_DEGRADATION_REASON_LICENSING_REQUIREMENT</unmanaged-short>
        LicensingRequirement = unchecked ((System.Int32)(1))}

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>MFT_AUDIO_DECODER_DEGRADATION_TYPE</unmanaged>
    /// <unmanaged-short>MFT_AUDIO_DECODER_DEGRADATION_TYPE</unmanaged-short>
    public enum TAudioDecoderDegradationType : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MFT_AUDIO_DECODER_DEGRADATION_TYPE_NONE</unmanaged>
        /// <unmanaged-short>MFT_AUDIO_DECODER_DEGRADATION_TYPE_NONE</unmanaged-short>
        None = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MFT_AUDIO_DECODER_DEGRADATION_TYPE_DOWNMIX2CHANNEL</unmanaged>
        /// <unmanaged-short>MFT_AUDIO_DECODER_DEGRADATION_TYPE_DOWNMIX2CHANNEL</unmanaged-short>
        Downmix2channel = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MFT_AUDIO_DECODER_DEGRADATION_TYPE_DOWNMIX6CHANNEL</unmanaged>
        /// <unmanaged-short>MFT_AUDIO_DECODER_DEGRADATION_TYPE_DOWNMIX6CHANNEL</unmanaged-short>
        Downmix6channel = unchecked ((System.Int32)(2)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MFT_AUDIO_DECODER_DEGRADATION_TYPE_DOWNMIX8CHANNEL</unmanaged>
        /// <unmanaged-short>MFT_AUDIO_DECODER_DEGRADATION_TYPE_DOWNMIX8CHANNEL</unmanaged-short>
        Downmix8channel = unchecked ((System.Int32)(3))}

    /// <summary>
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Specifies how text is aligned in its parent block element. </p>
    /// </summary>
    /// <doc-id>dn782325</doc-id>
    /// <unmanaged>MF_TIMED_TEXT_ALIGNMENT</unmanaged>
    /// <unmanaged-short>MF_TIMED_TEXT_ALIGNMENT</unmanaged-short>
    public enum TimedTextAlignment : System.Int32
    {
        /// <summary>
        /// <dd> <p>Text is aligned at the start of its parent block element.</p> </dd>
        /// </summary>
        /// <doc-id>dn782325</doc-id>
        /// <unmanaged>MF_TIMED_TEXT_ALIGNMENT_START</unmanaged>
        /// <unmanaged-short>MF_TIMED_TEXT_ALIGNMENT_START</unmanaged-short>
        Start = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>Text is aligned at the end of its parent block element.</p> </dd>
        /// </summary>
        /// <doc-id>dn782325</doc-id>
        /// <unmanaged>MF_TIMED_TEXT_ALIGNMENT_END</unmanaged>
        /// <unmanaged-short>MF_TIMED_TEXT_ALIGNMENT_END</unmanaged-short>
        End = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>Text is aligned in the center of its parent block element.</p> </dd>
        /// </summary>
        /// <doc-id>dn782325</doc-id>
        /// <unmanaged>MF_TIMED_TEXT_ALIGNMENT_CENTER</unmanaged>
        /// <unmanaged-short>MF_TIMED_TEXT_ALIGNMENT_CENTER</unmanaged-short>
        Center = unchecked ((System.Int32)(2))}

    /// <summary>
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Specifies the type of  a timed text cue event.</p>
    /// </summary>
    /// <doc-id>dn904197</doc-id>
    /// <unmanaged>MF_TIMED_TEXT_CUE_EVENT</unmanaged>
    /// <unmanaged-short>MF_TIMED_TEXT_CUE_EVENT</unmanaged-short>
    public enum TimedTextCueEvent : System.Int32
    {
        /// <summary>
        /// <dd> <p>The cue has become active.</p> </dd>
        /// </summary>
        /// <doc-id>dn904197</doc-id>
        /// <unmanaged>MF_TIMED_TEXT_CUE_EVENT_ACTIVE</unmanaged>
        /// <unmanaged-short>MF_TIMED_TEXT_CUE_EVENT_ACTIVE</unmanaged-short>
        Active = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>The cue has become inactive.</p> </dd>
        /// </summary>
        /// <doc-id>dn904197</doc-id>
        /// <unmanaged>MF_TIMED_TEXT_CUE_EVENT_INACTIVE</unmanaged>
        /// <unmanaged-short>MF_TIMED_TEXT_CUE_EVENT_INACTIVE</unmanaged-short>
        Inactive = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>All cues have been deactivated.</p> </dd>
        /// </summary>
        /// <doc-id>dn904197</doc-id>
        /// <unmanaged>MF_TIMED_TEXT_CUE_EVENT_CLEAR</unmanaged>
        /// <unmanaged-short>MF_TIMED_TEXT_CUE_EVENT_CLEAR</unmanaged-short>
        Clear = unchecked ((System.Int32)(2))}

    /// <summary>
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Specifies how text is decorated (underlined and so on). </p>
    /// </summary>
    /// <doc-id>dn782326</doc-id>
    /// <unmanaged>MF_TIMED_TEXT_DECORATION</unmanaged>
    /// <unmanaged-short>MF_TIMED_TEXT_DECORATION</unmanaged-short>
    public enum TimedTextDecoration : System.Int32
    {
        /// <summary>
        /// <dd> <p>Text isn't decorated.</p> </dd>
        /// </summary>
        /// <doc-id>dn782326</doc-id>
        /// <unmanaged>MF_TIMED_TEXT_DECORATION_NONE</unmanaged>
        /// <unmanaged-short>MF_TIMED_TEXT_DECORATION_NONE</unmanaged-short>
        None = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>Text is underlined.</p> </dd>
        /// </summary>
        /// <doc-id>dn782326</doc-id>
        /// <unmanaged>MF_TIMED_TEXT_DECORATION_UNDERLINE</unmanaged>
        /// <unmanaged-short>MF_TIMED_TEXT_DECORATION_UNDERLINE</unmanaged-short>
        Underline = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>Text has a line through it.</p> </dd>
        /// </summary>
        /// <doc-id>dn782326</doc-id>
        /// <unmanaged>MF_TIMED_TEXT_DECORATION_LINE_THROUGH</unmanaged>
        /// <unmanaged-short>MF_TIMED_TEXT_DECORATION_LINE_THROUGH</unmanaged-short>
        LineThrough = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>Text has a line over it.</p> </dd>
        /// </summary>
        /// <doc-id>dn782326</doc-id>
        /// <unmanaged>MF_TIMED_TEXT_DECORATION_OVERLINE</unmanaged>
        /// <unmanaged-short>MF_TIMED_TEXT_DECORATION_OVERLINE</unmanaged-short>
        Overline = unchecked ((System.Int32)(4))}

    /// <summary>
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Specifies how text is aligned with the display. </p>
    /// </summary>
    /// <doc-id>dn782327</doc-id>
    /// <unmanaged>MF_TIMED_TEXT_DISPLAY_ALIGNMENT</unmanaged>
    /// <unmanaged-short>MF_TIMED_TEXT_DISPLAY_ALIGNMENT</unmanaged-short>
    public enum TimedTextDisplayAlignment : System.Int32
    {
        /// <summary>
        /// <dd> <p>Text is aligned before an element.</p> </dd>
        /// </summary>
        /// <doc-id>dn782327</doc-id>
        /// <unmanaged>MF_TIMED_TEXT_DISPLAY_ALIGNMENT_BEFORE</unmanaged>
        /// <unmanaged-short>MF_TIMED_TEXT_DISPLAY_ALIGNMENT_BEFORE</unmanaged-short>
        Before = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>Text is aligned after an element.</p> </dd>
        /// </summary>
        /// <doc-id>dn782327</doc-id>
        /// <unmanaged>MF_TIMED_TEXT_DISPLAY_ALIGNMENT_AFTER</unmanaged>
        /// <unmanaged-short>MF_TIMED_TEXT_DISPLAY_ALIGNMENT_AFTER</unmanaged-short>
        After = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>Text is aligned in the center between elements.</p> </dd>
        /// </summary>
        /// <doc-id>dn782327</doc-id>
        /// <unmanaged>MF_TIMED_TEXT_DISPLAY_ALIGNMENT_CENTER</unmanaged>
        /// <unmanaged-short>MF_TIMED_TEXT_DISPLAY_ALIGNMENT_CENTER</unmanaged-short>
        Center = unchecked ((System.Int32)(2))}

    /// <summary>
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Specifies the kind error that occurred with a timed text track.</p>
    /// </summary>
    /// <remarks>
    /// <p>This enumeration is used to return error information  from the <strong>IMFTimedTextTrack::GetErrorCode</strong> method.</p>
    /// </remarks>
    /// <doc-id>dn859186</doc-id>
    /// <unmanaged>MF_TIMED_TEXT_ERROR_CODE</unmanaged>
    /// <unmanaged-short>MF_TIMED_TEXT_ERROR_CODE</unmanaged-short>
    public enum TimedTextErrorCode : System.Int32
    {
        /// <summary>
        /// <dd> <p>No error occurred.</p> </dd>
        /// </summary>
        /// <doc-id>dn859186</doc-id>
        /// <unmanaged>MF_TIMED_TEXT_ERROR_CODE_NOERROR</unmanaged>
        /// <unmanaged-short>MF_TIMED_TEXT_ERROR_CODE_NOERROR</unmanaged-short>
        Noerror = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>A fatal error occurred.</p> </dd>
        /// </summary>
        /// <doc-id>dn859186</doc-id>
        /// <unmanaged>MF_TIMED_TEXT_ERROR_CODE_FATAL</unmanaged>
        /// <unmanaged-short>MF_TIMED_TEXT_ERROR_CODE_FATAL</unmanaged-short>
        Fatal = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>An error occurred with the data format of the timed text track.</p> </dd>
        /// </summary>
        /// <doc-id>dn859186</doc-id>
        /// <unmanaged>MF_TIMED_TEXT_ERROR_CODE_DATA_FORMAT</unmanaged>
        /// <unmanaged-short>MF_TIMED_TEXT_ERROR_CODE_DATA_FORMAT</unmanaged-short>
        DataFormat = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>A network error occurred when trying to load the timed text track.</p> </dd>
        /// </summary>
        /// <doc-id>dn859186</doc-id>
        /// <unmanaged>MF_TIMED_TEXT_ERROR_CODE_NETWORK</unmanaged>
        /// <unmanaged-short>MF_TIMED_TEXT_ERROR_CODE_NETWORK</unmanaged-short>
        Network = unchecked ((System.Int32)(3)),
        /// <summary>
        /// <dd> <p>An internal error occurred.</p> </dd>
        /// </summary>
        /// <doc-id>dn859186</doc-id>
        /// <unmanaged>MF_TIMED_TEXT_ERROR_CODE_INTERNAL</unmanaged>
        /// <unmanaged-short>MF_TIMED_TEXT_ERROR_CODE_INTERNAL</unmanaged-short>
        Internal = unchecked ((System.Int32)(4))}

    /// <summary>
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Specifies the font style of the timed text.</p>
    /// </summary>
    /// <doc-id>dn782328</doc-id>
    /// <unmanaged>MF_TIMED_TEXT_FONT_STYLE</unmanaged>
    /// <unmanaged-short>MF_TIMED_TEXT_FONT_STYLE</unmanaged-short>
    public enum TimedTextFontStyle : System.Int32
    {
        /// <summary>
        /// <dd> <p>The font style is normal, sometimes referred to as roman.</p> </dd>
        /// </summary>
        /// <doc-id>dn782328</doc-id>
        /// <unmanaged>MF_TIMED_TEXT_FONT_STYLE_NORMAL</unmanaged>
        /// <unmanaged-short>MF_TIMED_TEXT_FONT_STYLE_NORMAL</unmanaged-short>
        Normal = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>The font style is oblique.</p> </dd>
        /// </summary>
        /// <doc-id>dn782328</doc-id>
        /// <unmanaged>MF_TIMED_TEXT_FONT_STYLE_OBLIQUE</unmanaged>
        /// <unmanaged-short>MF_TIMED_TEXT_FONT_STYLE_OBLIQUE</unmanaged-short>
        Oblique = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>The font style is italic.</p> </dd>
        /// </summary>
        /// <doc-id>dn782328</doc-id>
        /// <unmanaged>MF_TIMED_TEXT_FONT_STYLE_ITALIC</unmanaged>
        /// <unmanaged-short>MF_TIMED_TEXT_FONT_STYLE_ITALIC</unmanaged-short>
        Italic = unchecked ((System.Int32)(2))}

    /// <summary>
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Specifies how text appears when the parent element is scrolled.</p>
    /// </summary>
    /// <doc-id>dn782329</doc-id>
    /// <unmanaged>MF_TIMED_TEXT_SCROLL_MODE</unmanaged>
    /// <unmanaged-short>MF_TIMED_TEXT_SCROLL_MODE</unmanaged-short>
    public enum TimedTextScrollMode : System.Int32
    {
        /// <summary>
        /// <dd> <p>Text pops on when the parent element is scrolled.</p> </dd>
        /// </summary>
        /// <doc-id>dn782329</doc-id>
        /// <unmanaged>MF_TIMED_TEXT_SCROLL_MODE_POP_ON</unmanaged>
        /// <unmanaged-short>MF_TIMED_TEXT_SCROLL_MODE_POP_ON</unmanaged-short>
        PopOn = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>Text rolls up when the parent element is scrolled.</p> </dd>
        /// </summary>
        /// <doc-id>dn782329</doc-id>
        /// <unmanaged>MF_TIMED_TEXT_SCROLL_MODE_ROLL_UP</unmanaged>
        /// <unmanaged-short>MF_TIMED_TEXT_SCROLL_MODE_ROLL_UP</unmanaged-short>
        RollUp = unchecked ((System.Int32)(1))}

    /// <summary>
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Specifies the kind of timed text track.</p>
    /// </summary>
    /// <doc-id>dn782330</doc-id>
    /// <unmanaged>MF_TIMED_TEXT_TRACK_KIND</unmanaged>
    /// <unmanaged-short>MF_TIMED_TEXT_TRACK_KIND</unmanaged-short>
    public enum TimedTextTrackKind : System.Int32
    {
        /// <summary>
        /// <dd> <p>The kind of timed text track is unknown.</p> </dd>
        /// </summary>
        /// <doc-id>dn782330</doc-id>
        /// <unmanaged>MF_TIMED_TEXT_TRACK_KIND_UNKNOWN</unmanaged>
        /// <unmanaged-short>MF_TIMED_TEXT_TRACK_KIND_UNKNOWN</unmanaged-short>
        Unknown = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>The kind of timed text track is subtitles.</p> </dd>
        /// </summary>
        /// <doc-id>dn782330</doc-id>
        /// <unmanaged>MF_TIMED_TEXT_TRACK_KIND_SUBTITLES</unmanaged>
        /// <unmanaged-short>MF_TIMED_TEXT_TRACK_KIND_SUBTITLES</unmanaged-short>
        SubTitles = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>The kind of timed text track is closed captions.</p> </dd>
        /// </summary>
        /// <doc-id>dn782330</doc-id>
        /// <unmanaged>MF_TIMED_TEXT_TRACK_KIND_CAPTIONS</unmanaged>
        /// <unmanaged-short>MF_TIMED_TEXT_TRACK_KIND_CAPTIONS</unmanaged-short>
        Captions = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>The kind of timed text track is metadata.</p> </dd>
        /// </summary>
        /// <doc-id>dn782330</doc-id>
        /// <unmanaged>MF_TIMED_TEXT_TRACK_KIND_METADATA</unmanaged>
        /// <unmanaged-short>MF_TIMED_TEXT_TRACK_KIND_METADATA</unmanaged-short>
        Metadata = unchecked ((System.Int32)(3))}

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>MF_TIMED_TEXT_TRACK_READY_STATE</unmanaged>
    /// <unmanaged-short>MF_TIMED_TEXT_TRACK_READY_STATE</unmanaged-short>
    public enum TimedTextTrackReadyState : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_TIMED_TEXT_TRACK_READY_STATE_NONE</unmanaged>
        /// <unmanaged-short>MF_TIMED_TEXT_TRACK_READY_STATE_NONE</unmanaged-short>
        None = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_TIMED_TEXT_TRACK_READY_STATE_LOADING</unmanaged>
        /// <unmanaged-short>MF_TIMED_TEXT_TRACK_READY_STATE_LOADING</unmanaged-short>
        Loading = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_TIMED_TEXT_TRACK_READY_STATE_LOADED</unmanaged>
        /// <unmanaged-short>MF_TIMED_TEXT_TRACK_READY_STATE_LOADED</unmanaged-short>
        Loaded = unchecked ((System.Int32)(2)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_TIMED_TEXT_TRACK_READY_STATE_ERROR</unmanaged>
        /// <unmanaged-short>MF_TIMED_TEXT_TRACK_READY_STATE_ERROR</unmanaged-short>
        Error = unchecked ((System.Int32)(3))}

    /// <summary>
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Specifies the units in which the timed text is measured.</p>
    /// </summary>
    /// <doc-id>dn782331</doc-id>
    /// <unmanaged>MF_TIMED_TEXT_UNIT_TYPE</unmanaged>
    /// <unmanaged-short>MF_TIMED_TEXT_UNIT_TYPE</unmanaged-short>
    public enum TimedTextUnitType : System.Int32
    {
        /// <summary>
        /// <dd> <p>The timed text is measured in pixels.</p> </dd>
        /// </summary>
        /// <doc-id>dn782331</doc-id>
        /// <unmanaged>MF_TIMED_TEXT_UNIT_TYPE_PIXELS</unmanaged>
        /// <unmanaged-short>MF_TIMED_TEXT_UNIT_TYPE_PIXELS</unmanaged-short>
        Pixels = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>The timed text is measured as a percentage.</p> </dd>
        /// </summary>
        /// <doc-id>dn782331</doc-id>
        /// <unmanaged>MF_TIMED_TEXT_UNIT_TYPE_PERCENTAGE</unmanaged>
        /// <unmanaged-short>MF_TIMED_TEXT_UNIT_TYPE_PERCENTAGE</unmanaged-short>
        Percentage = unchecked ((System.Int32)(1))}

    /// <summary>
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Specifies the sequence in which text is written on its parent element.</p>
    /// </summary>
    /// <doc-id>dn782332</doc-id>
    /// <unmanaged>MF_TIMED_TEXT_WRITING_MODE</unmanaged>
    /// <unmanaged-short>MF_TIMED_TEXT_WRITING_MODE</unmanaged-short>
    public enum TimedTextWritingMode : System.Int32
    {
        /// <summary>
        /// <dd> <p>Text is written from left to right and top to bottom.</p> </dd>
        /// </summary>
        /// <doc-id>dn782332</doc-id>
        /// <unmanaged>MF_TIMED_TEXT_WRITING_MODE_LRTB</unmanaged>
        /// <unmanaged-short>MF_TIMED_TEXT_WRITING_MODE_LRTB</unmanaged-short>
        Lrtb = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>Text is written from right to left and top to bottom.</p> </dd>
        /// </summary>
        /// <doc-id>dn782332</doc-id>
        /// <unmanaged>MF_TIMED_TEXT_WRITING_MODE_RLTB</unmanaged>
        /// <unmanaged-short>MF_TIMED_TEXT_WRITING_MODE_RLTB</unmanaged-short>
        Rltb = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>Text is written from top to bottom and right to left.</p> </dd>
        /// </summary>
        /// <doc-id>dn782332</doc-id>
        /// <unmanaged>MF_TIMED_TEXT_WRITING_MODE_TBRL</unmanaged>
        /// <unmanaged-short>MF_TIMED_TEXT_WRITING_MODE_TBRL</unmanaged-short>
        Tbrl = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>Text is written from top to bottom and left to right.</p> </dd>
        /// </summary>
        /// <doc-id>dn782332</doc-id>
        /// <unmanaged>MF_TIMED_TEXT_WRITING_MODE_TBLR</unmanaged>
        /// <unmanaged-short>MF_TIMED_TEXT_WRITING_MODE_TBLR</unmanaged-short>
        Tblr = unchecked ((System.Int32)(3)),
        /// <summary>
        /// <dd> <p>Text is written from left to right.</p> </dd>
        /// </summary>
        /// <doc-id>dn782332</doc-id>
        /// <unmanaged>MF_TIMED_TEXT_WRITING_MODE_LR</unmanaged>
        /// <unmanaged-short>MF_TIMED_TEXT_WRITING_MODE_LR</unmanaged-short>
        Lr = unchecked ((System.Int32)(4)),
        /// <summary>
        /// <dd> <p>Text is written from right to left.</p> </dd>
        /// </summary>
        /// <doc-id>dn782332</doc-id>
        /// <unmanaged>MF_TIMED_TEXT_WRITING_MODE_RL</unmanaged>
        /// <unmanaged-short>MF_TIMED_TEXT_WRITING_MODE_RL</unmanaged-short>
        Rl = unchecked ((System.Int32)(5)),
        /// <summary>
        /// <dd> <p>Text is written from top to bottom.</p> </dd>
        /// </summary>
        /// <doc-id>dn782332</doc-id>
        /// <unmanaged>MF_TIMED_TEXT_WRITING_MODE_TB</unmanaged>
        /// <unmanaged-short>MF_TIMED_TEXT_WRITING_MODE_TB</unmanaged-short>
        Tb = unchecked ((System.Int32)(6))}

    [System.FlagsAttribute]
    /// <summary>
    /// <p> </p><p>Contains flags for the <strong>IMFTimer::SetTimer</strong> method.</p>
    /// </summary>
    /// <doc-id>ms703005</doc-id>
    /// <unmanaged>MFTIMER_FLAGS</unmanaged>
    /// <unmanaged-short>MFTIMER_FLAGS</unmanaged-short>
    public enum TimerFlags : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms703005</doc-id>
        /// <unmanaged>MFTIMER_RELATIVE</unmanaged>
        /// <unmanaged-short>MFTIMER_RELATIVE</unmanaged-short>
        Relative = unchecked ((System.Int32)(1)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    /// <summary>
    /// <p>Defines messages for a Media Foundation transform (MFT). To send a message to an MFT, call <strong>IMFTransform::ProcessMessage</strong>.</p>
    /// </summary>
    /// <remarks>
    /// <p>Some messages require specific actions from the MFT. These events have "MESSAGE" in the message name. Other messages are informational; they notify the MFT of some action by the client, and do not require any particular response from the MFT. These messages have "NOTIFY" in the messages name. Except where noted, an MFT should not rely on the client sending notification messages.</p>
    /// </remarks>
    /// <doc-id>ms697223</doc-id>
    /// <unmanaged>MFT_MESSAGE_TYPE</unmanaged>
    /// <unmanaged-short>MFT_MESSAGE_TYPE</unmanaged-short>
    public enum TMessageType : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697223</doc-id>
        /// <unmanaged>MFT_MESSAGE_COMMAND_FLUSH</unmanaged>
        /// <unmanaged-short>MFT_MESSAGE_COMMAND_FLUSH</unmanaged-short>
        CommandFlush = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697223</doc-id>
        /// <unmanaged>MFT_MESSAGE_COMMAND_DRAIN</unmanaged>
        /// <unmanaged-short>MFT_MESSAGE_COMMAND_DRAIN</unmanaged-short>
        CommandDrain = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697223</doc-id>
        /// <unmanaged>MFT_MESSAGE_SET_D3D_MANAGER</unmanaged>
        /// <unmanaged-short>MFT_MESSAGE_SET_D3D_MANAGER</unmanaged-short>
        SetD3DManager = unchecked ((System.Int32)(2)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697223</doc-id>
        /// <unmanaged>MFT_MESSAGE_DROP_SAMPLES</unmanaged>
        /// <unmanaged-short>MFT_MESSAGE_DROP_SAMPLES</unmanaged-short>
        DropSamples = unchecked ((System.Int32)(3)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697223</doc-id>
        /// <unmanaged>MFT_MESSAGE_COMMAND_TICK</unmanaged>
        /// <unmanaged-short>MFT_MESSAGE_COMMAND_TICK</unmanaged-short>
        CommandTick = unchecked ((System.Int32)(4)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697223</doc-id>
        /// <unmanaged>MFT_MESSAGE_NOTIFY_BEGIN_STREAMING</unmanaged>
        /// <unmanaged-short>MFT_MESSAGE_NOTIFY_BEGIN_STREAMING</unmanaged-short>
        NotifyBeginStreaming = unchecked ((System.Int32)(268435456)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697223</doc-id>
        /// <unmanaged>MFT_MESSAGE_NOTIFY_END_STREAMING</unmanaged>
        /// <unmanaged-short>MFT_MESSAGE_NOTIFY_END_STREAMING</unmanaged-short>
        NotifyEndStreaming = unchecked ((System.Int32)(268435457)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697223</doc-id>
        /// <unmanaged>MFT_MESSAGE_NOTIFY_END_OF_STREAM</unmanaged>
        /// <unmanaged-short>MFT_MESSAGE_NOTIFY_END_OF_STREAM</unmanaged-short>
        NotifyEndOfStream = unchecked ((System.Int32)(268435458)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697223</doc-id>
        /// <unmanaged>MFT_MESSAGE_NOTIFY_START_OF_STREAM</unmanaged>
        /// <unmanaged-short>MFT_MESSAGE_NOTIFY_START_OF_STREAM</unmanaged-short>
        NotifyStartOfStream = unchecked ((System.Int32)(268435459)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697223</doc-id>
        /// <unmanaged>MFT_MESSAGE_NOTIFY_RELEASE_RESOURCES</unmanaged>
        /// <unmanaged-short>MFT_MESSAGE_NOTIFY_RELEASE_RESOURCES</unmanaged-short>
        NotifyReleaseResources = unchecked ((System.Int32)(268435460)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697223</doc-id>
        /// <unmanaged>MFT_MESSAGE_NOTIFY_REACQUIRE_RESOURCES</unmanaged>
        /// <unmanaged-short>MFT_MESSAGE_NOTIFY_REACQUIRE_RESOURCES</unmanaged-short>
        NotifyReacquireResources = unchecked ((System.Int32)(268435461)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697223</doc-id>
        /// <unmanaged>MFT_MESSAGE_NOTIFY_EVENT</unmanaged>
        /// <unmanaged-short>MFT_MESSAGE_NOTIFY_EVENT</unmanaged-short>
        NotifyEvent = unchecked ((System.Int32)(268435462)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697223</doc-id>
        /// <unmanaged>MFT_MESSAGE_COMMAND_SET_OUTPUT_STREAM_STATE</unmanaged>
        /// <unmanaged-short>MFT_MESSAGE_COMMAND_SET_OUTPUT_STREAM_STATE</unmanaged-short>
        CommandSetOutputStreamState = unchecked ((System.Int32)(268435463)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697223</doc-id>
        /// <unmanaged>MFT_MESSAGE_COMMAND_FLUSH_OUTPUT_STREAM</unmanaged>
        /// <unmanaged-short>MFT_MESSAGE_COMMAND_FLUSH_OUTPUT_STREAM</unmanaged-short>
        CommandFlushOutputStream = unchecked ((System.Int32)(268435464)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms697223</doc-id>
        /// <unmanaged>MFT_MESSAGE_COMMAND_MARKER</unmanaged>
        /// <unmanaged-short>MFT_MESSAGE_COMMAND_MARKER</unmanaged-short>
        CommandMarker = unchecked ((System.Int32)(536870912))}

    /// <summary>
    /// <p>Specifies whether the topology loader enables Microsoft DirectX Video Acceleration (DXVA) in the topology.</p>
    /// </summary>
    /// <remarks>
    /// <p>This enumeration is used with the <see cref = "DXVAMode"/> topology attribute.</p><p>If an MFT supports DXVA, the MFT must return <strong>TRUE</strong> for the <strong><see cref = "D3DAware"/></strong> attribute. To enable DXVA, the topology loader calls <strong>IMFTransform::ProcessMessage</strong> on the MFT, passing the MFT a reference to the <strong>IDirect3DDeviceManager9</strong> interface. The topology loader gets the <strong>IDirect3DDeviceManager9</strong> reference from the media sink for the video stream. Typically the enhanced video renderer (EVR) is the media sink.</p><p>Previous versions of Microsoft Media Foundation supported DXVA only for decoders.</p>
    /// </remarks>
    /// <doc-id>dd388653</doc-id>
    /// <unmanaged>MFTOPOLOGY_DXVA_MODE</unmanaged>
    /// <unmanaged-short>MFTOPOLOGY_DXVA_MODE</unmanaged-short>
    public enum TopologyDxvaMode : System.Int32
    {
        /// <summary>
        /// <dd> <p>The topology loader enables DXVA
        /// on the decoder if possible, and drops optional Media Foundation transforms (MFTs) that do not support DXVA.</p> </dd>
        /// </summary>
        /// <doc-id>dd388653</doc-id>
        /// <unmanaged>MFTOPOLOGY_DXVA_DEFAULT</unmanaged>
        /// <unmanaged-short>MFTOPOLOGY_DXVA_DEFAULT</unmanaged-short>
        Default = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>The topology loader disables all video acceleration. This setting forces software processing, even when the decoder supports DXVA.</p> </dd>
        /// </summary>
        /// <doc-id>dd388653</doc-id>
        /// <unmanaged>MFTOPOLOGY_DXVA_NONE</unmanaged>
        /// <unmanaged-short>MFTOPOLOGY_DXVA_NONE</unmanaged-short>
        None = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>The topology loader enables DXVA on every MFT that supports it.</p> </dd>
        /// </summary>
        /// <doc-id>dd388653</doc-id>
        /// <unmanaged>MFTOPOLOGY_DXVA_FULL</unmanaged>
        /// <unmanaged-short>MFTOPOLOGY_DXVA_FULL</unmanaged-short>
        Full = unchecked ((System.Int32)(2))}

    /// <summary>
    /// <p>Specifies whether the topology loader will insert hardware-based Media Foundation transforms (MFTs) into the topology.</p>
    /// </summary>
    /// <remarks>
    /// <p> This enumeration is used with the <see cref = "HardwareMode"/> topology attribute. </p>
    /// </remarks>
    /// <doc-id>dd388654</doc-id>
    /// <unmanaged>MFTOPOLOGY_HARDWARE_MODE</unmanaged>
    /// <unmanaged-short>MFTOPOLOGY_HARDWARE_MODE</unmanaged-short>
    public enum TopologyHardwareMode : System.Int32
    {
        /// <summary>
        /// <dd> <p>Use only software  MFTs. Do not use hardware-based MFTs. This mode is the default, for backward compatibility with existing applications.</p> </dd>
        /// </summary>
        /// <doc-id>dd388654</doc-id>
        /// <unmanaged>MFTOPOLOGY_HWMODE_SOFTWARE_ONLY</unmanaged>
        /// <unmanaged-short>MFTOPOLOGY_HWMODE_SOFTWARE_ONLY</unmanaged-short>
        WmodeSoftwareOnly = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>Use hardware-based MFTs when possible, and software MFTs otherwise. This mode is the recommended one.</p> </dd>
        /// </summary>
        /// <doc-id>dd388654</doc-id>
        /// <unmanaged>MFTOPOLOGY_HWMODE_USE_HARDWARE</unmanaged>
        /// <unmanaged-short>MFTOPOLOGY_HWMODE_USE_HARDWARE</unmanaged-short>
        WmodeUseHardware = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>If hardware-based MFTs are available, the topoloader will insert them.  If not, the connection will fail.</p> <p>Supported in Windows?8.1 and later.</p> </dd>
        /// </summary>
        /// <doc-id>dd388654</doc-id>
        /// <unmanaged>MFTOPOLOGY_HWMODE_USE_ONLY_HARDWARE</unmanaged>
        /// <unmanaged-short>MFTOPOLOGY_HWMODE_USE_ONLY_HARDWARE</unmanaged-short>
        WmodeUseOnlyHardware = unchecked ((System.Int32)(2))}

    [System.FlagsAttribute]
    /// <summary>
    /// <p> </p><p>Defines status flags for the <strong><see cref = "ResolutionStatus"/></strong> attribute.</p>
    /// </summary>
    /// <doc-id>ms704637</doc-id>
    /// <unmanaged>MF_TOPOLOGY_RESOLUTION_STATUS_FLAGS</unmanaged>
    /// <unmanaged-short>MF_TOPOLOGY_RESOLUTION_STATUS_FLAGS</unmanaged-short>
    public enum TopologyResolutionStatusFlags : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms704637</doc-id>
        /// <unmanaged>MF_TOPOLOGY_RESOLUTION_SUCCEEDED</unmanaged>
        /// <unmanaged-short>MF_TOPOLOGY_RESOLUTION_SUCCEEDED</unmanaged-short>
        MfTopologyResolutionSucceeded = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms704637</doc-id>
        /// <unmanaged>MF_OPTIONAL_NODE_REJECTED_MEDIA_TYPE</unmanaged>
        /// <unmanaged-short>MF_OPTIONAL_NODE_REJECTED_MEDIA_TYPE</unmanaged-short>
        MfOptionalNodeRejectedMediaType = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms704637</doc-id>
        /// <unmanaged>MF_OPTIONAL_NODE_REJECTED_PROTECTED_PROCESS</unmanaged>
        /// <unmanaged-short>MF_OPTIONAL_NODE_REJECTED_PROTECTED_PROCESS</unmanaged-short>
        MfOptionalNodeRejectedProtectedProcess = unchecked ((System.Int32)(2)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    /// <summary>
    /// <p> Specifies the status of a topology during playback. </p>
    /// </summary>
    /// <remarks>
    /// <p> This enumeration is used with the MESessionTopologyStatus event. The MESessionTopologyStatus event always has an <strong><see cref = "TopologyStatus"/></strong> attribute whose value is a member of this enumeration. </p><p> For a single topology, the Media Session sends these status flags in numerical order, starting with <strong>MF_TOPOSTATUS_READY</strong>. However, there is no guarantee about the ordering of the events across two different topologies. For example, you might get <strong>MF_TOPOSTATUS_READY</strong> for a topology before you get <strong>MF_TOPOSTATUS_ENDED</strong> for the previous topology. </p>
    /// </remarks>
    /// <doc-id>aa370812</doc-id>
    /// <unmanaged>MF_TOPOSTATUS</unmanaged>
    /// <unmanaged-short>MF_TOPOSTATUS</unmanaged-short>
    public enum TopologyStatus : System.Int32
    {
        /// <summary>
        /// <dd> <p> This value is not used. </p> </dd>
        /// </summary>
        /// <doc-id>aa370812</doc-id>
        /// <unmanaged>MF_TOPOSTATUS_INVALID</unmanaged>
        /// <unmanaged-short>MF_TOPOSTATUS_INVALID</unmanaged-short>
        Invalid = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p> The topology is ready to start. After this status flag is received, you can use the Media Session's <strong>IMFGetService::GetService</strong> method to query the topology for services, such as rate control. </p> </dd>
        /// </summary>
        /// <doc-id>aa370812</doc-id>
        /// <unmanaged>MF_TOPOSTATUS_READY</unmanaged>
        /// <unmanaged-short>MF_TOPOSTATUS_READY</unmanaged-short>
        Ready = unchecked ((System.Int32)(100)),
        /// <summary>
        /// <dd> <p> The Media Session has started to read data from the media sources in the topology. </p> </dd>
        /// </summary>
        /// <doc-id>aa370812</doc-id>
        /// <unmanaged>MF_TOPOSTATUS_STARTED_SOURCE</unmanaged>
        /// <unmanaged-short>MF_TOPOSTATUS_STARTED_SOURCE</unmanaged-short>
        StartedSource = unchecked ((System.Int32)(200)),
        /// <summary>
        /// <dd> <p>The Media Session modified the topology, because the format of a stream changed.</p> </dd>
        /// </summary>
        /// <doc-id>aa370812</doc-id>
        /// <unmanaged>MF_TOPOSTATUS_DYNAMIC_CHANGED</unmanaged>
        /// <unmanaged-short>MF_TOPOSTATUS_DYNAMIC_CHANGED</unmanaged-short>
        DynamicChanged = unchecked ((System.Int32)(210)),
        /// <summary>
        /// <dd> <p> The media sinks have switched from the previous topology to this topology. This status value is not sent for the first topology that is played. For the first topology, the MESessionStarted event indicates that the media sinks have started receiving data. </p> </dd>
        /// </summary>
        /// <doc-id>aa370812</doc-id>
        /// <unmanaged>MF_TOPOSTATUS_SINK_SWITCHED</unmanaged>
        /// <unmanaged-short>MF_TOPOSTATUS_SINK_SWITCHED</unmanaged-short>
        SinkSwitched = unchecked ((System.Int32)(300)),
        /// <summary>
        /// <dd> <p> Playback of this topology is complete. The Media Session might still use the topology internally. The Media Session does not completely release the topology until it sends the next <strong>MF_TOPOSTATUS_STARTED_SOURCE</strong> status event or the MESessionEnded event. </p> </dd>
        /// </summary>
        /// <doc-id>aa370812</doc-id>
        /// <unmanaged>MF_TOPOSTATUS_ENDED</unmanaged>
        /// <unmanaged-short>MF_TOPOSTATUS_ENDED</unmanaged-short>
        Ended = unchecked ((System.Int32)(400))}

    /// <summary>
    /// <p> </p><p>Defines the type of a topology node.</p>
    /// </summary>
    /// <doc-id>ms698973</doc-id>
    /// <unmanaged>MF_TOPOLOGY_TYPE</unmanaged>
    /// <unmanaged-short>MF_TOPOLOGY_TYPE</unmanaged-short>
    public enum TopologyType : System.Int32
    {
        /// <summary>
        /// <dd> <p>Output node. Represents a media sink in the topology.</p> </dd>
        /// </summary>
        /// <doc-id>ms698973</doc-id>
        /// <unmanaged>MF_TOPOLOGY_OUTPUT_NODE</unmanaged>
        /// <unmanaged-short>MF_TOPOLOGY_OUTPUT_NODE</unmanaged-short>
        OutputNode = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>Source node. Represents a media stream in the topology.</p> </dd>
        /// </summary>
        /// <doc-id>ms698973</doc-id>
        /// <unmanaged>MF_TOPOLOGY_SOURCESTREAM_NODE</unmanaged>
        /// <unmanaged-short>MF_TOPOLOGY_SOURCESTREAM_NODE</unmanaged-short>
        SourceStreamNode = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>Transform node. Represents a Media Foundation Transform (MFT) in the topology.</p> </dd>
        /// </summary>
        /// <doc-id>ms698973</doc-id>
        /// <unmanaged>MF_TOPOLOGY_TRANSFORM_NODE</unmanaged>
        /// <unmanaged-short>MF_TOPOLOGY_TRANSFORM_NODE</unmanaged-short>
        TransformNode = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>Tee node. A tee node does not hold a reference to an object. Instead, it represents a fork in the stream. A tee node has one input and multiple outputs, and samples from the upstream node are delivered to all of the downstream nodes.</p> </dd>
        /// </summary>
        /// <doc-id>ms698973</doc-id>
        /// <unmanaged>MF_TOPOLOGY_TEE_NODE</unmanaged>
        /// <unmanaged-short>MF_TOPOLOGY_TEE_NODE</unmanaged-short>
        TeeNode = unchecked ((System.Int32)(3)),
        /// <summary>
        /// <dd> <p>Reserved.</p> </dd>
        /// </summary>
        /// <doc-id>ms698973</doc-id>
        /// <unmanaged>MF_TOPOLOGY_MAX</unmanaged>
        /// <unmanaged-short>MF_TOPOLOGY_MAX</unmanaged-short>
        Maximum = unchecked ((System.Int32)(-1))}

    /// <summary>
    /// <p> </p><p>Defines at what times a transform in a topology is drained.</p>
    /// </summary>
    /// <doc-id>aa370822</doc-id>
    /// <unmanaged>MF_TOPONODE_DRAIN_MODE</unmanaged>
    /// <unmanaged-short>MF_TOPONODE_DRAIN_MODE</unmanaged-short>
    public enum ToponodeDrainMode : System.Int32
    {
        /// <summary>
        /// <dd> <p>The transform is drained when the end of a stream is reached. It is not drained when markout is reached at the end of a segment.</p> </dd>
        /// </summary>
        /// <doc-id>aa370822</doc-id>
        /// <unmanaged>MF_TOPONODE_DRAIN_DEFAULT</unmanaged>
        /// <unmanaged-short>MF_TOPONODE_DRAIN_DEFAULT</unmanaged-short>
        Default = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>The transform is drained whenever a topology ends.</p> </dd>
        /// </summary>
        /// <doc-id>aa370822</doc-id>
        /// <unmanaged>MF_TOPONODE_DRAIN_ALWAYS</unmanaged>
        /// <unmanaged-short>MF_TOPONODE_DRAIN_ALWAYS</unmanaged-short>
        Always = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>The transform is never drained.</p> </dd>
        /// </summary>
        /// <doc-id>aa370822</doc-id>
        /// <unmanaged>MF_TOPONODE_DRAIN_NEVER</unmanaged>
        /// <unmanaged-short>MF_TOPONODE_DRAIN_NEVER</unmanaged-short>
        Never = unchecked ((System.Int32)(2))}

    /// <summary>
    /// <p> </p><p>Defines when a transform in a topology is flushed.</p>
    /// </summary>
    /// <doc-id>ms704760</doc-id>
    /// <unmanaged>MF_TOPONODE_FLUSH_MODE</unmanaged>
    /// <unmanaged-short>MF_TOPONODE_FLUSH_MODE</unmanaged-short>
    public enum ToponodeFlushMode : System.Int32
    {
        /// <summary>
        /// <dd> <p>The transform is flushed whenever the stream changes, including seeks and new segments.</p> </dd>
        /// </summary>
        /// <doc-id>ms704760</doc-id>
        /// <unmanaged>MF_TOPONODE_FLUSH_ALWAYS</unmanaged>
        /// <unmanaged-short>MF_TOPONODE_FLUSH_ALWAYS</unmanaged-short>
        Always = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>The transform is flushed when seeking is performed on the stream.</p> </dd>
        /// </summary>
        /// <doc-id>ms704760</doc-id>
        /// <unmanaged>MF_TOPONODE_FLUSH_SEEK</unmanaged>
        /// <unmanaged-short>MF_TOPONODE_FLUSH_SEEK</unmanaged-short>
        Seek = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>The transform is never flushed during streaming. It is flushed only when the object is released.</p> </dd>
        /// </summary>
        /// <doc-id>ms704760</doc-id>
        /// <unmanaged>MF_TOPONODE_FLUSH_NEVER</unmanaged>
        /// <unmanaged-short>MF_TOPONODE_FLUSH_NEVER</unmanaged-short>
        Never = unchecked ((System.Int32)(2))}

    [System.FlagsAttribute]
    /// <summary>
    /// <p>Defines the profile flags that are set in the <see cref = "TranscodeAdjustProfile"/> attribute.</p><p>These flags are checked by <strong>MFCreateTranscodeTopology</strong> during topology building. Based on these flags, <strong>MFCreateTranscodeTopology</strong> adjusts the  transcode profile by modifying the configuration settings for the streams according to the input requirements of the encoder used in the topology. </p><p>For more information about the stream settings that an application can specify, see Using the Transcode API.</p>
    /// </summary>
    /// <remarks>
    /// <p>If the <strong>MF_TRANSCODE_ADJUST_PROFILE_DEFAULT</strong> flag is specified, the following changes are made for the video stream:</p><ul> <li>If the frame rate of the media source specified in the <em>pSrc</em> parameter of  <strong>MFCreateTranscodeTopology</strong> and the frame rate specified by the application in the <strong><see cref = "FrameRate"/></strong> attribute differ by less than 1/1000, the profile uses the media source frame rate. This is because the pipeline considers the difference to be negligible.</li> <li>If the application does not specify an interlaced mode by setting the <strong><see cref = "InterlaceMode"/></strong> attribute, the profile is changed to use progressive frames.</li> </ul><p>The <strong>MF_TRANSCODE_ADJUST_PROFILE_DEFAULT</strong> flag must be accompanied with the required audio and video stream attributes provided by the application. For the audio stream, the required attributes are as follows:</p><ul> <li> <strong><see cref = "AudioNumChannels"/></strong> </li> <li> <strong><see cref = "AudioSamplesPerSecond"/></strong> </li> <li> <strong><see cref = "AudioBlockAlignment"/></strong> </li> <li> <strong><see cref = "AudioAvgBytesPerSecond"/></strong> </li> <li> <strong><see cref = "AudioBitsPerSample"/></strong> </li> </ul><p> For the video stream, the required attributes are as follows:</p><ul> <li> <strong><see cref = "FrameRate"/></strong> </li> <li> <strong><see cref = "FrameSize"/></strong> </li> <li> <strong><see cref = "AvgBitrate"/></strong> </li> <li> <strong><see cref = "PixelAspectRatio"/></strong> </li> </ul><p> If these attributes are not set, <strong>MFCreateTranscodeTopology</strong> creates the topology but Media Session fails to generate the encoded file. The failure code depends on the MFT node in the topology. For example, if the application does not set the frame size, the WMV encoder fails to encode the content and application gets the <see cref = "InvalidMediaType"/> error code through the Media Session.  </p><p>Use the <strong>MF_TRANSCODE_ADJUST_PROFILE_USE_SOURCE_ATTRIBUTES</strong> flag when you want to transcode the file by using the input stream attributes. The input source stream attributes are copied to the output media type before the MFT node is inserted in the topology. If you set additional stream attributes, this flag does not overwrite the set values. Only the missing attributes are filled with the input source's attribute values. This flag is useful in remux scenario where you want to generate the output file in the same format as the input source. If you want to perform format conversion, make sure you set the <strong><see cref = "Subtype"/></strong> attribute for the stream to specify the encoder that topology builder must use. The transform node is added in the topology unless <see cref = "TranscodeDonotInsertEncoder"/> is set. In this case, and the content is not encoded. Instead, if permitted by the container, the content is embedded in the specified container. </p><p>For example, assume that your input source is an MP3 file.  You set the container to be <strong><see cref = "Asf"/></strong>, you do not set any stream attributes, and you set the <strong>MF_TRANSCODE_ADJUST_PROFILE_USE_SOURCE_ATTRIBUTES</strong> flag. In this case, the generated output file is an ASF file (.wma)  containing MP3 media data. Note that if you use this flag, certain input stream attributes and the container type might not be compatible. </p>
    /// </remarks>
    /// <doc-id>dd388918</doc-id>
    /// <unmanaged>MF_TRANSCODE_ADJUST_PROFILE_FLAGS</unmanaged>
    /// <unmanaged-short>MF_TRANSCODE_ADJUST_PROFILE_FLAGS</unmanaged-short>
    public enum TranscodeAdjustProfileFlags : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd388918</doc-id>
        /// <unmanaged>MF_TRANSCODE_ADJUST_PROFILE_DEFAULT</unmanaged>
        /// <unmanaged-short>MF_TRANSCODE_ADJUST_PROFILE_DEFAULT</unmanaged-short>
        Default = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd388918</doc-id>
        /// <unmanaged>MF_TRANSCODE_ADJUST_PROFILE_USE_SOURCE_ATTRIBUTES</unmanaged>
        /// <unmanaged-short>MF_TRANSCODE_ADJUST_PROFILE_USE_SOURCE_ATTRIBUTES</unmanaged-short>
        UseSourceAttributes = unchecked ((System.Int32)(1)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    [System.FlagsAttribute]
    /// <summary>
    /// <p>Defines flags for the <see cref = "TranscodeTopologymode"/> attribute.</p>
    /// </summary>
    /// <doc-id>dd388926</doc-id>
    /// <unmanaged>MF_TRANSCODE_TOPOLOGYMODE_FLAGS</unmanaged>
    /// <unmanaged-short>MF_TRANSCODE_TOPOLOGYMODE_FLAGS</unmanaged-short>
    public enum TranscodeTopologymodeFlags : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd388926</doc-id>
        /// <unmanaged>MF_TRANSCODE_TOPOLOGYMODE_SOFTWARE_ONLY</unmanaged>
        /// <unmanaged-short>MF_TRANSCODE_TOPOLOGYMODE_SOFTWARE_ONLY</unmanaged-short>
        SoftwareOnly = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd388926</doc-id>
        /// <unmanaged>MF_TRANSCODE_TOPOLOGYMODE_HARDWARE_ALLOWED</unmanaged>
        /// <unmanaged-short>MF_TRANSCODE_TOPOLOGYMODE_HARDWARE_ALLOWED</unmanaged-short>
        HardwareAllowEd = unchecked ((System.Int32)(1)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    [System.FlagsAttribute]
    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>MF_TRANSFER_VIDEO_FRAME_FLAGS</unmanaged>
    /// <unmanaged-short>MF_TRANSFER_VIDEO_FRAME_FLAGS</unmanaged-short>
    public enum TransferVideoFrameFlags : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_TRANSFER_VIDEO_FRAME_DEFAULT</unmanaged>
        /// <unmanaged-short>MF_TRANSFER_VIDEO_FRAME_DEFAULT</unmanaged-short>
        Default = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_TRANSFER_VIDEO_FRAME_STRETCH</unmanaged>
        /// <unmanaged-short>MF_TRANSFER_VIDEO_FRAME_STRETCH</unmanaged-short>
        Stretch = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MF_TRANSFER_VIDEO_FRAME_IGNORE_PAR</unmanaged>
        /// <unmanaged-short>MF_TRANSFER_VIDEO_FRAME_IGNORE_PAR</unmanaged-short>
        IgnorePar = unchecked ((System.Int32)(2)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    [System.FlagsAttribute]
    /// <summary>
    /// <p>Contains flags for registering and enumeration Media Foundation transforms (MFTs).</p><p>These flags are used in the following functions:</p><ul> <li> <strong>MFTEnumEx</strong>: These flags control which Media Foundation transforms (MFTs) are enumerated, as well as the enumeration order.</li> <li> <strong>MFTRegister</strong>: A subset of these flags are used when registering an MFT.</li> </ul>
    /// </summary>
    /// <remarks>
    /// <p>For registration, these flags describe the MFT that is being registered. Some flags do not apply in that context. For enumeration, these flags control which MFTs are selected in the enumeration. For more details about the precise meaning of these flags, see the reference topics for <strong>MFTRegister</strong> and <strong>MFTEnumEx</strong> </p><p>For registration, the <strong>MFT_ENUM_FLAG_SYNCMFT</strong>,  <strong>MFT_ENUM_FLAG_ASYNCMFT</strong>, and <strong>MFT_ENUM_FLAG_HARDWARE</strong> flags are mutually exclusive. For enumeration, these three flags can be combined.</p>
    /// </remarks>
    /// <doc-id>dd389302</doc-id>
    /// <unmanaged>_MFT_ENUM_FLAG</unmanaged>
    /// <unmanaged-short>_MFT_ENUM_FLAG</unmanaged-short>
    public enum TransformEnumFlag : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd389302</doc-id>
        /// <unmanaged>MFT_ENUM_FLAG_SYNCMFT</unmanaged>
        /// <unmanaged-short>MFT_ENUM_FLAG_SYNCMFT</unmanaged-short>
        Syncmft = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd389302</doc-id>
        /// <unmanaged>MFT_ENUM_FLAG_ASYNCMFT</unmanaged>
        /// <unmanaged-short>MFT_ENUM_FLAG_ASYNCMFT</unmanaged-short>
        Asyncmft = unchecked ((System.Int32)(2)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd389302</doc-id>
        /// <unmanaged>MFT_ENUM_FLAG_HARDWARE</unmanaged>
        /// <unmanaged-short>MFT_ENUM_FLAG_HARDWARE</unmanaged-short>
        Hardware = unchecked ((System.Int32)(4)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd389302</doc-id>
        /// <unmanaged>MFT_ENUM_FLAG_FIELDOFUSE</unmanaged>
        /// <unmanaged-short>MFT_ENUM_FLAG_FIELDOFUSE</unmanaged-short>
        Fieldofuse = unchecked ((System.Int32)(8)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd389302</doc-id>
        /// <unmanaged>MFT_ENUM_FLAG_LOCALMFT</unmanaged>
        /// <unmanaged-short>MFT_ENUM_FLAG_LOCALMFT</unmanaged-short>
        Localmft = unchecked ((System.Int32)(16)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd389302</doc-id>
        /// <unmanaged>MFT_ENUM_FLAG_TRANSCODE_ONLY</unmanaged>
        /// <unmanaged-short>MFT_ENUM_FLAG_TRANSCODE_ONLY</unmanaged-short>
        TranscodeOnly = unchecked ((System.Int32)(32)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd389302</doc-id>
        /// <unmanaged>MFT_ENUM_FLAG_SORTANDFILTER</unmanaged>
        /// <unmanaged-short>MFT_ENUM_FLAG_SORTANDFILTER</unmanaged-short>
        SortAndFilter = unchecked ((System.Int32)(64)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd389302</doc-id>
        /// <unmanaged>MFT_ENUM_FLAG_SORTANDFILTER_APPROVED_ONLY</unmanaged>
        /// <unmanaged-short>MFT_ENUM_FLAG_SORTANDFILTER_APPROVED_ONLY</unmanaged-short>
        SortAndFilterApprovedOnly = unchecked ((System.Int32)(192)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd389302</doc-id>
        /// <unmanaged>MFT_ENUM_FLAG_SORTANDFILTER_WEB_ONLY</unmanaged>
        /// <unmanaged-short>MFT_ENUM_FLAG_SORTANDFILTER_WEB_ONLY</unmanaged-short>
        SortAndFilterWebOnly = unchecked ((System.Int32)(320)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd389302</doc-id>
        /// <unmanaged>MFT_ENUM_FLAG_SORTANDFILTER_WEB_ONLY_EDGEMODE</unmanaged>
        /// <unmanaged-short>MFT_ENUM_FLAG_SORTANDFILTER_WEB_ONLY_EDGEMODE</unmanaged-short>
        SortAndFilterWebOnlyEdgemode = unchecked ((System.Int32)(576)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd389302</doc-id>
        /// <unmanaged>MFT_ENUM_FLAG_UNTRUSTED_STOREMFT</unmanaged>
        /// <unmanaged-short>MFT_ENUM_FLAG_UNTRUSTED_STOREMFT</unmanaged-short>
        UntrustedStoremft = unchecked ((System.Int32)(1024)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dd389302</doc-id>
        /// <unmanaged>MFT_ENUM_FLAG_ALL</unmanaged>
        /// <unmanaged-short>MFT_ENUM_FLAG_ALL</unmanaged-short>
        All = unchecked ((System.Int32)(63)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    [System.FlagsAttribute]
    /// <summary>
    /// <p> </p><p>Defines flags for processing output samples in a Media Foundation transform (MFT).</p>
    /// </summary>
    /// <doc-id>ms700163</doc-id>
    /// <unmanaged>_MFT_PROCESS_OUTPUT_FLAGS</unmanaged>
    /// <unmanaged-short>_MFT_PROCESS_OUTPUT_FLAGS</unmanaged-short>
    public enum TransformProcessOutputFlags : System.Int32
    {
        /// <summary>
        /// <dd> <p>Do not produce output for streams in which the <strong>pSample</strong> member of the <strong><see cref = "SharpDX.MediaFoundation.TOutputDataBuffer"/></strong> structure is <strong><c>null</c></strong>. This flag is not valid unless the MFT has marked the output stream with the MFT_OUTPUT_STREAM_DISCARDABLE or MFT_OUTPUT_STREAM_LAZY_READ flag. For more information, see <strong>IMFTransform::GetOutputStreamInfo</strong>.</p> </dd>
        /// </summary>
        /// <doc-id>ms700163</doc-id>
        /// <unmanaged>MFT_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER</unmanaged>
        /// <unmanaged-short>MFT_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER</unmanaged-short>
        MftProcessOutputDiscardWhenNoBuffer = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>Regenerates the last output sample.</p> <p><strong>Note</strong> Requires Windows?8.</p> </dd>
        /// </summary>
        /// <doc-id>ms700163</doc-id>
        /// <unmanaged>MFT_PROCESS_OUTPUT_REGENERATE_LAST_OUTPUT</unmanaged>
        /// <unmanaged-short>MFT_PROCESS_OUTPUT_REGENERATE_LAST_OUTPUT</unmanaged-short>
        MftProcessOutputRegenerateLastOutput = unchecked ((System.Int32)(2)),
        /// <summary>
        /// None
        /// </summary>
        /// <unmanaged>None</unmanaged>
        /// <unmanaged-short>None</unmanaged-short>
        None = unchecked ((System.Int32)(0))}

    /// <summary>
    /// <p> </p><p>Indicates the status of a call to <strong>IMFTransform::ProcessOutput</strong>.</p>
    /// </summary>
    /// <remarks>
    /// <p>If the MFT sets this flag, the <strong>ProcessOutput</strong> method returns <see cref = "TransformStreamChange"/> and no output data is produced. The client should respond as follows:</p><ol> <li> <p>Call <strong>IMFTransform::GetStreamCount</strong> to get the new number of streams.</p> </li> <li> <p>Call <strong>IMFTransform::GetStreamIDs</strong> to get the new stream identifiers.</p> </li> <li> <p>Call <strong>IMFTransform::GetOutputAvailableType</strong> and <strong>IMFTransform::SetOutputType</strong> to set the media types on the new streams.</p> </li> </ol><p>Until these steps are completed, all further calls to <strong>ProcessOutput</strong> return <see cref = "TransformStreamChange"/>.</p>
    /// </remarks>
    /// <doc-id>ms699875</doc-id>
    /// <unmanaged>_MFT_PROCESS_OUTPUT_STATUS</unmanaged>
    /// <unmanaged-short>_MFT_PROCESS_OUTPUT_STATUS</unmanaged-short>
    public enum TransformProcessOutputStatus : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms699875</doc-id>
        /// <unmanaged>MFT_PROCESS_OUTPUT_STATUS_NEW_STREAMS</unmanaged>
        /// <unmanaged-short>MFT_PROCESS_OUTPUT_STATUS_NEW_STREAMS</unmanaged-short>
        MftProcessOutputStatusNewStreams = unchecked ((System.Int32)(256))}

    /// <summary>
    /// <p> </p><p>Indicates whether the URL is from a trusted source.</p>
    /// </summary>
    /// <doc-id>ms705652</doc-id>
    /// <unmanaged>MF_URL_TRUST_STATUS</unmanaged>
    /// <unmanaged-short>MF_URL_TRUST_STATUS</unmanaged-short>
    public enum UrlTrustStatus : System.Int32
    {
        /// <summary>
        /// <dd> <p>The validity of the URL cannot be guaranteed because it is not signed. The application should warn the user.</p> </dd>
        /// </summary>
        /// <doc-id>ms705652</doc-id>
        /// <unmanaged>MF_LICENSE_URL_UNTRUSTED</unmanaged>
        /// <unmanaged-short>MF_LICENSE_URL_UNTRUSTED</unmanaged-short>
        MfLicenseUrlUntrusted = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>The URL is the original one provided with the content.</p> </dd>
        /// </summary>
        /// <doc-id>ms705652</doc-id>
        /// <unmanaged>MF_LICENSE_URL_TRUSTED</unmanaged>
        /// <unmanaged-short>MF_LICENSE_URL_TRUSTED</unmanaged-short>
        MfLicenseUrlTrusted = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>The URL was originally signed and has been tampered with. The file should be considered corrupted, and the application should not navigate to the URL without issuing a strong warning the user.</p> </dd>
        /// </summary>
        /// <doc-id>ms705652</doc-id>
        /// <unmanaged>MF_LICENSE_URL_TAMPERED</unmanaged>
        /// <unmanaged-short>MF_LICENSE_URL_TAMPERED</unmanaged-short>
        MfLicenseUrlTampered = unchecked ((System.Int32)(2))}

    /// <summary>
    /// <p>Specifies how 3D video frames are stored in memory.</p>
    /// </summary>
    /// <remarks>
    /// <p>This enumeration is used with the <see cref = "Video3dFormat"/> attribute.</p>
    /// </remarks>
    /// <doc-id>hh162802</doc-id>
    /// <unmanaged>MFVideo3DFormat</unmanaged>
    /// <unmanaged-short>MFVideo3DFormat</unmanaged-short>
    public enum Video3DFormat : System.Int32
    {
        /// <summary>
        /// <dd> <p>The base view is stored in a single buffer. The other view is discarded.</p> </dd>
        /// </summary>
        /// <doc-id>hh162802</doc-id>
        /// <unmanaged>MFVideo3DSampleFormat_BaseView</unmanaged>
        /// <unmanaged-short>MFVideo3DSampleFormat_BaseView</unmanaged-short>
        SampleFormatBaseView = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>Each media sample contains multiple buffers, one for each view.</p> </dd>
        /// </summary>
        /// <doc-id>hh162802</doc-id>
        /// <unmanaged>MFVideo3DSampleFormat_MultiView</unmanaged>
        /// <unmanaged-short>MFVideo3DSampleFormat_MultiView</unmanaged-short>
        SampleFormatMultiView = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>Each media sample contains one buffer, with both views packed side-by-side into a single frame. </p> </dd>
        /// </summary>
        /// <doc-id>hh162802</doc-id>
        /// <unmanaged>MFVideo3DSampleFormat_Packed_LeftRight</unmanaged>
        /// <unmanaged-short>MFVideo3DSampleFormat_Packed_LeftRight</unmanaged-short>
        SampleFormatPackedLeftRight = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>Each media sample contains one buffer, with both views packed top-and-bottom into a single frame. </p> </dd>
        /// </summary>
        /// <doc-id>hh162802</doc-id>
        /// <unmanaged>MFVideo3DSampleFormat_Packed_TopBottom</unmanaged>
        /// <unmanaged-short>MFVideo3DSampleFormat_Packed_TopBottom</unmanaged-short>
        SampleFormatPackedTopBottom = unchecked ((System.Int32)(3))}

    /// <summary>
    /// <p>Specifies how to  output a 3D stereoscopic video stream.</p>
    /// </summary>
    /// <remarks>
    /// <p>This enumeration is used with the <see cref = "Enable3dvideoOutput"/> attribute.</p>
    /// </remarks>
    /// <doc-id>hh162743</doc-id>
    /// <unmanaged>MF3DVideoOutputType</unmanaged>
    /// <unmanaged-short>MF3DVideoOutputType</unmanaged-short>
    public enum Video3DOutputType : System.Int32
    {
        /// <summary>
        /// <dd> <p>Output the base view only. Discard the other view.</p> </dd>
        /// </summary>
        /// <doc-id>hh162743</doc-id>
        /// <unmanaged>MF3DVideoOutputType_BaseView</unmanaged>
        /// <unmanaged-short>MF3DVideoOutputType_BaseView</unmanaged-short>
        BaseView = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>Output a stereo view (two buffers).</p> </dd>
        /// </summary>
        /// <doc-id>hh162743</doc-id>
        /// <unmanaged>MF3DVideoOutputType_Stereo</unmanaged>
        /// <unmanaged-short>MF3DVideoOutputType_Stereo</unmanaged-short>
        Stereo = unchecked ((System.Int32)(1))}

    /// <summary>
    /// <p>Specifies how a 3D video frame is stored in a media sample.</p>
    /// </summary>
    /// <remarks>
    /// <p>This enumeration is used with the <see cref = "Video3DSampleFormat"/> attribute.</p><p>The exact layout of the views in memory is specified by the following media type attributes:</p><ul> <li> <see cref = "Video3dFormat"/> </li> <li> <see cref = "Video3dFirstIsLeft"/> </li> <li> <see cref = "Video3dLeftIsBase"/> </li> <li> <see cref = "Video3dNumViews"/> </li> </ul>
    /// </remarks>
    /// <doc-id>hh162803</doc-id>
    /// <unmanaged>MFVideo3DSampleFormat</unmanaged>
    /// <unmanaged-short>MFVideo3DSampleFormat</unmanaged-short>
    public enum Video3DSampleFormat : System.Int32
    {
        /// <summary>
        /// <dd> <p>Each view is stored in a separate buffer. The sample contains one buffer per view.</p> </dd>
        /// </summary>
        /// <doc-id>hh162803</doc-id>
        /// <unmanaged>MFSampleExtension_3DVideo_MultiView</unmanaged>
        /// <unmanaged-short>MFSampleExtension_3DVideo_MultiView</unmanaged-short>
        MFSampleExtension3DVideoMultiView = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>All of the views are stored in the same buffer. The sample contains a single buffer. </p> </dd>
        /// </summary>
        /// <doc-id>hh162803</doc-id>
        /// <unmanaged>MFSampleExtension_3DVideo_Packed</unmanaged>
        /// <unmanaged-short>MFSampleExtension_3DVideo_Packed</unmanaged-short>
        MFSampleExtension3DVideoPacked = unchecked ((System.Int32)(0))}

    /// <summary>
    /// <p> </p><p>Specifies the aspect-ratio mode.</p>
    /// </summary>
    /// <doc-id>ms703040</doc-id>
    /// <unmanaged>MFVideoAspectRatioMode</unmanaged>
    /// <unmanaged-short>MFVideoAspectRatioMode</unmanaged-short>
    public enum VideoAspectRatioMode : System.Int32
    {
        /// <summary>
        /// <dd> <p>Do not maintain the aspect ratio of the video. Stretch the video to fit the output rectangle.</p> </dd>
        /// </summary>
        /// <doc-id>ms703040</doc-id>
        /// <unmanaged>MFVideoARMode_None</unmanaged>
        /// <unmanaged-short>MFVideoARMode_None</unmanaged-short>
        RModeNone = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>Preserve the aspect ratio of the video by letterboxing or within the output rectangle.</p> </dd>
        /// </summary>
        /// <doc-id>ms703040</doc-id>
        /// <unmanaged>MFVideoARMode_PreservePicture</unmanaged>
        /// <unmanaged-short>MFVideoARMode_PreservePicture</unmanaged-short>
        RModePreservePicture = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <strong>Note</strong>??Currently the EVR ignores this flag. ? <p>Correct the aspect ratio if the physical size of the display device does not match the display resolution. For example, if the native resolution of the monitor is 1600 by 1200 (4:3) but the display resolution is 1280 by 1024 (5:4), the monitor will display non-square pixels.</p> <p>If this flag is set, you must also set the <strong>MFVideoARMode_PreservePicture</strong> flag.</p> </dd>
        /// </summary>
        /// <doc-id>ms703040</doc-id>
        /// <unmanaged>MFVideoARMode_PreservePixel</unmanaged>
        /// <unmanaged-short>MFVideoARMode_PreservePixel</unmanaged-short>
        RModePreservePixel = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>Apply a non-linear horizontal stretch if the aspect ratio of the destination rectangle does not match the aspect ratio of the source rectangle.</p> <p>The non-linear stretch algorithm preserves the aspect ratio in the middle of the picture and stretches (or shrinks) the image progressively more toward the left and right. This mode is useful when viewing 4:3 content full-screen on a 16:9 display, instead of pillar-boxing. Non-linear vertical stretch is not supported, because the visual results are generally poor.</p> <p>This mode may cause performance degradation.</p> <p>If this flag is set, you must also set the <strong>MFVideoARMode_PreservePixel</strong> and <strong>MFVideoARMode_PreservePicture</strong> flags.</p> </dd>
        /// </summary>
        /// <doc-id>ms703040</doc-id>
        /// <unmanaged>MFVideoARMode_NonLinearStretch</unmanaged>
        /// <unmanaged-short>MFVideoARMode_NonLinearStretch</unmanaged-short>
        RModeNonLinearStretch = unchecked ((System.Int32)(4))}

    /// <summary>
    /// <p> </p><p>Contains flags that define the chroma encoding scheme for Y'Cb'Cr' data.</p>
    /// </summary>
    /// <remarks>
    /// <p>These flags are used with the <strong><see cref = "VideoChromaSiting"/></strong> attribute.</p><p>For more information about these values, see the remarks for the <strong>DXVA2_VideoChromaSubSampling</strong> enumeration, which is the DirectX Video Acceleration (DXVA) equivalent of this enumeration.</p>
    /// </remarks>
    /// <doc-id>ms698989</doc-id>
    /// <unmanaged>MFVideoChromaSubsampling</unmanaged>
    /// <unmanaged-short>MFVideoChromaSubsampling</unmanaged-short>
    public enum VideoChromaSubsampling : System.Int32
    {
        /// <summary>
        /// <dd> <p>Unknown encoding scheme.</p> </dd>
        /// </summary>
        /// <doc-id>ms698989</doc-id>
        /// <unmanaged>MFVideoChromaSubsampling_Unknown</unmanaged>
        /// <unmanaged-short>MFVideoChromaSubsampling_Unknown</unmanaged-short>
        Unknown = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>Chroma should be reconstructed as if the underlying video was progressive content, rather than skipping fields or applying chroma filtering to minimize artifacts from reconstructing 4:2:0 interlaced chroma.</p> </dd>
        /// </summary>
        /// <doc-id>ms698989</doc-id>
        /// <unmanaged>MFVideoChromaSubsampling_ProgressiveChroma</unmanaged>
        /// <unmanaged-short>MFVideoChromaSubsampling_ProgressiveChroma</unmanaged-short>
        ProgressiveChroma = unchecked ((System.Int32)(8)),
        /// <summary>
        /// <dd> <p>Chroma samples are aligned horizontally with the luma samples, or with multiples of the luma samples. If this flag is not set, chroma samples are located 1/2 pixel to the right of the corresponding luma sample.</p> </dd>
        /// </summary>
        /// <doc-id>ms698989</doc-id>
        /// <unmanaged>MFVideoChromaSubsampling_Horizontally_Cosited</unmanaged>
        /// <unmanaged-short>MFVideoChromaSubsampling_Horizontally_Cosited</unmanaged-short>
        HorizontallyCosited = unchecked ((System.Int32)(4)),
        /// <summary>
        /// <dd> <p>Chroma samples are aligned vertically with the luma samples, or with multiples of the luma samples. If this flag is not set, chroma samples are located 1/2 pixel down from the corresponding luma sample.</p> </dd>
        /// </summary>
        /// <doc-id>ms698989</doc-id>
        /// <unmanaged>MFVideoChromaSubsampling_Vertically_Cosited</unmanaged>
        /// <unmanaged-short>MFVideoChromaSubsampling_Vertically_Cosited</unmanaged-short>
        VerticallyCosited = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>The U and V planes are aligned vertically. If this flag is not set, the chroma planes are assumed to be out of phase by 1/2 chroma sample, alternating between a line of U followed by a line of V.</p> </dd>
        /// </summary>
        /// <doc-id>ms698989</doc-id>
        /// <unmanaged>MFVideoChromaSubsampling_Vertically_AlignedChromaPlanes</unmanaged>
        /// <unmanaged-short>MFVideoChromaSubsampling_Vertically_AlignedChromaPlanes</unmanaged-short>
        VerticallyAlignedChromaPlanes = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>Specifies the chroma encoding scheme for MPEG-2 video. Chroma samples are aligned horizontally with the luma samples, but are not aligned vertically. The U and V planes are aligned vertically.</p> </dd>
        /// </summary>
        /// <doc-id>ms698989</doc-id>
        /// <unmanaged>MFVideoChromaSubsampling_MPEG2</unmanaged>
        /// <unmanaged-short>MFVideoChromaSubsampling_MPEG2</unmanaged-short>
        Mpeg2 = unchecked ((System.Int32)(5)),
        /// <summary>
        /// <dd> <p>Specifies the chroma encoding scheme for MPEG-1 video.</p> </dd>
        /// </summary>
        /// <doc-id>ms698989</doc-id>
        /// <unmanaged>MFVideoChromaSubsampling_MPEG1</unmanaged>
        /// <unmanaged-short>MFVideoChromaSubsampling_MPEG1</unmanaged-short>
        Mpeg1 = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>Specifies the chroma encoding scheme for PAL DV video.</p> </dd>
        /// </summary>
        /// <doc-id>ms698989</doc-id>
        /// <unmanaged>MFVideoChromaSubsampling_DV_PAL</unmanaged>
        /// <unmanaged-short>MFVideoChromaSubsampling_DV_PAL</unmanaged-short>
        DvPal = unchecked ((System.Int32)(6)),
        /// <summary>
        /// <dd> <p>Chroma samples are aligned vertically and horizontally with the luma samples. YUV formats such as 4:4:4, 4:2:2, and 4:1:1 are always cosited in both directions and should use this flag.</p> </dd>
        /// </summary>
        /// <doc-id>ms698989</doc-id>
        /// <unmanaged>MFVideoChromaSubsampling_Cosited</unmanaged>
        /// <unmanaged-short>MFVideoChromaSubsampling_Cosited</unmanaged-short>
        Cosited = unchecked ((System.Int32)(7)),
        /// <summary>
        /// <dd> <p>Reserved.</p> </dd>
        /// </summary>
        /// <doc-id>ms698989</doc-id>
        /// <unmanaged>MFVideoChromaSubsampling_Last</unmanaged>
        /// <unmanaged-short>MFVideoChromaSubsampling_Last</unmanaged-short>
        Last = unchecked ((System.Int32)(8)),
        /// <summary>
        /// <dd> <p>Reserved. This member forces the enumeration type to compile as a <strong><see cref = "System.Int32"/></strong> value.</p> </dd>
        /// </summary>
        /// <doc-id>ms698989</doc-id>
        /// <unmanaged>MFVideoChromaSubsampling_ForceDWORD</unmanaged>
        /// <unmanaged-short>MFVideoChromaSubsampling_ForceDWORD</unmanaged-short>
        ForceDWORD = unchecked ((System.Int32)(2147483647))}

    /// <summary>
    /// <p>Specifies the type of copy protection required for a video stream. </p>
    /// </summary>
    /// <remarks>
    /// <p>Use these flags with the <strong><see cref = "DrmFlags"/></strong> attribute.</p>
    /// </remarks>
    /// <doc-id>ms698900</doc-id>
    /// <unmanaged>MFVideoDRMFlags</unmanaged>
    /// <unmanaged-short>MFVideoDRMFlags</unmanaged-short>
    public enum VideoDRMFlags : System.Int32
    {
        /// <summary>
        /// <dd> <p>No copy protection is required. </p> </dd>
        /// </summary>
        /// <doc-id>ms698900</doc-id>
        /// <unmanaged>MFVideoDRMFlag_None</unmanaged>
        /// <unmanaged-short>MFVideoDRMFlag_None</unmanaged-short>
        None = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>Analog copy protection should be applied. </p> </dd>
        /// </summary>
        /// <doc-id>ms698900</doc-id>
        /// <unmanaged>MFVideoDRMFlag_AnalogProtected</unmanaged>
        /// <unmanaged-short>MFVideoDRMFlag_AnalogProtected</unmanaged-short>
        AnalogProtected = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>Digital copy protection should be applied. </p> </dd>
        /// </summary>
        /// <doc-id>ms698900</doc-id>
        /// <unmanaged>MFVideoDRMFlag_DigitallyProtected</unmanaged>
        /// <unmanaged-short>MFVideoDRMFlag_DigitallyProtected</unmanaged-short>
        DigitallyProtected = unchecked ((System.Int32)(2))}

    /// <summary>
    /// <p>Contains flags that describe a video stream.</p><p>These flags are used in the <strong><see cref = "SharpDX.MediaFoundation.VideoInfo"/></strong> structure, which is part of the <strong><see cref = "SharpDX.MediaFoundation.VideoFormat"/></strong> structure.</p>
    /// </summary>
    /// <remarks>
    /// <p>Developers are encouraged to use media type attributes instead of using the <strong><see cref = "SharpDX.MediaFoundation.VideoFormat"/></strong> structure. The following table lists the attributes that correspond to the flags defined in this enumeration.</p><table> <tr><th>Flags</th><th>Media Type Attribute</th></tr> <tr><td> <p>MFVideoFlag_PAD_TO_None</p> <p>MFVideoFlag_PAD_TO_4x3</p> <p>MFVideoFlag_PAD_TO_16x9</p> </td><td> <strong><see cref = "PadControlFlags"/></strong> </td></tr> <tr><td> <p>MFVideoFlag_SrcContentHint16x9</p> <p>MFVideoFlag_SrcContentHint16x9</p> <p>MFVideoFlag_SrcContentHint235_1</p> </td><td> <strong><see cref = "SourceContentHint"/></strong> </td></tr> <tr><td> <p>MFVideoFlag_AnalogProtected</p> <p>MFVideoFlag_DigitallyProtected</p> </td><td> <strong><see cref = "DrmFlags"/></strong> </td></tr> <tr><td>MFVideoFlag_PanScanEnabled</td><td> <strong><see cref = "PanScanEnabled"/></strong> </td></tr> <tr><td>MFVideoFlag_BottomUpLinearRep</td><td>Use the <strong><see cref = "DefaultStride"/></strong> attribute to specify a negative stride.</td></tr> </table><p>?</p><p>The following flags were defined to describe per-sample interlacing information, but are obsolete:</p><ul> <li> MFVideoFlag_ProgressiveContent </li> <li> MFVideoFlag_FieldRepeatCountMask </li> <li> MFVideoFlag_FieldRepeatCountShift </li> <li> MFVideoFlag_ProgressiveSeqReset </li> <li> MFVideoFlag_LowerFieldFirst </li> </ul><p>Instead, components should use sample attributes to describe per-sample interlacing information, as described in the topic Video Interlacing.</p>
    /// </remarks>
    /// <doc-id>aa473786</doc-id>
    /// <unmanaged>MFVideoFlags</unmanaged>
    /// <unmanaged-short>MFVideoFlags</unmanaged-short>
    public enum VideoFlags : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa473786</doc-id>
        /// <unmanaged>MFVideoFlag_PAD_TO_None</unmanaged>
        /// <unmanaged-short>MFVideoFlag_PAD_TO_None</unmanaged-short>
        PadToNone = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa473786</doc-id>
        /// <unmanaged>MFVideoFlag_PAD_TO_4x3</unmanaged>
        /// <unmanaged-short>MFVideoFlag_PAD_TO_4x3</unmanaged-short>
        PadTo4x3 = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa473786</doc-id>
        /// <unmanaged>MFVideoFlag_PAD_TO_16x9</unmanaged>
        /// <unmanaged-short>MFVideoFlag_PAD_TO_16x9</unmanaged-short>
        PadTo16x9 = unchecked ((System.Int32)(2)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa473786</doc-id>
        /// <unmanaged>MFVideoFlag_SrcContentHintMask</unmanaged>
        /// <unmanaged-short>MFVideoFlag_SrcContentHintMask</unmanaged-short>
        SrcContentHintMask = unchecked ((System.Int32)(28)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa473786</doc-id>
        /// <unmanaged>MFVideoFlag_SrcContentHintNone</unmanaged>
        /// <unmanaged-short>MFVideoFlag_SrcContentHintNone</unmanaged-short>
        SrcContentHintNone = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa473786</doc-id>
        /// <unmanaged>MFVideoFlag_SrcContentHint16x9</unmanaged>
        /// <unmanaged-short>MFVideoFlag_SrcContentHint16x9</unmanaged-short>
        SrcContentHint16x9 = unchecked ((System.Int32)(4)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa473786</doc-id>
        /// <unmanaged>MFVideoFlag_SrcContentHint235_1</unmanaged>
        /// <unmanaged-short>MFVideoFlag_SrcContentHint235_1</unmanaged-short>
        SrcContentHint2351 = unchecked ((System.Int32)(8)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa473786</doc-id>
        /// <unmanaged>MFVideoFlag_AnalogProtected</unmanaged>
        /// <unmanaged-short>MFVideoFlag_AnalogProtected</unmanaged-short>
        AnalogProtected = unchecked ((System.Int32)(32)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa473786</doc-id>
        /// <unmanaged>MFVideoFlag_DigitallyProtected</unmanaged>
        /// <unmanaged-short>MFVideoFlag_DigitallyProtected</unmanaged-short>
        DigitallyProtected = unchecked ((System.Int32)(64)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa473786</doc-id>
        /// <unmanaged>MFVideoFlag_ProgressiveContent</unmanaged>
        /// <unmanaged-short>MFVideoFlag_ProgressiveContent</unmanaged-short>
        ProgressiveContent = unchecked ((System.Int32)(128)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa473786</doc-id>
        /// <unmanaged>MFVideoFlag_FieldRepeatCountMask</unmanaged>
        /// <unmanaged-short>MFVideoFlag_FieldRepeatCountMask</unmanaged-short>
        FieldRepeatCountMask = unchecked ((System.Int32)(1792)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa473786</doc-id>
        /// <unmanaged>MFVideoFlag_FieldRepeatCountShift</unmanaged>
        /// <unmanaged-short>MFVideoFlag_FieldRepeatCountShift</unmanaged-short>
        FieldRepeatCountShift = unchecked ((System.Int32)(8)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa473786</doc-id>
        /// <unmanaged>MFVideoFlag_ProgressiveSeqReset</unmanaged>
        /// <unmanaged-short>MFVideoFlag_ProgressiveSeqReset</unmanaged-short>
        ProgressiveSeqReset = unchecked ((System.Int32)(2048)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa473786</doc-id>
        /// <unmanaged>MFVideoFlag_PanScanEnabled</unmanaged>
        /// <unmanaged-short>MFVideoFlag_PanScanEnabled</unmanaged-short>
        PanScanEnabled = unchecked ((System.Int32)(131072)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa473786</doc-id>
        /// <unmanaged>MFVideoFlag_LowerFieldFirst</unmanaged>
        /// <unmanaged-short>MFVideoFlag_LowerFieldFirst</unmanaged-short>
        LowerFieldFirst = unchecked ((System.Int32)(262144)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa473786</doc-id>
        /// <unmanaged>MFVideoFlag_BottomUpLinearRep</unmanaged>
        /// <unmanaged-short>MFVideoFlag_BottomUpLinearRep</unmanaged-short>
        BottomUpLinearRep = unchecked ((System.Int32)(524288)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa473786</doc-id>
        /// <unmanaged>MFVideoFlags_DXVASurface</unmanaged>
        /// <unmanaged-short>MFVideoFlags_DXVASurface</unmanaged-short>
        SDXVASurface = unchecked ((System.Int32)(1048576)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa473786</doc-id>
        /// <unmanaged>MFVideoFlags_RenderTargetSurface</unmanaged>
        /// <unmanaged-short>MFVideoFlags_RenderTargetSurface</unmanaged-short>
        SRenderTargetSurface = unchecked ((System.Int32)(4194304)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>aa473786</doc-id>
        /// <unmanaged>MFVideoFlags_ForceQWORD</unmanaged>
        /// <unmanaged-short>MFVideoFlags_ForceQWORD</unmanaged-short>
        SForceQWORD = unchecked ((System.Int32)(2147483647))}

    /// <summary>
    /// <p>Specifies how a video stream is interlaced.</p><p>In the descriptions that follow, upper field refers to the field that contains the leading half scan line. Lower field refers to the field that contains the first full scan line.</p>
    /// </summary>
    /// <remarks>
    /// <p>Scan lines in the lower field are 0.5 scan line lower than those in the upper field. In NTSC television, a frame consists of a lower field followed by an upper field. In PAL television, a frame consists of an upper field followed by a lower field.</p><p>The upper field is also called the even field, the top field, or field 2. The lower field is also called the odd field, the bottom field, or field 1.</p><p>If the interlace mode is MFVideoInterlace_FieldSingleUpper or MFVideoInterlace_FieldSingleLower, each sample contains a single field, so each buffer contains only half the number of field lines given in the media type.</p>
    /// </remarks>
    /// <doc-id>ms694269</doc-id>
    /// <unmanaged>MFVideoInterlaceMode</unmanaged>
    /// <unmanaged-short>MFVideoInterlaceMode</unmanaged-short>
    public enum VideoInterlaceMode : System.Int32
    {
        /// <summary>
        /// <dd> <p> The type of interlacing is not known. </p> </dd>
        /// </summary>
        /// <doc-id>ms694269</doc-id>
        /// <unmanaged>MFVideoInterlace_Unknown</unmanaged>
        /// <unmanaged-short>MFVideoInterlace_Unknown</unmanaged-short>
        Unknown = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p> Progressive frames. </p> </dd>
        /// </summary>
        /// <doc-id>ms694269</doc-id>
        /// <unmanaged>MFVideoInterlace_Progressive</unmanaged>
        /// <unmanaged-short>MFVideoInterlace_Progressive</unmanaged-short>
        Progressive = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p> Interlaced frames. Each frame contains two fields. The field lines are interleaved, with the upper field appearing on the first line. </p> </dd>
        /// </summary>
        /// <doc-id>ms694269</doc-id>
        /// <unmanaged>MFVideoInterlace_FieldInterleavedUpperFirst</unmanaged>
        /// <unmanaged-short>MFVideoInterlace_FieldInterleavedUpperFirst</unmanaged-short>
        FieldInterleavedUpperFirst = unchecked ((System.Int32)(3)),
        /// <summary>
        /// <dd> <p> Interlaced frames. Each frame contains two fields. The field lines are interleaved, with the lower field appearing on the first line. </p> </dd>
        /// </summary>
        /// <doc-id>ms694269</doc-id>
        /// <unmanaged>MFVideoInterlace_FieldInterleavedLowerFirst</unmanaged>
        /// <unmanaged-short>MFVideoInterlace_FieldInterleavedLowerFirst</unmanaged-short>
        FieldInterleavedLowerFirst = unchecked ((System.Int32)(4)),
        /// <summary>
        /// <dd> <p> Interlaced frames. Each frame contains one field, with the upper field appearing first. </p> </dd>
        /// </summary>
        /// <doc-id>ms694269</doc-id>
        /// <unmanaged>MFVideoInterlace_FieldSingleUpper</unmanaged>
        /// <unmanaged-short>MFVideoInterlace_FieldSingleUpper</unmanaged-short>
        FieldSingleUpper = unchecked ((System.Int32)(5)),
        /// <summary>
        /// <dd> <p> Interlaced frames. Each frame contains one field, with the lower field appearing first. </p> </dd>
        /// </summary>
        /// <doc-id>ms694269</doc-id>
        /// <unmanaged>MFVideoInterlace_FieldSingleLower</unmanaged>
        /// <unmanaged-short>MFVideoInterlace_FieldSingleLower</unmanaged-short>
        FieldSingleLower = unchecked ((System.Int32)(6)),
        /// <summary>
        /// <dd> <p> The stream contains a mix of interlaced and progressive modes. </p> </dd>
        /// </summary>
        /// <doc-id>ms694269</doc-id>
        /// <unmanaged>MFVideoInterlace_MixedInterlaceOrProgressive</unmanaged>
        /// <unmanaged-short>MFVideoInterlace_MixedInterlaceOrProgressive</unmanaged-short>
        MixedInterlaceOrProgressive = unchecked ((System.Int32)(7)),
        /// <summary>
        /// <dd> <p> Reserved. </p> </dd>
        /// </summary>
        /// <doc-id>ms694269</doc-id>
        /// <unmanaged>MFVideoInterlace_Last</unmanaged>
        /// <unmanaged-short>MFVideoInterlace_Last</unmanaged-short>
        Last = unchecked ((System.Int32)(8)),
        /// <summary>
        /// <dd> <p> Reserved. This member forces the enumeration type to compile as a <strong><see cref = "System.Int32"/></strong> value. </p> </dd>
        /// </summary>
        /// <doc-id>ms694269</doc-id>
        /// <unmanaged>MFVideoInterlace_ForceDWORD</unmanaged>
        /// <unmanaged-short>MFVideoInterlace_ForceDWORD</unmanaged-short>
        ForceDWORD = unchecked ((System.Int32)(2147483647))}

    /// <summary>
    /// <p> </p><p>Describes the optimal lighting for viewing a particular set of video content.</p>
    /// </summary>
    /// <remarks>
    /// <p>This enumeration is used with the <strong><see cref = "VideoLighting"/></strong> attribute.</p>
    /// </remarks>
    /// <doc-id>ms696202</doc-id>
    /// <unmanaged>MFVideoLighting</unmanaged>
    /// <unmanaged-short>MFVideoLighting</unmanaged-short>
    public enum VideoLighting : System.Int32
    {
        /// <summary>
        /// <dd> <p>The optimal lighting is unknown.</p> </dd>
        /// </summary>
        /// <doc-id>ms696202</doc-id>
        /// <unmanaged>MFVideoLighting_Unknown</unmanaged>
        /// <unmanaged-short>MFVideoLighting_Unknown</unmanaged-short>
        Unknown = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>Bright lighting; for example, outdoors.</p> </dd>
        /// </summary>
        /// <doc-id>ms696202</doc-id>
        /// <unmanaged>MFVideoLighting_bright</unmanaged>
        /// <unmanaged-short>MFVideoLighting_bright</unmanaged-short>
        Bright = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>Medium brightness; for example, normal office lighting.</p> </dd>
        /// </summary>
        /// <doc-id>ms696202</doc-id>
        /// <unmanaged>MFVideoLighting_office</unmanaged>
        /// <unmanaged-short>MFVideoLighting_office</unmanaged-short>
        Office = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>Dim; for example, a living room with a television and additional low lighting.</p> </dd>
        /// </summary>
        /// <doc-id>ms696202</doc-id>
        /// <unmanaged>MFVideoLighting_dim</unmanaged>
        /// <unmanaged-short>MFVideoLighting_dim</unmanaged-short>
        Dim = unchecked ((System.Int32)(3)),
        /// <summary>
        /// <dd> <p>Dark; for example, a movie theater.</p> </dd>
        /// </summary>
        /// <doc-id>ms696202</doc-id>
        /// <unmanaged>MFVideoLighting_dark</unmanaged>
        /// <unmanaged-short>MFVideoLighting_dark</unmanaged-short>
        Dark = unchecked ((System.Int32)(4)),
        /// <summary>
        /// <dd> <p>Reserved.</p> </dd>
        /// </summary>
        /// <doc-id>ms696202</doc-id>
        /// <unmanaged>MFVideoLighting_Last</unmanaged>
        /// <unmanaged-short>MFVideoLighting_Last</unmanaged-short>
        Last = unchecked ((System.Int32)(5)),
        /// <summary>
        /// <dd> <p>Reserved. This member forces the enumeration type to compile as a <strong><see cref = "System.Int32"/></strong> value.</p> </dd>
        /// </summary>
        /// <doc-id>ms696202</doc-id>
        /// <unmanaged>MFVideoLighting_ForceDWORD</unmanaged>
        /// <unmanaged-short>MFVideoLighting_ForceDWORD</unmanaged-short>
        ForceDWORD = unchecked ((System.Int32)(2147483647))}

    /// <summary>
    /// <p>Contains flags that are used to configure how the enhanced video renderer (EVR) performs  deinterlacing.</p>
    /// </summary>
    /// <remarks>
    /// <p>To set these flags, call the <strong>IMFVideoMixerControl2::SetMixingPrefs</strong> method.</p><p>These flags control some trade-offs between video quality and rendering speed. The constants named "MFVideoMixPrefs_Allow..." enable lower-quality settings, but only when the quality manager requests a drop in quality.  The constants named "MFVideoMixPrefs_Force..." force the EVR to use lower-quality settings regardless of  what the quality manager requests. (For more information about the quality manager, see <strong><see cref = "SharpDX.MediaFoundation.QualityAdvise"/></strong>.)</p><p>Currently two lower-quality modes are supported, as described in the following table. Either is preferable to dropping an entire frame.</p><p></p><table> <tr><th>Mode</th><th>Description</th></tr> <tr><td> <p>Half interface</p> </td><td> <p>The EVR's video mixer skips the second field (relative to temporal order) of each interlaced frame. The video mixer still deinterlaces the first field, and this operation typically interpolates data from the second field. The overall frame rate is unaffected.</p> </td></tr> <tr><td> <p>Bob deinterlacing</p> </td><td> <p>The video mixer uses bob deinterlacing, even if the driver supports  a higher-quality deinterlacing algorithm.</p> </td></tr> </table><p>?</p>
    /// </remarks>
    /// <doc-id>dd388675</doc-id>
    /// <unmanaged>MFVideoMixPrefs</unmanaged>
    /// <unmanaged-short>MFVideoMixPrefs</unmanaged-short>
    public enum VideoMixPrefs : System.Int32
    {
        /// <summary>
        /// <dd> <p>Force the EVR  to skip the second field (in temporal order) of every interlaced frame. </p> </dd>
        /// </summary>
        /// <doc-id>dd388675</doc-id>
        /// <unmanaged>MFVideoMixPrefs_ForceHalfInterlace</unmanaged>
        /// <unmanaged-short>MFVideoMixPrefs_ForceHalfInterlace</unmanaged-short>
        ForceHalfInterlace = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>If the EVR is falling behind, allow it to skip the second field (in temporal order) of every interlaced frame.</p> </dd>
        /// </summary>
        /// <doc-id>dd388675</doc-id>
        /// <unmanaged>MFVideoMixPrefs_AllowDropToHalfInterlace</unmanaged>
        /// <unmanaged-short>MFVideoMixPrefs_AllowDropToHalfInterlace</unmanaged-short>
        AllowDropToHalfInterlace = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>If the EVR is falling behind, allow it to use bob deinterlacing, even if the driver supports a higher-quality deinterlacing mode.</p> </dd>
        /// </summary>
        /// <doc-id>dd388675</doc-id>
        /// <unmanaged>MFVideoMixPrefs_AllowDropToBob</unmanaged>
        /// <unmanaged-short>MFVideoMixPrefs_AllowDropToBob</unmanaged-short>
        AllowDropToBob = unchecked ((System.Int32)(4)),
        /// <summary>
        /// <dd> <p>Force the EVR to use bob deinterlacing, even if the driver supports a higher-quality mode.</p> </dd>
        /// </summary>
        /// <doc-id>dd388675</doc-id>
        /// <unmanaged>MFVideoMixPrefs_ForceBob</unmanaged>
        /// <unmanaged-short>MFVideoMixPrefs_ForceBob</unmanaged-short>
        ForceBob = unchecked ((System.Int32)(8)),
        /// <summary>
        /// <dd> <p>The bitmask of valid flag values. This constant is not itself a valid flag.
        /// </p> </dd>
        /// </summary>
        /// <doc-id>dd388675</doc-id>
        /// <unmanaged>MFVideoMixPrefs_EnableRotation</unmanaged>
        /// <unmanaged-short>MFVideoMixPrefs_EnableRotation</unmanaged-short>
        EnableRotation = unchecked ((System.Int32)(16))}

    /// <summary>
    /// <p> </p><p>Specifies whether to pad a video image so that it fits within a specified aspect ratio.</p>
    /// </summary>
    /// <remarks>
    /// <p>Use these flags with the <strong><see cref = "PadControlFlags"/></strong> attribute.</p>
    /// </remarks>
    /// <doc-id>ms703091</doc-id>
    /// <unmanaged>MFVideoPadFlags</unmanaged>
    /// <unmanaged-short>MFVideoPadFlags</unmanaged-short>
    public enum VideoPadFlags : System.Int32
    {
        /// <summary>
        /// <dd> <p>Do not pad the image.</p> </dd>
        /// </summary>
        /// <doc-id>ms703091</doc-id>
        /// <unmanaged>MFVideoPadFlag_PAD_TO_None</unmanaged>
        /// <unmanaged-short>MFVideoPadFlag_PAD_TO_None</unmanaged-short>
        PadToNone = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>Pad the image so that it can be displayed in a 4?3 area.</p> </dd>
        /// </summary>
        /// <doc-id>ms703091</doc-id>
        /// <unmanaged>MFVideoPadFlag_PAD_TO_4x3</unmanaged>
        /// <unmanaged-short>MFVideoPadFlag_PAD_TO_4x3</unmanaged-short>
        PadTo4x3 = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>Pad the image so that it can be displayed in a 16?9 area.</p> </dd>
        /// </summary>
        /// <doc-id>ms703091</doc-id>
        /// <unmanaged>MFVideoPadFlag_PAD_TO_16x9</unmanaged>
        /// <unmanaged-short>MFVideoPadFlag_PAD_TO_16x9</unmanaged-short>
        PadTo16x9 = unchecked ((System.Int32)(2))}

    /// <summary>
    /// <p>Specifies the color primaries of a video source. The color primaries define how to convert colors from RGB color space to CIE XYZ color space.</p>
    /// </summary>
    /// <remarks>
    /// <p>This enumeration is used with the <strong><see cref = "VideoPrimaries"/></strong> attribute.</p><p>For more information about these values, see the remarks for the <strong>DXVA2_VideoPrimaries</strong> enumeration, which is the DirectX Video Acceleration (DXVA) equivalent of this enumeration.</p>
    /// </remarks>
    /// <doc-id>ms701628</doc-id>
    /// <unmanaged>MFVideoPrimaries</unmanaged>
    /// <unmanaged-short>MFVideoPrimaries</unmanaged-short>
    public enum VideoPrimaries : System.Int32
    {
        /// <summary>
        /// <dd> <p> The color primaries are unknown. </p> </dd>
        /// </summary>
        /// <doc-id>ms701628</doc-id>
        /// <unmanaged>MFVideoPrimaries_Unknown</unmanaged>
        /// <unmanaged-short>MFVideoPrimaries_Unknown</unmanaged-short>
        Unknown = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p> Reserved. </p> </dd>
        /// </summary>
        /// <doc-id>ms701628</doc-id>
        /// <unmanaged>MFVideoPrimaries_reserved</unmanaged>
        /// <unmanaged-short>MFVideoPrimaries_reserved</unmanaged-short>
        Reserved = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p> ITU-R BT.709. Also used for sRGB and scRGB. </p> </dd>
        /// </summary>
        /// <doc-id>ms701628</doc-id>
        /// <unmanaged>MFVideoPrimaries_BT709</unmanaged>
        /// <unmanaged-short>MFVideoPrimaries_BT709</unmanaged-short>
        Bt709 = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p> ITU-R BT.470-4 System M (NTSC). </p> </dd>
        /// </summary>
        /// <doc-id>ms701628</doc-id>
        /// <unmanaged>MFVideoPrimaries_BT470_2_SysM</unmanaged>
        /// <unmanaged-short>MFVideoPrimaries_BT470_2_SysM</unmanaged-short>
        Bt4702SysM = unchecked ((System.Int32)(3)),
        /// <summary>
        /// <dd> <p> ITU-R BT.470-4 System B,G (NTSC). </p> </dd>
        /// </summary>
        /// <doc-id>ms701628</doc-id>
        /// <unmanaged>MFVideoPrimaries_BT470_2_SysBG</unmanaged>
        /// <unmanaged-short>MFVideoPrimaries_BT470_2_SysBG</unmanaged-short>
        Bt4702SysBG = unchecked ((System.Int32)(4)),
        /// <summary>
        /// <dd> <p> SMPTE 170M. </p> </dd>
        /// </summary>
        /// <doc-id>ms701628</doc-id>
        /// <unmanaged>MFVideoPrimaries_SMPTE170M</unmanaged>
        /// <unmanaged-short>MFVideoPrimaries_SMPTE170M</unmanaged-short>
        Smpte170m = unchecked ((System.Int32)(5)),
        /// <summary>
        /// <dd> <p> SMPTE 240M. </p> </dd>
        /// </summary>
        /// <doc-id>ms701628</doc-id>
        /// <unmanaged>MFVideoPrimaries_SMPTE240M</unmanaged>
        /// <unmanaged-short>MFVideoPrimaries_SMPTE240M</unmanaged-short>
        Smpte240m = unchecked ((System.Int32)(6)),
        /// <summary>
        /// <dd> <p> EBU 3213. </p> </dd>
        /// </summary>
        /// <doc-id>ms701628</doc-id>
        /// <unmanaged>MFVideoPrimaries_EBU3213</unmanaged>
        /// <unmanaged-short>MFVideoPrimaries_EBU3213</unmanaged-short>
        Ebu3213 = unchecked ((System.Int32)(7)),
        /// <summary>
        /// <dd> <p> SMPTE C (SMPTE RP 145). </p> </dd>
        /// </summary>
        /// <doc-id>ms701628</doc-id>
        /// <unmanaged>MFVideoPrimaries_SMPTE_C</unmanaged>
        /// <unmanaged-short>MFVideoPrimaries_SMPTE_C</unmanaged-short>
        SmpteC = unchecked ((System.Int32)(8)),
        /// <summary>
        /// <dd> <p> Reserved. </p> </dd>
        /// </summary>
        /// <doc-id>ms701628</doc-id>
        /// <unmanaged>MFVideoPrimaries_BT2020</unmanaged>
        /// <unmanaged-short>MFVideoPrimaries_BT2020</unmanaged-short>
        Bt2020 = unchecked ((System.Int32)(9)),
        /// <summary>
        /// <dd> <p> Reserved. This member forces the enumeration type to compile as a <strong><see cref = "System.Int32"/></strong> value. </p> </dd>
        /// </summary>
        /// <doc-id>ms701628</doc-id>
        /// <unmanaged>MFVideoPrimaries_XYZ</unmanaged>
        /// <unmanaged-short>MFVideoPrimaries_XYZ</unmanaged-short>
        Xyz = unchecked ((System.Int32)(10)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms701628</doc-id>
        /// <unmanaged>MFVideoPrimaries_DCI_P3</unmanaged>
        /// <unmanaged-short>MFVideoPrimaries_DCI_P3</unmanaged-short>
        DeviceContextIP3 = unchecked ((System.Int32)(11)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms701628</doc-id>
        /// <unmanaged>MFVideoPrimaries_ACES</unmanaged>
        /// <unmanaged-short>MFVideoPrimaries_ACES</unmanaged-short>
        Aces = unchecked ((System.Int32)(12)),
        /// <summary>
        /// <dd> <p> Reserved. </p> </dd>
        /// </summary>
        /// <doc-id>ms701628</doc-id>
        /// <unmanaged>MFVideoPrimaries_Last</unmanaged>
        /// <unmanaged-short>MFVideoPrimaries_Last</unmanaged-short>
        Last = unchecked ((System.Int32)(13)),
        /// <summary>
        /// <dd> <p> Reserved. This member forces the enumeration type to compile as a <strong><see cref = "System.Int32"/></strong> value. </p> </dd>
        /// </summary>
        /// <doc-id>ms701628</doc-id>
        /// <unmanaged>MFVideoPrimaries_ForceDWORD</unmanaged>
        /// <unmanaged-short>MFVideoPrimaries_ForceDWORD</unmanaged-short>
        ForceDWORD = unchecked ((System.Int32)(2147483647))}

    /// <summary>
    /// <p>Defines algorithms for the video processor which is use by MF_VIDEO_PROCESSOR_ALGORITHM.</p>
    /// </summary>
    /// <doc-id>dn302208</doc-id>
    /// <unmanaged>MF_VIDEO_PROCESSOR_ALGORITHM_TYPE</unmanaged>
    /// <unmanaged-short>MF_VIDEO_PROCESSOR_ALGORITHM_TYPE</unmanaged-short>
    public enum VideoProcessorAlgorithmType : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn302208</doc-id>
        /// <unmanaged>MF_VIDEO_PROCESSOR_ALGORITHM_DEFAULT</unmanaged>
        /// <unmanaged-short>MF_VIDEO_PROCESSOR_ALGORITHM_DEFAULT</unmanaged-short>
        Default = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn302208</doc-id>
        /// <unmanaged>MF_VIDEO_PROCESSOR_ALGORITHM_MRF_CRF_444</unmanaged>
        /// <unmanaged-short>MF_VIDEO_PROCESSOR_ALGORITHM_MRF_CRF_444</unmanaged-short>
        MrfCrf444 = unchecked ((System.Int32)(1))}

    /// <summary>
    /// <p>Specifies how to flip a video image.</p>
    /// </summary>
    /// <doc-id>hh162904</doc-id>
    /// <unmanaged>MF_VIDEO_PROCESSOR_MIRROR</unmanaged>
    /// <unmanaged-short>MF_VIDEO_PROCESSOR_MIRROR</unmanaged-short>
    public enum VideoProcessorMirror : System.Int32
    {
        /// <summary>
        /// <dd> <p>Do not flip the image.</p> </dd>
        /// </summary>
        /// <doc-id>hh162904</doc-id>
        /// <unmanaged>MIRROR_NONE</unmanaged>
        /// <unmanaged-short>MIRROR_NONE</unmanaged-short>
        MirrorNone = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>Flip the image horizontally.</p> </dd>
        /// </summary>
        /// <doc-id>hh162904</doc-id>
        /// <unmanaged>MIRROR_HORIZONTAL</unmanaged>
        /// <unmanaged-short>MIRROR_HORIZONTAL</unmanaged-short>
        MirrorHorizontal = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>Flip the image vertically.</p> </dd>
        /// </summary>
        /// <doc-id>hh162904</doc-id>
        /// <unmanaged>MIRROR_VERTICAL</unmanaged>
        /// <unmanaged-short>MIRROR_VERTICAL</unmanaged-short>
        MirrorVertical = unchecked ((System.Int32)(2))}

    /// <summary>
    /// <p>Specifies how to rotate a video image.</p>
    /// </summary>
    /// <doc-id>hh162905</doc-id>
    /// <unmanaged>MF_VIDEO_PROCESSOR_ROTATION</unmanaged>
    /// <unmanaged-short>MF_VIDEO_PROCESSOR_ROTATION</unmanaged-short>
    public enum VideoProcessorRotation : System.Int32
    {
        /// <summary>
        /// <dd> <p>Do not rotate the image.</p> </dd>
        /// </summary>
        /// <doc-id>hh162905</doc-id>
        /// <unmanaged>ROTATION_NONE</unmanaged>
        /// <unmanaged-short>ROTATION_NONE</unmanaged-short>
        RotationNone = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>Rotate the image to the correct viewing orientation.</p> </dd>
        /// </summary>
        /// <doc-id>hh162905</doc-id>
        /// <unmanaged>ROTATION_NORMAL</unmanaged>
        /// <unmanaged-short>ROTATION_NORMAL</unmanaged-short>
        RotationNormal = unchecked ((System.Int32)(1))}

    /// <summary>
    /// <p> </p><p>Contains flags that define how the enhanced video renderer (EVR) displays the video.</p>
    /// </summary>
    /// <remarks>
    /// <p>To set these flags, call <strong>IMFVideoDisplayControl::SetRenderingPrefs</strong>.</p><p>The flags named "MFVideoRenderPrefs_Allow..." cause the EVR to use lower-quality settings only when requested by the quality manager. (For more information, see <strong><see cref = "SharpDX.MediaFoundation.QualityAdvise"/></strong>.) The flags named "MFVideoRenderPrefs_Force..." cause the video mixer to use lower-quality settings regardless of the quality manager. </p>
    /// </remarks>
    /// <doc-id>ms701834</doc-id>
    /// <unmanaged>MFVideoRenderPrefs</unmanaged>
    /// <unmanaged-short>MFVideoRenderPrefs</unmanaged-short>
    public enum VideoRenderPrefs : System.Int32
    {
        /// <summary>
        /// <dd> <p> If this flag is set, the EVR does not draw the border color. By default, the EVR draws a border on areas of the destination rectangle that have no video. See <strong>IMFVideoDisplayControl::SetBorderColor</strong>. </p> </dd>
        /// </summary>
        /// <doc-id>ms701834</doc-id>
        /// <unmanaged>MFVideoRenderPrefs_DoNotRenderBorder</unmanaged>
        /// <unmanaged-short>MFVideoRenderPrefs_DoNotRenderBorder</unmanaged-short>
        DoNotRenderBorder = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p> If this flag is set, the EVR does not clip the video when the video window straddles two monitors. By default, if the video window straddles two monitors, the EVR clips the video to the monitor that contains the largest area of video. </p> </dd>
        /// </summary>
        /// <doc-id>ms701834</doc-id>
        /// <unmanaged>MFVideoRenderPrefs_DoNotClipToDevice</unmanaged>
        /// <unmanaged-short>MFVideoRenderPrefs_DoNotClipToDevice</unmanaged-short>
        DoNotClipToDevice = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p> </p><strong>Note</strong>??Requires Windows?7 or later. ? <p>Allow the EVR to limit its output to match GPU bandwidth.</p> </dd>
        /// </summary>
        /// <doc-id>ms701834</doc-id>
        /// <unmanaged>MFVideoRenderPrefs_AllowOutputThrottling</unmanaged>
        /// <unmanaged-short>MFVideoRenderPrefs_AllowOutputThrottling</unmanaged-short>
        AllowOutputThrottling = unchecked ((System.Int32)(4)),
        /// <summary>
        /// <dd> <p> </p><strong>Note</strong>??Requires Windows?7 or later. ? <p>Force the EVR to limit its output to match GPU bandwidth.</p> </dd>
        /// </summary>
        /// <doc-id>ms701834</doc-id>
        /// <unmanaged>MFVideoRenderPrefs_ForceOutputThrottling</unmanaged>
        /// <unmanaged-short>MFVideoRenderPrefs_ForceOutputThrottling</unmanaged-short>
        ForceOutputThrottling = unchecked ((System.Int32)(8)),
        /// <summary>
        /// <dd> <p> </p><strong>Note</strong>??Requires Windows?7 or later. ? <p>Force the EVR to batch Direct3D <strong>Present</strong> calls. This optimization enables the system to enter to idle states more frequently, which can reduce power consumption. </p> </dd>
        /// </summary>
        /// <doc-id>ms701834</doc-id>
        /// <unmanaged>MFVideoRenderPrefs_ForceBatching</unmanaged>
        /// <unmanaged-short>MFVideoRenderPrefs_ForceBatching</unmanaged-short>
        ForceBatching = unchecked ((System.Int32)(16)),
        /// <summary>
        /// <dd> <p> </p><strong>Note</strong>??Requires Windows?7 or later. ? <p>Allow the EVR to batch Direct3D <strong>Present</strong> calls.</p> </dd>
        /// </summary>
        /// <doc-id>ms701834</doc-id>
        /// <unmanaged>MFVideoRenderPrefs_AllowBatching</unmanaged>
        /// <unmanaged-short>MFVideoRenderPrefs_AllowBatching</unmanaged-short>
        AllowBatching = unchecked ((System.Int32)(32)),
        /// <summary>
        /// <dd> <p> </p><strong>Note</strong>??Requires Windows?7 or later. ? <p>Force the EVR to mix the video inside a rectangle that is smaller than the output rectangle. The EVR will then scale the result to the correct output size. The effective resolution will be lower if this setting is applied.</p> </dd>
        /// </summary>
        /// <doc-id>ms701834</doc-id>
        /// <unmanaged>MFVideoRenderPrefs_ForceScaling</unmanaged>
        /// <unmanaged-short>MFVideoRenderPrefs_ForceScaling</unmanaged-short>
        ForceScaling = unchecked ((System.Int32)(64)),
        /// <summary>
        /// <dd> <p> </p><strong>Note</strong>??Requires Windows?7 or later. ? <p>Allow the EVR to mix the video inside a rectangle that is smaller than the output rectangle. </p> </dd>
        /// </summary>
        /// <doc-id>ms701834</doc-id>
        /// <unmanaged>MFVideoRenderPrefs_AllowScaling</unmanaged>
        /// <unmanaged-short>MFVideoRenderPrefs_AllowScaling</unmanaged-short>
        AllowScaling = unchecked ((System.Int32)(128)),
        /// <summary>
        /// <dd> <p> </p><strong>Note</strong>??Requires Windows?7 or later. ? <p>Prevent the EVR from repainting the video window after a stop command. By default, the EVR repaints the video window black after a stop command.</p> </dd>
        /// </summary>
        /// <doc-id>ms701834</doc-id>
        /// <unmanaged>MFVideoRenderPrefs_DoNotRepaintOnStop</unmanaged>
        /// <unmanaged-short>MFVideoRenderPrefs_DoNotRepaintOnStop</unmanaged-short>
        DoNotRepaintOnStop = unchecked ((System.Int32)(256))}

    /// <summary>
    /// <p>Describes the rotation of the video image in the counter-clockwise direction.</p>
    /// </summary>
    /// <remarks>
    /// <p>This enumeration is used with the <see cref = "VideoRotation"/> attribute.</p>
    /// </remarks>
    /// <doc-id>hh162805</doc-id>
    /// <unmanaged>MFVideoRotationFormat</unmanaged>
    /// <unmanaged-short>MFVideoRotationFormat</unmanaged-short>
    public enum VideoRotationFormat : System.Int32
    {
        /// <summary>
        /// <dd> <p>The image is not rotated.</p> </dd>
        /// </summary>
        /// <doc-id>hh162805</doc-id>
        /// <unmanaged>MFVideoRotationFormat_0</unmanaged>
        /// <unmanaged-short>MFVideoRotationFormat_0</unmanaged-short>
        Angle0 = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>The image is rotated 90 degrees counter-clockwise.</p> </dd>
        /// </summary>
        /// <doc-id>hh162805</doc-id>
        /// <unmanaged>MFVideoRotationFormat_90</unmanaged>
        /// <unmanaged-short>MFVideoRotationFormat_90</unmanaged-short>
        Angle90 = unchecked ((System.Int32)(90)),
        /// <summary>
        /// <dd> <p>The image is rotated 180 degrees.</p> </dd>
        /// </summary>
        /// <doc-id>hh162805</doc-id>
        /// <unmanaged>MFVideoRotationFormat_180</unmanaged>
        /// <unmanaged-short>MFVideoRotationFormat_180</unmanaged-short>
        Angle180 = unchecked ((System.Int32)(180)),
        /// <summary>
        /// <dd> <p>The image is rotated 270 degrees counter-clockwise.</p> </dd>
        /// </summary>
        /// <doc-id>hh162805</doc-id>
        /// <unmanaged>MFVideoRotationFormat_270</unmanaged>
        /// <unmanaged-short>MFVideoRotationFormat_270</unmanaged-short>
        Angle270 = unchecked ((System.Int32)(270))}

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>MFVideoSphericalFormat</unmanaged>
    /// <unmanaged-short>MFVideoSphericalFormat</unmanaged-short>
    public enum VideoSphericalFormat : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MFVideoSphericalFormat_Unsupported</unmanaged>
        /// <unmanaged-short>MFVideoSphericalFormat_Unsupported</unmanaged-short>
        Unsupported = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MFVideoSphericalFormat_Equirectangular</unmanaged>
        /// <unmanaged-short>MFVideoSphericalFormat_Equirectangular</unmanaged-short>
        Equirectangular = unchecked ((System.Int32)(1))}

    /// <summary>
    /// <p> </p><p>Describes the intended aspect ratio for a video stream.</p>
    /// </summary>
    /// <remarks>
    /// <p>Use these flags with the <strong><see cref = "SourceContentHint"/></strong> attribute.</p>
    /// </remarks>
    /// <doc-id>ms697451</doc-id>
    /// <unmanaged>MFVideoSrcContentHintFlags</unmanaged>
    /// <unmanaged-short>MFVideoSrcContentHintFlags</unmanaged-short>
    public enum VideoSrcContentHintFlags : System.Int32
    {
        /// <summary>
        /// <dd> <p>The aspect ratio is unknown.</p> </dd>
        /// </summary>
        /// <doc-id>ms697451</doc-id>
        /// <unmanaged>MFVideoSrcContentHintFlag_None</unmanaged>
        /// <unmanaged-short>MFVideoSrcContentHintFlag_None</unmanaged-short>
        None = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>The source is 16?9 content encoded within a 4?3 area.</p> </dd>
        /// </summary>
        /// <doc-id>ms697451</doc-id>
        /// <unmanaged>MFVideoSrcContentHintFlag_16x9</unmanaged>
        /// <unmanaged-short>MFVideoSrcContentHintFlag_16x9</unmanaged-short>
        Hint16x9 = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>The source is 2.35:1 content encoded within a 16?9 or 4?3 area.</p> </dd>
        /// </summary>
        /// <doc-id>ms697451</doc-id>
        /// <unmanaged>MFVideoSrcContentHintFlag_235_1</unmanaged>
        /// <unmanaged-short>MFVideoSrcContentHintFlag_235_1</unmanaged-short>
        Hint235_1 = unchecked ((System.Int32)(2))}

    /// <summary>
    /// <p> Specifies the conversion function from linear RGB to non-linear RGB (R'G'B'). </p>
    /// </summary>
    /// <remarks>
    /// <p> These flags are used with the <strong><see cref = "TransferFunction"/></strong> attribute. </p><p> For more information about these values, see the remarks for the <strong>DXVA2_VideoTransferFunction</strong> enumeration, which is the DirectX Video Acceleration (DXVA) equivalent of this enumeration. </p>
    /// </remarks>
    /// <doc-id>ms705629</doc-id>
    /// <unmanaged>MFVideoTransferFunction</unmanaged>
    /// <unmanaged-short>MFVideoTransferFunction</unmanaged-short>
    public enum VideoTransferFunction : System.Int32
    {
        /// <summary>
        /// <dd> <p> Unknown. Treat as MFVideoTransFunc_709. </p> </dd>
        /// </summary>
        /// <doc-id>ms705629</doc-id>
        /// <unmanaged>MFVideoTransFunc_Unknown</unmanaged>
        /// <unmanaged-short>MFVideoTransFunc_Unknown</unmanaged-short>
        FuncUnknown = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p> Linear RGB (gamma = 1.0). </p> </dd>
        /// </summary>
        /// <doc-id>ms705629</doc-id>
        /// <unmanaged>MFVideoTransFunc_10</unmanaged>
        /// <unmanaged-short>MFVideoTransFunc_10</unmanaged-short>
        Func10 = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p> True 1.8 gamma, L' = L^1/1.8. </p> </dd>
        /// </summary>
        /// <doc-id>ms705629</doc-id>
        /// <unmanaged>MFVideoTransFunc_18</unmanaged>
        /// <unmanaged-short>MFVideoTransFunc_18</unmanaged-short>
        Func18 = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p> True 2.0 gamma, L' = L^1/2.0. </p> </dd>
        /// </summary>
        /// <doc-id>ms705629</doc-id>
        /// <unmanaged>MFVideoTransFunc_20</unmanaged>
        /// <unmanaged-short>MFVideoTransFunc_20</unmanaged-short>
        Func20 = unchecked ((System.Int32)(3)),
        /// <summary>
        /// <dd> <p> True 2.2 gamma, L' = L^1/2.2. This transfer function is used in ITU-R BT.470-2 System M (NTSC). </p> </dd>
        /// </summary>
        /// <doc-id>ms705629</doc-id>
        /// <unmanaged>MFVideoTransFunc_22</unmanaged>
        /// <unmanaged-short>MFVideoTransFunc_22</unmanaged-short>
        Func22 = unchecked ((System.Int32)(4)),
        /// <summary>
        /// <dd> <p> ITU-R BT.709 transfer function. Gamma 2.2 curve with a linear segment in the lower range. This transfer function is used in BT.709, BT.601, SMPTE 296M, SMPTE 170M, BT.470, and SPMTE 274M. In addition BT-1361 uses this function within the range [0...1]. </p> </dd>
        /// </summary>
        /// <doc-id>ms705629</doc-id>
        /// <unmanaged>MFVideoTransFunc_709</unmanaged>
        /// <unmanaged-short>MFVideoTransFunc_709</unmanaged-short>
        Func709 = unchecked ((System.Int32)(5)),
        /// <summary>
        /// <dd> <p> SPMTE 240M transfer function. Gamma 2.2 curve with a linear segment in the lower range. </p> </dd>
        /// </summary>
        /// <doc-id>ms705629</doc-id>
        /// <unmanaged>MFVideoTransFunc_240M</unmanaged>
        /// <unmanaged-short>MFVideoTransFunc_240M</unmanaged-short>
        Func240m = unchecked ((System.Int32)(6)),
        /// <summary>
        /// <dd> <p> sRGB transfer function. Gamma 2.4 curve with a linear segment in the lower range. </p> </dd>
        /// </summary>
        /// <doc-id>ms705629</doc-id>
        /// <unmanaged>MFVideoTransFunc_sRGB</unmanaged>
        /// <unmanaged-short>MFVideoTransFunc_sRGB</unmanaged-short>
        FuncSRGB = unchecked ((System.Int32)(7)),
        /// <summary>
        /// <dd> <p> True 2.8 gamma. L' = L^1/2.8. This transfer function is used in ITU-R BT.470-2 System B, G (PAL). </p> </dd>
        /// </summary>
        /// <doc-id>ms705629</doc-id>
        /// <unmanaged>MFVideoTransFunc_28</unmanaged>
        /// <unmanaged-short>MFVideoTransFunc_28</unmanaged-short>
        Func28 = unchecked ((System.Int32)(8)),
        /// <summary>
        /// <dd> <p>Logarithmic transfer (100:1 range); for example, as used in H.264 video.</p> <strong>Note</strong>??Requires Windows?7 or later. ? </dd>
        /// </summary>
        /// <doc-id>ms705629</doc-id>
        /// <unmanaged>MFVideoTransFunc_Log_100</unmanaged>
        /// <unmanaged-short>MFVideoTransFunc_Log_100</unmanaged-short>
        FuncLog100 = unchecked ((System.Int32)(9)),
        /// <summary>
        /// <dd> <p>Logarithmic transfer (316.22777:1 range); for example, as used in H.264 video.</p> <strong>Note</strong>??Requires Windows?7 or later. ? </dd>
        /// </summary>
        /// <doc-id>ms705629</doc-id>
        /// <unmanaged>MFVideoTransFunc_Log_316</unmanaged>
        /// <unmanaged-short>MFVideoTransFunc_Log_316</unmanaged-short>
        FuncLog316 = unchecked ((System.Int32)(10)),
        /// <summary>
        /// <dd> <p>Symmetric ITU-R BT.709.</p> <strong>Note</strong>??Requires Windows?7 or later. ? </dd>
        /// </summary>
        /// <doc-id>ms705629</doc-id>
        /// <unmanaged>MFVideoTransFunc_709_sym</unmanaged>
        /// <unmanaged-short>MFVideoTransFunc_709_sym</unmanaged-short>
        Func709Sym = unchecked ((System.Int32)(11)),
        /// <summary>
        /// <dd> <p> Reserved. </p> </dd>
        /// </summary>
        /// <doc-id>ms705629</doc-id>
        /// <unmanaged>MFVideoTransFunc_2020_const</unmanaged>
        /// <unmanaged-short>MFVideoTransFunc_2020_const</unmanaged-short>
        Func2020Const = unchecked ((System.Int32)(12)),
        /// <summary>
        /// <dd> <p> Reserved. This member forces the enumeration type to compile as a <strong><see cref = "System.Int32"/></strong> value. </p> </dd>
        /// </summary>
        /// <doc-id>ms705629</doc-id>
        /// <unmanaged>MFVideoTransFunc_2020</unmanaged>
        /// <unmanaged-short>MFVideoTransFunc_2020</unmanaged-short>
        Func2020 = unchecked ((System.Int32)(13)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms705629</doc-id>
        /// <unmanaged>MFVideoTransFunc_26</unmanaged>
        /// <unmanaged-short>MFVideoTransFunc_26</unmanaged-short>
        Func26 = unchecked ((System.Int32)(14)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms705629</doc-id>
        /// <unmanaged>MFVideoTransFunc_2084</unmanaged>
        /// <unmanaged-short>MFVideoTransFunc_2084</unmanaged-short>
        Func2084 = unchecked ((System.Int32)(15)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms705629</doc-id>
        /// <unmanaged>MFVideoTransFunc_HLG</unmanaged>
        /// <unmanaged-short>MFVideoTransFunc_HLG</unmanaged-short>
        FuncHlg = unchecked ((System.Int32)(16)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms705629</doc-id>
        /// <unmanaged>MFVideoTransFunc_10_rel</unmanaged>
        /// <unmanaged-short>MFVideoTransFunc_10_rel</unmanaged-short>
        Func10Rel = unchecked ((System.Int32)(17)),
        /// <summary>
        /// <dd> <p> Reserved. </p> </dd>
        /// </summary>
        /// <doc-id>ms705629</doc-id>
        /// <unmanaged>MFVideoTransFunc_Last</unmanaged>
        /// <unmanaged-short>MFVideoTransFunc_Last</unmanaged-short>
        FuncLast = unchecked ((System.Int32)(18)),
        /// <summary>
        /// <dd> <p> Reserved. This member forces the enumeration type to compile as a <strong><see cref = "System.Int32"/></strong> value. </p> </dd>
        /// </summary>
        /// <doc-id>ms705629</doc-id>
        /// <unmanaged>MFVideoTransFunc_ForceDWORD</unmanaged>
        /// <unmanaged-short>MFVideoTransFunc_ForceDWORD</unmanaged-short>
        FuncForceDWORD = unchecked ((System.Int32)(2147483647))}

    /// <summary>
    /// <p> </p><p>Describes the conversion matrices between Y'PbPr (component video) and studio R'G'B'.</p>
    /// </summary>
    /// <remarks>
    /// <p>This enumeration is used with the <strong><see cref = "YuvMatrix"/></strong> attribute.</p><p>For more information about these values, see the remarks for the <strong>DXVA2_VideoTransferMatrix</strong> enumeration, which is the DirectX Video Acceleration (DXVA) equivalent of this enumeration.</p>
    /// </remarks>
    /// <doc-id>ms694036</doc-id>
    /// <unmanaged>MFVideoTransferMatrix</unmanaged>
    /// <unmanaged-short>MFVideoTransferMatrix</unmanaged-short>
    public enum VideoTransferMatrix : System.Int32
    {
        /// <summary>
        /// <dd> <p>Unknown transfer matrix. Treat as MFVideoTransferMatrix_BT709.</p> </dd>
        /// </summary>
        /// <doc-id>ms694036</doc-id>
        /// <unmanaged>MFVideoTransferMatrix_Unknown</unmanaged>
        /// <unmanaged-short>MFVideoTransferMatrix_Unknown</unmanaged-short>
        Unknown = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>ITU-R BT.709 transfer matrix.</p> </dd>
        /// </summary>
        /// <doc-id>ms694036</doc-id>
        /// <unmanaged>MFVideoTransferMatrix_BT709</unmanaged>
        /// <unmanaged-short>MFVideoTransferMatrix_BT709</unmanaged-short>
        Bt709 = unchecked ((System.Int32)(1)),
        /// <summary>
        /// <dd> <p>ITU-R BT.601 transfer matrix. Also used for SMPTE 170 and ITU-R BT.470-2 System B,G.</p> </dd>
        /// </summary>
        /// <doc-id>ms694036</doc-id>
        /// <unmanaged>MFVideoTransferMatrix_BT601</unmanaged>
        /// <unmanaged-short>MFVideoTransferMatrix_BT601</unmanaged-short>
        Bt601 = unchecked ((System.Int32)(2)),
        /// <summary>
        /// <dd> <p>SMPTE 240M transfer matrix.</p> </dd>
        /// </summary>
        /// <doc-id>ms694036</doc-id>
        /// <unmanaged>MFVideoTransferMatrix_SMPTE240M</unmanaged>
        /// <unmanaged-short>MFVideoTransferMatrix_SMPTE240M</unmanaged-short>
        Smpte240m = unchecked ((System.Int32)(3)),
        /// <summary>
        /// <dd> <p>Reserved.</p> </dd>
        /// </summary>
        /// <doc-id>ms694036</doc-id>
        /// <unmanaged>MFVideoTransferMatrix_BT2020_10</unmanaged>
        /// <unmanaged-short>MFVideoTransferMatrix_BT2020_10</unmanaged-short>
        Bt202010 = unchecked ((System.Int32)(4)),
        /// <summary>
        /// <dd> <p>Reserved. This member forces the enumeration type to compile as a <strong><see cref = "System.Int32"/></strong> value.</p> </dd>
        /// </summary>
        /// <doc-id>ms694036</doc-id>
        /// <unmanaged>MFVideoTransferMatrix_BT2020_12</unmanaged>
        /// <unmanaged-short>MFVideoTransferMatrix_BT2020_12</unmanaged-short>
        Bt202012 = unchecked ((System.Int32)(5)),
        /// <summary>
        /// <dd> <p>Reserved.</p> </dd>
        /// </summary>
        /// <doc-id>ms694036</doc-id>
        /// <unmanaged>MFVideoTransferMatrix_Last</unmanaged>
        /// <unmanaged-short>MFVideoTransferMatrix_Last</unmanaged-short>
        Last = unchecked ((System.Int32)(6)),
        /// <summary>
        /// <dd> <p>Reserved. This member forces the enumeration type to compile as a <strong><see cref = "System.Int32"/></strong> value.</p> </dd>
        /// </summary>
        /// <doc-id>ms694036</doc-id>
        /// <unmanaged>MFVideoTransferMatrix_ForceDWORD</unmanaged>
        /// <unmanaged-short>MFVideoTransferMatrix_ForceDWORD</unmanaged-short>
        ForceDWORD = unchecked ((System.Int32)(2147483647))}

    /// <summary>
    /// <p>Defines messages for an enhanced video renderer (EVR) presenter. This enumeration is used with the <strong>IMFVideoPresenter::ProcessMessage</strong> method.</p>
    /// </summary>
    /// <doc-id>ms698964</doc-id>
    /// <unmanaged>MFVP_MESSAGE_TYPE</unmanaged>
    /// <unmanaged-short>MFVP_MESSAGE_TYPE</unmanaged-short>
    public enum VpMessageType : System.Int32
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms698964</doc-id>
        /// <unmanaged>MFVP_MESSAGE_FLUSH</unmanaged>
        /// <unmanaged-short>MFVP_MESSAGE_FLUSH</unmanaged-short>
        Flush = unchecked ((System.Int32)(0)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms698964</doc-id>
        /// <unmanaged>MFVP_MESSAGE_INVALIDATEMEDIATYPE</unmanaged>
        /// <unmanaged-short>MFVP_MESSAGE_INVALIDATEMEDIATYPE</unmanaged-short>
        InvalidateMediaType = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms698964</doc-id>
        /// <unmanaged>MFVP_MESSAGE_PROCESSINPUTNOTIFY</unmanaged>
        /// <unmanaged-short>MFVP_MESSAGE_PROCESSINPUTNOTIFY</unmanaged-short>
        Processinputnotify = unchecked ((System.Int32)(2)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms698964</doc-id>
        /// <unmanaged>MFVP_MESSAGE_BEGINSTREAMING</unmanaged>
        /// <unmanaged-short>MFVP_MESSAGE_BEGINSTREAMING</unmanaged-short>
        Beginstreaming = unchecked ((System.Int32)(3)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms698964</doc-id>
        /// <unmanaged>MFVP_MESSAGE_ENDSTREAMING</unmanaged>
        /// <unmanaged-short>MFVP_MESSAGE_ENDSTREAMING</unmanaged-short>
        Endstreaming = unchecked ((System.Int32)(4)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms698964</doc-id>
        /// <unmanaged>MFVP_MESSAGE_ENDOFSTREAM</unmanaged>
        /// <unmanaged-short>MFVP_MESSAGE_ENDOFSTREAM</unmanaged-short>
        Endofstream = unchecked ((System.Int32)(5)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms698964</doc-id>
        /// <unmanaged>MFVP_MESSAGE_STEP</unmanaged>
        /// <unmanaged-short>MFVP_MESSAGE_STEP</unmanaged-short>
        Step = unchecked ((System.Int32)(6)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ms698964</doc-id>
        /// <unmanaged>MFVP_MESSAGE_CANCELSTEP</unmanaged>
        /// <unmanaged-short>MFVP_MESSAGE_CANCELSTEP</unmanaged-short>
        Cancelstep = unchecked ((System.Int32)(7))}

    /// <summary>
    /// <p> </p><p>Contains flags that specify how to convert an audio media type.</p>
    /// </summary>
    /// <doc-id>ms703181</doc-id>
    /// <unmanaged>MFWaveFormatExConvertFlags</unmanaged>
    /// <unmanaged-short>MFWaveFormatExConvertFlags</unmanaged-short>
    public enum WaveFormatExConvertFlags : System.Int32
    {
        /// <summary>
        /// <dd> <p>Convert the media type to a <strong><see cref = "SharpDX.Multimedia.WaveFormat"/></strong> structure if possible, or a <strong><see cref = "SharpDX.Multimedia.WaveFormatExtensible"/></strong> structure otherwise.</p> </dd>
        /// </summary>
        /// <doc-id>ms703181</doc-id>
        /// <unmanaged>MFWaveFormatExConvertFlag_Normal</unmanaged>
        /// <unmanaged-short>MFWaveFormatExConvertFlag_Normal</unmanaged-short>
        Normal = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p>Convert the media type to a <strong><see cref = "SharpDX.Multimedia.WaveFormatExtensible"/></strong> structure.</p> </dd>
        /// </summary>
        /// <doc-id>ms703181</doc-id>
        /// <unmanaged>MFWaveFormatExConvertFlag_ForceExtensible</unmanaged>
        /// <unmanaged-short>MFWaveFormatExConvertFlag_ForceExtensible</unmanaged-short>
        ForceExtensible = unchecked ((System.Int32)(1))}

    /// <summary>
    /// <p> </p><p>Provides configuration information to the dispatching thread for a callback.</p>
    /// </summary>
    /// <remarks>
    /// <p> The <strong>GetParameters</strong> method returns information about the callback so that the dispatching thread can optimize the process that it uses to invoke the callback. </p><p> If the method returns a value other than zero in the <em>pdwFlags</em> parameter, your <strong>Invoke</strong> method must meet the requirements described here. Otherwise, the callback might delay the pipeline.</p><p> If you want default values for both parameters, return <strong>E_NOTIMPL</strong>. The default values are given in the parameter descriptions on this page.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
    /// </remarks>
    /// <doc-id>bb970381</doc-id>
    /// <unmanaged>MFASYNC_CALLBACK_QUEUE</unmanaged>
    /// <unmanaged-short>MFASYNC_CALLBACK_QUEUE</unmanaged-short>
    public enum WorkQueueType : System.Int32
    {
        /// <summary>
        /// <dd> <p>Receives a flag indicating the behavior of the callback object's <strong>IMFAsyncCallback::Invoke</strong> method. The following values are defined. The default value is zero.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>Zero</strong></dt> </dl> </td><td> <p>The callback does not take a long time to complete, but has no specific restrictions on what system calls it makes. The callback generally takes less than 30 milliseconds to complete.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MFASYNC_FAST_IO_PROCESSING_CALLBACK</strong></strong></dt> </dl> </td><td> <p>The callback does very minimal processing. It takes less than 1 millisecond to complete.</p> <p>The callback must be invoked from one of the following work queues:</p> <ul> <li><strong>MFASYNC_CALLBACK_QUEUE_IO</strong></li> <li><strong>MFASYNC_CALLBACK_QUEUE_TIMER</strong></li> </ul> </td></tr> <tr><td><dl> <dt><strong><strong>MFASYNC_SIGNAL_CALLBACK</strong></strong></dt> </dl> </td><td> <p>Implies <strong>MFASYNC_FAST_IO_PROCESSING_CALLBACK</strong>, with the additional restriction that the callback does no processing (less than 50 microseconds), and the only system call it makes is <strong>SetEvent</strong>.</p> <p>The callback must be invoked from one of the following work queues:</p> <ul> <li><strong>MFASYNC_CALLBACK_QUEUE_IO</strong></li> <li><strong>MFASYNC_CALLBACK_QUEUE_TIMER</strong></li> </ul> </td></tr> <tr><td><dl> <dt><strong><strong>MFASYNC_BLOCKING_CALLBACK</strong></strong></dt> </dl> </td><td> <p>Blocking callback.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MFASYNC_REPLY_CALLBACK</strong></strong></dt> </dl> </td><td> <p>Reply callback.</p> </td></tr> </table> <p>?</p> </dd>
        /// </summary>
        /// <doc-id>bb970381</doc-id>
        /// <unmanaged>MFASYNC_CALLBACK_QUEUE_UNDEFINED</unmanaged>
        /// <unmanaged-short>MFASYNC_CALLBACK_QUEUE_UNDEFINED</unmanaged-short>
        Undefined = unchecked ((System.Int32)(0)),
        /// <summary>
        /// <dd> <p> Receives the identifier of the work queue on which the callback is dispatched.  </p> <p>This value can specify one of the standard Media Foundation work queues, or a work queue created by the application. For list of standard Media Foundation work queues, see <strong>Work Queue Identifiers</strong>. To create a new work queue, call <strong>MFAllocateWorkQueue</strong>. The default value is <strong>MFASYNC_CALLBACK_QUEUE_STANDARD</strong>.</p> <p>If the work queue is not compatible with the value returned in <em>pdwFlags</em>, the Media Foundation platform returns <strong><see cref = "InvalidWorkqueue"/></strong> when it tries to dispatch the callback. (See <strong>MFPutWorkItem</strong>.)</p> </dd>
        /// </summary>
        /// <doc-id>bb970381</doc-id>
        /// <unmanaged>MFASYNC_CALLBACK_QUEUE_STANDARD</unmanaged>
        /// <unmanaged-short>MFASYNC_CALLBACK_QUEUE_STANDARD</unmanaged-short>
        Standard = unchecked ((System.Int32)(1)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>bb970381</doc-id>
        /// <unmanaged>MFASYNC_CALLBACK_QUEUE_RT</unmanaged>
        /// <unmanaged-short>MFASYNC_CALLBACK_QUEUE_RT</unmanaged-short>
        Rt = unchecked ((System.Int32)(2)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>bb970381</doc-id>
        /// <unmanaged>MFASYNC_CALLBACK_QUEUE_IO</unmanaged>
        /// <unmanaged-short>MFASYNC_CALLBACK_QUEUE_IO</unmanaged-short>
        Io = unchecked ((System.Int32)(3)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>bb970381</doc-id>
        /// <unmanaged>MFASYNC_CALLBACK_QUEUE_TIMER</unmanaged>
        /// <unmanaged-short>MFASYNC_CALLBACK_QUEUE_TIMER</unmanaged-short>
        Timer = unchecked ((System.Int32)(4)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>bb970381</doc-id>
        /// <unmanaged>MFASYNC_CALLBACK_QUEUE_MULTITHREADED</unmanaged>
        /// <unmanaged-short>MFASYNC_CALLBACK_QUEUE_MULTITHREADED</unmanaged-short>
        Multithreaded = unchecked ((System.Int32)(5)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>bb970381</doc-id>
        /// <unmanaged>MFASYNC_CALLBACK_QUEUE_LONG_FUNCTION</unmanaged>
        /// <unmanaged-short>MFASYNC_CALLBACK_QUEUE_LONG_FUNCTION</unmanaged-short>
        LongFunction = unchecked ((System.Int32)(7)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>bb970381</doc-id>
        /// <unmanaged>MFASYNC_CALLBACK_QUEUE_PRIVATE_MASK</unmanaged>
        /// <unmanaged-short>MFASYNC_CALLBACK_QUEUE_PRIVATE_MASK</unmanaged-short>
        PrivateMask = unchecked ((System.Int32)(-65536)),
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>bb970381</doc-id>
        /// <unmanaged>MFASYNC_CALLBACK_QUEUE_ALL</unmanaged>
        /// <unmanaged-short>MFASYNC_CALLBACK_QUEUE_ALL</unmanaged-short>
        All = unchecked ((System.Int32)(-1))}
}
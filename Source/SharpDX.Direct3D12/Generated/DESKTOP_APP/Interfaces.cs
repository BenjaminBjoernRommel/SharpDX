// <auto-generated/>

namespace SharpDX.Direct3D12
{
    [System.Runtime.InteropServices.GuidAttribute("6102dee4-af59-4b09-b999-b44d73f09b24")]
    public partial class CommandAllocator : SharpDX.Direct3D12.Pageable
    {
        public CommandAllocator(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator CommandAllocator(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new CommandAllocator(nativePtr);
        /// <summary>
        /// <p>Indicates to re-use the memory that is associated with the command allocator.</p>
        /// </summary>
        /// <returns><p>This method returns <strong>E_FAIL</strong> if there is an actively recording command list referencing the command allocator.  The debug layer will also issue an error in this case.   See Direct3D 12 Return Codes for other possible return values.</p></returns>
        /// <remarks>
        /// <p>Apps call <strong>Reset</strong> to re-use the memory that is associated with a command allocator.  From this call to <strong>Reset</strong>, the runtime and driver determine that the graphics processing unit (GPU) is no longer executing any command lists that have recorded commands with the command allocator.</p><p>Unlike <strong>ID3D12GraphicsCommandList::Reset</strong>, it is not recommended that you call <strong>Reset</strong> on the command allocator while a command list is still being executed. </p><p>The debug layer will issue a warning if it can't prove that there are no pending GPU references to command lists that have recorded commands in the allocator.</p><p>The debug layer will issue an error if <strong>Reset</strong> is called concurrently by multiple threads (on the same allocator object).</p>
        /// </remarks>
        /// <doc-id>dn770464</doc-id>
        /// <unmanaged>HRESULT ID3D12CommandAllocator::Reset()</unmanaged>
        /// <unmanaged-short>ID3D12CommandAllocator::Reset</unmanaged-short>
        public unsafe void Reset()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("7116d91c-e7e4-47ce-b8c6-ec8168f437e5")]
    public partial class CommandList : SharpDX.Direct3D12.DeviceChild
    {
        public CommandList(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator CommandList(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new CommandList(nativePtr);
        /// <summary>
        /// <p> Gets the type of the command list, such as direct, bundle, compute, or copy. </p>
        /// </summary>
        /// <doc-id>dn903824</doc-id>
        /// <unmanaged>GetType</unmanaged>
        /// <unmanaged-short>GetType</unmanaged-short>
        public SharpDX.Direct3D12.CommandListType TypeInfo
        {
            get => GetTypeInfo();
        }

        /// <summary>
        /// <p> Gets the type of the command list, such as direct, bundle, compute, or copy. </p>
        /// </summary>
        /// <returns><p> This method returns the type of the command list,  as a <strong><see cref = "SharpDX.Direct3D12.CommandListType"/></strong> enumeration constant,  such as direct, bundle, compute, or copy. </p></returns>
        /// <doc-id>dn903824</doc-id>
        /// <unmanaged>D3D12_COMMAND_LIST_TYPE ID3D12CommandList::GetType()</unmanaged>
        /// <unmanaged-short>ID3D12CommandList::GetType</unmanaged-short>
        internal unsafe SharpDX.Direct3D12.CommandListType GetTypeInfo()
        {
            SharpDX.Direct3D12.CommandListType __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallSharpDXDirect3D12CommandListType(this._nativePointer, (*(void ***)this._nativePointer)[8]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("0ec870a6-5d7e-4c22-8cfc-5baae07616ed")]
    public partial class CommandQueue : SharpDX.Direct3D12.Pageable
    {
        public CommandQueue(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator CommandQueue(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new CommandQueue(nativePtr);
        /// <summary>
        /// <p>This method is used to determine the rate at which the GPU timestamp counter increments.</p>
        /// </summary>
        /// <remarks>
        /// <p>For more information, refer to Timing.</p>
        /// </remarks>
        /// <doc-id>dn903826</doc-id>
        /// <unmanaged>GetTimestampFrequency</unmanaged>
        /// <unmanaged-short>GetTimestampFrequency</unmanaged-short>
        public System.Int64 TimestampFrequency
        {
            get
            {
                GetTimestampFrequency(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p> Gets the description of the command queue. </p>
        /// </summary>
        /// <doc-id>dn914410</doc-id>
        /// <unmanaged>GetDesc</unmanaged>
        /// <unmanaged-short>GetDesc</unmanaged-short>
        public SharpDX.Direct3D12.CommandQueueDescription Description
        {
            get => GetDescription();
        }

        /// <summary>
        /// <p> Updates mappings of tile locations in reserved resources to memory locations in a resource heap. </p>
        /// </summary>
        /// <param name = "resourceRef"><dd> <p> A reference to the reserved resource. </p> </dd></param>
        /// <param name = "numResourceRegions"><dd> <p> The number of reserved resource regions. </p> </dd></param>
        /// <param name = "resourceRegionStartCoordinatesRef"><dd> <p> An array of <strong><see cref = "SharpDX.Direct3D12.TiledResourceCoordinate"/></strong> structures that describe the starting coordinates of the reserved resource regions. The <em>NumResourceRegions</em> parameter specifies the number of <strong><see cref = "SharpDX.Direct3D12.TiledResourceCoordinate"/></strong> structures in the array. </p> </dd></param>
        /// <param name = "resourceRegionSizesRef"><dd> <p> An array of <strong><see cref = "SharpDX.Direct3D12.TileRegionSize"/></strong> structures that describe the sizes of the reserved resource regions. The <em>NumResourceRegions</em> parameter specifies the number of <strong><see cref = "SharpDX.Direct3D12.TileRegionSize"/></strong> structures in the array. </p> </dd></param>
        /// <param name = "heapRef"><dd> <p> A reference to the resource heap. </p> </dd></param>
        /// <param name = "numRanges"><dd> <p> The number of tile  ranges. </p> </dd></param>
        /// <param name = "rangeFlagsRef"><dd> <p> A reference to an  array of <strong><see cref = "SharpDX.Direct3D12.TileRangeFlags"/></strong> values that describes each tile range. The <em>NumRanges</em> parameter specifies the number of values in the array. </p> </dd></param>
        /// <param name = "heapRangeStartOffsetsRef"><dd> <p> An array of offsets into the resource heap. These are 0-based tile offsets, counting in tiles (not bytes). </p> </dd></param>
        /// <param name = "rangeTileCountsRef"><dd> <p> An array of tiles. An array of values that specify the number of tiles in each tile range. The <em>NumRanges</em> parameter specifies the number of values in the array. </p> </dd></param>
        /// <param name = "flags"><dd> <p> A combination of <strong><see cref = "SharpDX.Direct3D12.TileMappingFlags"/></strong> values that are combined by using a bitwise OR operation. </p> </dd></param>
        /// <remarks>
        /// <p>Use <strong>UpdateTileMappings</strong> to map the virtual pages of a reserved resource to the physical pages of a heap. The mapping does not have to be in order. The operation is similar to  <strong>ID3D11DeviceContext2::UpdateTileMappings</strong> with the one key difference that D3D12 allows a reserved resource to have tiles from multiple heaps.</p><p> In a single call to <strong>UpdateTileMappings</strong>, you can map one or more ranges of resource tiles to one or more ranges of heap tiles.  </p><p> You can organize the parameters of  <strong>UpdateTileMappings</strong> in these ways to perform an update: </p><ul> <li><strong>Reserved resource whose mappings are updated.</strong> Mappings start off all <c>null</c> when a resource is initially created. </li> <li><strong>Set of tile regions on the reserved resource whose mappings are updated.</strong> You can make one <strong>UpdateTileMappings</strong> call to update many mappings or multiple calls with a bit more API call overhead as well if that is more convenient. <ul> <li><em>NumResourceRegions</em> specifies how many regions there are.</li> <li><em>pResourceRegionStartCoordinates</em> and <em>pResourceRegionSizes</em> are each arrays that identify the start location and extend of each region. If <em>NumResourceRegions</em> is 1, for convenience either or both of the arrays that describe the regions can be <c>null</c>.  <c>null</c> for <em>pResourceRegionStartCoordinates</em> means the start coordinate is all 0s, and <c>null</c> for <em>pResourceRegionSizes</em> identifies a default region that is the full set of tiles for the entire reserved resource, including all mipmaps, array slices, or both.  </li> <li> <p> If <em>pResourceRegionStartCoordinates</em> isn't <c>null</c> and <em>pResourceRegionSizes</em> is <c>null</c>, the region size defaults to 1 tile for all regions.  This makes it easy to define mappings for a set of individual tiles each at disparate locations by providing an array of locations in <em>pResourceRegionStartCoordinates</em> without having to send an array of <em>pResourceRegionSizes</em> all set to 1. </p> </li> </ul> <p>The updates are applied from first region to last; so, if regions overlap in a single call, the updates later in the list overwrite the areas that overlap with previous updates.</p> </li> <li><strong>Heap that provides memory where tile mappings can go.</strong> If <strong>UpdateTileMappings</strong> only defines <c>null</c> mappings, you don't need to specify a heap.</li> <li><strong>Set of tile ranges where mappings are going.</strong> Each given tile range can specify one of a few types of ranges: a range of tiles in a heap (default), a count of tiles in the reserved resource to map to a single tile in a heap (sharing the tile), a count of tile mappings in the reserved resource to skip and leave as they are, or a count of tiles in the heap to map to <c>null</c>.<p><em>NumRanges</em> specifies the number of tile ranges, where the total tiles identified across all ranges must match the total number of tiles in the tile regions from the previously described reserved resource.  Mappings are defined by iterating through the tiles in the tile regions in sequential order - x then y then z order for box regions - while walking through the set of tile ranges in sequential order.  The breakdown of tile regions doesn't have to line up with the breakdown of tile ranges, but the total number of tiles on both sides must be equal so that each reserved resource tile specified has a mapping specified. </p> <p><em>pRangeFlags</em>, <em>pHeapRangeStartOffsets</em>, and <em>pRangeTileCounts</em> are all arrays, of size <em>NumRanges</em>, that describe the tile ranges.  If <em>pRangeFlags</em> is <c>null</c>, all ranges are sequential tiles in the heap; otherwise, for each range i,<em>pRangeFlags[i]</em> identifies how the mappings in that range of tiles work: </p> <ul> <li> If <em>pRangeFlags[i]</em> is <strong>D3D12_TILE_RANGE_FLAG_NONE</strong>, that range defines sequential tiles in the heap, with the number of tiles being <em>pRangeTileCounts[i]</em> and the starting location <em>pHeapRangeStartOffsets[i]</em>.  If <em>NumRanges</em> is 1, <em>pRangeTileCounts</em> can be <c>null</c> and defaults to the total number of tiles specified by all the tile regions. </li> <li> If <em>pRangeFlags[i]</em> is <strong>D3D12_TILE_RANGE_FLAG_REUSE_SINGLE_TILE</strong>, <em>pHeapRangeStartOffsets[i]</em> identifies the single tile in the heap to map to, and <em>pRangeTileCounts[i]</em> specifies how many tiles from the tile regions to map to that heap location.  If <em>NumRanges</em> is 1, <em>pRangeTileCounts</em> can be <c>null</c> and defaults to the total number of tiles specified by all the tile regions. </li> <li> If <em>pRangeFlags[i]</em> is <strong>D3D12_TILE_RANGE_FLAG_NULL</strong>, <em>pRangeTileCounts[i]</em> specifies how many tiles from the tile regions to map to <c>null</c>.  If <em>NumRanges</em> is 1, <em>pRangeTileCounts</em> can be <c>null</c> and defaults to the total number of tiles specified by all the tile regions. <em>pHeapRangeStartOffsets[i]</em> is ignored for <c>null</c> mappings. </li> <li> If <em>pRangeFlags[i]</em> is <strong>D3D12_TILE_RANGE_FLAG_SKIP</strong>, <em>pRangeTileCounts[i]</em> specifies how many tiles from the tile regions to skip over and leave existing mappings unchanged for.  This can be useful if a tile region conveniently bounds an area of tile mappings to update except with some exceptions that need to be left the same as whatever they were mapped to before. <em>pHeapRangeStartOffsets[i]</em> is ignored for SKIP mappings. </li> </ul> </li> <li><strong>Flags parameter for overall options.</strong> <strong>D3D12_TILE_MAPPING_FLAG_NO_HAZARD</strong>. Refer to the description of this flag in <strong><see cref = "SharpDX.Direct3D12.TileMappingFlags"/></strong>.</li> </ul><p> Reserved resources must follow the same rules for tile aliasing, initialization, and data inheritance as placed resources. See <strong>CreatePlacedResource</strong> for more details.</p><p> Here are some examples of common <strong>UpdateTileMappings</strong> cases: </p>
        /// </remarks>
        /// <doc-id>dn788641</doc-id>
        /// <unmanaged>void ID3D12CommandQueue::UpdateTileMappings([In] ID3D12Resource* pResource,[In] unsigned int NumResourceRegions,[In, Buffer, Optional] const D3D12_TILED_RESOURCE_COORDINATE* pResourceRegionStartCoordinates,[In, Buffer, Optional] const D3D12_TILE_REGION_SIZE* pResourceRegionSizes,[In, Optional] ID3D12Heap* pHeap,[In] unsigned int NumRanges,[In, Buffer, Optional] const D3D12_TILE_RANGE_FLAGS* pRangeFlags,[In, Buffer, Optional] const unsigned int* pHeapRangeStartOffsets,[In, Buffer, Optional] const unsigned int* pRangeTileCounts,[In] D3D12_TILE_MAPPING_FLAGS Flags)</unmanaged>
        /// <unmanaged-short>ID3D12CommandQueue::UpdateTileMappings</unmanaged-short>
        public unsafe void UpdateTileMappings(SharpDX.Direct3D12.Resource resourceRef, System.Int32 numResourceRegions, SharpDX.Direct3D12.TiledResourceCoordinate[] resourceRegionStartCoordinatesRef, SharpDX.Direct3D12.TileRegionSize[] resourceRegionSizesRef, SharpDX.Direct3D12.Heap heapRef, System.Int32 numRanges, SharpDX.Direct3D12.TileRangeFlags[] rangeFlagsRef, System.Int32[] heapRangeStartOffsetsRef, System.Int32[] rangeTileCountsRef, SharpDX.Direct3D12.TileMappingFlags flags)
        {
            System.IntPtr resourceRef_ = System.IntPtr.Zero;
            System.IntPtr heapRef_ = System.IntPtr.Zero;
            resourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(resourceRef);
            heapRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Heap>(heapRef);
            fixed (void *rangeTileCountsRef_ = rangeTileCountsRef)
                fixed (void *heapRangeStartOffsetsRef_ = heapRangeStartOffsetsRef)
                    fixed (void *rangeFlagsRef_ = rangeFlagsRef)
                        fixed (void *resourceRegionSizesRef_ = resourceRegionSizesRef)
                            fixed (void *resourceRegionStartCoordinatesRef_ = resourceRegionStartCoordinatesRef)
                                SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)resourceRef_, numResourceRegions, resourceRegionStartCoordinatesRef_, resourceRegionSizesRef_, (void *)heapRef_, numRanges, rangeFlagsRef_, heapRangeStartOffsetsRef_, rangeTileCountsRef_, unchecked ((System.Int32)flags), (*(void ***)this._nativePointer)[8]);
        }

        /// <summary>
        /// <p>Copies mappings from a source reserved resource to a destination reserved resource.</p>
        /// </summary>
        /// <param name = "dstResourceRef"><dd> <p>A reference to the destination reserved resource.</p> </dd></param>
        /// <param name = "dstRegionStartCoordinateRef"><dd> <p> A reference to a <strong><see cref = "SharpDX.Direct3D12.TiledResourceCoordinate"/></strong> structure that describes the starting coordinates of the destination reserved resource. </p> </dd></param>
        /// <param name = "srcResourceRef"><dd> <p>A reference to the source reserved resource.</p> </dd></param>
        /// <param name = "srcRegionStartCoordinateRef"><dd> <p> A reference to a <strong><see cref = "SharpDX.Direct3D12.TiledResourceCoordinate"/></strong> structure that describes the starting coordinates of the source reserved resource. </p> </dd></param>
        /// <param name = "regionSizeRef"><dd> <p> A reference to a <strong><see cref = "SharpDX.Direct3D12.TileRegionSize"/></strong> structure that describes the size of the reserved region. </p> </dd></param>
        /// <param name = "flags"><dd> <p> One member of <strong><see cref = "SharpDX.Direct3D12.TileMappingFlags"/></strong>. </p> </dd></param>
        /// <remarks>
        /// <p>Use <strong>CopyTileMappings</strong> to copy the tile mappings from one reserved resource to another, either to duplicate a resource mapping, or to initialize a new mapping before modifying it using <strong>UpdateTileMappings</strong>.</p><p><strong>CopyTileMappings</strong> helps with tasks such as shifting mappings around within and across reserved resources, for example, scrolling tiles.  The source and destination regions can overlap; the result of the copy in this situation is as if the source was saved to a temporary location  and from there written to the destination. </p><p>The destination and the source regions must each entirely fit in their resource or behavior is undefined and the debug layer will emit an error.</p><p> For more info on tiled resources, refer to the  "DirectX tiled resources" section within DirectX programming. </p>
        /// </remarks>
        /// <doc-id>dn788629</doc-id>
        /// <unmanaged>void ID3D12CommandQueue::CopyTileMappings([In] ID3D12Resource* pDstResource,[In] const D3D12_TILED_RESOURCE_COORDINATE* pDstRegionStartCoordinate,[In] ID3D12Resource* pSrcResource,[In] const D3D12_TILED_RESOURCE_COORDINATE* pSrcRegionStartCoordinate,[In] const D3D12_TILE_REGION_SIZE* pRegionSize,[In] D3D12_TILE_MAPPING_FLAGS Flags)</unmanaged>
        /// <unmanaged-short>ID3D12CommandQueue::CopyTileMappings</unmanaged-short>
        public unsafe void CopyTileMappings(SharpDX.Direct3D12.Resource dstResourceRef, SharpDX.Direct3D12.TiledResourceCoordinate dstRegionStartCoordinateRef, SharpDX.Direct3D12.Resource srcResourceRef, SharpDX.Direct3D12.TiledResourceCoordinate srcRegionStartCoordinateRef, SharpDX.Direct3D12.TileRegionSize regionSizeRef, SharpDX.Direct3D12.TileMappingFlags flags)
        {
            System.IntPtr dstResourceRef_ = System.IntPtr.Zero;
            System.IntPtr srcResourceRef_ = System.IntPtr.Zero;
            dstResourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(dstResourceRef);
            srcResourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(srcResourceRef);
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)dstResourceRef_, &dstRegionStartCoordinateRef, (void *)srcResourceRef_, &srcRegionStartCoordinateRef, &regionSizeRef, unchecked ((System.Int32)flags), (*(void ***)this._nativePointer)[9]);
        }

        /// <summary>
        /// <p>Submits an array of command lists for execution.</p>
        /// </summary>
        /// <param name = "numCommandLists"><dd> <p> The number of command lists to be executed. </p> </dd></param>
        /// <param name = "commandListsOut"><dd> <p> The array of <strong><see cref = "SharpDX.Direct3D12.CommandList"/></strong> command lists to be executed. </p> </dd></param>
        /// <remarks>
        /// <p> The driver is free to patch the submitted command lists. It is the calling application?s responsibility to ensure that the graphics processing unit (GPU) is not currently reading the any of the submitted command lists from a previous execution. </p><p> Applications are encouraged to batch together command list executions to reduce fixed costs associated with submitted commands to the GPU. </p>
        /// </remarks>
        /// <doc-id>dn788631</doc-id>
        /// <unmanaged>void ID3D12CommandQueue::ExecuteCommandLists([In] unsigned int NumCommandLists,[In, Buffer] const ID3D12CommandList** ppCommandLists)</unmanaged>
        /// <unmanaged-short>ID3D12CommandQueue::ExecuteCommandLists</unmanaged-short>
        public unsafe void ExecuteCommandLists(System.Int32 numCommandLists, SharpDX.Direct3D12.CommandList[] commandListsOut)
        {
            System.IntPtr*commandListsOut_;
            commandListsOut_ = (System.IntPtr*)0;
            if (commandListsOut != null)
            {
                System.IntPtr*_commandListsOut = stackalloc System.IntPtr[commandListsOut.Length];
                commandListsOut_ = _commandListsOut;
            }

            if (commandListsOut != null)
                for (int i = 0; i < commandListsOut.Length; ++i)
                    (commandListsOut_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.CommandList>(commandListsOut[i]);
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, numCommandLists, (void *)commandListsOut_, (*(void ***)this._nativePointer)[10]);
        }

        /// <summary>
        /// <p> Not intended to be called directly.? Use the PIX event runtime to insert events into a command queue.</p>
        /// </summary>
        /// <param name = "metadata">No documentation.</param>
        /// <param name = "dataRef">No documentation.</param>
        /// <param name = "size">No documentation.</param>
        /// <remarks>
        /// <p>This is a support method used internally by the PIX event runtime.? It is not intended to be called directly.</p><p>To insert instrumentation markers at the current location within a D3D12 command queue, use the <strong>PIXSetMarker</strong> function.? This is provided by the WinPixEventRuntime NuGet package.</p>
        /// </remarks>
        /// <doc-id>dn986872</doc-id>
        /// <unmanaged>void ID3D12CommandQueue::SetMarker([In] unsigned int Metadata,[In, Buffer, Optional] const void* pData,[In] unsigned int Size)</unmanaged>
        /// <unmanaged-short>ID3D12CommandQueue::SetMarker</unmanaged-short>
        public unsafe void SetMarker(System.Int32 metadata, System.IntPtr dataRef, System.Int32 size)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, metadata, (void *)dataRef, size, (*(void ***)this._nativePointer)[11]);
        }

        /// <summary>
        /// <p> Not intended to be called directly.? Use the PIX event runtime to insert events into a command queue.</p>
        /// </summary>
        /// <param name = "metadata">No documentation.</param>
        /// <param name = "dataRef">No documentation.</param>
        /// <param name = "size">No documentation.</param>
        /// <remarks>
        /// <p>This is a support method used internally by the PIX event runtime.? It is not intended to be called directly.</p><p>To mark the start of an instrumentation region at the current location within a D3D12 command queue, use the <strong>PIXBeginEvent</strong> function or <strong>PIXScopedEvent</strong> macro.? These are provided by the WinPixEventRuntime NuGet package.</p>
        /// </remarks>
        /// <doc-id>dn986870</doc-id>
        /// <unmanaged>void ID3D12CommandQueue::BeginEvent([In] unsigned int Metadata,[In, Buffer, Optional] const void* pData,[In] unsigned int Size)</unmanaged>
        /// <unmanaged-short>ID3D12CommandQueue::BeginEvent</unmanaged-short>
        public unsafe void BeginEvent(System.Int32 metadata, System.IntPtr dataRef, System.Int32 size)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, metadata, (void *)dataRef, size, (*(void ***)this._nativePointer)[12]);
        }

        /// <summary>
        /// <p> Not intended to be called directly.? Use the PIX event runtime to insert events into a command queue.</p>
        /// </summary>
        /// <remarks>
        /// <p>This is a support method used internally by the PIX event runtime.? It is not intended to be called directly.</p><p>To mark the end of an instrumentation region at the current location within a D3D12 command queue, use the <strong>PIXEndEvent</strong> function or <strong>PIXScopedEvent</strong> macro.? These are provided by the WinPixEventRuntime NuGet package.</p>
        /// </remarks>
        /// <doc-id>dn986871</doc-id>
        /// <unmanaged>void ID3D12CommandQueue::EndEvent()</unmanaged>
        /// <unmanaged-short>ID3D12CommandQueue::EndEvent</unmanaged-short>
        public unsafe void EndEvent()
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (*(void ***)this._nativePointer)[13]);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "fenceRef">No documentation.</param>
        /// <param name = "value">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D12CommandQueue::Signal([In] ID3D12Fence* pFence,[In] unsigned longlong Value)</unmanaged>
        /// <unmanaged-short>ID3D12CommandQueue::Signal</unmanaged-short>
        public unsafe void Signal(SharpDX.Direct3D12.Fence fenceRef, System.Int64 value)
        {
            System.IntPtr fenceRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fenceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Fence>(fenceRef);
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, (void *)fenceRef_, value, (*(void ***)this._nativePointer)[14]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Waits until the specified fence reaches or exceeds the specified value.</p>
        /// </summary>
        /// <param name = "fenceRef"><dd>  <p> A reference to the <strong><see cref = "SharpDX.Direct3D12.Fence"/></strong> object. </p> </dd></param>
        /// <param name = "value"><dd>  <p>The value that the command queue is waiting for the fence to reach or exceed.  So when  <strong>ID3D12Fence::GetCompletedValue</strong> is greater than or equal to <em>Value</em>, the wait is terminated.</p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. </p></returns>
        /// <doc-id>dn899173</doc-id>
        /// <unmanaged>HRESULT ID3D12CommandQueue::Wait([In] ID3D12Fence* pFence,[In] unsigned longlong Value)</unmanaged>
        /// <unmanaged-short>ID3D12CommandQueue::Wait</unmanaged-short>
        public unsafe void Wait(SharpDX.Direct3D12.Fence fenceRef, System.Int64 value)
        {
            System.IntPtr fenceRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fenceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Fence>(fenceRef);
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, (void *)fenceRef_, value, (*(void ***)this._nativePointer)[15]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>This method is used to determine the rate at which the GPU timestamp counter increments.</p>
        /// </summary>
        /// <param name = "frequencyRef"><dd>  <p>The GPU timestamp counter frequency (in ticks/second).</p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.</p></returns>
        /// <remarks>
        /// <p>For more information, refer to Timing.</p>
        /// </remarks>
        /// <doc-id>dn903826</doc-id>
        /// <unmanaged>HRESULT ID3D12CommandQueue::GetTimestampFrequency([Out] unsigned longlong* pFrequency)</unmanaged>
        /// <unmanaged-short>ID3D12CommandQueue::GetTimestampFrequency</unmanaged-short>
        internal unsafe void GetTimestampFrequency(out System.Int64 frequencyRef)
        {
            SharpDX.Result __result__;
            fixed (void *frequencyRef_ = &frequencyRef)
                __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, frequencyRef_, (*(void ***)this._nativePointer)[16]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>This method samples the CPU and GPU timestamp counters at the same moment in time. </p>
        /// </summary>
        /// <param name = "gpuTimestampRef"><dd>  <p>The value of the GPU timestamp counter.</p> </dd></param>
        /// <param name = "cpuTimestampRef"><dd>  <p>The value of the CPU timestamp counter.</p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.</p></returns>
        /// <remarks>
        /// <p>For more information, refer to Timing.</p>
        /// </remarks>
        /// <doc-id>dn903825</doc-id>
        /// <unmanaged>HRESULT ID3D12CommandQueue::GetClockCalibration([Out] unsigned longlong* pGpuTimestamp,[Out] unsigned longlong* pCpuTimestamp)</unmanaged>
        /// <unmanaged-short>ID3D12CommandQueue::GetClockCalibration</unmanaged-short>
        public unsafe void GetClockCalibration(out System.Int64 gpuTimestampRef, out System.Int64 cpuTimestampRef)
        {
            SharpDX.Result __result__;
            fixed (void *cpuTimestampRef_ = &cpuTimestampRef)
                fixed (void *gpuTimestampRef_ = &gpuTimestampRef)
                    __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, gpuTimestampRef_, cpuTimestampRef_, (*(void ***)this._nativePointer)[17]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Gets the description of the command queue. </p>
        /// </summary>
        /// <returns><p> The description of the command queue, as a <strong><see cref = "SharpDX.Direct3D12.CommandQueueDescription"/></strong> structure. </p></returns>
        /// <doc-id>dn914410</doc-id>
        /// <unmanaged>D3D12_COMMAND_QUEUE_DESC ID3D12CommandQueue::GetDesc()</unmanaged>
        /// <unmanaged-short>ID3D12CommandQueue::GetDesc</unmanaged-short>
        internal unsafe SharpDX.Direct3D12.CommandQueueDescription GetDescription()
        {
            SharpDX.Direct3D12.CommandQueueDescription __result__;
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoidPtr(this._nativePointer, &__result__, (*(void ***)this._nativePointer)[18]);
            return __result__;
        }

        /// <summary>
        /// <p>Submits an array of command lists for execution.</p>
        /// </summary>
        /// <param name = "numCommandLists"><dd> <p> The number of command lists to be executed. </p> </dd></param>
        /// <param name = "commandListsOut"><dd> <p> The array of <strong><see cref = "SharpDX.Direct3D12.CommandList"/></strong> command lists to be executed. </p> </dd></param>
        /// <remarks>
        /// <p> The driver is free to patch the submitted command lists. It is the calling application?s responsibility to ensure that the graphics processing unit (GPU) is not currently reading the any of the submitted command lists from a previous execution. </p><p> Applications are encouraged to batch together command list executions to reduce fixed costs associated with submitted commands to the GPU. </p>
        /// </remarks>
        /// <doc-id>dn788631</doc-id>
        /// <unmanaged>void ID3D12CommandQueue::ExecuteCommandLists([In] unsigned int NumCommandLists,[In, Buffer] const ID3D12CommandList** ppCommandLists)</unmanaged>
        /// <unmanaged-short>ID3D12CommandQueue::ExecuteCommandLists</unmanaged-short>
        public unsafe void ExecuteCommandLists(System.Int32 numCommandLists, SharpDX.ComArray<SharpDX.Direct3D12.CommandList> commandListsOut)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, numCommandLists, (void *)(commandListsOut?.NativePointer ?? System.IntPtr.Zero), (*(void ***)this._nativePointer)[10]);
        }

        /// <summary>
        /// <p>Submits an array of command lists for execution.</p>
        /// </summary>
        /// <param name = "numCommandLists"><dd> <p> The number of command lists to be executed. </p> </dd></param>
        /// <param name = "commandListsOut"><dd> <p> The array of <strong><see cref = "SharpDX.Direct3D12.CommandList"/></strong> command lists to be executed. </p> </dd></param>
        /// <remarks>
        /// <p> The driver is free to patch the submitted command lists. It is the calling application?s responsibility to ensure that the graphics processing unit (GPU) is not currently reading the any of the submitted command lists from a previous execution. </p><p> Applications are encouraged to batch together command list executions to reduce fixed costs associated with submitted commands to the GPU. </p>
        /// </remarks>
        /// <doc-id>dn788631</doc-id>
        /// <unmanaged>void ID3D12CommandQueue::ExecuteCommandLists([In] unsigned int NumCommandLists,[In, Buffer] const ID3D12CommandList** ppCommandLists)</unmanaged>
        /// <unmanaged-short>ID3D12CommandQueue::ExecuteCommandLists</unmanaged-short>
        private unsafe void ExecuteCommandLists(System.Int32 numCommandLists, System.IntPtr commandListsOut)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, numCommandLists, (void *)commandListsOut, (*(void ***)this._nativePointer)[10]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("c36a797c-ec80-4f0a-8985-a7b2475082d1")]
    public partial class CommandSignature : SharpDX.Direct3D12.Pageable
    {
        public CommandSignature(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator CommandSignature(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new CommandSignature(nativePtr);
    }

    [System.Runtime.InteropServices.GuidAttribute("affaa4ca-63fe-4d8e-b8ad-159000af4304")]
    public partial class Debug1 : SharpDX.ComObject
    {
        public Debug1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Debug1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Debug1(nativePtr);
        /// <summary>
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>This method enables or disables GPU-Based Validation (GBV) before creating a device with the debug layer enabled.  </p>
        /// </summary>
        /// <remarks>
        /// <p>GPU-Based Validation can only be enabled/disabled prior to creating a device.  By default, GPU-Based Validation is disabled.  To disable GPU-Based Validation after initially enabling it the device must be fully released and recreated.  </p><p>For more information, see Using D3D12 Debug Layer GPU-Based Validation.</p>
        /// </remarks>
        /// <doc-id>mt762995</doc-id>
        /// <unmanaged>SetEnableGPUBasedValidation</unmanaged>
        /// <unmanaged-short>SetEnableGPUBasedValidation</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool EnableGPUBasedValidation
        {
            set => SetEnableGPUBasedValidation(value);
        }

        /// <summary>
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Enables or disables dependent command queue synchronization when using a D3D12 device with the debug layer enabled.</p>
        /// </summary>
        /// <remarks>
        /// <p>Dependent Command Queue Synchronization is a D3D12 Debug Layer feature that gives the debug layer the ability to track resource states more accurately when enabled.  Dependent Command Queue Synchronization is enabled by default.  </p><p>When Dependent Command Queue Synchronization is enabled, the debug layer holds back actual submission of GPU work until all outstanding fence <strong>Wait</strong> conditions are met.  This gives the debug layer the ability to make reasonable assumptions about GPU state (such as resource states) on the CPU-timeline when multiple command queues are potentially doing concurrent work.</p><p>With Dependent Command Queue Synchronization disabled, all resource states tracked by the debug layer are cleared each time <strong>ID3D12CommandQueue::Signal</strong> is called.  This results in significantly less useful resource state validation.</p><p>Disabling Dependent Command Queue Synchronization may reduce some debug layer performance overhead when using multiple command queues.  However, it is suggested to leave it enabled unless this overhead is problematic.  Note that applications that use only a single command queue will see no performance changes with Dependent Command Queue Synchronization disabled.</p>
        /// </remarks>
        /// <doc-id>mt762996</doc-id>
        /// <unmanaged>SetEnableSynchronizedCommandQueueValidation</unmanaged>
        /// <unmanaged-short>SetEnableSynchronizedCommandQueueValidation</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool EnableSynchronizedCommandQueueValidation
        {
            set => SetEnableSynchronizedCommandQueueValidation(value);
        }

        /// <summary>
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Enables the debug layer.</p>
        /// </summary>
        /// <remarks>
        /// <p>This method is identical to <strong>ID3D12Debug::EnableDebugLayer</strong>.</p>
        /// </remarks>
        /// <doc-id>mt762991</doc-id>
        /// <unmanaged>void ID3D12Debug1::EnableDebugLayer()</unmanaged>
        /// <unmanaged-short>ID3D12Debug1::EnableDebugLayer</unmanaged-short>
        public unsafe void EnableDebugLayer()
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (*(void ***)this._nativePointer)[3]);
        }

        /// <summary>
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>This method enables or disables GPU-Based Validation (GBV) before creating a device with the debug layer enabled.  </p>
        /// </summary>
        /// <param name = "enable"><dd>  <p>TRUE to enable GPU-Based Validation, otherwise <see cref = "SharpDX.Result.False"/>.</p> </dd></param>
        /// <remarks>
        /// <p>GPU-Based Validation can only be enabled/disabled prior to creating a device.  By default, GPU-Based Validation is disabled.  To disable GPU-Based Validation after initially enabling it the device must be fully released and recreated.  </p><p>For more information, see Using D3D12 Debug Layer GPU-Based Validation.</p>
        /// </remarks>
        /// <doc-id>mt762995</doc-id>
        /// <unmanaged>void ID3D12Debug1::SetEnableGPUBasedValidation([In] BOOL Enable)</unmanaged>
        /// <unmanaged-short>ID3D12Debug1::SetEnableGPUBasedValidation</unmanaged-short>
        internal unsafe void SetEnableGPUBasedValidation(SharpDX.Mathematics.Interop.RawBool enable)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid0(this._nativePointer, enable, (*(void ***)this._nativePointer)[4]);
        }

        /// <summary>
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Enables or disables dependent command queue synchronization when using a D3D12 device with the debug layer enabled.</p>
        /// </summary>
        /// <param name = "enable"><dd>  <p>TRUE to enable Dependent Command Queue Synchronization, otherwise <see cref = "SharpDX.Result.False"/>.</p> </dd></param>
        /// <remarks>
        /// <p>Dependent Command Queue Synchronization is a D3D12 Debug Layer feature that gives the debug layer the ability to track resource states more accurately when enabled.  Dependent Command Queue Synchronization is enabled by default.  </p><p>When Dependent Command Queue Synchronization is enabled, the debug layer holds back actual submission of GPU work until all outstanding fence <strong>Wait</strong> conditions are met.  This gives the debug layer the ability to make reasonable assumptions about GPU state (such as resource states) on the CPU-timeline when multiple command queues are potentially doing concurrent work.</p><p>With Dependent Command Queue Synchronization disabled, all resource states tracked by the debug layer are cleared each time <strong>ID3D12CommandQueue::Signal</strong> is called.  This results in significantly less useful resource state validation.</p><p>Disabling Dependent Command Queue Synchronization may reduce some debug layer performance overhead when using multiple command queues.  However, it is suggested to leave it enabled unless this overhead is problematic.  Note that applications that use only a single command queue will see no performance changes with Dependent Command Queue Synchronization disabled.</p>
        /// </remarks>
        /// <doc-id>mt762996</doc-id>
        /// <unmanaged>void ID3D12Debug1::SetEnableSynchronizedCommandQueueValidation([In] BOOL Enable)</unmanaged>
        /// <unmanaged-short>ID3D12Debug1::SetEnableSynchronizedCommandQueueValidation</unmanaged-short>
        internal unsafe void SetEnableSynchronizedCommandQueueValidation(SharpDX.Mathematics.Interop.RawBool enable)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid0(this._nativePointer, enable, (*(void ***)this._nativePointer)[5]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("93a665c4-a3b2-4e5d-b692-a26ae14e3374")]
    public partial class Debug2 : SharpDX.ComObject
    {
        public Debug2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Debug2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Debug2(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>SetGPUBasedValidationFlags</unmanaged>
        /// <unmanaged-short>SetGPUBasedValidationFlags</unmanaged-short>
        public SharpDX.Direct3D12.GpuBasedValidationFlags GPUBasedValidationFlags
        {
            set => SetGPUBasedValidationFlags(value);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "flags">No documentation.</param>
        /// <unmanaged>void ID3D12Debug2::SetGPUBasedValidationFlags([In] D3D12_GPU_BASED_VALIDATION_FLAGS Flags)</unmanaged>
        /// <unmanaged-short>ID3D12Debug2::SetGPUBasedValidationFlags</unmanaged-short>
        internal unsafe void SetGPUBasedValidationFlags(SharpDX.Direct3D12.GpuBasedValidationFlags flags)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, unchecked ((System.Int32)flags), (*(void ***)this._nativePointer)[3]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("5cf4e58f-f671-4ff1-a542-3686e3d153d1")]
    public partial class Debug3 : SharpDX.Direct3D12.DebugInterface
    {
        public Debug3(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Debug3(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Debug3(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>SetEnableGPUBasedValidation</unmanaged>
        /// <unmanaged-short>SetEnableGPUBasedValidation</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool EnableGPUBasedValidation
        {
            set => SetEnableGPUBasedValidation(value);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>SetEnableSynchronizedCommandQueueValidation</unmanaged>
        /// <unmanaged-short>SetEnableSynchronizedCommandQueueValidation</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool EnableSynchronizedCommandQueueValidation
        {
            set => SetEnableSynchronizedCommandQueueValidation(value);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>SetGPUBasedValidationFlags</unmanaged>
        /// <unmanaged-short>SetGPUBasedValidationFlags</unmanaged-short>
        public SharpDX.Direct3D12.GpuBasedValidationFlags GPUBasedValidationFlags
        {
            set => SetGPUBasedValidationFlags(value);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "enable">No documentation.</param>
        /// <unmanaged>void ID3D12Debug3::SetEnableGPUBasedValidation([In] BOOL Enable)</unmanaged>
        /// <unmanaged-short>ID3D12Debug3::SetEnableGPUBasedValidation</unmanaged-short>
        internal unsafe void SetEnableGPUBasedValidation(SharpDX.Mathematics.Interop.RawBool enable)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid0(this._nativePointer, enable, (*(void ***)this._nativePointer)[4]);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "enable">No documentation.</param>
        /// <unmanaged>void ID3D12Debug3::SetEnableSynchronizedCommandQueueValidation([In] BOOL Enable)</unmanaged>
        /// <unmanaged-short>ID3D12Debug3::SetEnableSynchronizedCommandQueueValidation</unmanaged-short>
        internal unsafe void SetEnableSynchronizedCommandQueueValidation(SharpDX.Mathematics.Interop.RawBool enable)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid0(this._nativePointer, enable, (*(void ***)this._nativePointer)[5]);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "flags">No documentation.</param>
        /// <unmanaged>void ID3D12Debug3::SetGPUBasedValidationFlags([In] D3D12_GPU_BASED_VALIDATION_FLAGS Flags)</unmanaged>
        /// <unmanaged-short>ID3D12Debug3::SetGPUBasedValidationFlags</unmanaged-short>
        internal unsafe void SetGPUBasedValidationFlags(SharpDX.Direct3D12.GpuBasedValidationFlags flags)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, unchecked ((System.Int32)flags), (*(void ***)this._nativePointer)[6]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("09e0bf36-54ac-484f-8847-4baeeab6053f")]
    public partial class DebugCommandList : SharpDX.ComObject
    {
        public DebugCommandList(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DebugCommandList(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DebugCommandList(nativePtr);
        /// <summary>
        /// <p>Returns or sets the debug feature flags that have been set on a command list. </p>
        /// </summary>
        /// <doc-id>dn950156</doc-id>
        /// <unmanaged>GetFeatureMask / SetFeatureMask</unmanaged>
        /// <unmanaged-short>GetFeatureMask</unmanaged-short>
        public SharpDX.Direct3D12.DebugFeature FeatureMask
        {
            get => GetFeatureMask();
            set => SetFeatureMask(value);
        }

        /// <summary>
        /// <p> Checks whether a resource, or subresource, is in a specified state, or not.</p>
        /// </summary>
        /// <param name = "resourceRef"><dd>  <p>Specifies the  <strong><see cref = "SharpDX.Direct3D12.Resource"/></strong> to check.</p> </dd></param>
        /// <param name = "subresource"><dd>  <p>The index of the subresource to check. This can be set to an index, or D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES.</p> </dd></param>
        /// <param name = "state"><dd>  <p>Specifies the state to check for. This can be one or more <see cref = "SharpDX.Direct3D12.ResourceStates"/> flags Or'ed together.</p> </dd></param>
        /// <returns><p>This method returns true if the resource or subresource is in the specified state, false otherwise.</p></returns>
        /// <doc-id>dn950155</doc-id>
        /// <unmanaged>BOOL ID3D12DebugCommandList::AssertResourceState([In] ID3D12Resource* pResource,[In] unsigned int Subresource,[In] unsigned int State)</unmanaged>
        /// <unmanaged-short>ID3D12DebugCommandList::AssertResourceState</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool AssertResourceState(SharpDX.Direct3D12.Resource resourceRef, System.Int32 subresource, System.Int32 state)
        {
            System.IntPtr resourceRef_ = System.IntPtr.Zero;
            SharpDX.Mathematics.Interop.RawBool __result__;
            resourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(resourceRef);
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, (void *)resourceRef_, subresource, state, (*(void ***)this._nativePointer)[3]);
            return __result__;
        }

        /// <summary>
        /// <p> Turns the debug features for a command list on or off.</p>
        /// </summary>
        /// <param name = "mask"><dd>  <p> A combination of feature-mask flags that are combined by using a bitwise OR operation. If a flag is present, that feature will be set to on, otherwise the feature will be set to off.  </p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.  </p></returns>
        /// <doc-id>dn950157</doc-id>
        /// <unmanaged>HRESULT ID3D12DebugCommandList::SetFeatureMask([In] D3D12_DEBUG_FEATURE Mask)</unmanaged>
        /// <unmanaged-short>ID3D12DebugCommandList::SetFeatureMask</unmanaged-short>
        internal unsafe void SetFeatureMask(SharpDX.Direct3D12.DebugFeature mask)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)mask), (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Returns the debug feature flags that have been set on a command list. </p>
        /// </summary>
        /// <returns><p> A bit mask containing the set debug features. </p></returns>
        /// <doc-id>dn950156</doc-id>
        /// <unmanaged>D3D12_DEBUG_FEATURE ID3D12DebugCommandList::GetFeatureMask()</unmanaged>
        /// <unmanaged-short>ID3D12DebugCommandList::GetFeatureMask</unmanaged-short>
        internal unsafe SharpDX.Direct3D12.DebugFeature GetFeatureMask()
        {
            SharpDX.Direct3D12.DebugFeature __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallSharpDXDirect3D12DebugFeature(this._nativePointer, (*(void ***)this._nativePointer)[5]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("102ca951-311b-4b01-b11f-ecb83e061b37")]
    public partial class DebugCommandList1 : SharpDX.ComObject
    {
        public DebugCommandList1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DebugCommandList1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DebugCommandList1(nativePtr);
        /// <summary>
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Validates that the given state matches the state of the subresource, assuming the state of the given subresource is known during recording of a command list (e.g. the resource was transitioned earlier in the same command list recording).  If the state is not yet known this method sets the known state for further validation later in the same command list recording.</p>
        /// </summary>
        /// <param name = "resourceRef"><dd>  <p>Specifies the <strong><see cref = "SharpDX.Direct3D12.Resource"/></strong> to check.</p> </dd></param>
        /// <param name = "subresource"><dd>  <p>The index of the subresource to check. This can be set to an index, or D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES.</p> </dd></param>
        /// <param name = "state"><dd>  <p>Specifies the state to check for. This can be one or more <strong><see cref = "SharpDX.Direct3D12.ResourceStates"/></strong> flags Or'ed together.</p> </dd></param>
        /// <returns><p>This method returns <strong>true</strong> if the tracked state of the resource or subresource matches the specified state, <strong>false</strong> otherwise.</p></returns>
        /// <remarks>
        /// <p>Since execution of command lists occurs sometime after recording, the state of a resource often cannot be known during command list recording.  <strong>AssertResourceState</strong> gives an application developer the ability to impose an assumed state on a resource or subresource at a fixed recording point in a command list.</p><p>Often the state of a resource or subresource can either be known due to a previous barrier or inferred-by-use (for example, was used in an earlier call to <strong>CopyBufferRegion</strong>) during command list recording.  In such cases <strong>AssertResourceState</strong> can produce a debug message if the given state does not match the known or assumed state.</p><p>This API is for debug validation only and does not affect the actual runtime or GPU state of the resource.</p>
        /// </remarks>
        /// <doc-id>mt762987</doc-id>
        /// <unmanaged>BOOL ID3D12DebugCommandList1::AssertResourceState([In] ID3D12Resource* pResource,[In] unsigned int Subresource,[In] unsigned int State)</unmanaged>
        /// <unmanaged-short>ID3D12DebugCommandList1::AssertResourceState</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool AssertResourceState(SharpDX.Direct3D12.Resource resourceRef, System.Int32 subresource, System.Int32 state)
        {
            System.IntPtr resourceRef_ = System.IntPtr.Zero;
            SharpDX.Mathematics.Interop.RawBool __result__;
            resourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(resourceRef);
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, (void *)resourceRef_, subresource, state, (*(void ***)this._nativePointer)[3]);
            return __result__;
        }

        /// <summary>
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Modifies optional Debug Layer settings of a command list.</p>
        /// </summary>
        /// <param name = "type"><dd>  <p>Specifies a <strong><see cref = "SharpDX.Direct3D12.DebugCommandListParameterType"/></strong> value that indicates which debug parameter data to set.</p> </dd></param>
        /// <param name = "dataRef"><dd>  <p>Pointer to debug parameter data to set.  The interpretation of this data depends on the <strong><see cref = "SharpDX.Direct3D12.DebugCommandListParameterType"/></strong> given in the <em>Type</em> parameter.</p> </dd></param>
        /// <param name = "dataSize"><dd>  <p>Specifies the size in bytes of the debug parameter <em>pData</em>.</p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.  </p></returns>
        /// <remarks>
        /// <p>Certain debug behaviors of D3D12 Debug Layer can be modified by setting debug parameters.  These can be used to toggle extra validation or expose experimental debug features.</p><p><strong>ID3D12DebugCommandList1::SetDebugParameter</strong> only impacts debug settings for the associated command list.  For device-wide debug parameters see the <strong>ID3D12DebugDevice1::SetDebugParameter</strong> method.</p><p>Resetting a command list restores the debug parameters to the default values.  This is because a command list reset is treated as equivalent to creating a new command list.</p>
        /// </remarks>
        /// <doc-id>mt762989</doc-id>
        /// <unmanaged>HRESULT ID3D12DebugCommandList1::SetDebugParameter([In] D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE Type,[In, Buffer] const void* pData,[In] unsigned int DataSize)</unmanaged>
        /// <unmanaged-short>ID3D12DebugCommandList1::SetDebugParameter</unmanaged-short>
        public unsafe void SetDebugParameter(SharpDX.Direct3D12.DebugCommandListParameterType type, System.IntPtr dataRef, System.Int32 dataSize)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)type), (void *)dataRef, dataSize, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets optional Command List Debug Layer settings.</p>
        /// </summary>
        /// <param name = "type"><dd>  <p>Specifies a <strong><see cref = "SharpDX.Direct3D12.DebugCommandListParameterType"/></strong> value that determines which debug parameter data to copy to the memory pointed to by <em>pData</em>.</p> </dd></param>
        /// <param name = "dataRef"><dd>  <p>Points to the memory that will be filled with a copy of the debug parameter data. The interpretation of this data depends on the <strong><see cref = "SharpDX.Direct3D12.DebugCommandListParameterType"/></strong> given in the <em>Type</em> parameter.</p> </dd></param>
        /// <param name = "dataSize"><dd>  <p>Size in bytes of the memory buffer pointed to by <em>pData</em>.</p> </dd></param>
        /// <returns><p> Returns <see cref = "SharpDX.Result.Ok"/> if successful, otherwise E_INVALIDARG.  </p></returns>
        /// <doc-id>mt762988</doc-id>
        /// <unmanaged>HRESULT ID3D12DebugCommandList1::GetDebugParameter([In] D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE Type,[Out, Buffer] void* pData,[In] unsigned int DataSize)</unmanaged>
        /// <unmanaged-short>ID3D12DebugCommandList1::GetDebugParameter</unmanaged-short>
        public unsafe void GetDebugParameter(SharpDX.Direct3D12.DebugCommandListParameterType type, System.IntPtr dataRef, System.Int32 dataSize)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)type), (void *)dataRef, dataSize, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("aeb575cf-4e06-48be-ba3b-c450fc96652e")]
    public partial class DebugCommandList2 : SharpDX.Direct3D12.DebugCommandList
    {
        public DebugCommandList2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DebugCommandList2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DebugCommandList2(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "type">No documentation.</param>
        /// <param name = "dataRef">No documentation.</param>
        /// <param name = "dataSize">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D12DebugCommandList2::SetDebugParameter([In] D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE Type,[In, Buffer] const void* pData,[In] unsigned int DataSize)</unmanaged>
        /// <unmanaged-short>ID3D12DebugCommandList2::SetDebugParameter</unmanaged-short>
        public unsafe void SetDebugParameter(SharpDX.Direct3D12.DebugCommandListParameterType type, System.IntPtr dataRef, System.Int32 dataSize)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)type), (void *)dataRef, dataSize, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "type">No documentation.</param>
        /// <param name = "dataRef">No documentation.</param>
        /// <param name = "dataSize">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D12DebugCommandList2::GetDebugParameter([In] D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE Type,[Out, Buffer] void* pData,[In] unsigned int DataSize)</unmanaged>
        /// <unmanaged-short>ID3D12DebugCommandList2::GetDebugParameter</unmanaged-short>
        public unsafe void GetDebugParameter(SharpDX.Direct3D12.DebugCommandListParameterType type, System.IntPtr dataRef, System.Int32 dataSize)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)type), (void *)dataRef, dataSize, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("09e0bf36-54ac-484f-8847-4baeeab6053a")]
    public partial class DebugCommandQueue : SharpDX.ComObject
    {
        public DebugCommandQueue(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DebugCommandQueue(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DebugCommandQueue(nativePtr);
        /// <summary>
        /// <p> Checks whether a resource, or subresource, is in a specified state, or not.</p>
        /// </summary>
        /// <param name = "resourceRef"><dd>  <p> Specifies the  <strong><see cref = "SharpDX.Direct3D12.Resource"/></strong> to check.</p> </dd></param>
        /// <param name = "subresource"><dd>  <p> The index of the subresource to check. This can be set to an index, or D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES.</p> </dd></param>
        /// <param name = "state"><dd>  <p> Specifies the state to check for. This can be one or more <see cref = "SharpDX.Direct3D12.ResourceStates"/> flags Or'ed together.</p> </dd></param>
        /// <returns><p> This method returns true if the resource or subresource is in the specified state, false otherwise. </p></returns>
        /// <remarks>
        /// <p>This method is very similar to <strong>ID3D12DebugCommandList::AssertResourceState</strong>, however there are methods on the command queue that work directly with resources that might need to be monitored (for example <strong>ID3D13CommandQueue::CopyTileMappings</strong>).</p>
        /// </remarks>
        /// <doc-id>dn950159</doc-id>
        /// <unmanaged>BOOL ID3D12DebugCommandQueue::AssertResourceState([In] ID3D12Resource* pResource,[In] unsigned int Subresource,[In] unsigned int State)</unmanaged>
        /// <unmanaged-short>ID3D12DebugCommandQueue::AssertResourceState</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool AssertResourceState(SharpDX.Direct3D12.Resource resourceRef, System.Int32 subresource, System.Int32 state)
        {
            System.IntPtr resourceRef_ = System.IntPtr.Zero;
            SharpDX.Mathematics.Interop.RawBool __result__;
            resourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(resourceRef);
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, (void *)resourceRef_, subresource, state, (*(void ***)this._nativePointer)[3]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("3febd6dd-4973-4787-8194-e45f9e28923e")]
    public partial class DebugDevice : SharpDX.ComObject
    {
        public DebugDevice(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DebugDevice(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DebugDevice(nativePtr);
        /// <summary>
        /// <p>Gets or sets a bit field of flags that indicates which debug features are on or off. </p>
        /// </summary>
        /// <doc-id>dn986874</doc-id>
        /// <unmanaged>GetFeatureMask / SetFeatureMask</unmanaged>
        /// <unmanaged-short>GetFeatureMask</unmanaged-short>
        public SharpDX.Direct3D12.DebugFeature FeatureMask
        {
            get => GetFeatureMask();
            set => SetFeatureMask(value);
        }

        /// <summary>
        /// <p> Set a bit field of flags that will turn debug features on and off. </p>
        /// </summary>
        /// <param name = "mask"><dd>  <p> Feature-mask flags, as a bitwise-OR'd combination of <strong><see cref = "SharpDX.Direct3D12.DebugFeature"/></strong> enumeration constants. If a flag is present, that feature will be set to on; otherwise, the feature will be set to off. </p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. <strong><see cref = "SharpDX.Result"/></strong> </p></returns>
        /// <doc-id>dn986876</doc-id>
        /// <unmanaged>HRESULT ID3D12DebugDevice::SetFeatureMask([In] D3D12_DEBUG_FEATURE Mask)</unmanaged>
        /// <unmanaged-short>ID3D12DebugDevice::SetFeatureMask</unmanaged-short>
        internal unsafe void SetFeatureMask(SharpDX.Direct3D12.DebugFeature mask)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)mask), (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Gets a bit field of flags that indicates which debug features are on or off. </p>
        /// </summary>
        /// <returns><p> Mask of feature-mask flags, as a bitwise OR'ed combination of <strong><see cref = "SharpDX.Direct3D12.DebugFeature"/></strong> enumeration constants. If a flag is present, then that feature will be set to on, otherwise the feature will be set to off.  </p></returns>
        /// <doc-id>dn986874</doc-id>
        /// <unmanaged>D3D12_DEBUG_FEATURE ID3D12DebugDevice::GetFeatureMask()</unmanaged>
        /// <unmanaged-short>ID3D12DebugDevice::GetFeatureMask</unmanaged-short>
        internal unsafe SharpDX.Direct3D12.DebugFeature GetFeatureMask()
        {
            SharpDX.Direct3D12.DebugFeature __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallSharpDXDirect3D12DebugFeature(this._nativePointer, (*(void ***)this._nativePointer)[4]);
            return __result__;
        }

        /// <summary>
        /// <p> Reports information about a device object's lifetime. </p>
        /// </summary>
        /// <param name = "flags"><dd>  <p> A value from the <strong><see cref = "SharpDX.Direct3D12.ReportingLevel"/></strong> enumeration. This method uses the value in <em>Flags</em> to determine the amount of information to report about a device object's lifetime. </p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. <strong><see cref = "SharpDX.Result"/></strong> </p></returns>
        /// <doc-id>dn986875</doc-id>
        /// <unmanaged>HRESULT ID3D12DebugDevice::ReportLiveDeviceObjects([In] D3D12_RLDO_FLAGS Flags)</unmanaged>
        /// <unmanaged-short>ID3D12DebugDevice::ReportLiveDeviceObjects</unmanaged-short>
        public unsafe void ReportLiveDeviceObjects(SharpDX.Direct3D12.ReportingLevel flags)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)flags), (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("a9b71770-d099-4a65-a698-3dee10020f88")]
    public partial class DebugDevice1 : SharpDX.ComObject
    {
        public DebugDevice1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DebugDevice1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DebugDevice1(nativePtr);
        /// <summary>
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Modifies the D3D12 optional device-wide Debug Layer settings.</p>
        /// </summary>
        /// <param name = "type"><dd>  <p>Specifies a <strong><see cref = "SharpDX.Direct3D12.DebugDeviceParameterType"/></strong> value that indicates which debug parameter data to get.</p> </dd></param>
        /// <param name = "dataRef"><dd>  <p>Debug parameter data to set.</p> </dd></param>
        /// <param name = "dataSize"><dd>  <p>Size in bytes of the data pointed to by <em>pData</em>.</p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.  </p></returns>
        /// <doc-id>mt762994</doc-id>
        /// <unmanaged>HRESULT ID3D12DebugDevice1::SetDebugParameter([In] D3D12_DEBUG_DEVICE_PARAMETER_TYPE Type,[In, Buffer] const void* pData,[In] unsigned int DataSize)</unmanaged>
        /// <unmanaged-short>ID3D12DebugDevice1::SetDebugParameter</unmanaged-short>
        public unsafe void SetDebugParameter(SharpDX.Direct3D12.DebugDeviceParameterType type, System.IntPtr dataRef, System.Int32 dataSize)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)type), (void *)dataRef, dataSize, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets optional device-wide Debug Layer settings.</p>
        /// </summary>
        /// <param name = "type"><dd>  <p>Specifies a <strong><see cref = "SharpDX.Direct3D12.DebugDeviceParameterType"/></strong> value that indicates which debug parameter data to set.</p> </dd></param>
        /// <param name = "dataRef"><dd>  <p>Points to the memory that will be filled with a copy of the debug parameter data. The interpretation of this data depends on the <strong><see cref = "SharpDX.Direct3D12.DebugDeviceParameterType"/></strong> given in the <em>Type</em> parameter.</p> </dd></param>
        /// <param name = "dataSize"><dd>  <p>Size in bytes of the memory buffer pointed to by <em>pData</em>.</p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.  </p></returns>
        /// <doc-id>mt762992</doc-id>
        /// <unmanaged>HRESULT ID3D12DebugDevice1::GetDebugParameter([In] D3D12_DEBUG_DEVICE_PARAMETER_TYPE Type,[Out, Buffer] void* pData,[In] unsigned int DataSize)</unmanaged>
        /// <unmanaged-short>ID3D12DebugDevice1::GetDebugParameter</unmanaged-short>
        public unsafe void GetDebugParameter(SharpDX.Direct3D12.DebugDeviceParameterType type, System.IntPtr dataRef, System.Int32 dataSize)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)type), (void *)dataRef, dataSize, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Specifies the amount of information to report  on a device object's lifetime.</p>
        /// </summary>
        /// <param name = "flags"><dd>  <p>A value from the <strong><see cref = "SharpDX.Direct3D12.ReportingLevel"/></strong> enumeration. This method uses the value in <em>Flags</em> to determine the amount of information to report about a device object's lifetime.</p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.  </p></returns>
        /// <doc-id>mt762993</doc-id>
        /// <unmanaged>HRESULT ID3D12DebugDevice1::ReportLiveDeviceObjects([In] D3D12_RLDO_FLAGS Flags)</unmanaged>
        /// <unmanaged-short>ID3D12DebugDevice1::ReportLiveDeviceObjects</unmanaged-short>
        public unsafe void ReportLiveDeviceObjects(SharpDX.Direct3D12.ReportingLevel flags)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)flags), (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("60eccbc1-378d-4df1-894c-f8ac5ce4d7dd")]
    public partial class DebugDevice2 : SharpDX.Direct3D12.DebugDevice
    {
        public DebugDevice2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DebugDevice2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DebugDevice2(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "type">No documentation.</param>
        /// <param name = "dataRef">No documentation.</param>
        /// <param name = "dataSize">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D12DebugDevice2::SetDebugParameter([In] D3D12_DEBUG_DEVICE_PARAMETER_TYPE Type,[In, Buffer] const void* pData,[In] unsigned int DataSize)</unmanaged>
        /// <unmanaged-short>ID3D12DebugDevice2::SetDebugParameter</unmanaged-short>
        public unsafe void SetDebugParameter(SharpDX.Direct3D12.DebugDeviceParameterType type, System.IntPtr dataRef, System.Int32 dataSize)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)type), (void *)dataRef, dataSize, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "type">No documentation.</param>
        /// <param name = "dataRef">No documentation.</param>
        /// <param name = "dataSize">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D12DebugDevice2::GetDebugParameter([In] D3D12_DEBUG_DEVICE_PARAMETER_TYPE Type,[Out, Buffer] void* pData,[In] unsigned int DataSize)</unmanaged>
        /// <unmanaged-short>ID3D12DebugDevice2::GetDebugParameter</unmanaged-short>
        public unsafe void GetDebugParameter(SharpDX.Direct3D12.DebugDeviceParameterType type, System.IntPtr dataRef, System.Int32 dataSize)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)type), (void *)dataRef, dataSize, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("344488b7-6846-474b-b989-f027448245e0")]
    public partial class DebugInterface : SharpDX.ComObject
    {
        public DebugInterface(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DebugInterface(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DebugInterface(nativePtr);
        /// <summary>
        /// <p> Enables the debug layer. </p>
        /// </summary>
        /// <remarks>
        /// <p>To enable the debug layers using this API, it must be called before the D3D12 device is created. Calling this API after creating the D3D12 device will cause the D3D12 runtime to remove the device.</p>
        /// </remarks>
        /// <doc-id>dn986877</doc-id>
        /// <unmanaged>void ID3D12Debug::EnableDebugLayer()</unmanaged>
        /// <unmanaged-short>ID3D12Debug::EnableDebugLayer</unmanaged-short>
        public unsafe void EnableDebugLayer()
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (*(void ***)this._nativePointer)[3]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("8efb471d-616c-4f49-90f7-127bb763fa51")]
    public partial class DescriptorHeap : SharpDX.Direct3D12.Pageable
    {
        public DescriptorHeap(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DescriptorHeap(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DescriptorHeap(nativePtr);
        /// <summary>
        /// <p> Gets the descriptor heap description. </p>
        /// </summary>
        /// <doc-id>dn788649</doc-id>
        /// <unmanaged>GetDesc</unmanaged>
        /// <unmanaged-short>GetDesc</unmanaged-short>
        public SharpDX.Direct3D12.DescriptorHeapDescription Description
        {
            get => GetDescription();
        }

        /// <summary>
        /// <p>Gets the CPU descriptor handle that represents the start of the heap.</p>
        /// </summary>
        /// <doc-id>dn899174</doc-id>
        /// <unmanaged>GetCPUDescriptorHandleForHeapStart</unmanaged>
        /// <unmanaged-short>GetCPUDescriptorHandleForHeapStart</unmanaged-short>
        public SharpDX.Direct3D12.CpuDescriptorHandle CPUDescriptorHandleForHeapStart
        {
            get => GetCPUDescriptorHandleForHeapStart();
        }

        /// <summary>
        /// <p>Gets the GPU descriptor handle that represents the start of the heap.</p>
        /// </summary>
        /// <doc-id>dn899175</doc-id>
        /// <unmanaged>GetGPUDescriptorHandleForHeapStart</unmanaged>
        /// <unmanaged-short>GetGPUDescriptorHandleForHeapStart</unmanaged-short>
        public SharpDX.Direct3D12.GpuDescriptorHandle GPUDescriptorHandleForHeapStart
        {
            get => GetGPUDescriptorHandleForHeapStart();
        }

        /// <summary>
        /// <p> Gets the descriptor heap description. </p>
        /// </summary>
        /// <returns><p> The description of the descriptor heap, as a <strong><see cref = "SharpDX.Direct3D12.DescriptorHeapDescription"/></strong> structure. </p></returns>
        /// <doc-id>dn788649</doc-id>
        /// <unmanaged>D3D12_DESCRIPTOR_HEAP_DESC ID3D12DescriptorHeap::GetDesc()</unmanaged>
        /// <unmanaged-short>ID3D12DescriptorHeap::GetDesc</unmanaged-short>
        internal unsafe SharpDX.Direct3D12.DescriptorHeapDescription GetDescription()
        {
            SharpDX.Direct3D12.DescriptorHeapDescription __result__;
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoidPtr(this._nativePointer, &__result__, (*(void ***)this._nativePointer)[8]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets the CPU descriptor handle that represents the start of the heap.</p>
        /// </summary>
        /// <returns><p>Returns the CPU descriptor handle that represents the start of the heap.</p></returns>
        /// <doc-id>dn899174</doc-id>
        /// <unmanaged>D3D12_CPU_DESCRIPTOR_HANDLE ID3D12DescriptorHeap::GetCPUDescriptorHandleForHeapStart()</unmanaged>
        /// <unmanaged-short>ID3D12DescriptorHeap::GetCPUDescriptorHandleForHeapStart</unmanaged-short>
        internal unsafe SharpDX.Direct3D12.CpuDescriptorHandle GetCPUDescriptorHandleForHeapStart()
        {
            SharpDX.Direct3D12.CpuDescriptorHandle __result__;
            SharpDX.Direct3D12.CpuDescriptorHandle.__Native __result__native = default (SharpDX.Direct3D12.CpuDescriptorHandle.__Native);
            __result__ = default (SharpDX.Direct3D12.CpuDescriptorHandle);
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoidPtr(this._nativePointer, &__result__native, (*(void ***)this._nativePointer)[9]);
            __result__.__MarshalFrom(ref __result__native);
            return __result__;
        }

        /// <summary>
        /// <p>Gets the GPU descriptor handle that represents the start of the heap.</p>
        /// </summary>
        /// <returns><p>Returns the GPU descriptor handle that represents the start of the heap.</p></returns>
        /// <doc-id>dn899175</doc-id>
        /// <unmanaged>D3D12_GPU_DESCRIPTOR_HANDLE ID3D12DescriptorHeap::GetGPUDescriptorHandleForHeapStart()</unmanaged>
        /// <unmanaged-short>ID3D12DescriptorHeap::GetGPUDescriptorHandleForHeapStart</unmanaged-short>
        internal unsafe SharpDX.Direct3D12.GpuDescriptorHandle GetGPUDescriptorHandleForHeapStart()
        {
            SharpDX.Direct3D12.GpuDescriptorHandle __result__;
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoidPtr(this._nativePointer, &__result__, (*(void ***)this._nativePointer)[10]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("189819f1-1db6-4b57-be54-1821339b85f7")]
    public partial class Device : SharpDX.Direct3D12.Object
    {
        public Device(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Device(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Device(nativePtr);
        /// <summary>
        /// <p> Reports the number of physical adapters (nodes) that are associated with this device. </p>
        /// </summary>
        /// <doc-id>dn914412</doc-id>
        /// <unmanaged>GetNodeCount</unmanaged>
        /// <unmanaged-short>GetNodeCount</unmanaged-short>
        public System.Int32 NodeCount
        {
            get => GetNodeCount();
        }

        /// <summary>
        /// <p>Gets the reason that the device was removed.</p>
        /// </summary>
        /// <doc-id>dn899187</doc-id>
        /// <unmanaged>GetDeviceRemovedReason</unmanaged>
        /// <unmanaged-short>GetDeviceRemovedReason</unmanaged-short>
        public SharpDX.Result DeviceRemovedReason
        {
            get => GetDeviceRemovedReason();
        }

        /// <summary>
        /// <p>A development-time aid for certain types of profiling and experimental prototyping.</p>
        /// </summary>
        /// <remarks>
        /// <p>This method is only useful during the development of applications. It enables developers to profile GPU usage of multiple algorithms without experiencing artifacts from dynamic frequency scaling.</p><p>Do not call this method in normal execution for a shipped application. This method only works while the machine is in developer mode. If developer mode is not enabled, then device removal will occur. Instead, call this method in response to an off-by-default, developer-facing switch. Calling it in response to command line parameters, config files, registry keys, and developer console commands are reasonable usage scenarios. </p><p>A stable power state typically fixes GPU clock rates at a slower setting that is significantly lower than that experienced by users under normal application load. This reduction in clock rate affects the entire system. Slow clock rates are required to ensure processors don?t exhaust power, current, and thermal limits. Normal usage scenarios commonly leverage a processors ability to dynamically over-clock. Any conclusions made by comparing two designs under a stable power state should be double-checked with supporting results from real usage scenarios.</p>
        /// </remarks>
        /// <doc-id>dn903835</doc-id>
        /// <unmanaged>SetStablePowerState</unmanaged>
        /// <unmanaged-short>SetStablePowerState</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool StablePowerState
        {
            set => SetStablePowerState(value);
        }

        /// <summary>
        /// <p> Gets a locally unique identifier for the current device (adapter). </p>
        /// </summary>
        /// <remarks>
        /// <p> This method returns a unique identifier for the adapter that is specific to the adapter hardware. Applications can use this identifier to define robust mappings across various APIs (Direct3D 12, DXGI). </p><p> A locally unique identifier (<see cref = "System.Int64"/>) is a 64-bit value that is guaranteed to be unique only on the system on which it was generated. The uniqueness of a locally unique identifier (<see cref = "System.Int64"/>) is guaranteed only until the system is restarted. </p>
        /// </remarks>
        /// <doc-id>dn914411</doc-id>
        /// <unmanaged>GetAdapterLuid</unmanaged>
        /// <unmanaged-short>GetAdapterLuid</unmanaged-short>
        public System.Int64 AdapterLuid
        {
            get => GetAdapterLuid();
        }

        /// <summary>
        /// <p> Reports the number of physical adapters (nodes) that are associated with this device. </p>
        /// </summary>
        /// <returns><p> The number of physical adapters (nodes) that this device has. </p></returns>
        /// <doc-id>dn914412</doc-id>
        /// <unmanaged>unsigned int ID3D12Device::GetNodeCount()</unmanaged>
        /// <unmanaged-short>ID3D12Device::GetNodeCount</unmanaged-short>
        internal unsafe System.Int32 GetNodeCount()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[7]);
            return __result__;
        }

        /// <summary>
        /// <p>Creates a command queue.</p>
        /// </summary>
        /// <param name = "descRef"><dd>  <p> Specifies a <see cref = "SharpDX.Direct3D12.CommandQueueDescription"/> that describes the command queue. </p> </dd></param>
        /// <param name = "riid"><dd>  <p> The globally unique identifier (<see cref = "System.Guid"/>) for the command queue interface. See remarks.  An input parameter. </p> </dd></param>
        /// <returns><dd>  <p> A reference to a memory block that receives a reference to the <strong><see cref = "SharpDX.Direct3D12.CommandQueue"/></strong> interface for the command queue. </p> </dd></returns>
        /// <remarks>
        /// <p> The <strong>REFIID</strong>, or <strong><see cref = "System.Guid"/></strong>, of the interface to the command queue can be obtained by using the __uuidof() macro. For example, __uuidof(<see cref = "SharpDX.Direct3D12.CommandQueue"/>) will get the <strong><see cref = "System.Guid"/></strong> of the interface to a command queue. </p>
        /// </remarks>
        /// <doc-id>dn788657</doc-id>
        /// <unmanaged>HRESULT ID3D12Device::CreateCommandQueue([In] const D3D12_COMMAND_QUEUE_DESC* pDesc,[In] const GUID&amp; riid,[Out] void** ppCommandQueue)</unmanaged>
        /// <unmanaged-short>ID3D12Device::CreateCommandQueue</unmanaged-short>
        private unsafe SharpDX.Direct3D12.CommandQueue CreateCommandQueue(SharpDX.Direct3D12.CommandQueueDescription descRef, System.Guid riid)
        {
            SharpDX.Direct3D12.CommandQueue commandQueueOut;
            System.IntPtr commandQueueOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, &descRef, &riid, &commandQueueOut_, (*(void ***)this._nativePointer)[8]);
            if (commandQueueOut_ != System.IntPtr.Zero)
                commandQueueOut = new SharpDX.Direct3D12.CommandQueue(commandQueueOut_);
            else
                commandQueueOut = null;
            __result__.CheckError();
            return commandQueueOut;
        }

        /// <summary>
        /// <p>Creates a command allocator object.</p>
        /// </summary>
        /// <param name = "type"><dd>  <p> A <strong><see cref = "SharpDX.Direct3D12.CommandListType"/></strong>-typed value that specifies the type of command allocator to create. The type of command allocator can be the type that records either direct command lists or bundles. </p> </dd></param>
        /// <param name = "riid"><dd>  <p> The globally unique identifier (<strong><see cref = "System.Guid"/></strong>) for the command allocator interface (<strong><see cref = "SharpDX.Direct3D12.CommandAllocator"/></strong>). The <strong>REFIID</strong>, or <strong><see cref = "System.Guid"/></strong>, of the interface to the command allocator can be obtained by using the __uuidof() macro. For example, __uuidof(<see cref = "SharpDX.Direct3D12.CommandAllocator"/>) will get the <strong><see cref = "System.Guid"/></strong> of the interface to a command allocator. </p> </dd></param>
        /// <returns><dd>  <p> A reference to a memory block that receives a reference to the <strong><see cref = "SharpDX.Direct3D12.CommandAllocator"/></strong> interface for the command allocator. </p> </dd></returns>
        /// <remarks>
        /// <p> The device creates command lists from the command allocator. </p>
        /// </remarks>
        /// <doc-id>dn788655</doc-id>
        /// <unmanaged>HRESULT ID3D12Device::CreateCommandAllocator([In] D3D12_COMMAND_LIST_TYPE type,[In] const GUID&amp; riid,[Out] void** ppCommandAllocator)</unmanaged>
        /// <unmanaged-short>ID3D12Device::CreateCommandAllocator</unmanaged-short>
        private unsafe SharpDX.Direct3D12.CommandAllocator CreateCommandAllocator(SharpDX.Direct3D12.CommandListType type, System.Guid riid)
        {
            SharpDX.Direct3D12.CommandAllocator commandAllocatorOut;
            System.IntPtr commandAllocatorOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)type), &riid, &commandAllocatorOut_, (*(void ***)this._nativePointer)[9]);
            if (commandAllocatorOut_ != System.IntPtr.Zero)
                commandAllocatorOut = new SharpDX.Direct3D12.CommandAllocator(commandAllocatorOut_);
            else
                commandAllocatorOut = null;
            __result__.CheckError();
            return commandAllocatorOut;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "descRef">No documentation.</param>
        /// <param name = "riid">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D12Device::CreateGraphicsPipelineState([In] const D3D12_GRAPHICS_PIPELINE_STATE_DESC* pDesc,[In] const GUID&amp; riid,[Out] void** ppPipelineState)</unmanaged>
        /// <unmanaged-short>ID3D12Device::CreateGraphicsPipelineState</unmanaged-short>
        private unsafe SharpDX.Direct3D12.PipelineState CreateGraphicsPipelineState(System.IntPtr descRef, System.Guid riid)
        {
            SharpDX.Direct3D12.PipelineState pipelineStateOut;
            System.IntPtr pipelineStateOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, (void *)descRef, &riid, &pipelineStateOut_, (*(void ***)this._nativePointer)[10]);
            if (pipelineStateOut_ != System.IntPtr.Zero)
                pipelineStateOut = new SharpDX.Direct3D12.PipelineState(pipelineStateOut_);
            else
                pipelineStateOut = null;
            __result__.CheckError();
            return pipelineStateOut;
        }

        /// <summary>
        /// <p>Creates a compute pipeline state object.</p>
        /// </summary>
        /// <param name = "descRef"><dd>  <p> A reference to a <strong><see cref = "SharpDX.Direct3D12.ComputePipelineStateDescription"/></strong> structure that describes compute pipeline state. </p> </dd></param>
        /// <param name = "riid"><dd>  <p> The globally unique identifier (<strong><see cref = "System.Guid"/></strong>) for the pipeline state interface (<strong><see cref = "SharpDX.Direct3D12.PipelineState"/></strong>). The <strong>REFIID</strong>, or <strong><see cref = "System.Guid"/></strong>, of the interface to the pipeline state can be obtained by using the __uuidof() macro. For example, __uuidof(<see cref = "SharpDX.Direct3D12.PipelineState"/>) will get the <strong><see cref = "System.Guid"/></strong> of the interface to a pipeline state. </p> </dd></param>
        /// <returns><dd>  <p> A reference to a memory block that receives a reference to the <strong><see cref = "SharpDX.Direct3D12.PipelineState"/></strong> interface for the pipeline state object. The pipeline state object is an immutable state object.  It contains no methods. </p> </dd></returns>
        /// <doc-id>dn788658</doc-id>
        /// <unmanaged>HRESULT ID3D12Device::CreateComputePipelineState([In] const D3D12_COMPUTE_PIPELINE_STATE_DESC* pDesc,[In] const GUID&amp; riid,[Out] void** ppPipelineState)</unmanaged>
        /// <unmanaged-short>ID3D12Device::CreateComputePipelineState</unmanaged-short>
        private unsafe SharpDX.Direct3D12.PipelineState CreateComputePipelineState(System.IntPtr descRef, System.Guid riid)
        {
            SharpDX.Direct3D12.PipelineState pipelineStateOut;
            System.IntPtr pipelineStateOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, (void *)descRef, &riid, &pipelineStateOut_, (*(void ***)this._nativePointer)[11]);
            if (pipelineStateOut_ != System.IntPtr.Zero)
                pipelineStateOut = new SharpDX.Direct3D12.PipelineState(pipelineStateOut_);
            else
                pipelineStateOut = null;
            __result__.CheckError();
            return pipelineStateOut;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "nodeMask">No documentation.</param>
        /// <param name = "type">No documentation.</param>
        /// <param name = "commandAllocatorRef">No documentation.</param>
        /// <param name = "initialStateRef">No documentation.</param>
        /// <param name = "riid">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D12Device::CreateCommandList([In] unsigned int nodeMask,[In] D3D12_COMMAND_LIST_TYPE type,[In] ID3D12CommandAllocator* pCommandAllocator,[In, Optional] ID3D12PipelineState* pInitialState,[In] const GUID&amp; riid,[Out] void** ppCommandList)</unmanaged>
        /// <unmanaged-short>ID3D12Device::CreateCommandList</unmanaged-short>
        private unsafe System.IntPtr CreateCommandList(System.Int32 nodeMask, SharpDX.Direct3D12.CommandListType type, SharpDX.Direct3D12.CommandAllocator commandAllocatorRef, SharpDX.Direct3D12.PipelineState initialStateRef, System.Guid riid)
        {
            System.IntPtr commandAllocatorRef_ = System.IntPtr.Zero;
            System.IntPtr initialStateRef_ = System.IntPtr.Zero;
            System.IntPtr commandListOut;
            SharpDX.Result __result__;
            commandAllocatorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.CommandAllocator>(commandAllocatorRef);
            initialStateRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.PipelineState>(initialStateRef);
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, nodeMask, unchecked ((System.Int32)type), (void *)commandAllocatorRef_, (void *)initialStateRef_, &riid, &commandListOut, (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
            return commandListOut;
        }

        /// <summary>
        /// <p> Gets information about the features that are supported by the current graphics driver.</p>
        /// </summary>
        /// <param name = "feature"><dd>  <p> A <strong><see cref = "SharpDX.Direct3D12.Feature"/></strong>-typed value that describes the feature to query for support. </p> </dd></param>
        /// <param name = "featureSupportDataRef"><dd>  <p> The passed structure is filled with data that describes the feature support. To see the structure types, see the Remarks section in <strong><see cref = "SharpDX.Direct3D12.Feature"/> enumeration</strong>. </p> </dd></param>
        /// <param name = "featureSupportDataSize"><dd>  <p> The size of the structure passed to the <em>pFeatureSupportData</em> parameter. </p> </dd></param>
        /// <returns><p> Returns <strong><see cref = "SharpDX.Result.Ok"/></strong> if successful; otherwise, returns <strong>E_INVALIDARG</strong> if an unsupported data type is passed to the <em>pFeatureSupportData</em> parameter or a size mismatch is detected for the <em>FeatureSupportDataSize</em> parameter. </p></returns>
        /// <remarks>
        /// <p>Refer to Capability Querying.</p>
        /// </remarks>
        /// <doc-id>dn788653</doc-id>
        /// <unmanaged>HRESULT ID3D12Device::CheckFeatureSupport([In] D3D12_FEATURE Feature,[Out, Buffer] void* pFeatureSupportData,[In] unsigned int FeatureSupportDataSize)</unmanaged>
        /// <unmanaged-short>ID3D12Device::CheckFeatureSupport</unmanaged-short>
        private unsafe SharpDX.Result CheckFeatureSupport(SharpDX.Direct3D12.Feature feature, System.IntPtr featureSupportDataRef, System.Int32 featureSupportDataSize)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)feature), (void *)featureSupportDataRef, featureSupportDataSize, (*(void ***)this._nativePointer)[13]);
            return __result__;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "descriptorHeapDescRef">No documentation.</param>
        /// <param name = "riid">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D12Device::CreateDescriptorHeap([In] const D3D12_DESCRIPTOR_HEAP_DESC* pDescriptorHeapDesc,[In] const GUID&amp; riid,[Out] void** ppvHeap)</unmanaged>
        /// <unmanaged-short>ID3D12Device::CreateDescriptorHeap</unmanaged-short>
        private unsafe SharpDX.Direct3D12.DescriptorHeap CreateDescriptorHeap(SharpDX.Direct3D12.DescriptorHeapDescription descriptorHeapDescRef, System.Guid riid)
        {
            SharpDX.Direct3D12.DescriptorHeap vHeapOut;
            System.IntPtr vHeapOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, &descriptorHeapDescRef, &riid, &vHeapOut_, (*(void ***)this._nativePointer)[14]);
            if (vHeapOut_ != System.IntPtr.Zero)
                vHeapOut = new SharpDX.Direct3D12.DescriptorHeap(vHeapOut_);
            else
                vHeapOut = null;
            __result__.CheckError();
            return vHeapOut;
        }

        /// <summary>
        /// <p> Gets the size of the handle increment for the given type of descriptor heap. This value is typically used to increment a handle into a descriptor array by the correct amount.</p>
        /// </summary>
        /// <param name = "descriptorHeapType"><dd> <p> The <strong><see cref = "SharpDX.Direct3D12.DescriptorHeapType"/></strong>-typed value that specifies the type of descriptor heap to get the size of the handle increment for. </p> </dd></param>
        /// <returns><p> Returns the size of the handle increment for the given type of descriptor heap, including any necessary padding.</p></returns>
        /// <remarks>
        /// <p>The descriptor size returned by this method is used as one input to the helper structures <strong>CD3DX12_CPU_DESCRIPTOR_HANDLE</strong> and <strong>CD3DX12_GPU_DESCRIPTOR_HANDLE</strong>.</p>
        /// </remarks>
        /// <doc-id>dn899186</doc-id>
        /// <unmanaged>unsigned int ID3D12Device::GetDescriptorHandleIncrementSize([In] D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapType)</unmanaged>
        /// <unmanaged-short>ID3D12Device::GetDescriptorHandleIncrementSize</unmanaged-short>
        public unsafe System.Int32 GetDescriptorHandleIncrementSize(SharpDX.Direct3D12.DescriptorHeapType descriptorHeapType)
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)descriptorHeapType), (*(void ***)this._nativePointer)[15]);
            return __result__;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "nodeMask">No documentation.</param>
        /// <param name = "blobWithRootSignatureRef">No documentation.</param>
        /// <param name = "blobLengthInBytes">No documentation.</param>
        /// <param name = "riid">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D12Device::CreateRootSignature([In] unsigned int nodeMask,[In, Buffer] const void* pBlobWithRootSignature,[In] SIZE_T blobLengthInBytes,[In] const GUID&amp; riid,[Out] void** ppvRootSignature)</unmanaged>
        /// <unmanaged-short>ID3D12Device::CreateRootSignature</unmanaged-short>
        private unsafe SharpDX.Direct3D12.RootSignature CreateRootSignature(System.Int32 nodeMask, System.IntPtr blobWithRootSignatureRef, SharpDX.PointerSize blobLengthInBytes, System.Guid riid)
        {
            SharpDX.Direct3D12.RootSignature vRootSignatureOut;
            System.IntPtr vRootSignatureOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, nodeMask, (void *)blobWithRootSignatureRef, (void *)blobLengthInBytes, &riid, &vRootSignatureOut_, (*(void ***)this._nativePointer)[16]);
            if (vRootSignatureOut_ != System.IntPtr.Zero)
                vRootSignatureOut = new SharpDX.Direct3D12.RootSignature(vRootSignatureOut_);
            else
                vRootSignatureOut = null;
            __result__.CheckError();
            return vRootSignatureOut;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "descRef">No documentation.</param>
        /// <param name = "destDescriptor">No documentation.</param>
        /// <unmanaged>void ID3D12Device::CreateConstantBufferView([In, Optional] const D3D12_CONSTANT_BUFFER_VIEW_DESC* pDesc,[In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor)</unmanaged>
        /// <unmanaged-short>ID3D12Device::CreateConstantBufferView</unmanaged-short>
        public unsafe void CreateConstantBufferView(SharpDX.Direct3D12.ConstantBufferViewDescription? descRef, SharpDX.Direct3D12.CpuDescriptorHandle destDescriptor)
        {
            SharpDX.Direct3D12.ConstantBufferViewDescription descRef_;
            SharpDX.Direct3D12.CpuDescriptorHandle.__Native destDescriptor_ = default (SharpDX.Direct3D12.CpuDescriptorHandle.__Native);
            if (descRef != null)
                descRef_ = descRef.Value;
            destDescriptor.__MarshalTo(ref destDescriptor_);
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid0(this._nativePointer, descRef == null ? (void *)0 : &descRef_, destDescriptor_, (*(void ***)this._nativePointer)[17]);
            destDescriptor.__MarshalFree(ref destDescriptor_);
        }

        /// <summary>
        /// <p>Creates a shader-resource view for accessing data in a resource.</p>
        /// </summary>
        /// <param name = "resourceRef"><dd>  <p>A reference to the <strong><see cref = "SharpDX.Direct3D12.Resource"/></strong> object that represents the shader resource.</p> <p>At least one of <em>pResource</em> or <em>pDesc</em> must be provided.A null <em>pResource</em> is used to initialize a null descriptor, which guarantees D3D11-like null binding behavior (reading 0s, writes are discarded), but must have a valid <em>pDesc</em> in order to determine the descriptor type.</p> </dd></param>
        /// <param name = "descRef"><dd>  <p>A reference to a <strong><see cref = "SharpDX.Direct3D12.ShaderResourceViewDescription"/></strong> structure that describes the shader-resource view. </p> <p>A null <em>pDesc</em> is used to initialize a default descriptor, if possible. This behavior is identical to the D3D11 null descriptor behavior, where defaults are filled in. This behavior inherits the resource format and dimension (if not typeless) and for buffers SRVs target a full buffer and are typed (not raw or structured), and for textures SRVs target a full texture, all mips and all array slices. Not all resources support null descriptor initialization.</p> </dd></param>
        /// <param name = "destDescriptor"><dd>  <p>Describes the CPU descriptor handle that represents the shader-resource view. This handle can be created in a shader-visible or non-shader-visible descriptor heap.</p> </dd></param>
        /// <doc-id>dn788672</doc-id>
        /// <unmanaged>void ID3D12Device::CreateShaderResourceView([In, Optional] ID3D12Resource* pResource,[In, Optional] const D3D12_SHADER_RESOURCE_VIEW_DESC* pDesc,[In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor)</unmanaged>
        /// <unmanaged-short>ID3D12Device::CreateShaderResourceView</unmanaged-short>
        public unsafe void CreateShaderResourceView(SharpDX.Direct3D12.Resource resourceRef, SharpDX.Direct3D12.ShaderResourceViewDescription? descRef, SharpDX.Direct3D12.CpuDescriptorHandle destDescriptor)
        {
            System.IntPtr resourceRef_ = System.IntPtr.Zero;
            SharpDX.Direct3D12.ShaderResourceViewDescription descRef_;
            SharpDX.Direct3D12.CpuDescriptorHandle.__Native destDescriptor_ = default (SharpDX.Direct3D12.CpuDescriptorHandle.__Native);
            resourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(resourceRef);
            if (descRef != null)
                descRef_ = descRef.Value;
            destDescriptor.__MarshalTo(ref destDescriptor_);
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid0(this._nativePointer, (void *)resourceRef_, descRef == null ? (void *)0 : &descRef_, destDescriptor_, (*(void ***)this._nativePointer)[18]);
            destDescriptor.__MarshalFree(ref destDescriptor_);
        }

        /// <summary>
        /// <p> Creates a view for unordered accessing. </p>
        /// </summary>
        /// <param name = "resourceRef"><dd>  <p>A reference to the <strong><see cref = "SharpDX.Direct3D12.Resource"/></strong> object that represents the unordered access. </p> <p>At least one of <em>pResource</em> or <em>pDesc</em> must be provided.A null <em>pResource</em> is used to initialize a null descriptor, which guarantees D3D11-like null binding behavior (reading 0s, writes are discarded), but must have a valid <em>pDesc</em> in order to determine the descriptor type.</p> </dd></param>
        /// <param name = "counterResourceRef"><dd>  <p> The <strong><see cref = "SharpDX.Direct3D12.Resource"/></strong> for the counter (if any) associated with the UAV. </p> <p> If <em>pCounterResource</em> is not specified, the <strong>CounterOffsetInBytes</strong> member of the <strong><see cref = "SharpDX.Direct3D12.BufferResource"/></strong> structure must be 0. </p> <p> If <em>pCounterResource</em> is specified, then there is a counter associated with the UAV, and the runtime performs validation of the following requirements: </p> <ul> <li> The <strong>StructureByteStride</strong> member of the <strong><see cref = "SharpDX.Direct3D12.BufferResource"/></strong> structure must be greater than 0. </li> <li> The format must be DXGI_FORMAT_UNKNOWN. </li> <li> The D3D12_BUFFER_UAV_FLAG_RAW flag (a <strong><see cref = "SharpDX.Direct3D12.BufferUnorderedAccessViewFlags"/></strong> enumeration constant) must not be set. </li> <li> Both of the resources (<em>pResource</em> and <em>pCounterResource</em>) must be buffers. </li> <li> The <strong>CounterOffsetInBytes</strong> member of the <strong><see cref = "SharpDX.Direct3D12.BufferResource"/></strong> structure must be a multiple of 4 bytes, and must be within the range of the counter resource. </li> <li><em>pResource</em> cannot be <c>null</c> </li> <li><em>pDesc</em> cannot be <c>null</c>. </li> </ul> </dd></param>
        /// <param name = "descRef"><dd>  <p>A reference to a <strong><see cref = "SharpDX.Direct3D12.UnorderedAccessViewDescription"/></strong> structure that describes the unordered-access view. </p> <p>A null <em>pDesc</em> is used to initialize a default descriptor, if possible. This behavior is identical to the D3D11 null descriptor behavior, where defaults are filled in. This behavior inherits the resource format and dimension (if not typeless) and for buffers UAVs target a full buffer and are typed, and for textures UAVs target the first mip and all array slices. Not all resources support null descriptor initialization.</p> </dd></param>
        /// <param name = "destDescriptor"><dd>  <p>Describes the CPU descriptor handle that represents the start of the heap that holds the unordered-access view. </p> </dd></param>
        /// <doc-id>dn788674</doc-id>
        /// <unmanaged>void ID3D12Device::CreateUnorderedAccessView([In, Optional] ID3D12Resource* pResource,[In, Optional] ID3D12Resource* pCounterResource,[In, Optional] const D3D12_UNORDERED_ACCESS_VIEW_DESC* pDesc,[In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor)</unmanaged>
        /// <unmanaged-short>ID3D12Device::CreateUnorderedAccessView</unmanaged-short>
        public unsafe void CreateUnorderedAccessView(SharpDX.Direct3D12.Resource resourceRef, SharpDX.Direct3D12.Resource counterResourceRef, SharpDX.Direct3D12.UnorderedAccessViewDescription? descRef, SharpDX.Direct3D12.CpuDescriptorHandle destDescriptor)
        {
            System.IntPtr resourceRef_ = System.IntPtr.Zero;
            System.IntPtr counterResourceRef_ = System.IntPtr.Zero;
            SharpDX.Direct3D12.UnorderedAccessViewDescription descRef_;
            SharpDX.Direct3D12.CpuDescriptorHandle.__Native destDescriptor_ = default (SharpDX.Direct3D12.CpuDescriptorHandle.__Native);
            resourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(resourceRef);
            counterResourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(counterResourceRef);
            if (descRef != null)
                descRef_ = descRef.Value;
            destDescriptor.__MarshalTo(ref destDescriptor_);
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid0(this._nativePointer, (void *)resourceRef_, (void *)counterResourceRef_, descRef == null ? (void *)0 : &descRef_, destDescriptor_, (*(void ***)this._nativePointer)[19]);
            destDescriptor.__MarshalFree(ref destDescriptor_);
        }

        /// <summary>
        /// <p>Creates a render-target view for accessing resource data.</p>
        /// </summary>
        /// <param name = "resourceRef"><dd>  <p>A reference to the <strong><see cref = "SharpDX.Direct3D12.Resource"/></strong> object that represents the render target. </p> <p>At least one of <em>pResource</em> or <em>pDesc</em> must be provided.A null <em>pResource</em> is used to initialize a null descriptor, which guarantees D3D11-like null binding behavior (reading 0s, writes are discarded), but must have a valid <em>pDesc</em> in order to determine the descriptor type.</p> </dd></param>
        /// <param name = "descRef"><dd>  <p>A reference to a <strong><see cref = "SharpDX.Direct3D12.RenderTargetViewDescription"/></strong> structure that describes the render-target view.</p> <p>A null <em>pDesc</em> is used to initialize a default descriptor, if possible. This behavior is identical to the D3D11 null descriptor behavior, where defaults are filled in. This behavior inherits the resource format and dimension (if not typeless) and RTVs target the first mip and all array slices. Not all resources support null descriptor initialization.</p> </dd></param>
        /// <param name = "destDescriptor"><dd>  <p> Describes the CPU descriptor handle that represents the start of the heap that holds the render-target view. </p> </dd></param>
        /// <doc-id>dn788668</doc-id>
        /// <unmanaged>void ID3D12Device::CreateRenderTargetView([In, Optional] ID3D12Resource* pResource,[In, Optional] const D3D12_RENDER_TARGET_VIEW_DESC* pDesc,[In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor)</unmanaged>
        /// <unmanaged-short>ID3D12Device::CreateRenderTargetView</unmanaged-short>
        public unsafe void CreateRenderTargetView(SharpDX.Direct3D12.Resource resourceRef, SharpDX.Direct3D12.RenderTargetViewDescription? descRef, SharpDX.Direct3D12.CpuDescriptorHandle destDescriptor)
        {
            System.IntPtr resourceRef_ = System.IntPtr.Zero;
            SharpDX.Direct3D12.RenderTargetViewDescription descRef_;
            SharpDX.Direct3D12.CpuDescriptorHandle.__Native destDescriptor_ = default (SharpDX.Direct3D12.CpuDescriptorHandle.__Native);
            resourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(resourceRef);
            if (descRef != null)
                descRef_ = descRef.Value;
            destDescriptor.__MarshalTo(ref destDescriptor_);
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid0(this._nativePointer, (void *)resourceRef_, descRef == null ? (void *)0 : &descRef_, destDescriptor_, (*(void ***)this._nativePointer)[20]);
            destDescriptor.__MarshalFree(ref destDescriptor_);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "resourceRef">No documentation.</param>
        /// <param name = "descRef">No documentation.</param>
        /// <param name = "destDescriptor">No documentation.</param>
        /// <unmanaged>void ID3D12Device::CreateDepthStencilView([In, Optional] ID3D12Resource* pResource,[In, Optional] const D3D12_DEPTH_STENCIL_VIEW_DESC* pDesc,[In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor)</unmanaged>
        /// <unmanaged-short>ID3D12Device::CreateDepthStencilView</unmanaged-short>
        public unsafe void CreateDepthStencilView(SharpDX.Direct3D12.Resource resourceRef, SharpDX.Direct3D12.DepthStencilViewDescription? descRef, SharpDX.Direct3D12.CpuDescriptorHandle destDescriptor)
        {
            System.IntPtr resourceRef_ = System.IntPtr.Zero;
            SharpDX.Direct3D12.DepthStencilViewDescription descRef_;
            SharpDX.Direct3D12.CpuDescriptorHandle.__Native destDescriptor_ = default (SharpDX.Direct3D12.CpuDescriptorHandle.__Native);
            resourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(resourceRef);
            if (descRef != null)
                descRef_ = descRef.Value;
            destDescriptor.__MarshalTo(ref destDescriptor_);
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid0(this._nativePointer, (void *)resourceRef_, descRef == null ? (void *)0 : &descRef_, destDescriptor_, (*(void ***)this._nativePointer)[21]);
            destDescriptor.__MarshalFree(ref destDescriptor_);
        }

        /// <summary>
        /// <p>Create a sampler object that encapsulates sampling information for a texture.</p>
        /// </summary>
        /// <param name = "descRef"><dd>  <p>A reference to a <strong><see cref = "SharpDX.Direct3D12.SamplerStateDescription"/></strong> structure that describes the sampler. </p> </dd></param>
        /// <param name = "destDescriptor"><dd>  <p>Describes the CPU descriptor handle that represents the start of the heap that holds the sampler.</p> </dd></param>
        /// <doc-id>dn788671</doc-id>
        /// <unmanaged>void ID3D12Device::CreateSampler([In, Value] const D3D12_SAMPLER_DESC* pDesc,[In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor)</unmanaged>
        /// <unmanaged-short>ID3D12Device::CreateSampler</unmanaged-short>
        public unsafe void CreateSampler(SharpDX.Direct3D12.SamplerStateDescription descRef, SharpDX.Direct3D12.CpuDescriptorHandle destDescriptor)
        {
            SharpDX.Direct3D12.CpuDescriptorHandle.__Native destDescriptor_ = default (SharpDX.Direct3D12.CpuDescriptorHandle.__Native);
            destDescriptor.__MarshalTo(ref destDescriptor_);
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid0(this._nativePointer, &descRef, destDescriptor_, (*(void ***)this._nativePointer)[22]);
            destDescriptor.__MarshalFree(ref destDescriptor_);
        }

        /// <summary>
        /// <p> Copies descriptors from a source to a destination. </p>
        /// </summary>
        /// <param name = "numDestDescriptorRanges"><dd>  <p> The number of destination descriptor ranges to copy to. </p> </dd></param>
        /// <param name = "destDescriptorRangeStartsRef"><dd>  <p> An array of CPU_descriptor_handle objects to copy to. </p> </dd></param>
        /// <param name = "destDescriptorRangeSizesRef"><dd>  <p> An array of destination descriptor range sizes to copy to. </p> </dd></param>
        /// <param name = "numSrcDescriptorRanges"><dd>  <p> The number of source descriptor ranges to copy from. </p> </dd></param>
        /// <param name = "srcDescriptorRangeStartsRef"><dd>  <p> An array of CPU_descriptor_handle objects to copy from. </p> </dd></param>
        /// <param name = "srcDescriptorRangeSizesRef"><dd>  <p> An array of source descriptor range sizes to copy from. </p> </dd></param>
        /// <param name = "descriptorHeapsType"><dd>  <p> The <strong><see cref = "SharpDX.Direct3D12.DescriptorHeapType"/></strong>-typed value that specifies the type of descriptor heap to copy with. </p> </dd></param>
        /// <doc-id>dn899176</doc-id>
        /// <unmanaged>void ID3D12Device::CopyDescriptors([In] unsigned int NumDestDescriptorRanges,[In, Buffer] const D3D12_CPU_DESCRIPTOR_HANDLE* pDestDescriptorRangeStarts,[In, Buffer, Optional] const unsigned int* pDestDescriptorRangeSizes,[In] unsigned int NumSrcDescriptorRanges,[In, Buffer] const D3D12_CPU_DESCRIPTOR_HANDLE* pSrcDescriptorRangeStarts,[In, Buffer, Optional] const unsigned int* pSrcDescriptorRangeSizes,[In] D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapsType)</unmanaged>
        /// <unmanaged-short>ID3D12Device::CopyDescriptors</unmanaged-short>
        public unsafe void CopyDescriptors(System.Int32 numDestDescriptorRanges, SharpDX.Direct3D12.CpuDescriptorHandle[] destDescriptorRangeStartsRef, System.Int32[] destDescriptorRangeSizesRef, System.Int32 numSrcDescriptorRanges, SharpDX.Direct3D12.CpuDescriptorHandle[] srcDescriptorRangeStartsRef, System.Int32[] srcDescriptorRangeSizesRef, SharpDX.Direct3D12.DescriptorHeapType descriptorHeapsType)
        {
            SharpDX.Direct3D12.CpuDescriptorHandle.__Native[] destDescriptorRangeStartsRef_ = new SharpDX.Direct3D12.CpuDescriptorHandle.__Native[destDescriptorRangeStartsRef.Length];
            SharpDX.Direct3D12.CpuDescriptorHandle.__Native[] srcDescriptorRangeStartsRef_ = new SharpDX.Direct3D12.CpuDescriptorHandle.__Native[srcDescriptorRangeStartsRef.Length];
            for (int i = 0; i < destDescriptorRangeStartsRef.Length; ++i)
                destDescriptorRangeStartsRef[i].__MarshalTo(ref (destDescriptorRangeStartsRef_)[i]);
            for (int i = 0; i < srcDescriptorRangeStartsRef.Length; ++i)
                srcDescriptorRangeStartsRef[i].__MarshalTo(ref (srcDescriptorRangeStartsRef_)[i]);
            fixed (void *srcDescriptorRangeSizesRef_ = srcDescriptorRangeSizesRef)
                fixed (void *_srcDescriptorRangeStartsRef = srcDescriptorRangeStartsRef_)
                    fixed (void *destDescriptorRangeSizesRef_ = destDescriptorRangeSizesRef)
                        fixed (void *_destDescriptorRangeStartsRef = destDescriptorRangeStartsRef_)
                            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, numDestDescriptorRanges, _destDescriptorRangeStartsRef, destDescriptorRangeSizesRef_, numSrcDescriptorRanges, _srcDescriptorRangeStartsRef, srcDescriptorRangeSizesRef_, unchecked ((System.Int32)descriptorHeapsType), (*(void ***)this._nativePointer)[23]);
            for (int i = 0; i < destDescriptorRangeStartsRef.Length; ++i)
                destDescriptorRangeStartsRef[i].__MarshalFree(ref (destDescriptorRangeStartsRef_)[i]);
            for (int i = 0; i < srcDescriptorRangeStartsRef.Length; ++i)
                srcDescriptorRangeStartsRef[i].__MarshalFree(ref (srcDescriptorRangeStartsRef_)[i]);
        }

        /// <summary>
        /// <p> Copies descriptors from a source to a destination. </p>
        /// </summary>
        /// <param name = "numDescriptors"><dd>  <p> The number of descriptors to copy. </p> </dd></param>
        /// <param name = "destDescriptorRangeStart"><dd>  <p> A CPU_descriptor_handle that describes the destination descriptors to start to copy to. </p> </dd></param>
        /// <param name = "srcDescriptorRangeStart"><dd>  <p> A CPU_descriptor_handle that describes the source descriptors to start to copy from. </p> </dd></param>
        /// <param name = "descriptorHeapsType"><dd>  <p> The <strong><see cref = "SharpDX.Direct3D12.DescriptorHeapType"/></strong>-typed value that specifies the type of descriptor heap to copy with. </p> </dd></param>
        /// <doc-id>dn899177</doc-id>
        /// <unmanaged>void ID3D12Device::CopyDescriptorsSimple([In] unsigned int NumDescriptors,[In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptorRangeStart,[In] D3D12_CPU_DESCRIPTOR_HANDLE SrcDescriptorRangeStart,[In] D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapsType)</unmanaged>
        /// <unmanaged-short>ID3D12Device::CopyDescriptorsSimple</unmanaged-short>
        public unsafe void CopyDescriptorsSimple(System.Int32 numDescriptors, SharpDX.Direct3D12.CpuDescriptorHandle destDescriptorRangeStart, SharpDX.Direct3D12.CpuDescriptorHandle srcDescriptorRangeStart, SharpDX.Direct3D12.DescriptorHeapType descriptorHeapsType)
        {
            SharpDX.Direct3D12.CpuDescriptorHandle.__Native destDescriptorRangeStart_ = default (SharpDX.Direct3D12.CpuDescriptorHandle.__Native);
            SharpDX.Direct3D12.CpuDescriptorHandle.__Native srcDescriptorRangeStart_ = default (SharpDX.Direct3D12.CpuDescriptorHandle.__Native);
            destDescriptorRangeStart.__MarshalTo(ref destDescriptorRangeStart_);
            srcDescriptorRangeStart.__MarshalTo(ref srcDescriptorRangeStart_);
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid0(this._nativePointer, numDescriptors, destDescriptorRangeStart_, srcDescriptorRangeStart_, unchecked ((System.Int32)descriptorHeapsType), (*(void ***)this._nativePointer)[24]);
            destDescriptorRangeStart.__MarshalFree(ref destDescriptorRangeStart_);
            srcDescriptorRangeStart.__MarshalFree(ref srcDescriptorRangeStart_);
        }

        /// <summary>
        /// <p> Gets the size and alignment of memory required for a collection of resources on this adapter. </p>
        /// </summary>
        /// <param name = "visibleMask"><dd>  <p> For single GPU operation, set this to zero.  If there are multiple GPU nodes, set bits to identify the nodes (the  device's physical adapters). Each bit in the mask corresponds to a single node. Refer to Multi-Adapter.</p> </dd></param>
        /// <param name = "numResourceDescs"><dd>  <p> The number of resource descriptors in the <em>pResourceDescs</em> array. </p> </dd></param>
        /// <param name = "resourceDescsRef"><dd>  <p> An array of <strong><see cref = "SharpDX.Direct3D12.ResourceDescription"/></strong> structures that described the resources to get info about. </p> </dd></param>
        /// <returns><p> Returns a <strong><see cref = "SharpDX.Direct3D12.ResourceAllocationInformation"/></strong> structure that provides info about video memory allocated for the specified array of resources. </p></returns>
        /// <remarks>
        /// <p> When using <strong>CreatePlacedResource</strong>, the application must use this method to understand the size and alignment characteristics of texture resources.  The results of this method vary depending on the particular adapter, and must be treated as unique to this adapter and driver version. </p><p> Applications cannot use the output of <strong>GetResourceAllocationInfo</strong> to understand packed mip properties of textures. To understand packed mip properties of textures, applications must use <strong>GetResourceTiling</strong>.  Texture resource sizes significantly differ from the information returned by <strong>GetResourceTiling</strong>, because some adapter architectures allocate extra memory for textures to reduce the effective bandwidth during common rendering scenarios.  This even includes textures that have constraints on their texture layouts or have standardized texture layouts.  That extra memory cannot be sparsely mapped or remapped by an application using <strong>CreateReservedResource</strong> and  <strong>UpdateTileMappings</strong>, so it isn't reported in <strong>GetResourceTiling</strong>. </p><p> Applications can forgo using <strong>GetResourceAllocationInfo</strong> for buffer resources (<strong><see cref = "SharpDX.Direct3D12.ResourceDimension"/></strong>_BUFFER).  Buffers have the same size on all adapters, which is merely the smallest multiple of 64KB which is greater or equal to <strong><see cref = "SharpDX.Direct3D12.ResourceDescription"/></strong>::<strong>Width</strong>. </p><p> When multiple resource descriptions are passed in, the C++ algorithm for calculating a structure size and alignment are used.  For example, a three-element array with two tiny 64KB-aligned resources and a tiny 4MB-aligned resource reports differing sizes based on the order of the array.  If the 4MB aligned resource is in the middle, the resulting <strong>Size</strong> is 12MB.  Otherwise, the resulting <strong>Size</strong> is 8MB.  The <strong>Alignment</strong> returned would always be 4MB, as it is the superset of all alignments in the resource array. </p>
        /// </remarks>
        /// <doc-id>dn788680</doc-id>
        /// <unmanaged>D3D12_RESOURCE_ALLOCATION_INFO ID3D12Device::GetResourceAllocationInfo([In] unsigned int visibleMask,[In] unsigned int numResourceDescs,[In, Buffer] const D3D12_RESOURCE_DESC* pResourceDescs)</unmanaged>
        /// <unmanaged-short>ID3D12Device::GetResourceAllocationInfo</unmanaged-short>
        public unsafe SharpDX.Direct3D12.ResourceAllocationInformation GetResourceAllocationInfo(System.Int32 visibleMask, System.Int32 numResourceDescs, SharpDX.Direct3D12.ResourceDescription[] resourceDescsRef)
        {
            SharpDX.Direct3D12.ResourceAllocationInformation __result__;
            fixed (void *resourceDescsRef_ = resourceDescsRef)
                SharpDX.Direct3D12.LocalInterop.CalliStdCallvoidPtr(this._nativePointer, &__result__, visibleMask, numResourceDescs, resourceDescsRef_, (*(void ***)this._nativePointer)[25]);
            return __result__;
        }

        /// <summary>
        /// <p> Divulges the equivalent custom heap properties that are used for non-custom heap types, based on the adapter's architectural properties. </p>
        /// </summary>
        /// <param name = "nodeMask"><dd>  <p> For single-GPU operation, set this to zero.  If there are multiple GPU nodes, set a bit to identify the node (the  device's physical adapter). Each bit in the mask corresponds to a single node. Only 1 bit must be set. See Multi-Adapter. </p> </dd></param>
        /// <param name = "heapType"><dd>  <p> A <strong><see cref = "SharpDX.Direct3D12.HeapType"/></strong>-typed value that specifies the heap to get properties for. D3D12_HEAP_TYPE_CUSTOM is not supported as a parameter value. </p> </dd></param>
        /// <returns><p> Returns a <strong><see cref = "SharpDX.Direct3D12.HeapProperties"/></strong> structure that provides properties for the specified heap. The <strong>Type</strong> member of the returned <see cref = "SharpDX.Direct3D12.HeapProperties"/> is always D3D12_HEAP_TYPE_CUSTOM. </p><p> When <strong><see cref = "SharpDX.Direct3D12.FeatureDataArchitecture"/></strong>::UMA is <see cref = "SharpDX.Result.False"/>, the returned <see cref = "SharpDX.Direct3D12.HeapProperties"/> members convert as follows: </p><table> <tr><th>Heap Type</th><th>How the returned <see cref = "SharpDX.Direct3D12.HeapProperties"/> members convert</th></tr> <tr><td>D3D12_HEAP_TYPE_UPLOAD</td><td><strong>CPUPageProperty</strong> = WRITE_COMBINE, <strong>MemoryPoolPreference</strong> = L0.</td></tr> <tr><td>D3D12_HEAP_TYPE_DEFAULT</td><td><strong>CPUPageProperty</strong> = NOT_AVAILABLE, <strong>MemoryPoolPreference</strong> = L1.</td></tr> <tr><td>D3D12_HEAP_TYPE_READBACK</td><td><strong>CPUPageProperty</strong> = WRITE_BACK, <strong>MemoryPoolPreference</strong> = L0.</td></tr> </table><p>?</p><p> When D3D12_FEATURE_DATA_ARCHITECTURE::UMA is TRUE and D3D12_FEATURE_DATA_ARCHITECTURE::CacheCoherentUMA is <see cref = "SharpDX.Result.False"/>, the returned <see cref = "SharpDX.Direct3D12.HeapProperties"/> members convert as follows: </p><table> <tr><th>Heap Type</th><th>How the returned <see cref = "SharpDX.Direct3D12.HeapProperties"/> members convert</th></tr> <tr><td>D3D12_HEAP_TYPE_UPLOAD</td><td><strong>CPUPageProperty</strong> = WRITE_COMBINE, <strong>MemoryPoolPreference</strong> = L0.</td></tr> <tr><td>D3D12_HEAP_TYPE_DEFAULT</td><td><strong>CPUPageProperty</strong> = NOT_AVAILABLE, <strong>MemoryPoolPreference</strong> = L0.</td></tr> <tr><td>D3D12_HEAP_TYPE_READBACK</td><td><strong>CPUPageProperty</strong> = WRITE_BACK, <strong>MemoryPoolPreference</strong> = L0.</td></tr> </table><p>?</p><p> When D3D12_FEATURE_DATA_ARCHITECTURE::UMA is TRUE and D3D12_FEATURE_DATA_ARCHITECTURE::CacheCoherentUMA is TRUE, the returned <see cref = "SharpDX.Direct3D12.HeapProperties"/> members convert as follows: </p><table> <tr><th>Heap Type</th><th>How the returned <see cref = "SharpDX.Direct3D12.HeapProperties"/> members convert</th></tr> <tr><td>D3D12_HEAP_TYPE_UPLOAD</td><td><strong>CPUPageProperty</strong> = WRITE_BACK, <strong>MemoryPoolPreference</strong> = L0.</td></tr> <tr><td>D3D12_HEAP_TYPE_DEFAULT</td><td><strong>CPUPageProperty</strong> = NOT_AVAILABLE, <strong>MemoryPoolPreference</strong> = L0.</td></tr> <tr><td>D3D12_HEAP_TYPE_READBACK</td><td><strong>CPUPageProperty</strong> = WRITE_BACK, <strong>MemoryPoolPreference</strong> = L0.</td></tr> </table><p>?</p></returns>
        /// <doc-id>dn788678</doc-id>
        /// <unmanaged>D3D12_HEAP_PROPERTIES ID3D12Device::GetCustomHeapProperties([In] unsigned int nodeMask,[In] D3D12_HEAP_TYPE heapType)</unmanaged>
        /// <unmanaged-short>ID3D12Device::GetCustomHeapProperties</unmanaged-short>
        public unsafe SharpDX.Direct3D12.HeapProperties GetCustomHeapProperties(System.Int32 nodeMask, SharpDX.Direct3D12.HeapType heapType)
        {
            SharpDX.Direct3D12.HeapProperties __result__;
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoidPtr(this._nativePointer, &__result__, nodeMask, unchecked ((System.Int32)heapType), (*(void ***)this._nativePointer)[26]);
            return __result__;
        }

        /// <summary>
        /// <p> Creates both a resource and an implicit heap, such that the heap is big enough to contain the entire resource and the resource is mapped to the heap. </p>
        /// </summary>
        /// <param name = "heapPropertiesRef"><dd>  <p> A reference to a <strong><see cref = "SharpDX.Direct3D12.HeapProperties"/></strong> structure that provides properties for the resource's heap. </p> </dd></param>
        /// <param name = "heapFlags"><dd>  <p> Heap options, as a bitwise-OR'd combination of <strong><see cref = "SharpDX.Direct3D12.HeapFlags"/></strong> enumeration constants. </p> </dd></param>
        /// <param name = "descRef"><dd>  <p> A reference to a <strong><see cref = "SharpDX.Direct3D12.ResourceDescription"/></strong> structure that describes the resource. </p> </dd></param>
        /// <param name = "initialResourceState"><dd>  <p> The initial state of the resource, as a bitwise-OR'd combination of <strong><see cref = "SharpDX.Direct3D12.ResourceStates"/></strong> enumeration constants. </p> <p> When a resource is created together with a <strong><see cref = "SharpDX.Direct3D12.HeapType"/></strong>_UPLOAD heap, <em>InitialResourceState</em> must be <strong>D3D12_RESOURCE_STATE</strong>_GENERIC_READ. When a resource is created together with a D3D12_HEAP_TYPE_READBACK heap, <em>InitialResourceState</em> must be D3D12_RESOURCE_STATE_COPY_DEST. </p> </dd></param>
        /// <param name = "optimizedClearValueRef"><dd>  <p> Specifies a <strong><see cref = "SharpDX.Direct3D12.ClearValue"/></strong> that describes the default value for a clear color. </p> <p><em>pOptimizedClearValue</em> specifies a value for which clear operations are most optimal. When the created resource is a texture with either the <strong>D3D12_RESOURCE_FLAG</strong>_ALLOW_RENDER_TARGET or D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL flags, applications should choose the value that the clear operation will most commonly be called with. Clear operations can be called with other values, but those operations will not be as efficient as when the value matches the one passed into resource creation. <em>pOptimizedClearValue</em> must be <c>null</c> when used with <strong><see cref = "SharpDX.Direct3D12.ResourceDimension"/></strong>_BUFFER. </p> </dd></param>
        /// <param name = "riidResource"><dd>  <p> The globally unique identifier (<strong><see cref = "System.Guid"/></strong>) for the resource interface. This is an input parameter. The <strong>REFIID</strong>, or <strong><see cref = "System.Guid"/></strong>, of the interface to the resource can be obtained by using the __uuidof() macro. For example, __uuidof(<strong><see cref = "SharpDX.Direct3D12.Resource"/></strong>) will get the <strong><see cref = "System.Guid"/></strong> of the interface to a resource. </p> <p> While riidResource is, most commonly, the <see cref = "System.Guid"/> for <strong><see cref = "SharpDX.Direct3D12.Resource"/></strong>, it may be any <see cref = "System.Guid"/> for any interface. If the resource object doesn't support the interface for this <see cref = "System.Guid"/>, creation will fail with E_NOINTERFACE. </p> </dd></param>
        /// <returns><dd>  <p> A reference to memory that receives the requested interface reference to the created resource object. <em>ppvResource</em> can be <c>null</c>, to enable capability testing. When <em>ppvResource</em> is <c>null</c>, no object will be created and S_FALSE will be returned when <em>pResourceDesc</em> is valid. </p> </dd></returns>
        /// <remarks>
        /// <p> This method creates both a resource and a heap, such that the heap is big enough to contain the entire resource and the resource is mapped to the heap. The created heap is known as an implicit heap, because the heap object cannot be obtained by the application. The application must ensure the GPU will no longer read or write to this resource before releasing the final reference on the resource. </p><p> The implicit heap is made resident for GPU access before the method returns to the application. See Residency. </p><p> The resource GPU VA mapping cannot be changed. See <strong>ID3D12CommandQueue::UpdateTileMappings</strong> and Volume Tiled Resources. </p><p> This method may be called by multiple threads concurrently. </p>
        /// </remarks>
        /// <doc-id>dn899178</doc-id>
        /// <unmanaged>HRESULT ID3D12Device::CreateCommittedResource([In] const D3D12_HEAP_PROPERTIES* pHeapProperties,[In] D3D12_HEAP_FLAGS HeapFlags,[In] const D3D12_RESOURCE_DESC* pDesc,[In] D3D12_RESOURCE_STATES InitialResourceState,[In, Optional] const D3D12_CLEAR_VALUE* pOptimizedClearValue,[In] const GUID&amp; riidResource,[Out] void** ppvResource)</unmanaged>
        /// <unmanaged-short>ID3D12Device::CreateCommittedResource</unmanaged-short>
        private unsafe SharpDX.Direct3D12.Resource CreateCommittedResource(ref SharpDX.Direct3D12.HeapProperties heapPropertiesRef, SharpDX.Direct3D12.HeapFlags heapFlags, ref SharpDX.Direct3D12.ResourceDescription descRef, SharpDX.Direct3D12.ResourceStates initialResourceState, SharpDX.Direct3D12.ClearValue? optimizedClearValueRef, System.Guid riidResource)
        {
            SharpDX.Direct3D12.ClearValue optimizedClearValueRef_;
            SharpDX.Direct3D12.Resource vResourceOut;
            System.IntPtr vResourceOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            if (optimizedClearValueRef != null)
                optimizedClearValueRef_ = optimizedClearValueRef.Value;
            fixed (void *descRef_ = &descRef)
                fixed (void *heapPropertiesRef_ = &heapPropertiesRef)
                    __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, heapPropertiesRef_, unchecked ((System.Int32)heapFlags), descRef_, unchecked ((System.Int32)initialResourceState), optimizedClearValueRef == null ? (void *)0 : &optimizedClearValueRef_, &riidResource, &vResourceOut_, (*(void ***)this._nativePointer)[27]);
            if (vResourceOut_ != System.IntPtr.Zero)
                vResourceOut = new SharpDX.Direct3D12.Resource(vResourceOut_);
            else
                vResourceOut = null;
            __result__.CheckError();
            return vResourceOut;
        }

        /// <summary>
        /// <p> Creates a heap that can be used with placed resources and reserved resources. </p>
        /// </summary>
        /// <param name = "descRef"><dd>  <p> A reference to a <strong><see cref = "SharpDX.Direct3D12.HeapDescription"/></strong> structure that describes the heap. </p> </dd></param>
        /// <param name = "riid"><dd>  <p> The globally unique identifier (<strong><see cref = "System.Guid"/></strong>) for the heap interface. This is an input parameter. The <strong>REFIID</strong>, or <strong><see cref = "System.Guid"/></strong>, of the interface to the heap can be obtained by using the __uuidof() macro. For example, __uuidof(<strong><see cref = "SharpDX.Direct3D12.Heap"/></strong>) will get the <strong><see cref = "System.Guid"/></strong> of the interface to a heap. <em>riid</em> is, most commonly, the <see cref = "System.Guid"/> for <strong><see cref = "SharpDX.Direct3D12.Heap"/></strong>, but it may be any <see cref = "System.Guid"/> for any interface. If the resource object does not support the interface for the specified <see cref = "System.Guid"/>, creation will fail with E_NOINTERFACE. </p> </dd></param>
        /// <returns><dd>  <p> A reference to a memory block that receives a reference to the heap. <em>ppvHeap</em> can be <c>null</c>, to enable capability testing. When <em>ppvHeap</em> is <c>null</c>, no object will be created and S_FALSE will be returned when <em>pDesc</em> is valid. </p> </dd></returns>
        /// <remarks>
        /// <p><strong>CreateHeap</strong> creates a heap that can be used with placed resources and reserved resources. Before releasing the final reference on the heap, the application must ensure that the GPU will no longer read or write to this heap. Placed resource objects will hold a reference on the heap they are created on, but reserved resources will not hold a reference for each mapping made to a heap. </p>
        /// </remarks>
        /// <doc-id>dn788664</doc-id>
        /// <unmanaged>HRESULT ID3D12Device::CreateHeap([In] const D3D12_HEAP_DESC* pDesc,[In] const GUID&amp; riid,[Out] void** ppvHeap)</unmanaged>
        /// <unmanaged-short>ID3D12Device::CreateHeap</unmanaged-short>
        private unsafe SharpDX.Direct3D12.Heap CreateHeap(ref SharpDX.Direct3D12.HeapDescription descRef, System.Guid riid)
        {
            SharpDX.Direct3D12.Heap vHeapOut;
            System.IntPtr vHeapOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *descRef_ = &descRef)
                __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, descRef_, &riid, &vHeapOut_, (*(void ***)this._nativePointer)[28]);
            if (vHeapOut_ != System.IntPtr.Zero)
                vHeapOut = new SharpDX.Direct3D12.Heap(vHeapOut_);
            else
                vHeapOut = null;
            __result__.CheckError();
            return vHeapOut;
        }

        /// <summary>
        /// <p> Creates a resource that is placed in a specific heap. Placed resources are the lightest weight resource objects available, and are the fastest to create and destroy. </p>
        /// </summary>
        /// <param name = "heapRef"><dd>  <p> A reference to the <strong><see cref = "SharpDX.Direct3D12.Heap"/></strong> interface that represents the heap in which the resource is placed. </p> </dd></param>
        /// <param name = "heapOffset"><dd>  <p> The offset, in bytes, to the resource. The <em>HeapOffset</em> must be a multiple of the resource's alignment, and <em>HeapOffset</em> plus the resource size must be smaller than or equal to the heap size. <strong>GetResourceAllocationInfo</strong> must be used to understand the sizes of texture resources. </p> </dd></param>
        /// <param name = "descRef"><dd>  <p> A reference to a <strong><see cref = "SharpDX.Direct3D12.ResourceDescription"/></strong> structure that describes the resource. </p> </dd></param>
        /// <param name = "initialState"><dd>  <p> The initial state of the resource, as a bitwise-OR'd combination of <strong><see cref = "SharpDX.Direct3D12.ResourceStates"/></strong> enumeration constants. </p> <p> When a resource is created together with a D3D12_HEAP_TYPE_UPLOAD heap, <em>InitialState</em> must be D3D12_RESOURCE_STATE_GENERIC_READ. When a resource is created together with a D3D12_HEAP_TYPE_READBACK heap, <em>InitialState</em> must be D3D12_RESOURCE_STATE_COPY_DEST. </p> </dd></param>
        /// <param name = "optimizedClearValueRef"><dd>  <p> Specifies a <strong><see cref = "SharpDX.Direct3D12.ClearValue"/></strong> that describes the default value for a clear color. </p> <p><em>pOptimizedClearValue</em> specifies a value for which clear operations are most optimal. When the created resource is a texture with either the D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET or D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL flags, applications should choose the value that the clear operation will most commonly be called with. Clear operations can be called with other values, but those operations will not be as efficient as when the value matches the one passed into resource creation. <em>pOptimizedClearValue</em> must be <c>null</c> when used with D3D12_RESOURCE_DIMENSION_BUFFER. </p> </dd></param>
        /// <param name = "riid"><dd>  <p> The globally unique identifier (<strong><see cref = "System.Guid"/></strong>) for the resource interface. This is an input parameter. </p> <p> The <strong>REFIID</strong>, or <strong><see cref = "System.Guid"/></strong>, of the interface to the resource can be obtained by using the __uuidof() macro. For example, __uuidof(<strong><see cref = "SharpDX.Direct3D12.Resource"/></strong>) will get the <strong><see cref = "System.Guid"/></strong> of the interface to a resource. Although <strong>riid</strong> is, most commonly, the <see cref = "System.Guid"/> for <strong><see cref = "SharpDX.Direct3D12.Resource"/></strong>, it may be any <see cref = "System.Guid"/> for any interface.  If the resource object doesn't support the interface for this <see cref = "System.Guid"/>, creation will fail with E_NOINTERFACE. </p> </dd></param>
        /// <returns><dd>  <p> A reference to a memory block that receives a reference to the resource. <em>ppvResource</em> can be <c>null</c>, to enable capability testing.  When <em>ppvResource</em> is <c>null</c>, no object will be created and S_FALSE will be returned when <em>pResourceDesc</em> and other parameters are valid. </p> </dd></returns>
        /// <remarks>
        /// <p><strong>CreatePlacedResource</strong> is similar to fully mapping a reserved resource to an offset within a heap; but the virtual address space associated with a heap may be reused as well. </p><p> Placed resources are lighter weight than committed resources to create and destroy, because no heap is created or destroyed during this operation.  However, placed resources enable an even lighter weight technique to reuse memory than resource creation and destruction: reuse through aliasing and aliasing barriers. Multiple placed resources may simultaneously overlap each other on the same heap, but only a single overlapping resource can be used at a time. </p><p> There are two placed resource usage semantics, a simple model and an advanced model. The simple model is recommended, and is the most likely model for tool support, until the advanced model is proven to be required by the app. </p>
        /// </remarks>
        /// <doc-id>dn899180</doc-id>
        /// <unmanaged>HRESULT ID3D12Device::CreatePlacedResource([In] ID3D12Heap* pHeap,[In] unsigned longlong HeapOffset,[In] const D3D12_RESOURCE_DESC* pDesc,[In] D3D12_RESOURCE_STATES InitialState,[In, Optional] const D3D12_CLEAR_VALUE* pOptimizedClearValue,[In] const GUID&amp; riid,[Out] void** ppvResource)</unmanaged>
        /// <unmanaged-short>ID3D12Device::CreatePlacedResource</unmanaged-short>
        private unsafe SharpDX.Direct3D12.Resource CreatePlacedResource(SharpDX.Direct3D12.Heap heapRef, System.Int64 heapOffset, ref SharpDX.Direct3D12.ResourceDescription descRef, SharpDX.Direct3D12.ResourceStates initialState, SharpDX.Direct3D12.ClearValue? optimizedClearValueRef, System.Guid riid)
        {
            System.IntPtr heapRef_ = System.IntPtr.Zero;
            SharpDX.Direct3D12.ClearValue optimizedClearValueRef_;
            SharpDX.Direct3D12.Resource vResourceOut;
            System.IntPtr vResourceOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            heapRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Heap>(heapRef);
            if (optimizedClearValueRef != null)
                optimizedClearValueRef_ = optimizedClearValueRef.Value;
            fixed (void *descRef_ = &descRef)
                __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, (void *)heapRef_, heapOffset, descRef_, unchecked ((System.Int32)initialState), optimizedClearValueRef == null ? (void *)0 : &optimizedClearValueRef_, &riid, &vResourceOut_, (*(void ***)this._nativePointer)[29]);
            if (vResourceOut_ != System.IntPtr.Zero)
                vResourceOut = new SharpDX.Direct3D12.Resource(vResourceOut_);
            else
                vResourceOut = null;
            __result__.CheckError();
            return vResourceOut;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "descRef">No documentation.</param>
        /// <param name = "initialState">No documentation.</param>
        /// <param name = "optimizedClearValueRef">No documentation.</param>
        /// <param name = "riid">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D12Device::CreateReservedResource([In] const D3D12_RESOURCE_DESC* pDesc,[In] D3D12_RESOURCE_STATES InitialState,[In, Optional] const D3D12_CLEAR_VALUE* pOptimizedClearValue,[In] const GUID&amp; riid,[Out] void** ppvResource)</unmanaged>
        /// <unmanaged-short>ID3D12Device::CreateReservedResource</unmanaged-short>
        private unsafe SharpDX.Direct3D12.Resource CreateReservedResource(ref SharpDX.Direct3D12.ResourceDescription descRef, SharpDX.Direct3D12.ResourceStates initialState, SharpDX.Direct3D12.ClearValue? optimizedClearValueRef, System.Guid riid)
        {
            SharpDX.Direct3D12.ClearValue optimizedClearValueRef_;
            SharpDX.Direct3D12.Resource vResourceOut;
            System.IntPtr vResourceOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            if (optimizedClearValueRef != null)
                optimizedClearValueRef_ = optimizedClearValueRef.Value;
            fixed (void *descRef_ = &descRef)
                __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, descRef_, unchecked ((System.Int32)initialState), optimizedClearValueRef == null ? (void *)0 : &optimizedClearValueRef_, &riid, &vResourceOut_, (*(void ***)this._nativePointer)[30]);
            if (vResourceOut_ != System.IntPtr.Zero)
                vResourceOut = new SharpDX.Direct3D12.Resource(vResourceOut_);
            else
                vResourceOut = null;
            __result__.CheckError();
            return vResourceOut;
        }

        /// <summary>
        /// <p> Creates a shared handle to an heap, resource, or fence object. </p>
        /// </summary>
        /// <param name = "objectRef"><dd>  <p> A reference to the <strong><see cref = "SharpDX.Direct3D12.DeviceChild"/></strong> interface that represents the heap, resource, or fence object to create for sharing. The following interfaces (derived from <strong><see cref = "SharpDX.Direct3D12.DeviceChild"/></strong>) are supported: </p> <ul> <li> <strong><see cref = "SharpDX.Direct3D12.Heap"/></strong> </li> <li> <strong><see cref = "SharpDX.Direct3D12.Resource"/></strong> </li> <li> <strong><see cref = "SharpDX.Direct3D12.Fence"/></strong> </li> </ul> </dd></param>
        /// <param name = "attributesRef"><dd>  <p> A reference to a <strong><see cref = "SharpDX.Win32.SecurityAttributes"/></strong> structure that contains two separate but related data members: an optional security descriptor, and a <strong>Boolean</strong> value that determines whether child processes can inherit the returned handle. </p> <p> Set this parameter to <strong><c>null</c></strong> if you want child processes that the application might create to not  inherit  the handle returned by <strong>CreateSharedHandle</strong>, and if you want the resource that is associated with the returned handle to get a default security descriptor. </p> <p> The <strong>lpSecurityDescriptor</strong> member of the structure specifies a <strong>SECURITY_DESCRIPTOR</strong> for the resource. Set this member to <strong><c>null</c></strong> if you want the runtime to assign a default security descriptor to the resource that is associated with the returned handle. The ACLs in the default security descriptor for the resource come from the primary or impersonation token of the creator. For more info, see Synchronization Object Security and Access Rights. </p> </dd></param>
        /// <param name = "access"><dd>  <p>Currently the only value this parameter accepts is GENERIC_ALL.</p> </dd></param>
        /// <param name = "name"><dd>  <p> A <strong><c>null</c></strong>-terminated <strong>UNICODE</strong> string that contains the name to associate with the shared heap. The name is limited to MAX_PATH characters. Name comparison is case-sensitive. </p> <p> If <em>Name</em> matches the name of an existing resource, <strong>CreateSharedHandle</strong> fails with <see cref = "NameAlreadyExists"/>. This occurs because these objects share the same namespace. </p> <p> The name can have a "Global\" or "Local\" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see Kernel Object Namespaces. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users. </p> <p> The object can be created in a private namespace. For more information, see Object Namespaces. </p> </dd></param>
        /// <param name = "handleRef"><dd>  <p> A reference to a variable that receives the NT HANDLE value to the resource to share. You can use this handle in calls to access the resource. </p> </dd></param>
        /// <returns><p> Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise, returns one of the following values: </p><ul> <li><see cref = "InvalidCall"/> if one of the parameters is invalid. </li> <li><see cref = "NameAlreadyExists"/> if the supplied name of the resource to share is already associated with another resource. </li> <li>E_ACCESSDENIED if the object is being created in a protected namespace.</li> <li>E_OUTOFMEMORY if sufficient memory is not available to create the handle.</li> <li> Possibly other error codes that are described in the Direct3D 12 Return Codes topic. </li> </ul></returns>
        /// <remarks>
        /// <p> Both heaps and committed resources can be shared. Sharing a committed resource shares the implicit heap along with the committed resource description, such that a compatible resource description can be mapped to the heap from another device.  </p>
        /// </remarks>
        /// <doc-id>dn899183</doc-id>
        /// <unmanaged>HRESULT ID3D12Device::CreateSharedHandle([In] ID3D12DeviceChild* pObject,[In, Optional] const SECURITY_ATTRIBUTES* pAttributes,[In] DWORD Access,[In, Optional] const wchar_t* Name,[Out] void** pHandle)</unmanaged>
        /// <unmanaged-short>ID3D12Device::CreateSharedHandle</unmanaged-short>
        internal unsafe void CreateSharedHandle(SharpDX.Direct3D12.DeviceChild objectRef, SharpDX.Win32.SecurityAttributes? attributesRef, System.Int32 access, System.String name, out System.IntPtr handleRef)
        {
            System.IntPtr objectRef_ = System.IntPtr.Zero;
            SharpDX.Win32.SecurityAttributes attributesRef_;
            SharpDX.Result __result__;
            objectRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.DeviceChild>(objectRef);
            if (attributesRef != null)
                attributesRef_ = attributesRef.Value;
            fixed (void *handleRef_ = &handleRef)
                fixed (char *name_ = name)
                    __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, (void *)objectRef_, attributesRef == null ? (void *)0 : &attributesRef_, access, (void *)name_, handleRef_, (*(void ***)this._nativePointer)[31]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Opens a handle for shared resources, shared heaps, and shared fences, by using HANDLE and REFIID. </p>
        /// </summary>
        /// <param name = "nTHandle"><dd>  <p> The handle that was output by the call to  <strong>ID3D12Device::CreateSharedHandle</strong>. </p> </dd></param>
        /// <param name = "riid"><dd>  <p> The globally unique identifier (<strong><see cref = "System.Guid"/></strong>) for one of the following interfaces: </p> <ul> <li> <strong><see cref = "SharpDX.Direct3D12.Heap"/></strong> </li> <li> <strong><see cref = "SharpDX.Direct3D12.Resource"/></strong> </li> <li> <strong><see cref = "SharpDX.Direct3D12.Fence"/></strong> </li> </ul> <p> The <strong>REFIID</strong>, or <strong><see cref = "System.Guid"/></strong>, of the interface can be obtained by using the __uuidof() macro. For example, __uuidof(<see cref = "SharpDX.Direct3D12.Heap"/>) will get the <strong><see cref = "System.Guid"/></strong> of the interface to a resource. </p> </dd></param>
        /// <param name = "vObjOut"><dd>  <p> A reference to a memory block that receives a reference to one of the following interfaces: </p> <ul> <li> <strong><see cref = "SharpDX.Direct3D12.Heap"/></strong> </li> <li> <strong><see cref = "SharpDX.Direct3D12.Resource"/></strong> </li> <li> <strong><see cref = "SharpDX.Direct3D12.Fence"/></strong> </li> </ul> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. </p></returns>
        /// <doc-id>dn903831</doc-id>
        /// <unmanaged>HRESULT ID3D12Device::OpenSharedHandle([In] void* NTHandle,[In] const GUID&amp; riid,[Out, Optional] void** ppvObj)</unmanaged>
        /// <unmanaged-short>ID3D12Device::OpenSharedHandle</unmanaged-short>
        public unsafe void OpenSharedHandle(System.IntPtr nTHandle, System.Guid riid, out System.IntPtr vObjOut)
        {
            SharpDX.Result __result__;
            fixed (void *vObjOut_ = &vObjOut)
                __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, (void *)nTHandle, &riid, vObjOut_, (*(void ***)this._nativePointer)[32]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Opens a handle for shared resources, shared heaps, and shared fences, by using Name and Access. </p>
        /// </summary>
        /// <param name = "name"><dd>  <p> The name that was optionally passed as the <em>Name</em> parameter in the call to  <strong>ID3D12Device::CreateSharedHandle</strong>. </p> </dd></param>
        /// <param name = "access"><dd>  <p> The access level that was specified in the <em>Access</em> parameter in the call to  <strong>ID3D12Device::CreateSharedHandle</strong>. </p> </dd></param>
        /// <param name = "nTHandleRef"><dd>  <p> Pointer to the shared handle. </p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. </p></returns>
        /// <doc-id>dn903832</doc-id>
        /// <unmanaged>HRESULT ID3D12Device::OpenSharedHandleByName([In] const wchar_t* Name,[In] DWORD Access,[Out] void** pNTHandle)</unmanaged>
        /// <unmanaged-short>ID3D12Device::OpenSharedHandleByName</unmanaged-short>
        public unsafe void OpenSharedHandleByName(System.String name, System.Int32 access, out System.IntPtr nTHandleRef)
        {
            SharpDX.Result __result__;
            fixed (void *nTHandleRef_ = &nTHandleRef)
                fixed (char *name_ = name)
                    __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, (void *)name_, access, nTHandleRef_, (*(void ***)this._nativePointer)[33]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Makes objects resident for the device.</p>
        /// </summary>
        /// <param name = "numObjects"><dd>  <p> The number of objects  in the <em>ppObjects</em> array to make resident for the device. </p> </dd></param>
        /// <param name = "objectsOut"><dd>  <p>A reference to a memory block that contains an array of <strong><see cref = "SharpDX.Direct3D12.Pageable"/></strong> interface references for the objects. </p> <p>Even though most D3D12 objects inherit from <strong><see cref = "SharpDX.Direct3D12.Pageable"/></strong>, residency changes are only supported on the following objects:Descriptor Heaps, Heaps, Committed Resources, and Query Heaps</p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. </p></returns>
        /// <remarks>
        /// <p><strong>MakeResident</strong> loads the data associated with a resource from disk, and re-allocates the memory from the resource's appropriate memory pool. This method should be called on the object which owns the physical memory.
        /// </p><p>Use this method, and <strong>Evict</strong>, to manage GPU video memory, noting that this was done automatically in D3D11, but now has to be done by the app in D3D12.</p><p><strong>MakeResident</strong> and <strong>Evict</strong> can help applications manage the residency budget on many adapters. <strong>MakeResident</strong> explicitly pages-in data and, then, precludes page-out so the GPU can access the data. <strong>Evict</strong> enables page-out.</p><p>Some GPU architectures do not benefit from residency manipulation, due to the lack of sufficient GPU virtual address space. Use <strong><see cref = "SharpDX.Direct3D12.FeatureDataGpuVirtualAddressSupport"/></strong> and <strong>IDXGIAdapter3::QueryVideoMemoryInfo</strong> to recognize when the maximum GPU VA space per-process is too small or roughly the same size as the residency budget. For such architectures, the residency budget will always be constrained by the amount of GPU virtual address space. <strong>Evict</strong> will not free-up any residency budget on such systems.
        /// </p><p>Applications must handle <strong>MakeResident</strong> failures, even if there appears to be enough residency budget available. Physical memory fragmentation and adapter architecture quirks can preclude the utilization of large contiguous ranges. Applications should free up more residency budget before trying again.
        /// </p><p><strong>MakeResident</strong> is ref-counted, such that <strong>Evict</strong> must be called the same amount of times as <strong>MakeResident</strong> before <strong>Evict</strong> takes effect. Objects that support residency are made resident during creation, so a single <strong>Evict</strong> call will actually evict the object. </p><p>Applications must use fences to ensure the GPU doesn't use non-resident objects. <strong>MakeResident</strong> must return before the GPU executes a command list that references the object. <strong>Evict</strong> must be called after the GPU finishes executing a command list that references the object.</p><p>Evicted objects still consume the same GPU virtual address and same amount of GPU virtual address space. Therefore, resource descriptors and other GPU virtual address references are not invalidated after <strong>Evict</strong>.</p>
        /// </remarks>
        /// <doc-id>dn788682</doc-id>
        /// <unmanaged>HRESULT ID3D12Device::MakeResident([In] unsigned int NumObjects,[In, Buffer] const ID3D12Pageable** ppObjects)</unmanaged>
        /// <unmanaged-short>ID3D12Device::MakeResident</unmanaged-short>
        public unsafe void MakeResident(System.Int32 numObjects, SharpDX.Direct3D12.Pageable[] objectsOut)
        {
            System.IntPtr*objectsOut_;
            objectsOut_ = (System.IntPtr*)0;
            if (objectsOut != null)
            {
                System.IntPtr*_objectsOut = stackalloc System.IntPtr[objectsOut.Length];
                objectsOut_ = _objectsOut;
            }

            SharpDX.Result __result__;
            if (objectsOut != null)
                for (int i = 0; i < objectsOut.Length; ++i)
                    (objectsOut_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Pageable>(objectsOut[i]);
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, numObjects, (void *)objectsOut_, (*(void ***)this._nativePointer)[34]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Enables the page-out of data, which precludes GPU access of that data.</p>
        /// </summary>
        /// <param name = "numObjects"><dd>  <p> The number of objects in the <em>ppObjects</em> array to evict from the device. </p> </dd></param>
        /// <param name = "objectsOut"><dd>  <p> A reference to a memory block that contains an array of <strong><see cref = "SharpDX.Direct3D12.Pageable"/></strong> interface references for the objects. </p> <p>Even though most D3D12 objects inherit from <strong><see cref = "SharpDX.Direct3D12.Pageable"/></strong>, residency changes are only supported on the following objects:Descriptor Heaps, Heaps, Committed Resources, and Query Heaps</p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. </p></returns>
        /// <remarks>
        /// <p><strong>Evict</strong> persists the data associated with a resource to disk, and then removes the resource from the memory pool where it was located. This method should be called on the object which owns the physical memory: either a committed resource (which owns both virtual  and physical memory assignments) or a heap - noting that reserved resources do not have physical memory, and placed resources are borrowing memory from a heap.
        /// </p><p>Refer to the remarks for <strong>MakeResident</strong>.</p>
        /// </remarks>
        /// <doc-id>dn788676</doc-id>
        /// <unmanaged>HRESULT ID3D12Device::Evict([In] unsigned int NumObjects,[In, Buffer] const ID3D12Pageable** ppObjects)</unmanaged>
        /// <unmanaged-short>ID3D12Device::Evict</unmanaged-short>
        public unsafe void Evict(System.Int32 numObjects, SharpDX.Direct3D12.Pageable[] objectsOut)
        {
            System.IntPtr*objectsOut_;
            objectsOut_ = (System.IntPtr*)0;
            if (objectsOut != null)
            {
                System.IntPtr*_objectsOut = stackalloc System.IntPtr[objectsOut.Length];
                objectsOut_ = _objectsOut;
            }

            SharpDX.Result __result__;
            if (objectsOut != null)
                for (int i = 0; i < objectsOut.Length; ++i)
                    (objectsOut_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Pageable>(objectsOut[i]);
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, numObjects, (void *)objectsOut_, (*(void ***)this._nativePointer)[35]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "initialValue">No documentation.</param>
        /// <param name = "flags">No documentation.</param>
        /// <param name = "riid">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D12Device::CreateFence([In] unsigned longlong InitialValue,[In] D3D12_FENCE_FLAGS Flags,[In] const GUID&amp; riid,[Out] void** ppFence)</unmanaged>
        /// <unmanaged-short>ID3D12Device::CreateFence</unmanaged-short>
        private unsafe SharpDX.Direct3D12.Fence CreateFence(System.Int64 initialValue, SharpDX.Direct3D12.FenceFlags flags, System.Guid riid)
        {
            SharpDX.Direct3D12.Fence fenceOut;
            System.IntPtr fenceOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, initialValue, unchecked ((System.Int32)flags), &riid, &fenceOut_, (*(void ***)this._nativePointer)[36]);
            if (fenceOut_ != System.IntPtr.Zero)
                fenceOut = new SharpDX.Direct3D12.Fence(fenceOut_);
            else
                fenceOut = null;
            __result__.CheckError();
            return fenceOut;
        }

        /// <summary>
        /// <p>Gets the reason that the device was removed.</p>
        /// </summary>
        /// <returns><p>This method returns the reason that the device was removed.</p></returns>
        /// <doc-id>dn899187</doc-id>
        /// <unmanaged>HRESULT ID3D12Device::GetDeviceRemovedReason()</unmanaged>
        /// <unmanaged-short>ID3D12Device::GetDeviceRemovedReason</unmanaged-short>
        internal unsafe SharpDX.Result GetDeviceRemovedReason()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[37]);
            return __result__;
        }

        /// <summary>
        /// <p> Gets a resource layout that can be copied. Helps the app fill-in  <strong><see cref = "SharpDX.Direct3D12.PlacedSubResourceFootprint"/></strong> and  <strong><see cref = "SharpDX.Direct3D12.SubResourceFootprint"/></strong> when suballocating space in upload heaps. </p>
        /// </summary>
        /// <param name = "resourceDescRef">No documentation.</param>
        /// <param name = "firstSubresource">No documentation.</param>
        /// <param name = "numSubresources">No documentation.</param>
        /// <param name = "baseOffset">No documentation.</param>
        /// <param name = "layoutsRef">No documentation.</param>
        /// <param name = "numRowsRef">No documentation.</param>
        /// <param name = "rowSizeInBytesRef">No documentation.</param>
        /// <param name = "totalBytesRef">No documentation.</param>
        /// <remarks>
        /// <p> This routine assists the application in filling out <strong><see cref = "SharpDX.Direct3D12.PlacedSubResourceFootprint"/></strong> and <strong><see cref = "SharpDX.Direct3D12.SubResourceFootprint"/></strong> structures, when suballocating space in upload heaps. The resulting structures are GPU adapter-agnostic, meaning that the values will not vary from one GPU adapter to the next. <strong>GetCopyableFootprints</strong> uses specified details about resource formats, texture layouts, and alignment requirements (from the <strong><see cref = "SharpDX.Direct3D12.ResourceDescription"/></strong> structure)  to fill out the subresource structures. Applications have access to all these details, so this method, or a variation of it, could be  written as part of the app. </p>
        /// </remarks>
        /// <doc-id>dn986878</doc-id>
        /// <unmanaged>void ID3D12Device::GetCopyableFootprints([In] const D3D12_RESOURCE_DESC* pResourceDesc,[In] unsigned int FirstSubresource,[In] unsigned int NumSubresources,[In] unsigned longlong BaseOffset,[Out, Buffer, Optional] D3D12_PLACED_SUBRESOURCE_FOOTPRINT* pLayouts,[Out, Buffer, Optional] unsigned int* pNumRows,[Out, Buffer, Optional] unsigned longlong* pRowSizeInBytes,[Out, Optional] unsigned longlong* pTotalBytes)</unmanaged>
        /// <unmanaged-short>ID3D12Device::GetCopyableFootprints</unmanaged-short>
        public unsafe void GetCopyableFootprints(ref SharpDX.Direct3D12.ResourceDescription resourceDescRef, System.Int32 firstSubresource, System.Int32 numSubresources, System.Int64 baseOffset, SharpDX.Direct3D12.PlacedSubResourceFootprint[] layoutsRef, System.Int32[] numRowsRef, System.Int64[] rowSizeInBytesRef, out System.Int64 totalBytesRef)
        {
            fixed (void *totalBytesRef_ = &totalBytesRef)
                fixed (void *rowSizeInBytesRef_ = rowSizeInBytesRef)
                    fixed (void *numRowsRef_ = numRowsRef)
                        fixed (void *layoutsRef_ = layoutsRef)
                            fixed (void *resourceDescRef_ = &resourceDescRef)
                                SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, resourceDescRef_, firstSubresource, numSubresources, baseOffset, layoutsRef_, numRowsRef_, rowSizeInBytesRef_, totalBytesRef_, (*(void ***)this._nativePointer)[38]);
        }

        /// <summary>
        /// <p> Creates a query heap. A query heap contains an array of queries. </p>
        /// </summary>
        /// <param name = "descRef"><dd>  <p> Specifies the query heap in a <strong><see cref = "SharpDX.Direct3D12.QueryHeapDescription"/></strong> structure. </p> </dd></param>
        /// <param name = "riid"><dd>  <p> Specifies a REFIID that uniquely identifies the heap. </p> </dd></param>
        /// <returns><dd>  <p> Specifies a reference to the heap, that will be returned on successful completion of the method. <em>ppvHeap</em> can be <c>null</c>, to enable capability testing. When <em>ppvHeap</em> is <c>null</c>, no object will be created and S_FALSE will be returned when <em>pDesc</em> is valid. </p> </dd></returns>
        /// <remarks>
        /// <p> Refer to Queries for more information. </p>
        /// </remarks>
        /// <doc-id>dn903828</doc-id>
        /// <unmanaged>HRESULT ID3D12Device::CreateQueryHeap([In] const D3D12_QUERY_HEAP_DESC* pDesc,[In] const GUID&amp; riid,[Out] void** ppvHeap)</unmanaged>
        /// <unmanaged-short>ID3D12Device::CreateQueryHeap</unmanaged-short>
        private unsafe SharpDX.Direct3D12.QueryHeap CreateQueryHeap(SharpDX.Direct3D12.QueryHeapDescription descRef, System.Guid riid)
        {
            SharpDX.Direct3D12.QueryHeap vHeapOut;
            System.IntPtr vHeapOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, &descRef, &riid, &vHeapOut_, (*(void ***)this._nativePointer)[39]);
            if (vHeapOut_ != System.IntPtr.Zero)
                vHeapOut = new SharpDX.Direct3D12.QueryHeap(vHeapOut_);
            else
                vHeapOut = null;
            __result__.CheckError();
            return vHeapOut;
        }

        /// <summary>
        /// <p>A development-time aid for certain types of profiling and experimental prototyping.</p>
        /// </summary>
        /// <param name = "enable"><dd>  <p>Specifies a <see cref = "SharpDX.Mathematics.Interop.RawBool"/> that turns the stable power state on or off.</p> </dd></param>
        /// <returns><p>This method returns one of the Direct3D 12 Return Codes.</p></returns>
        /// <remarks>
        /// <p>This method is only useful during the development of applications. It enables developers to profile GPU usage of multiple algorithms without experiencing artifacts from dynamic frequency scaling.</p><p>Do not call this method in normal execution for a shipped application. This method only works while the machine is in developer mode. If developer mode is not enabled, then device removal will occur. Instead, call this method in response to an off-by-default, developer-facing switch. Calling it in response to command line parameters, config files, registry keys, and developer console commands are reasonable usage scenarios. </p><p>A stable power state typically fixes GPU clock rates at a slower setting that is significantly lower than that experienced by users under normal application load. This reduction in clock rate affects the entire system. Slow clock rates are required to ensure processors don?t exhaust power, current, and thermal limits. Normal usage scenarios commonly leverage a processors ability to dynamically over-clock. Any conclusions made by comparing two designs under a stable power state should be double-checked with supporting results from real usage scenarios.</p>
        /// </remarks>
        /// <doc-id>dn903835</doc-id>
        /// <unmanaged>HRESULT ID3D12Device::SetStablePowerState([In] BOOL Enable)</unmanaged>
        /// <unmanaged-short>ID3D12Device::SetStablePowerState</unmanaged-short>
        internal unsafe void SetStablePowerState(SharpDX.Mathematics.Interop.RawBool enable)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint0(this._nativePointer, enable, (*(void ***)this._nativePointer)[40]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> This method creates a command signature. </p>
        /// </summary>
        /// <param name = "descRef"><dd>  <p> Describes the command signature to be created with the <strong><see cref = "SharpDX.Direct3D12.CommandSignatureDescription"/></strong> structure. </p> </dd></param>
        /// <param name = "rootSignatureRef"><dd>  <p>Specifies the  <strong><see cref = "SharpDX.Direct3D12.RootSignature"/></strong> that the command signature applies to. </p> <p>The root signature is required if any of the commands in the signature will update bindings on the pipeline. If the only command present is a draw or dispatch, the root signature parameter can be set to <c>null</c>.</p> </dd></param>
        /// <param name = "riid"><dd>  <p> The globally unique identifier (<strong><see cref = "System.Guid"/></strong>) for the command signature interface (<strong><see cref = "SharpDX.Direct3D12.CommandSignature"/></strong>). The <strong>REFIID</strong>, or <strong><see cref = "System.Guid"/></strong>, of the interface to the command signature can be obtained by using the __uuidof() macro. For example, __uuidof(<strong><see cref = "SharpDX.Direct3D12.CommandSignature"/></strong>) will get the <strong><see cref = "System.Guid"/></strong> of the interface to a command signature. </p> </dd></param>
        /// <returns><dd>  <p> Specifies a reference, that on successful completion of the method will point to the created command signature (<strong><see cref = "SharpDX.Direct3D12.CommandSignature"/></strong>). </p> </dd></returns>
        /// <doc-id>dn903827</doc-id>
        /// <unmanaged>HRESULT ID3D12Device::CreateCommandSignature([In] const D3D12_COMMAND_SIGNATURE_DESC* pDesc,[In, Optional] ID3D12RootSignature* pRootSignature,[In] const GUID&amp; riid,[Out] void** ppvCommandSignature)</unmanaged>
        /// <unmanaged-short>ID3D12Device::CreateCommandSignature</unmanaged-short>
        private unsafe SharpDX.Direct3D12.CommandSignature CreateCommandSignature(System.IntPtr descRef, SharpDX.Direct3D12.RootSignature rootSignatureRef, System.Guid riid)
        {
            System.IntPtr rootSignatureRef_ = System.IntPtr.Zero;
            SharpDX.Direct3D12.CommandSignature vCommandSignatureOut;
            System.IntPtr vCommandSignatureOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            rootSignatureRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.RootSignature>(rootSignatureRef);
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, (void *)descRef, (void *)rootSignatureRef_, &riid, &vCommandSignatureOut_, (*(void ***)this._nativePointer)[41]);
            if (vCommandSignatureOut_ != System.IntPtr.Zero)
                vCommandSignatureOut = new SharpDX.Direct3D12.CommandSignature(vCommandSignatureOut_);
            else
                vCommandSignatureOut = null;
            __result__.CheckError();
            return vCommandSignatureOut;
        }

        /// <summary>
        /// <p> Gets info about how a tiled resource is broken into tiles. </p>
        /// </summary>
        /// <param name = "tiledResourceRef"><dd>  <p> Specifies a tiled <strong><see cref = "SharpDX.Direct3D12.Resource"/></strong> to get info about. </p> </dd></param>
        /// <param name = "numTilesForEntireResourceRef"><dd>  <p> A reference to a variable that receives the number of tiles needed to store the entire tiled resource. </p> </dd></param>
        /// <param name = "packedMipDescRef"><dd>  <p> A reference to a <strong><see cref = "SharpDX.Direct3D12.PackedMipInformation"/></strong> structure that <strong>GetResourceTiling</strong> fills with info about how the tiled resource's mipmaps are packed. </p> </dd></param>
        /// <param name = "standardTileShapeForNonPackedMipsRef"><dd>  <p> Specifies a <strong><see cref = "SharpDX.Direct3D12.TileShape"/></strong> structure that <strong>GetResourceTiling</strong> fills with info about the tile shape. This is info about how pixels fit in the tiles, independent of tiled resource's dimensions, not including packed mipmaps. If the entire tiled resource is packed, this parameter is meaningless because the tiled resource has no defined layout for packed mipmaps. In this situation, <strong>GetResourceTiling</strong> sets the members of <see cref = "SharpDX.Direct3D12.TileShape"/> to zeros. </p> </dd></param>
        /// <param name = "numSubresourceTilingsRef"><dd>  <p> A reference to a variable that contains the number of tiles in the subresource. On input, this is the number of subresources to query tilings for; on output, this is the number that was actually retrieved at <em>pSubresourceTilingsForNonPackedMips</em> (clamped to what's available). </p> </dd></param>
        /// <param name = "firstSubresourceTilingToGet"><dd>  <p> The number of the first subresource tile to get. <strong>GetResourceTiling</strong> ignores this parameter if the number that <em>pNumSubresourceTilings</em> points to is 0. </p> </dd></param>
        /// <param name = "subresourceTilingsForNonPackedMipsRef"><dd>  <p> Specifies a <strong><see cref = "SharpDX.Direct3D12.SubResourceTiling"/></strong> structure that <strong>GetResourceTiling</strong> fills with info about subresource tiles. If subresource tiles are part of packed mipmaps, <strong>GetResourceTiling</strong> sets the members of <see cref = "SharpDX.Direct3D12.SubResourceTiling"/> to zeros, except the <em>StartTileIndexInOverallResource</em> member, which <strong>GetResourceTiling</strong> sets to D3D12_PACKED_TILE (0xffffffff). The D3D12_PACKED_TILE constant indicates that the whole <strong><see cref = "SharpDX.Direct3D12.SubResourceTiling"/></strong> structure is meaningless for this situation, and the info that the <em>pPackedMipDesc</em> parameter points to applies. </p> </dd></param>
        /// <remarks>
        /// <p> To estimate the total resource size of textures needed when calculating heap sizes and calling <strong>CreatePlacedResource</strong>, use <strong>GetResourceAllocationInfo</strong> instead of <strong>GetResourceTiling</strong>. <strong>GetResourceTiling</strong> cannot be used for this. </p><p> For more information on tiled resources, refer to Volume Tiled Resources. </p>
        /// </remarks>
        /// <doc-id>dn903829</doc-id>
        /// <unmanaged>void ID3D12Device::GetResourceTiling([In] ID3D12Resource* pTiledResource,[Out, Optional] unsigned int* pNumTilesForEntireResource,[Out, Optional] D3D12_PACKED_MIP_INFO* pPackedMipDesc,[Out, Optional] D3D12_TILE_SHAPE* pStandardTileShapeForNonPackedMips,[InOut, Optional] unsigned int* pNumSubresourceTilings,[In] unsigned int FirstSubresourceTilingToGet,[Out, Buffer] D3D12_SUBRESOURCE_TILING* pSubresourceTilingsForNonPackedMips)</unmanaged>
        /// <unmanaged-short>ID3D12Device::GetResourceTiling</unmanaged-short>
        public unsafe void GetResourceTiling(SharpDX.Direct3D12.Resource tiledResourceRef, out System.Int32 numTilesForEntireResourceRef, out SharpDX.Direct3D12.PackedMipInformation packedMipDescRef, out SharpDX.Direct3D12.TileShape standardTileShapeForNonPackedMipsRef, System.IntPtr numSubresourceTilingsRef, System.Int32 firstSubresourceTilingToGet, SharpDX.Direct3D12.SubResourceTiling[] subresourceTilingsForNonPackedMipsRef)
        {
            System.IntPtr tiledResourceRef_ = System.IntPtr.Zero;
            packedMipDescRef = default (SharpDX.Direct3D12.PackedMipInformation);
            standardTileShapeForNonPackedMipsRef = default (SharpDX.Direct3D12.TileShape);
            tiledResourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(tiledResourceRef);
            fixed (void *subresourceTilingsForNonPackedMipsRef_ = subresourceTilingsForNonPackedMipsRef)
                fixed (void *standardTileShapeForNonPackedMipsRef_ = &standardTileShapeForNonPackedMipsRef)
                    fixed (void *packedMipDescRef_ = &packedMipDescRef)
                        fixed (void *numTilesForEntireResourceRef_ = &numTilesForEntireResourceRef)
                            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)tiledResourceRef_, numTilesForEntireResourceRef_, packedMipDescRef_, standardTileShapeForNonPackedMipsRef_, (void *)numSubresourceTilingsRef, firstSubresourceTilingToGet, subresourceTilingsForNonPackedMipsRef_, (*(void ***)this._nativePointer)[42]);
        }

        /// <summary>
        /// <p> Gets a locally unique identifier for the current device (adapter). </p>
        /// </summary>
        /// <returns><p> The locally unique identifier for the adapter. </p></returns>
        /// <remarks>
        /// <p> This method returns a unique identifier for the adapter that is specific to the adapter hardware. Applications can use this identifier to define robust mappings across various APIs (Direct3D 12, DXGI). </p><p> A locally unique identifier (<see cref = "System.Int64"/>) is a 64-bit value that is guaranteed to be unique only on the system on which it was generated. The uniqueness of a locally unique identifier (<see cref = "System.Int64"/>) is guaranteed only until the system is restarted. </p>
        /// </remarks>
        /// <doc-id>dn914411</doc-id>
        /// <unmanaged>LUID ID3D12Device::GetAdapterLuid()</unmanaged>
        /// <unmanaged-short>ID3D12Device::GetAdapterLuid</unmanaged-short>
        internal unsafe System.Int64 GetAdapterLuid()
        {
            System.Int64 __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCalllong(this._nativePointer, (*(void ***)this._nativePointer)[43]);
            return __result__;
        }

        /// <summary>
        /// <p>Makes objects resident for the device.</p>
        /// </summary>
        /// <param name = "numObjects"><dd>  <p> The number of objects  in the <em>ppObjects</em> array to make resident for the device. </p> </dd></param>
        /// <param name = "objectsOut"><dd>  <p>A reference to a memory block that contains an array of <strong><see cref = "SharpDX.Direct3D12.Pageable"/></strong> interface references for the objects. </p> <p>Even though most D3D12 objects inherit from <strong><see cref = "SharpDX.Direct3D12.Pageable"/></strong>, residency changes are only supported on the following objects:Descriptor Heaps, Heaps, Committed Resources, and Query Heaps</p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. </p></returns>
        /// <remarks>
        /// <p><strong>MakeResident</strong> loads the data associated with a resource from disk, and re-allocates the memory from the resource's appropriate memory pool. This method should be called on the object which owns the physical memory.
        /// </p><p>Use this method, and <strong>Evict</strong>, to manage GPU video memory, noting that this was done automatically in D3D11, but now has to be done by the app in D3D12.</p><p><strong>MakeResident</strong> and <strong>Evict</strong> can help applications manage the residency budget on many adapters. <strong>MakeResident</strong> explicitly pages-in data and, then, precludes page-out so the GPU can access the data. <strong>Evict</strong> enables page-out.</p><p>Some GPU architectures do not benefit from residency manipulation, due to the lack of sufficient GPU virtual address space. Use <strong><see cref = "SharpDX.Direct3D12.FeatureDataGpuVirtualAddressSupport"/></strong> and <strong>IDXGIAdapter3::QueryVideoMemoryInfo</strong> to recognize when the maximum GPU VA space per-process is too small or roughly the same size as the residency budget. For such architectures, the residency budget will always be constrained by the amount of GPU virtual address space. <strong>Evict</strong> will not free-up any residency budget on such systems.
        /// </p><p>Applications must handle <strong>MakeResident</strong> failures, even if there appears to be enough residency budget available. Physical memory fragmentation and adapter architecture quirks can preclude the utilization of large contiguous ranges. Applications should free up more residency budget before trying again.
        /// </p><p><strong>MakeResident</strong> is ref-counted, such that <strong>Evict</strong> must be called the same amount of times as <strong>MakeResident</strong> before <strong>Evict</strong> takes effect. Objects that support residency are made resident during creation, so a single <strong>Evict</strong> call will actually evict the object. </p><p>Applications must use fences to ensure the GPU doesn't use non-resident objects. <strong>MakeResident</strong> must return before the GPU executes a command list that references the object. <strong>Evict</strong> must be called after the GPU finishes executing a command list that references the object.</p><p>Evicted objects still consume the same GPU virtual address and same amount of GPU virtual address space. Therefore, resource descriptors and other GPU virtual address references are not invalidated after <strong>Evict</strong>.</p>
        /// </remarks>
        /// <doc-id>dn788682</doc-id>
        /// <unmanaged>HRESULT ID3D12Device::MakeResident([In] unsigned int NumObjects,[In, Buffer] const ID3D12Pageable** ppObjects)</unmanaged>
        /// <unmanaged-short>ID3D12Device::MakeResident</unmanaged-short>
        public unsafe void MakeResident(System.Int32 numObjects, SharpDX.ComArray<SharpDX.Direct3D12.Pageable> objectsOut)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, numObjects, (void *)(objectsOut?.NativePointer ?? System.IntPtr.Zero), (*(void ***)this._nativePointer)[34]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Makes objects resident for the device.</p>
        /// </summary>
        /// <param name = "numObjects"><dd>  <p> The number of objects  in the <em>ppObjects</em> array to make resident for the device. </p> </dd></param>
        /// <param name = "objectsOut"><dd>  <p>A reference to a memory block that contains an array of <strong><see cref = "SharpDX.Direct3D12.Pageable"/></strong> interface references for the objects. </p> <p>Even though most D3D12 objects inherit from <strong><see cref = "SharpDX.Direct3D12.Pageable"/></strong>, residency changes are only supported on the following objects:Descriptor Heaps, Heaps, Committed Resources, and Query Heaps</p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. </p></returns>
        /// <remarks>
        /// <p><strong>MakeResident</strong> loads the data associated with a resource from disk, and re-allocates the memory from the resource's appropriate memory pool. This method should be called on the object which owns the physical memory.
        /// </p><p>Use this method, and <strong>Evict</strong>, to manage GPU video memory, noting that this was done automatically in D3D11, but now has to be done by the app in D3D12.</p><p><strong>MakeResident</strong> and <strong>Evict</strong> can help applications manage the residency budget on many adapters. <strong>MakeResident</strong> explicitly pages-in data and, then, precludes page-out so the GPU can access the data. <strong>Evict</strong> enables page-out.</p><p>Some GPU architectures do not benefit from residency manipulation, due to the lack of sufficient GPU virtual address space. Use <strong><see cref = "SharpDX.Direct3D12.FeatureDataGpuVirtualAddressSupport"/></strong> and <strong>IDXGIAdapter3::QueryVideoMemoryInfo</strong> to recognize when the maximum GPU VA space per-process is too small or roughly the same size as the residency budget. For such architectures, the residency budget will always be constrained by the amount of GPU virtual address space. <strong>Evict</strong> will not free-up any residency budget on such systems.
        /// </p><p>Applications must handle <strong>MakeResident</strong> failures, even if there appears to be enough residency budget available. Physical memory fragmentation and adapter architecture quirks can preclude the utilization of large contiguous ranges. Applications should free up more residency budget before trying again.
        /// </p><p><strong>MakeResident</strong> is ref-counted, such that <strong>Evict</strong> must be called the same amount of times as <strong>MakeResident</strong> before <strong>Evict</strong> takes effect. Objects that support residency are made resident during creation, so a single <strong>Evict</strong> call will actually evict the object. </p><p>Applications must use fences to ensure the GPU doesn't use non-resident objects. <strong>MakeResident</strong> must return before the GPU executes a command list that references the object. <strong>Evict</strong> must be called after the GPU finishes executing a command list that references the object.</p><p>Evicted objects still consume the same GPU virtual address and same amount of GPU virtual address space. Therefore, resource descriptors and other GPU virtual address references are not invalidated after <strong>Evict</strong>.</p>
        /// </remarks>
        /// <doc-id>dn788682</doc-id>
        /// <unmanaged>HRESULT ID3D12Device::MakeResident([In] unsigned int NumObjects,[In, Buffer] const ID3D12Pageable** ppObjects)</unmanaged>
        /// <unmanaged-short>ID3D12Device::MakeResident</unmanaged-short>
        private unsafe void MakeResident(System.Int32 numObjects, System.IntPtr objectsOut)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, numObjects, (void *)objectsOut, (*(void ***)this._nativePointer)[34]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Enables the page-out of data, which precludes GPU access of that data.</p>
        /// </summary>
        /// <param name = "numObjects"><dd>  <p> The number of objects in the <em>ppObjects</em> array to evict from the device. </p> </dd></param>
        /// <param name = "objectsOut"><dd>  <p> A reference to a memory block that contains an array of <strong><see cref = "SharpDX.Direct3D12.Pageable"/></strong> interface references for the objects. </p> <p>Even though most D3D12 objects inherit from <strong><see cref = "SharpDX.Direct3D12.Pageable"/></strong>, residency changes are only supported on the following objects:Descriptor Heaps, Heaps, Committed Resources, and Query Heaps</p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. </p></returns>
        /// <remarks>
        /// <p><strong>Evict</strong> persists the data associated with a resource to disk, and then removes the resource from the memory pool where it was located. This method should be called on the object which owns the physical memory: either a committed resource (which owns both virtual  and physical memory assignments) or a heap - noting that reserved resources do not have physical memory, and placed resources are borrowing memory from a heap.
        /// </p><p>Refer to the remarks for <strong>MakeResident</strong>.</p>
        /// </remarks>
        /// <doc-id>dn788676</doc-id>
        /// <unmanaged>HRESULT ID3D12Device::Evict([In] unsigned int NumObjects,[In, Buffer] const ID3D12Pageable** ppObjects)</unmanaged>
        /// <unmanaged-short>ID3D12Device::Evict</unmanaged-short>
        public unsafe void Evict(System.Int32 numObjects, SharpDX.ComArray<SharpDX.Direct3D12.Pageable> objectsOut)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, numObjects, (void *)(objectsOut?.NativePointer ?? System.IntPtr.Zero), (*(void ***)this._nativePointer)[35]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Enables the page-out of data, which precludes GPU access of that data.</p>
        /// </summary>
        /// <param name = "numObjects"><dd>  <p> The number of objects in the <em>ppObjects</em> array to evict from the device. </p> </dd></param>
        /// <param name = "objectsOut"><dd>  <p> A reference to a memory block that contains an array of <strong><see cref = "SharpDX.Direct3D12.Pageable"/></strong> interface references for the objects. </p> <p>Even though most D3D12 objects inherit from <strong><see cref = "SharpDX.Direct3D12.Pageable"/></strong>, residency changes are only supported on the following objects:Descriptor Heaps, Heaps, Committed Resources, and Query Heaps</p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. </p></returns>
        /// <remarks>
        /// <p><strong>Evict</strong> persists the data associated with a resource to disk, and then removes the resource from the memory pool where it was located. This method should be called on the object which owns the physical memory: either a committed resource (which owns both virtual  and physical memory assignments) or a heap - noting that reserved resources do not have physical memory, and placed resources are borrowing memory from a heap.
        /// </p><p>Refer to the remarks for <strong>MakeResident</strong>.</p>
        /// </remarks>
        /// <doc-id>dn788676</doc-id>
        /// <unmanaged>HRESULT ID3D12Device::Evict([In] unsigned int NumObjects,[In, Buffer] const ID3D12Pageable** ppObjects)</unmanaged>
        /// <unmanaged-short>ID3D12Device::Evict</unmanaged-short>
        private unsafe void Evict(System.Int32 numObjects, System.IntPtr objectsOut)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, numObjects, (void *)objectsOut, (*(void ***)this._nativePointer)[35]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("77acce80-638e-4e65-8895-c1f23386863e")]
    public partial class Device1 : SharpDX.Direct3D12.Device
    {
        public Device1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Device1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Device1(nativePtr);
        /// <summary>
        /// <p>Specifies an event that should be fired when one or more of a collection of fences reach specific values.</p>
        /// </summary>
        /// <param name = "fencesOut"><dd>  <p>An array of length <em>NumFences</em> that specifies the <strong><see cref = "SharpDX.Direct3D12.Fence"/></strong> objects.</p> </dd></param>
        /// <param name = "fenceValuesRef"><dd>  <p>An array of length <em>NumFences</em> that specifies the fence values required for the event is to be signaled.</p> </dd></param>
        /// <param name = "numFences"><dd>  <p>Specifies the number of fences to be included.</p> </dd></param>
        /// <param name = "flags"><dd>  <p>Specifies one  of the <strong><see cref = "SharpDX.Direct3D12.MultipleFenceWaitFlags"/></strong> that determines how to proceed.</p> </dd></param>
        /// <param name = "hEvent"><dd>  <p>A handle to the event object.</p> </dd></param>
        /// <returns><p>This method returns an <see cref = "SharpDX.Result"/> success or error code.</p></returns>
        /// <remarks>
        /// <p>To specify a single fence refer to the <strong>SetEventOnCompletion</strong> method.</p>
        /// </remarks>
        /// <doc-id>mt709134</doc-id>
        /// <unmanaged>HRESULT ID3D12Device1::SetEventOnMultipleFenceCompletion([In, Buffer] const ID3D12Fence** ppFences,[In, Buffer] const unsigned longlong* pFenceValues,[In] unsigned int NumFences,[In] D3D12_MULTIPLE_FENCE_WAIT_FLAGS Flags,[In] void* hEvent)</unmanaged>
        /// <unmanaged-short>ID3D12Device1::SetEventOnMultipleFenceCompletion</unmanaged-short>
        public unsafe void SetEventOnMultipleFenceCompletion(SharpDX.Direct3D12.Fence[] fencesOut, System.Int64[] fenceValuesRef, System.Int32 numFences, SharpDX.Direct3D12.MultipleFenceWaitFlags flags, System.IntPtr hEvent)
        {
            System.IntPtr*fencesOut_;
            fencesOut_ = (System.IntPtr*)0;
            if (fencesOut != null)
            {
                System.IntPtr*_fencesOut = stackalloc System.IntPtr[fencesOut.Length];
                fencesOut_ = _fencesOut;
            }

            SharpDX.Result __result__;
            if (fencesOut != null)
                for (int i = 0; i < fencesOut.Length; ++i)
                    (fencesOut_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Fence>(fencesOut[i]);
            fixed (void *fenceValuesRef_ = fenceValuesRef)
                __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, (void *)fencesOut_, fenceValuesRef_, numFences, unchecked ((System.Int32)flags), (void *)hEvent, (*(void ***)this._nativePointer)[45]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> </p><p>This method sets residency priorities of a specified list of objects.</p>
        /// </summary>
        /// <param name = "numObjects"><dd>  <p>Specifies the number of objects in the <em>ppObjects</em> and <em>pPriorities</em> arrays.</p> </dd></param>
        /// <param name = "objectsOut"><dd>  <p>Specifies an array, of length <em>NumObjects</em>, containing references to <strong><see cref = "SharpDX.Direct3D12.Pageable"/></strong> objects.</p> </dd></param>
        /// <param name = "prioritiesRef"><dd>  <p>Specifies an array, of length <em>NumObjects</em>, of <strong><see cref = "SharpDX.Direct3D12.ResidencyPriority"/></strong> values for the list of objects.</p> </dd></param>
        /// <returns><p>This method returns an <see cref = "SharpDX.Result"/> success or error code.</p></returns>
        /// <remarks>
        /// <p>For more information, refer to Residency.</p>
        /// </remarks>
        /// <doc-id>mt709135</doc-id>
        /// <unmanaged>HRESULT ID3D12Device1::SetResidencyPriority([In] unsigned int NumObjects,[In, Buffer] const ID3D12Pageable** ppObjects,[In, Buffer] const D3D12_RESIDENCY_PRIORITY* pPriorities)</unmanaged>
        /// <unmanaged-short>ID3D12Device1::SetResidencyPriority</unmanaged-short>
        public unsafe void SetResidencyPriority(System.Int32 numObjects, SharpDX.Direct3D12.Pageable[] objectsOut, SharpDX.Direct3D12.ResidencyPriority[] prioritiesRef)
        {
            System.IntPtr*objectsOut_;
            objectsOut_ = (System.IntPtr*)0;
            if (objectsOut != null)
            {
                System.IntPtr*_objectsOut = stackalloc System.IntPtr[objectsOut.Length];
                objectsOut_ = _objectsOut;
            }

            SharpDX.Result __result__;
            if (objectsOut != null)
                for (int i = 0; i < objectsOut.Length; ++i)
                    (objectsOut_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Pageable>(objectsOut[i]);
            fixed (void *prioritiesRef_ = prioritiesRef)
                __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, numObjects, (void *)objectsOut_, prioritiesRef_, (*(void ***)this._nativePointer)[46]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Specifies an event that should be fired when one or more of a collection of fences reach specific values.</p>
        /// </summary>
        /// <param name = "fencesOut"><dd>  <p>An array of length <em>NumFences</em> that specifies the <strong><see cref = "SharpDX.Direct3D12.Fence"/></strong> objects.</p> </dd></param>
        /// <param name = "fenceValuesRef"><dd>  <p>An array of length <em>NumFences</em> that specifies the fence values required for the event is to be signaled.</p> </dd></param>
        /// <param name = "numFences"><dd>  <p>Specifies the number of fences to be included.</p> </dd></param>
        /// <param name = "flags"><dd>  <p>Specifies one  of the <strong><see cref = "SharpDX.Direct3D12.MultipleFenceWaitFlags"/></strong> that determines how to proceed.</p> </dd></param>
        /// <param name = "hEvent"><dd>  <p>A handle to the event object.</p> </dd></param>
        /// <returns><p>This method returns an <see cref = "SharpDX.Result"/> success or error code.</p></returns>
        /// <remarks>
        /// <p>To specify a single fence refer to the <strong>SetEventOnCompletion</strong> method.</p>
        /// </remarks>
        /// <doc-id>mt709134</doc-id>
        /// <unmanaged>HRESULT ID3D12Device1::SetEventOnMultipleFenceCompletion([In, Buffer] const ID3D12Fence** ppFences,[In, Buffer] const unsigned longlong* pFenceValues,[In] unsigned int NumFences,[In] D3D12_MULTIPLE_FENCE_WAIT_FLAGS Flags,[In] void* hEvent)</unmanaged>
        /// <unmanaged-short>ID3D12Device1::SetEventOnMultipleFenceCompletion</unmanaged-short>
        public unsafe void SetEventOnMultipleFenceCompletion(SharpDX.ComArray<SharpDX.Direct3D12.Fence> fencesOut, System.Int64[] fenceValuesRef, System.Int32 numFences, SharpDX.Direct3D12.MultipleFenceWaitFlags flags, System.IntPtr hEvent)
        {
            SharpDX.Result __result__;
            fixed (void *fenceValuesRef_ = fenceValuesRef)
                __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, (void *)(fencesOut?.NativePointer ?? System.IntPtr.Zero), fenceValuesRef_, numFences, unchecked ((System.Int32)flags), (void *)hEvent, (*(void ***)this._nativePointer)[45]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Specifies an event that should be fired when one or more of a collection of fences reach specific values.</p>
        /// </summary>
        /// <param name = "fencesOut"><dd>  <p>An array of length <em>NumFences</em> that specifies the <strong><see cref = "SharpDX.Direct3D12.Fence"/></strong> objects.</p> </dd></param>
        /// <param name = "fenceValuesRef"><dd>  <p>An array of length <em>NumFences</em> that specifies the fence values required for the event is to be signaled.</p> </dd></param>
        /// <param name = "numFences"><dd>  <p>Specifies the number of fences to be included.</p> </dd></param>
        /// <param name = "flags"><dd>  <p>Specifies one  of the <strong><see cref = "SharpDX.Direct3D12.MultipleFenceWaitFlags"/></strong> that determines how to proceed.</p> </dd></param>
        /// <param name = "hEvent"><dd>  <p>A handle to the event object.</p> </dd></param>
        /// <returns><p>This method returns an <see cref = "SharpDX.Result"/> success or error code.</p></returns>
        /// <remarks>
        /// <p>To specify a single fence refer to the <strong>SetEventOnCompletion</strong> method.</p>
        /// </remarks>
        /// <doc-id>mt709134</doc-id>
        /// <unmanaged>HRESULT ID3D12Device1::SetEventOnMultipleFenceCompletion([In, Buffer] const ID3D12Fence** ppFences,[In, Buffer] const unsigned longlong* pFenceValues,[In] unsigned int NumFences,[In] D3D12_MULTIPLE_FENCE_WAIT_FLAGS Flags,[In] void* hEvent)</unmanaged>
        /// <unmanaged-short>ID3D12Device1::SetEventOnMultipleFenceCompletion</unmanaged-short>
        private unsafe void SetEventOnMultipleFenceCompletion(System.IntPtr fencesOut, System.IntPtr fenceValuesRef, System.Int32 numFences, SharpDX.Direct3D12.MultipleFenceWaitFlags flags, System.IntPtr hEvent)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, (void *)fencesOut, (void *)fenceValuesRef, numFences, unchecked ((System.Int32)flags), (void *)hEvent, (*(void ***)this._nativePointer)[45]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> </p><p>This method sets residency priorities of a specified list of objects.</p>
        /// </summary>
        /// <param name = "numObjects"><dd>  <p>Specifies the number of objects in the <em>ppObjects</em> and <em>pPriorities</em> arrays.</p> </dd></param>
        /// <param name = "objectsOut"><dd>  <p>Specifies an array, of length <em>NumObjects</em>, containing references to <strong><see cref = "SharpDX.Direct3D12.Pageable"/></strong> objects.</p> </dd></param>
        /// <param name = "prioritiesRef"><dd>  <p>Specifies an array, of length <em>NumObjects</em>, of <strong><see cref = "SharpDX.Direct3D12.ResidencyPriority"/></strong> values for the list of objects.</p> </dd></param>
        /// <returns><p>This method returns an <see cref = "SharpDX.Result"/> success or error code.</p></returns>
        /// <remarks>
        /// <p>For more information, refer to Residency.</p>
        /// </remarks>
        /// <doc-id>mt709135</doc-id>
        /// <unmanaged>HRESULT ID3D12Device1::SetResidencyPriority([In] unsigned int NumObjects,[In, Buffer] const ID3D12Pageable** ppObjects,[In, Buffer] const D3D12_RESIDENCY_PRIORITY* pPriorities)</unmanaged>
        /// <unmanaged-short>ID3D12Device1::SetResidencyPriority</unmanaged-short>
        public unsafe void SetResidencyPriority(System.Int32 numObjects, SharpDX.ComArray<SharpDX.Direct3D12.Pageable> objectsOut, SharpDX.Direct3D12.ResidencyPriority[] prioritiesRef)
        {
            SharpDX.Result __result__;
            fixed (void *prioritiesRef_ = prioritiesRef)
                __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, numObjects, (void *)(objectsOut?.NativePointer ?? System.IntPtr.Zero), prioritiesRef_, (*(void ***)this._nativePointer)[46]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> </p><p>This method sets residency priorities of a specified list of objects.</p>
        /// </summary>
        /// <param name = "numObjects"><dd>  <p>Specifies the number of objects in the <em>ppObjects</em> and <em>pPriorities</em> arrays.</p> </dd></param>
        /// <param name = "objectsOut"><dd>  <p>Specifies an array, of length <em>NumObjects</em>, containing references to <strong><see cref = "SharpDX.Direct3D12.Pageable"/></strong> objects.</p> </dd></param>
        /// <param name = "prioritiesRef"><dd>  <p>Specifies an array, of length <em>NumObjects</em>, of <strong><see cref = "SharpDX.Direct3D12.ResidencyPriority"/></strong> values for the list of objects.</p> </dd></param>
        /// <returns><p>This method returns an <see cref = "SharpDX.Result"/> success or error code.</p></returns>
        /// <remarks>
        /// <p>For more information, refer to Residency.</p>
        /// </remarks>
        /// <doc-id>mt709135</doc-id>
        /// <unmanaged>HRESULT ID3D12Device1::SetResidencyPriority([In] unsigned int NumObjects,[In, Buffer] const ID3D12Pageable** ppObjects,[In, Buffer] const D3D12_RESIDENCY_PRIORITY* pPriorities)</unmanaged>
        /// <unmanaged-short>ID3D12Device1::SetResidencyPriority</unmanaged-short>
        private unsafe void SetResidencyPriority(System.Int32 numObjects, System.IntPtr objectsOut, System.IntPtr prioritiesRef)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, numObjects, (void *)objectsOut, (void *)prioritiesRef, (*(void ***)this._nativePointer)[46]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("30baa41e-b15b-475c-a0bb-1af5c5b64328")]
    public partial class Device2 : SharpDX.Direct3D12.Device1
    {
        public Device2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Device2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Device2(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "descRef">No documentation.</param>
        /// <param name = "riid">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D12Device2::CreatePipelineState([In] const D3D12_PIPELINE_STATE_STREAM_DESC* pDesc,[In] const GUID&amp; riid,[Out] void** ppPipelineState)</unmanaged>
        /// <unmanaged-short>ID3D12Device2::CreatePipelineState</unmanaged-short>
        private unsafe SharpDX.Direct3D12.PipelineState CreatePipelineState(ref SharpDX.Direct3D12.PipelineStateStreamDescription descRef, System.Guid riid)
        {
            SharpDX.Direct3D12.PipelineStateStreamDescription.__Native descRef_ = default (SharpDX.Direct3D12.PipelineStateStreamDescription.__Native);
            SharpDX.Direct3D12.PipelineState pipelineStateOut;
            System.IntPtr pipelineStateOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            descRef.__MarshalTo(ref descRef_);
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, &descRef_, &riid, &pipelineStateOut_, (*(void ***)this._nativePointer)[47]);
            if (pipelineStateOut_ != System.IntPtr.Zero)
                pipelineStateOut = new SharpDX.Direct3D12.PipelineState(pipelineStateOut_);
            else
                pipelineStateOut = null;
            descRef.__MarshalFree(ref descRef_);
            __result__.CheckError();
            return pipelineStateOut;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("81dadc15-2bad-4392-93c5-101345c4aa98")]
    public partial class Device3 : SharpDX.Direct3D12.Device2
    {
        public Device3(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Device3(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Device3(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "addressRef">No documentation.</param>
        /// <param name = "riid">No documentation.</param>
        /// <param name = "vHeapOut">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D12Device3::OpenExistingHeapFromAddress([In] const void* pAddress,[In] const GUID&amp; riid,[Out] void** ppvHeap)</unmanaged>
        /// <unmanaged-short>ID3D12Device3::OpenExistingHeapFromAddress</unmanaged-short>
        public unsafe void OpenExistingHeapFromAddress(System.IntPtr addressRef, System.Guid riid, out System.IntPtr vHeapOut)
        {
            SharpDX.Result __result__;
            fixed (void *vHeapOut_ = &vHeapOut)
                __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, (void *)addressRef, &riid, vHeapOut_, (*(void ***)this._nativePointer)[48]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "hFileMapping">No documentation.</param>
        /// <param name = "riid">No documentation.</param>
        /// <param name = "vHeapOut">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D12Device3::OpenExistingHeapFromFileMapping([In] void* hFileMapping,[In] const GUID&amp; riid,[Out] void** ppvHeap)</unmanaged>
        /// <unmanaged-short>ID3D12Device3::OpenExistingHeapFromFileMapping</unmanaged-short>
        public unsafe void OpenExistingHeapFromFileMapping(System.IntPtr hFileMapping, System.Guid riid, out System.IntPtr vHeapOut)
        {
            SharpDX.Result __result__;
            fixed (void *vHeapOut_ = &vHeapOut)
                __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, (void *)hFileMapping, &riid, vHeapOut_, (*(void ***)this._nativePointer)[49]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "flags">No documentation.</param>
        /// <param name = "numObjects">No documentation.</param>
        /// <param name = "objectsOut">No documentation.</param>
        /// <param name = "fenceToSignalRef">No documentation.</param>
        /// <param name = "fenceValueToSignal">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D12Device3::EnqueueMakeResident([In] D3D12_RESIDENCY_FLAGS Flags,[In] unsigned int NumObjects,[In, Buffer] const ID3D12Pageable** ppObjects,[In] ID3D12Fence* pFenceToSignal,[In] unsigned longlong FenceValueToSignal)</unmanaged>
        /// <unmanaged-short>ID3D12Device3::EnqueueMakeResident</unmanaged-short>
        public unsafe void EnqueueMakeResident(SharpDX.Direct3D12.ResidencyFlags flags, System.Int32 numObjects, SharpDX.Direct3D12.Pageable[] objectsOut, SharpDX.Direct3D12.Fence fenceToSignalRef, System.Int64 fenceValueToSignal)
        {
            System.IntPtr*objectsOut_;
            objectsOut_ = (System.IntPtr*)0;
            if (objectsOut != null)
            {
                System.IntPtr*_objectsOut = stackalloc System.IntPtr[objectsOut.Length];
                objectsOut_ = _objectsOut;
            }

            System.IntPtr fenceToSignalRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            if (objectsOut != null)
                for (int i = 0; i < objectsOut.Length; ++i)
                    (objectsOut_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Pageable>(objectsOut[i]);
            fenceToSignalRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Fence>(fenceToSignalRef);
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)flags), numObjects, (void *)objectsOut_, (void *)fenceToSignalRef_, fenceValueToSignal, (*(void ***)this._nativePointer)[50]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "flags">No documentation.</param>
        /// <param name = "numObjects">No documentation.</param>
        /// <param name = "objectsOut">No documentation.</param>
        /// <param name = "fenceToSignalRef">No documentation.</param>
        /// <param name = "fenceValueToSignal">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D12Device3::EnqueueMakeResident([In] D3D12_RESIDENCY_FLAGS Flags,[In] unsigned int NumObjects,[In, Buffer] const ID3D12Pageable** ppObjects,[In] ID3D12Fence* pFenceToSignal,[In] unsigned longlong FenceValueToSignal)</unmanaged>
        /// <unmanaged-short>ID3D12Device3::EnqueueMakeResident</unmanaged-short>
        public unsafe void EnqueueMakeResident(SharpDX.Direct3D12.ResidencyFlags flags, System.Int32 numObjects, SharpDX.ComArray<SharpDX.Direct3D12.Pageable> objectsOut, SharpDX.Direct3D12.Fence fenceToSignalRef, System.Int64 fenceValueToSignal)
        {
            System.IntPtr fenceToSignalRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fenceToSignalRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Fence>(fenceToSignalRef);
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)flags), numObjects, (void *)(objectsOut?.NativePointer ?? System.IntPtr.Zero), (void *)fenceToSignalRef_, fenceValueToSignal, (*(void ***)this._nativePointer)[50]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "flags">No documentation.</param>
        /// <param name = "numObjects">No documentation.</param>
        /// <param name = "objectsOut">No documentation.</param>
        /// <param name = "fenceToSignalRef">No documentation.</param>
        /// <param name = "fenceValueToSignal">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D12Device3::EnqueueMakeResident([In] D3D12_RESIDENCY_FLAGS Flags,[In] unsigned int NumObjects,[In, Buffer] const ID3D12Pageable** ppObjects,[In] ID3D12Fence* pFenceToSignal,[In] unsigned longlong FenceValueToSignal)</unmanaged>
        /// <unmanaged-short>ID3D12Device3::EnqueueMakeResident</unmanaged-short>
        private unsafe void EnqueueMakeResident(SharpDX.Direct3D12.ResidencyFlags flags, System.Int32 numObjects, System.IntPtr objectsOut, System.IntPtr fenceToSignalRef, System.Int64 fenceValueToSignal)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)flags), numObjects, (void *)objectsOut, (void *)fenceToSignalRef, fenceValueToSignal, (*(void ***)this._nativePointer)[50]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("e865df17-a9ee-46f9-a463-3098315aa2e5")]
    public partial class Device4 : SharpDX.Direct3D12.Device3
    {
        public Device4(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Device4(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Device4(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "nodeMask">No documentation.</param>
        /// <param name = "type">No documentation.</param>
        /// <param name = "flags">No documentation.</param>
        /// <param name = "riid">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D12Device4::CreateCommandList1([In] unsigned int nodeMask,[In] D3D12_COMMAND_LIST_TYPE type,[In] D3D12_COMMAND_LIST_FLAGS flags,[In] const GUID&amp; riid,[Out] void** ppCommandList)</unmanaged>
        /// <unmanaged-short>ID3D12Device4::CreateCommandList1</unmanaged-short>
        private unsafe System.IntPtr CreateCommandList1(System.Int32 nodeMask, SharpDX.Direct3D12.CommandListType type, SharpDX.Direct3D12.CommandListFlags flags, System.Guid riid)
        {
            System.IntPtr commandListOut;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, nodeMask, unchecked ((System.Int32)type), unchecked ((System.Int32)flags), &riid, &commandListOut, (*(void ***)this._nativePointer)[51]);
            __result__.CheckError();
            return commandListOut;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "descRef">No documentation.</param>
        /// <param name = "riid">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D12Device4::CreateProtectedResourceSession([In] const D3D12_PROTECTED_RESOURCE_SESSION_DESC* pDesc,[In] const GUID&amp; riid,[Out] void** ppSession)</unmanaged>
        /// <unmanaged-short>ID3D12Device4::CreateProtectedResourceSession</unmanaged-short>
        private unsafe SharpDX.Direct3D12.ProtectedResourceSession CreateProtectedResourceSession(SharpDX.Direct3D12.ProtectedResourceSessionDescription descRef, System.Guid riid)
        {
            SharpDX.Direct3D12.ProtectedResourceSession sessionOut;
            System.IntPtr sessionOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, &descRef, &riid, &sessionOut_, (*(void ***)this._nativePointer)[52]);
            if (sessionOut_ != System.IntPtr.Zero)
                sessionOut = new SharpDX.Direct3D12.ProtectedResourceSession(sessionOut_);
            else
                sessionOut = null;
            __result__.CheckError();
            return sessionOut;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "heapPropertiesRef">No documentation.</param>
        /// <param name = "heapFlags">No documentation.</param>
        /// <param name = "descRef">No documentation.</param>
        /// <param name = "initialResourceState">No documentation.</param>
        /// <param name = "optimizedClearValueRef">No documentation.</param>
        /// <param name = "protectedSessionRef">No documentation.</param>
        /// <param name = "riidResource">No documentation.</param>
        /// <param name = "vResourceOut">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D12Device4::CreateCommittedResource1([In] const D3D12_HEAP_PROPERTIES* pHeapProperties,[In] D3D12_HEAP_FLAGS HeapFlags,[In] const D3D12_RESOURCE_DESC* pDesc,[In] D3D12_RESOURCE_STATES InitialResourceState,[In, Optional] const D3D12_CLEAR_VALUE* pOptimizedClearValue,[In, Optional] ID3D12ProtectedResourceSession* pProtectedSession,[In] const GUID&amp; riidResource,[Out, Optional] void** ppvResource)</unmanaged>
        /// <unmanaged-short>ID3D12Device4::CreateCommittedResource1</unmanaged-short>
        public unsafe void CreateCommittedResource1(ref SharpDX.Direct3D12.HeapProperties heapPropertiesRef, SharpDX.Direct3D12.HeapFlags heapFlags, ref SharpDX.Direct3D12.ResourceDescription descRef, SharpDX.Direct3D12.ResourceStates initialResourceState, SharpDX.Direct3D12.ClearValue? optimizedClearValueRef, SharpDX.Direct3D12.ProtectedResourceSession protectedSessionRef, System.Guid riidResource, out System.IntPtr vResourceOut)
        {
            SharpDX.Direct3D12.ClearValue optimizedClearValueRef_;
            System.IntPtr protectedSessionRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            if (optimizedClearValueRef != null)
                optimizedClearValueRef_ = optimizedClearValueRef.Value;
            protectedSessionRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.ProtectedResourceSession>(protectedSessionRef);
            fixed (void *vResourceOut_ = &vResourceOut)
                fixed (void *descRef_ = &descRef)
                    fixed (void *heapPropertiesRef_ = &heapPropertiesRef)
                        __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, heapPropertiesRef_, unchecked ((System.Int32)heapFlags), descRef_, unchecked ((System.Int32)initialResourceState), optimizedClearValueRef == null ? (void *)0 : &optimizedClearValueRef_, (void *)protectedSessionRef_, &riidResource, vResourceOut_, (*(void ***)this._nativePointer)[53]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "descRef">No documentation.</param>
        /// <param name = "protectedSessionRef">No documentation.</param>
        /// <param name = "riid">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D12Device4::CreateHeap1([In] const D3D12_HEAP_DESC* pDesc,[In, Optional] ID3D12ProtectedResourceSession* pProtectedSession,[In] const GUID&amp; riid,[Out] void** ppvHeap)</unmanaged>
        /// <unmanaged-short>ID3D12Device4::CreateHeap1</unmanaged-short>
        private unsafe SharpDX.Direct3D12.Heap1 CreateHeap1(ref SharpDX.Direct3D12.HeapDescription descRef, SharpDX.Direct3D12.ProtectedResourceSession protectedSessionRef, System.Guid riid)
        {
            System.IntPtr protectedSessionRef_ = System.IntPtr.Zero;
            SharpDX.Direct3D12.Heap1 vHeapOut;
            System.IntPtr vHeapOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            protectedSessionRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.ProtectedResourceSession>(protectedSessionRef);
            fixed (void *descRef_ = &descRef)
                __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, descRef_, (void *)protectedSessionRef_, &riid, &vHeapOut_, (*(void ***)this._nativePointer)[54]);
            if (vHeapOut_ != System.IntPtr.Zero)
                vHeapOut = new SharpDX.Direct3D12.Heap1(vHeapOut_);
            else
                vHeapOut = null;
            __result__.CheckError();
            return vHeapOut;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "descRef">No documentation.</param>
        /// <param name = "initialState">No documentation.</param>
        /// <param name = "optimizedClearValueRef">No documentation.</param>
        /// <param name = "protectedSessionRef">No documentation.</param>
        /// <param name = "riid">No documentation.</param>
        /// <param name = "vResourceOut">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D12Device4::CreateReservedResource1([In] const D3D12_RESOURCE_DESC* pDesc,[In] D3D12_RESOURCE_STATES InitialState,[In, Optional] const D3D12_CLEAR_VALUE* pOptimizedClearValue,[In, Optional] ID3D12ProtectedResourceSession* pProtectedSession,[In] const GUID&amp; riid,[Out, Optional] void** ppvResource)</unmanaged>
        /// <unmanaged-short>ID3D12Device4::CreateReservedResource1</unmanaged-short>
        public unsafe void CreateReservedResource1(ref SharpDX.Direct3D12.ResourceDescription descRef, SharpDX.Direct3D12.ResourceStates initialState, SharpDX.Direct3D12.ClearValue? optimizedClearValueRef, SharpDX.Direct3D12.ProtectedResourceSession protectedSessionRef, System.Guid riid, out System.IntPtr vResourceOut)
        {
            SharpDX.Direct3D12.ClearValue optimizedClearValueRef_;
            System.IntPtr protectedSessionRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            if (optimizedClearValueRef != null)
                optimizedClearValueRef_ = optimizedClearValueRef.Value;
            protectedSessionRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.ProtectedResourceSession>(protectedSessionRef);
            fixed (void *vResourceOut_ = &vResourceOut)
                fixed (void *descRef_ = &descRef)
                    __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, descRef_, unchecked ((System.Int32)initialState), optimizedClearValueRef == null ? (void *)0 : &optimizedClearValueRef_, (void *)protectedSessionRef_, &riid, vResourceOut_, (*(void ***)this._nativePointer)[55]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "visibleMask">No documentation.</param>
        /// <param name = "numResourceDescs">No documentation.</param>
        /// <param name = "resourceDescsRef">No documentation.</param>
        /// <param name = "resourceAllocationInfo1Ref">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>D3D12_RESOURCE_ALLOCATION_INFO ID3D12Device4::GetResourceAllocationInfo1([In] unsigned int visibleMask,[In] unsigned int numResourceDescs,[In, Buffer] const D3D12_RESOURCE_DESC* pResourceDescs,[Out, Buffer, Optional] D3D12_RESOURCE_ALLOCATION_INFO1* pResourceAllocationInfo1)</unmanaged>
        /// <unmanaged-short>ID3D12Device4::GetResourceAllocationInfo1</unmanaged-short>
        public unsafe SharpDX.Direct3D12.ResourceAllocationInformation GetResourceAllocationInfo1(System.Int32 visibleMask, System.Int32 numResourceDescs, SharpDX.Direct3D12.ResourceDescription[] resourceDescsRef, SharpDX.Direct3D12.ResourceAllocationInformation1[] resourceAllocationInfo1Ref)
        {
            SharpDX.Direct3D12.ResourceAllocationInformation __result__;
            fixed (void *resourceAllocationInfo1Ref_ = resourceAllocationInfo1Ref)
                fixed (void *resourceDescsRef_ = resourceDescsRef)
                    SharpDX.Direct3D12.LocalInterop.CalliStdCallvoidPtr(this._nativePointer, &__result__, visibleMask, numResourceDescs, resourceDescsRef_, resourceAllocationInfo1Ref_, (*(void ***)this._nativePointer)[56]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("8b4f173b-2fea-4b80-8f58-4307191ab95d")]
    public partial class Device5 : SharpDX.Direct3D12.Device4
    {
        public Device5(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Device5(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Device5(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "ownerRef">No documentation.</param>
        /// <param name = "riid">No documentation.</param>
        /// <param name = "vTrackerOut">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D12Device5::CreateLifetimeTracker([In] ID3D12LifetimeOwner* pOwner,[In] const GUID&amp; riid,[Out] void** ppvTracker)</unmanaged>
        /// <unmanaged-short>ID3D12Device5::CreateLifetimeTracker</unmanaged-short>
        public unsafe void CreateLifetimeTracker(SharpDX.Direct3D12.LifetimeOwner ownerRef, System.Guid riid, out System.IntPtr vTrackerOut)
        {
            System.IntPtr ownerRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            ownerRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.LifetimeOwner>(ownerRef);
            fixed (void *vTrackerOut_ = &vTrackerOut)
                __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, (void *)ownerRef_, &riid, vTrackerOut_, (*(void ***)this._nativePointer)[57]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>void ID3D12Device5::RemoveDevice()</unmanaged>
        /// <unmanaged-short>ID3D12Device5::RemoveDevice</unmanaged-short>
        public unsafe void RemoveDevice()
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (*(void ***)this._nativePointer)[58]);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "numMetaCommandsRef">No documentation.</param>
        /// <param name = "descsRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D12Device5::EnumerateMetaCommands([InOut] unsigned int* pNumMetaCommands,[Out, Buffer, Optional] D3D12_META_COMMAND_DESC* pDescs)</unmanaged>
        /// <unmanaged-short>ID3D12Device5::EnumerateMetaCommands</unmanaged-short>
        public unsafe void EnumerateMetaCommands(ref System.Int32 numMetaCommandsRef, SharpDX.Direct3D12.MetaCommandDescription[] descsRef)
        {
            SharpDX.Direct3D12.MetaCommandDescription.__Native[] descsRef_ = descsRef == null ? null : new SharpDX.Direct3D12.MetaCommandDescription.__Native[descsRef.Length];
            SharpDX.Result __result__;
            fixed (void *_descsRef = descsRef_)
                fixed (void *numMetaCommandsRef_ = &numMetaCommandsRef)
                    __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, numMetaCommandsRef_, _descsRef, (*(void ***)this._nativePointer)[59]);
            if (descsRef != null)
                for (int i = 0; i < descsRef.Length; ++i)
                    if (descsRef != null)
                        descsRef[i].__MarshalFrom(ref (descsRef_)[i]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "commandId">No documentation.</param>
        /// <param name = "stage">No documentation.</param>
        /// <param name = "totalStructureSizeInBytesRef">No documentation.</param>
        /// <param name = "parameterCountRef">No documentation.</param>
        /// <param name = "parameterDescsRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D12Device5::EnumerateMetaCommandParameters([In] const GUID&amp; CommandId,[In] D3D12_META_COMMAND_PARAMETER_STAGE Stage,[Out, Optional] unsigned int* pTotalStructureSizeInBytes,[InOut] unsigned int* pParameterCount,[Out, Buffer, Optional] D3D12_META_COMMAND_PARAMETER_DESC* pParameterDescs)</unmanaged>
        /// <unmanaged-short>ID3D12Device5::EnumerateMetaCommandParameters</unmanaged-short>
        public unsafe void EnumerateMetaCommandParameters(System.Guid commandId, SharpDX.Direct3D12.MetaCommandParameterStage stage, out System.Int32 totalStructureSizeInBytesRef, ref System.Int32 parameterCountRef, SharpDX.Direct3D12.MetaCommandParameterDescription[] parameterDescsRef)
        {
            SharpDX.Direct3D12.MetaCommandParameterDescription.__Native[] parameterDescsRef_ = parameterDescsRef == null ? null : new SharpDX.Direct3D12.MetaCommandParameterDescription.__Native[parameterDescsRef.Length];
            SharpDX.Result __result__;
            fixed (void *_parameterDescsRef = parameterDescsRef_)
                fixed (void *parameterCountRef_ = &parameterCountRef)
                    fixed (void *totalStructureSizeInBytesRef_ = &totalStructureSizeInBytesRef)
                        __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, &commandId, unchecked ((System.Int32)stage), totalStructureSizeInBytesRef_, parameterCountRef_, _parameterDescsRef, (*(void ***)this._nativePointer)[60]);
            if (parameterDescsRef != null)
                for (int i = 0; i < parameterDescsRef.Length; ++i)
                    if (parameterDescsRef != null)
                        parameterDescsRef[i].__MarshalFrom(ref (parameterDescsRef_)[i]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "commandId">No documentation.</param>
        /// <param name = "nodeMask">No documentation.</param>
        /// <param name = "creationParametersDataRef">No documentation.</param>
        /// <param name = "creationParametersDataSizeInBytes">No documentation.</param>
        /// <param name = "riid">No documentation.</param>
        /// <param name = "metaCommandOut">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D12Device5::CreateMetaCommand([In] const GUID&amp; CommandId,[In] unsigned int NodeMask,[In, Buffer, Optional] const void* pCreationParametersData,[In] SIZE_T CreationParametersDataSizeInBytes,[In] const GUID&amp; riid,[Out] void** ppMetaCommand)</unmanaged>
        /// <unmanaged-short>ID3D12Device5::CreateMetaCommand</unmanaged-short>
        public unsafe void CreateMetaCommand(System.Guid commandId, System.Int32 nodeMask, System.IntPtr creationParametersDataRef, SharpDX.PointerSize creationParametersDataSizeInBytes, System.Guid riid, out System.IntPtr metaCommandOut)
        {
            SharpDX.Result __result__;
            fixed (void *metaCommandOut_ = &metaCommandOut)
                __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, &commandId, nodeMask, (void *)creationParametersDataRef, (void *)creationParametersDataSizeInBytes, &riid, metaCommandOut_, (*(void ***)this._nativePointer)[61]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "descRef">No documentation.</param>
        /// <param name = "riid">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D12Device5::CreateStateObject([In] const D3D12_STATE_OBJECT_DESC* pDesc,[In] const GUID&amp; riid,[Out] void** ppStateObject)</unmanaged>
        /// <unmanaged-short>ID3D12Device5::CreateStateObject</unmanaged-short>
        private unsafe SharpDX.Direct3D12.StateObject CreateStateObject(SharpDX.Direct3D12.StateObjectDescription descRef, System.Guid riid)
        {
            SharpDX.Direct3D12.StateObject stateObjectOut;
            System.IntPtr stateObjectOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, &descRef, &riid, &stateObjectOut_, (*(void ***)this._nativePointer)[62]);
            if (stateObjectOut_ != System.IntPtr.Zero)
                stateObjectOut = new SharpDX.Direct3D12.StateObject(stateObjectOut_);
            else
                stateObjectOut = null;
            __result__.CheckError();
            return stateObjectOut;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "descRef">No documentation.</param>
        /// <unmanaged>void ID3D12Device5::GetRaytracingAccelerationStructurePrebuildInfo([In] const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS* pDesc,[Out] D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO* pInfo)</unmanaged>
        /// <unmanaged-short>ID3D12Device5::GetRaytracingAccelerationStructurePrebuildInfo</unmanaged-short>
        public unsafe SharpDX.Direct3D12.RaytracingAccelerationStructurePrebuildInformation GetRaytracingAccelerationStructurePrebuildInfo(SharpDX.Direct3D12.BuildRaytracingAccelerationStructureInputs descRef)
        {
            SharpDX.Direct3D12.BuildRaytracingAccelerationStructureInputs.__Native descRef_ = default (SharpDX.Direct3D12.BuildRaytracingAccelerationStructureInputs.__Native);
            SharpDX.Direct3D12.RaytracingAccelerationStructurePrebuildInformation infoRef;
            descRef.__MarshalTo(ref descRef_);
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, &descRef_, &infoRef, (*(void ***)this._nativePointer)[63]);
            descRef.__MarshalFree(ref descRef_);
            return infoRef;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "serializedDataType">No documentation.</param>
        /// <param name = "identifierToCheckRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS ID3D12Device5::CheckDriverMatchingIdentifier([In] D3D12_SERIALIZED_DATA_TYPE SerializedDataType,[In] const D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER* pIdentifierToCheck)</unmanaged>
        /// <unmanaged-short>ID3D12Device5::CheckDriverMatchingIdentifier</unmanaged-short>
        public unsafe SharpDX.Direct3D12.DriverMatchingIdentifierStatus CheckDriverMatchingIdentifier(SharpDX.Direct3D12.SerializedDataType serializedDataType, ref SharpDX.Direct3D12.SerializedDataDriverMatchingIdentifier identifierToCheckRef)
        {
            SharpDX.Direct3D12.SerializedDataDriverMatchingIdentifier.__Native identifierToCheckRef_ = default (SharpDX.Direct3D12.SerializedDataDriverMatchingIdentifier.__Native);
            SharpDX.Direct3D12.DriverMatchingIdentifierStatus __result__;
            identifierToCheckRef.__MarshalTo(ref identifierToCheckRef_);
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallSharpDXDirect3D12DriverMatchingIdentifierStatus(this._nativePointer, unchecked ((System.Int32)serializedDataType), &identifierToCheckRef_, (*(void ***)this._nativePointer)[64]);
            identifierToCheckRef.__MarshalFree(ref identifierToCheckRef_);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("905db94b-a00c-4140-9df5-2b64ca9ea357")]
    public partial class DeviceChild : SharpDX.Direct3D12.Object
    {
        public DeviceChild(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DeviceChild(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DeviceChild(nativePtr);
        /// <summary>
        /// <p>Gets a reference to the device that created this interface. </p>
        /// </summary>
        /// <param name = "riid"><dd>  <p> The globally unique identifier (<strong><see cref = "System.Guid"/></strong>) for the device interface. The <strong>REFIID</strong>, or <strong><see cref = "System.Guid"/></strong>, of the interface to the device can be obtained by using the __uuidof() macro. For example, __uuidof(<strong><see cref = "SharpDX.Direct3D12.Device"/></strong>) will get the <strong><see cref = "System.Guid"/></strong> of the interface to a device. </p> </dd></param>
        /// <param name = "vDeviceOut"><dd>  <p> A reference to a memory block that receives a reference to the <strong><see cref = "SharpDX.Direct3D12.Device"/></strong> interface for the device. </p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. </p></returns>
        /// <remarks>
        /// <p> Any returned interfaces have their reference count incremented by one, so be sure to call ::release() on the returned references before they are freed or else you will have a memory leak. </p>
        /// </remarks>
        /// <doc-id>dn788652</doc-id>
        /// <unmanaged>HRESULT ID3D12DeviceChild::GetDevice([In] const GUID&amp; riid,[Out, Optional] void** ppvDevice)</unmanaged>
        /// <unmanaged-short>ID3D12DeviceChild::GetDevice</unmanaged-short>
        public unsafe void GetDevice(System.Guid riid, out System.IntPtr vDeviceOut)
        {
            SharpDX.Result __result__;
            fixed (void *vDeviceOut_ = &vDeviceOut)
                __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, &riid, vDeviceOut_, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("0a753dcf-c4d8-4b91-adf6-be5a60d95a76")]
    public partial class Fence : SharpDX.Direct3D12.Pageable
    {
        public Fence(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Fence(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Fence(nativePtr);
        /// <summary>
        /// <p>Gets the current value of the fence.</p>
        /// </summary>
        /// <doc-id>dn899189</doc-id>
        /// <unmanaged>GetCompletedValue</unmanaged>
        /// <unmanaged-short>GetCompletedValue</unmanaged-short>
        public System.Int64 CompletedValue
        {
            get => GetCompletedValue();
        }

        /// <summary>
        /// <p>Gets the current value of the fence.</p>
        /// </summary>
        /// <returns><p>Returns the current value of the fence. </p></returns>
        /// <doc-id>dn899189</doc-id>
        /// <unmanaged>unsigned longlong ID3D12Fence::GetCompletedValue()</unmanaged>
        /// <unmanaged-short>ID3D12Fence::GetCompletedValue</unmanaged-short>
        internal unsafe System.Int64 GetCompletedValue()
        {
            System.Int64 __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCalllong(this._nativePointer, (*(void ***)this._nativePointer)[8]);
            return __result__;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "value">No documentation.</param>
        /// <param name = "hEvent">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D12Fence::SetEventOnCompletion([In] unsigned longlong Value,[In] void* hEvent)</unmanaged>
        /// <unmanaged-short>ID3D12Fence::SetEventOnCompletion</unmanaged-short>
        public unsafe void SetEventOnCompletion(System.Int64 value, System.IntPtr hEvent)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, value, (void *)hEvent, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the fence to the specified value.</p>
        /// </summary>
        /// <param name = "value"><dd>  <p>The value to set the fence to.</p> </dd></param>
        /// <returns><p>This method returns one of the Direct3D 12 Return Codes. </p></returns>
        /// <remarks>
        /// <p>Use this method to set a fence value from the CPU side. Use <strong>ID3D12CommandQueue::Signal</strong> to set a fence from the GPU side.</p>
        /// </remarks>
        /// <doc-id>dn899191</doc-id>
        /// <unmanaged>HRESULT ID3D12Fence::Signal([In] unsigned longlong Value)</unmanaged>
        /// <unmanaged-short>ID3D12Fence::Signal</unmanaged-short>
        public unsafe void Signal(System.Int64 value)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, value, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("433685fe-e22b-4ca0-a8db-b5b4f4dd0e4a")]
    public partial class Fence1 : SharpDX.Direct3D12.Fence
    {
        public Fence1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Fence1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Fence1(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>GetCreationFlags</unmanaged>
        /// <unmanaged-short>GetCreationFlags</unmanaged-short>
        public SharpDX.Direct3D12.FenceFlags CreationFlags
        {
            get => GetCreationFlags();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <returns>No documentation.</returns>
        /// <unmanaged>D3D12_FENCE_FLAGS ID3D12Fence1::GetCreationFlags()</unmanaged>
        /// <unmanaged-short>ID3D12Fence1::GetCreationFlags</unmanaged-short>
        internal unsafe SharpDX.Direct3D12.FenceFlags GetCreationFlags()
        {
            SharpDX.Direct3D12.FenceFlags __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallSharpDXDirect3D12FenceFlags(this._nativePointer, (*(void ***)this._nativePointer)[11]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("5b160d0f-ac1b-4185-8ba8-b3ae42a5a455")]
    public partial class GraphicsCommandList : SharpDX.Direct3D12.CommandList
    {
        public GraphicsCommandList(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator GraphicsCommandList(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new GraphicsCommandList(nativePtr);
        /// <summary>
        /// <p>Bind information about the primitive type, and data order that describes input data for the input assembler stage.</p>
        /// </summary>
        /// <doc-id>dn903885</doc-id>
        /// <unmanaged>IASetPrimitiveTopology</unmanaged>
        /// <unmanaged-short>IASetPrimitiveTopology</unmanaged-short>
        public SharpDX.Direct3D.PrimitiveTopology PrimitiveTopology
        {
            set => SetPrimitiveTopology(value);
        }

        /// <summary>
        /// <p>Sets the blend factor that modulate values for a pixel shader, render target, or both.</p>
        /// </summary>
        /// <remarks>
        /// <p> If you created the blend-state object with D3D11_BLEND_BLEND_FACTOR or D3D11_BLEND_INV_BLEND_FACTOR, the blending stage uses the non-<c>null</c> array of blend factors. </p><p> If you didn't create the blend-state object with D3D11_BLEND_BLEND_FACTOR or D3D11_BLEND_INV_BLEND_FACTOR, the blending stage does not use the non-<c>null</c> array of blend factors; the runtime stores the blend factors. </p><p> If you pass <c>null</c>, the runtime uses or stores a blend factor equal to { 1, 1, 1, 1 }. </p><p> D3D11_BLEND_BLEND_FACTOR and D3D11_BLEND_INV_BLEND_FACTOR are <strong><see cref = "SharpDX.Direct3D12.BlendOption"/></strong> enumeration constants. </p>
        /// </remarks>
        /// <doc-id>dn903886</doc-id>
        /// <unmanaged>OMSetBlendFactor</unmanaged>
        /// <unmanaged-short>OMSetBlendFactor</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector4 BlendFactor
        {
            set => SetBlendFactor(value);
        }

        /// <summary>
        /// <p>Sets the reference value for depth stencil tests.</p>
        /// </summary>
        /// <doc-id>dn903887</doc-id>
        /// <unmanaged>OMSetStencilRef</unmanaged>
        /// <unmanaged-short>OMSetStencilRef</unmanaged-short>
        public System.Int32 StencilReference
        {
            set => SetStencilReference(value);
        }

        /// <summary>
        /// <p> Sets all shaders and programs most of the fixed-function state of the graphics processing unit (GPU) pipeline. </p>
        /// </summary>
        /// <doc-id>dn903918</doc-id>
        /// <unmanaged>SetPipelineState</unmanaged>
        /// <unmanaged-short>SetPipelineState</unmanaged-short>
        public SharpDX.Direct3D12.PipelineState PipelineState
        {
            set => SetPipelineState(value);
        }

        /// <summary>
        /// <p> Indicates that recording to the command list has finished. </p>
        /// </summary>
        /// <returns><p> Returns <strong><see cref = "SharpDX.Result.Ok"/></strong> if successful; otherwise, returns one of the following values: </p><ul> <li><strong>E_FAIL</strong> if the command list has already been closed, or an invalid API was called during command list recording. </li> <li><strong>E_OUTOFMEMORY</strong> if the operating system ran out of memory during recording. </li> <li><strong>E_INVALIDARG</strong> if an invalid argument was passed to the command list API during recording. </li> </ul><p> See Direct3D 12 Return Codes for other possible return values. </p></returns>
        /// <remarks>
        /// <p> The runtime will validate that the command list has not previously been closed.  If an error was encountered during recording, the error code is returned here.  The runtime won't call the close device driver interface (DDI) in this case. </p>
        /// </remarks>
        /// <doc-id>dn903855</doc-id>
        /// <unmanaged>HRESULT ID3D12GraphicsCommandList::Close()</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::Close</unmanaged-short>
        public unsafe void Close()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Resets a command list back to its initial state as if a new command list was just created. </p>
        /// </summary>
        /// <param name = "allocatorRef"><dd>  <p> A reference to the <strong><see cref = "SharpDX.Direct3D12.CommandAllocator"/></strong> object that the device creates command lists from. </p> </dd></param>
        /// <param name = "initialStateRef"><dd>  <p>A reference to the <strong><see cref = "SharpDX.Direct3D12.PipelineState"/></strong> object that contains the initial pipeline state for the command list.  This is optional and can be <c>null</c>.  If <c>null</c>, the runtime sets a dummy initial pipeline state so that drivers don't have to deal with undefined state.  The overhead for this is low, particularly for a command list, for which the overall cost of recording the command list likely dwarfs the cost of one initial state setting.  So there is little cost in  not setting the initial pipeline state parameter if it isn't convenient.  </p> <p>For bundles on the other hand, it might make more sense to try to set the initial state parameter since bundles are likely smaller overall and can be reused frequently.</p> </dd></param>
        /// <returns><p> Returns <strong><see cref = "SharpDX.Result.Ok"/></strong> if successful; otherwise, returns one of the following values: </p><ul> <li><strong>E_FAIL</strong> if the command list was not in the "closed" state when the <strong>Reset</strong> call was made, or the per-device limit would have been exceeded. </li> <li><strong>E_OUTOFMEMORY</strong> if the operating system ran out of memory. </li> <li><strong>E_INVALIDARG</strong> if the allocator is currently being used with another command list in the "recording" state or if the specified allocator was created with the wrong type. </li> </ul><p> See Direct3D 12 Return Codes for other possible return values. </p></returns>
        /// <remarks>
        /// <p> By using <strong>Reset</strong>, you can re-use command list tracking structures without any allocations. Unlike <strong>ID3D12CommandAllocator::Reset</strong>, you can call <strong>Reset</strong> while the command list is still being executed. A typical pattern is to submit a command list and then immediately reset it to reuse the allocated memory for another command list. </p><p> You can use <strong>Reset</strong> for both direct command lists and bundles. </p><p> The command allocator that <strong>Reset</strong> takes as input can be associated with no more than one recording command list at a time.  The allocator type, direct command list or bundle, must match the type of command list that is being created. </p><p> If a bundle doesn't specify a resource heap, it can't make changes to which descriptor tables are bound. Either way, bundles can't change the resource heap within the bundle. If a heap is specified for a bundle, the heap must match the calling 'parent' command list?s heap. </p>
        /// </remarks>
        /// <doc-id>dn903895</doc-id>
        /// <unmanaged>HRESULT ID3D12GraphicsCommandList::Reset([In] ID3D12CommandAllocator* pAllocator,[In, Optional] ID3D12PipelineState* pInitialState)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::Reset</unmanaged-short>
        public unsafe void Reset(SharpDX.Direct3D12.CommandAllocator allocatorRef, SharpDX.Direct3D12.PipelineState initialStateRef)
        {
            System.IntPtr allocatorRef_ = System.IntPtr.Zero;
            System.IntPtr initialStateRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            allocatorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.CommandAllocator>(allocatorRef);
            initialStateRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.PipelineState>(initialStateRef);
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, (void *)allocatorRef_, (void *)initialStateRef_, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Resets the state of a direct command list back to the state it was in when the command list was created.  </p>
        /// </summary>
        /// <param name = "pipelineStateRef"><dd>  <p> A reference to the <strong><see cref = "SharpDX.Direct3D12.PipelineState"/></strong> object that contains the initial pipeline state for the command list. </p> </dd></param>
        /// <remarks>
        /// <p> It is invalid to call <strong>ClearState</strong> on a bundle.  If an app calls <strong>ClearState</strong> on a bundle, the call to <strong>Close</strong> will return <strong>E_FAIL</strong>. </p><p> When <strong>ClearState</strong> is called, all currently bound resources are unbound.  The primitive topology is set to <strong>D3D_PRIMITIVE_TOPOLOGY_UNDEFINED</strong>.  Viewports, scissor rectangles, stencil reference value, and the blend factor are set to empty values (all zeros).  Predication is disabled. </p><p> The app-provided pipeline state object becomes bound as the currently set pipeline state object. </p>
        /// </remarks>
        /// <doc-id>dn903847</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::ClearState([In, Optional] ID3D12PipelineState* pPipelineState)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::ClearState</unmanaged-short>
        public unsafe void ClearState(SharpDX.Direct3D12.PipelineState pipelineStateRef)
        {
            System.IntPtr pipelineStateRef_ = System.IntPtr.Zero;
            pipelineStateRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.PipelineState>(pipelineStateRef);
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)pipelineStateRef_, (*(void ***)this._nativePointer)[11]);
        }

        /// <summary>
        /// <p> Draws non-indexed, instanced primitives. </p>
        /// </summary>
        /// <param name = "vertexCountPerInstance"><dd>  <p> Number of vertices to draw. </p> </dd></param>
        /// <param name = "instanceCount"><dd>  <p> Number of instances to draw. </p> </dd></param>
        /// <param name = "startVertexLocation"><dd>  <p> Index of the first vertex. </p> </dd></param>
        /// <param name = "startInstanceLocation"><dd>  <p> A value added to each index before reading per-instance data from a vertex buffer. </p> </dd></param>
        /// <remarks>
        /// <p> A draw API submits work to the rendering pipeline. </p><p> Instancing might extend performance by reusing the same geometry to draw multiple objects in a scene. One example of instancing could be to draw the same object with different positions and colors. </p><p> The vertex data for an instanced draw call typically comes from a vertex buffer that is bound to the pipeline. But, you could also provide the vertex data from a shader that has instanced data identified with a system-value semantic (SV_InstanceID). </p>
        /// </remarks>
        /// <doc-id>dn903877</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::DrawInstanced([In] unsigned int VertexCountPerInstance,[In] unsigned int InstanceCount,[In] unsigned int StartVertexLocation,[In] unsigned int StartInstanceLocation)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::DrawInstanced</unmanaged-short>
        public unsafe void DrawInstanced(System.Int32 vertexCountPerInstance, System.Int32 instanceCount, System.Int32 startVertexLocation, System.Int32 startInstanceLocation)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, vertexCountPerInstance, instanceCount, startVertexLocation, startInstanceLocation, (*(void ***)this._nativePointer)[12]);
        }

        /// <summary>
        /// <p> Draws indexed, instanced primitives. </p>
        /// </summary>
        /// <param name = "indexCountPerInstance"><dd>  <p>Number of indices read from the index buffer for each instance.</p> </dd></param>
        /// <param name = "instanceCount"><dd>  <p>Number of instances to draw.</p> </dd></param>
        /// <param name = "startIndexLocation"><dd>  <p>The location of the first index read by the GPU from the index buffer.</p> </dd></param>
        /// <param name = "baseVertexLocation"><dd>  <p>A value added to each index before reading a vertex from the vertex buffer.</p> </dd></param>
        /// <param name = "startInstanceLocation"><dd>  <p>A value added to each index before reading per-instance data from a vertex buffer.</p> </dd></param>
        /// <remarks>
        /// <p>A draw API submits work to the rendering pipeline.</p><p>Instancing might extend performance by reusing the same geometry to draw multiple objects in a scene. One example of instancing could be  to draw the same object with different positions and colors. Instancing requires multiple vertex buffers: at least one for per-vertex data  and a second buffer for per-instance data.</p>
        /// </remarks>
        /// <doc-id>dn903874</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::DrawIndexedInstanced([In] unsigned int IndexCountPerInstance,[In] unsigned int InstanceCount,[In] unsigned int StartIndexLocation,[In] int BaseVertexLocation,[In] unsigned int StartInstanceLocation)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::DrawIndexedInstanced</unmanaged-short>
        public unsafe void DrawIndexedInstanced(System.Int32 indexCountPerInstance, System.Int32 instanceCount, System.Int32 startIndexLocation, System.Int32 baseVertexLocation, System.Int32 startInstanceLocation)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, indexCountPerInstance, instanceCount, startIndexLocation, baseVertexLocation, startInstanceLocation, (*(void ***)this._nativePointer)[13]);
        }

        /// <summary>
        /// <p>Executes a command list from a thread group.</p>
        /// </summary>
        /// <param name = "threadGroupCountX"><dd>  <p> The number of groups dispatched in the x direction. <em>ThreadGroupCountX</em> must be less than or equal to <see cref = "DispatchMaximumThreadGroupsPerDimension"/> (65535). </p> </dd></param>
        /// <param name = "threadGroupCountY"><dd>  <p> The number of groups dispatched in the y direction. <em>ThreadGroupCountY</em> must be less than or equal to <see cref = "DispatchMaximumThreadGroupsPerDimension"/> (65535). </p> </dd></param>
        /// <param name = "threadGroupCountZ"><dd>  <p> The number of groups dispatched in the z direction.  <em>ThreadGroupCountZ</em> must be less than or equal to <see cref = "DispatchMaximumThreadGroupsPerDimension"/> (65535). In feature level 10 the value for <em>ThreadGroupCountZ</em> must be 1. </p> </dd></param>
        /// <remarks>
        /// <p> You call the <strong>Dispatch</strong> method to execute commands in a compute shader. A compute shader can be run on many threads in parallel, within a thread group. Index a particular thread, within a thread group using a 3D vector given by (x,y,z). </p>
        /// </remarks>
        /// <doc-id>dn903871</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::Dispatch([In] unsigned int ThreadGroupCountX,[In] unsigned int ThreadGroupCountY,[In] unsigned int ThreadGroupCountZ)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::Dispatch</unmanaged-short>
        public unsafe void Dispatch(System.Int32 threadGroupCountX, System.Int32 threadGroupCountY, System.Int32 threadGroupCountZ)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, threadGroupCountX, threadGroupCountY, threadGroupCountZ, (*(void ***)this._nativePointer)[14]);
        }

        /// <summary>
        /// <p> Copies a region of a buffer from one resource to another. </p>
        /// </summary>
        /// <param name = "dstBufferRef"><dd>  <p> Specifies the destination <strong><see cref = "SharpDX.Direct3D12.Resource"/></strong>. </p> </dd></param>
        /// <param name = "dstOffset"><dd>  <p> Specifies a UINT64 offset (in bytes) into the destination resource. </p> </dd></param>
        /// <param name = "srcBufferRef"><dd>  <p> Specifies the source  <strong><see cref = "SharpDX.Direct3D12.Resource"/></strong>. </p> </dd></param>
        /// <param name = "srcOffset"><dd>  <p> Specifies a UINT64 offset (in bytes) into the source resource, to start the copy from. </p> </dd></param>
        /// <param name = "numBytes"><dd>  <p> Specifies the number of bytes to copy. </p> </dd></param>
        /// <remarks>
        /// <p> Consider using the <strong>CopyResource</strong> method when copying an entire resource, and use this method for copying regions of a resource. </p><p><strong>CopyBufferRegion</strong> may be used to initialize resources which alias the same heap memory. See <strong>CreatePlacedResource</strong> for more details.</p>
        /// </remarks>
        /// <doc-id>dn903856</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::CopyBufferRegion([In] ID3D12Resource* pDstBuffer,[In] unsigned longlong DstOffset,[In] ID3D12Resource* pSrcBuffer,[In] unsigned longlong SrcOffset,[In] unsigned longlong NumBytes)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::CopyBufferRegion</unmanaged-short>
        public unsafe void CopyBufferRegion(SharpDX.Direct3D12.Resource dstBufferRef, System.Int64 dstOffset, SharpDX.Direct3D12.Resource srcBufferRef, System.Int64 srcOffset, System.Int64 numBytes)
        {
            System.IntPtr dstBufferRef_ = System.IntPtr.Zero;
            System.IntPtr srcBufferRef_ = System.IntPtr.Zero;
            dstBufferRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(dstBufferRef);
            srcBufferRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(srcBufferRef);
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)dstBufferRef_, dstOffset, (void *)srcBufferRef_, srcOffset, numBytes, (*(void ***)this._nativePointer)[15]);
        }

        /// <summary>
        /// <p> This method uses the GPU to copy texture data between two locations. Both the source and the destination may reference texture data located within either a buffer resource or a texture resource.</p>
        /// </summary>
        /// <param name = "dstRef"><dd>  <p>Specifies the destination <strong><see cref = "SharpDX.Direct3D12.TextureCopyLocation"/></strong>. The subresource referred to must be in the D3D12_RESOURCE_STATE_COPY_DEST state.</p> </dd></param>
        /// <param name = "dstX"><dd>  <p> The x-coordinate of the upper left corner of the destination region. </p> </dd></param>
        /// <param name = "dstY"><dd>  <p> The y-coordinate of the upper left corner of the destination region. For a 1D subresource, this must be zero. </p> </dd></param>
        /// <param name = "dstZ"><dd>  <p> The z-coordinate of the upper left corner of the destination region. For a 1D or 2D subresource, this must be zero. </p> </dd></param>
        /// <param name = "srcRef"><dd>  <p> Specifies the source <strong><see cref = "SharpDX.Direct3D12.TextureCopyLocation"/></strong>. The subresource referred to must be in the D3D12_RESOURCE_STATE_COPY_SOURCE state.</p> </dd></param>
        /// <param name = "srcBoxRef"><dd>  <p> Specifies an optional  <see cref = "SharpDX.Direct3D12.ResourceRegion"/> that sets the size of the source texture to copy. </p> </dd></param>
        /// <remarks>
        /// <p> The source box must be within the size of the source resource. The destination offsets, (x, y, and z), allow the source box to be offset when writing into the destination resource; however, the dimensions of the source box and the offsets must be within the size of the resource. If you try and copy outside the destination resource or specify a source box that is larger than the source resource, the behavior of <strong>CopyTextureRegion</strong> is undefined. If you created a device that supports the debug layer, the debug output reports an error on this invalid <strong>CopyTextureRegion</strong> call. Invalid parameters to <strong>CopyTextureRegion</strong> cause undefined behavior and might result in incorrect rendering, clipping, no copy, or even the removal of the rendering device. </p><p>If the resources are buffers, all coordinates are in bytes; if the resources are textures, all coordinates are in texels. </p><p><strong>CopyTextureRegion</strong> performs the copy on the GPU (similar to a <code>memcpy</code> by the CPU). As a consequence, the source and destination resources: </p><ul> <li>Must be different subresources (although they can be from the same resource).</li> <li>Must have compatible <strong><see cref = "SharpDX.DXGI.Format"/></strong>s (identical or from the same type group). For example, a DXGI_FORMAT_R32G32B32_FLOAT texture can be copied to an DXGI_FORMAT_R32G32B32_UINT texture since both of these formats are in the DXGI_FORMAT_R32G32B32_TYPELESS group. <strong>CopyTextureRegion</strong> can copy between a few format types. For more info, see Format Conversion using Direct3D 10.1.</li> </ul><p><strong>CopyTextureRegion</strong> only supports copy; it does not support any stretch, color key, or blend. <strong>CopyTextureRegion</strong> can reinterpret the resource data between a few format types. </p><p> If your app needs to copy an entire resource, we recommend to use <strong>CopyResource</strong> instead. </p><strong>Note</strong>?? If you use <strong>CopyTextureRegion</strong> with a depth-stencil buffer or a multisampled resource, you must copy the whole subresource. In this situation, you must pass 0 to the <em>DstX</em>, <em>DstY</em>, and <em>DstZ</em> parameters and <strong><c>null</c></strong> to the <em>pSrcBox</em> parameter. In addition, source and destination resources, which are represented by the <em>pSrcResource</em> and <em>pDstResource</em> parameters, should have identical sample count values.?<p><strong>CopyTextureRegion</strong> may be used to initialize resources which alias the same heap memory. See <strong>CreatePlacedResource</strong> for more details.</p>
        /// </remarks>
        /// <doc-id>dn903862</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::CopyTextureRegion([In] const D3D12_TEXTURE_COPY_LOCATION* pDst,[In] unsigned int DstX,[In] unsigned int DstY,[In] unsigned int DstZ,[In] const D3D12_TEXTURE_COPY_LOCATION* pSrc,[In, Optional] const D3D12_BOX* pSrcBox)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::CopyTextureRegion</unmanaged-short>
        public unsafe void CopyTextureRegion(SharpDX.Direct3D12.TextureCopyLocation dstRef, System.Int32 dstX, System.Int32 dstY, System.Int32 dstZ, SharpDX.Direct3D12.TextureCopyLocation srcRef, SharpDX.Direct3D12.ResourceRegion? srcBoxRef)
        {
            SharpDX.Direct3D12.ResourceRegion srcBoxRef_;
            if (srcBoxRef != null)
                srcBoxRef_ = srcBoxRef.Value;
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, &dstRef, dstX, dstY, dstZ, &srcRef, srcBoxRef == null ? (void *)0 : &srcBoxRef_, (*(void ***)this._nativePointer)[16]);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "dstResourceRef">No documentation.</param>
        /// <param name = "srcResourceRef">No documentation.</param>
        /// <unmanaged>void ID3D12GraphicsCommandList::CopyResource([In] ID3D12Resource* pDstResource,[In] ID3D12Resource* pSrcResource)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::CopyResource</unmanaged-short>
        public unsafe void CopyResource(SharpDX.Direct3D12.Resource dstResourceRef, SharpDX.Direct3D12.Resource srcResourceRef)
        {
            System.IntPtr dstResourceRef_ = System.IntPtr.Zero;
            System.IntPtr srcResourceRef_ = System.IntPtr.Zero;
            dstResourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(dstResourceRef);
            srcResourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(srcResourceRef);
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)dstResourceRef_, (void *)srcResourceRef_, (*(void ***)this._nativePointer)[17]);
        }

        /// <summary>
        /// <p> Copies tiles from buffer to tiled resource or vice versa. </p>
        /// </summary>
        /// <param name = "tiledResourceRef"><dd>  <p>A reference to a tiled resource.</p> </dd></param>
        /// <param name = "tileRegionStartCoordinateRef"><dd>  <p> A reference to a <strong><see cref = "SharpDX.Direct3D12.TiledResourceCoordinate"/></strong> structure that describes the starting coordinates of the tiled resource. </p> </dd></param>
        /// <param name = "tileRegionSizeRef"><dd>  <p> A reference to a <strong><see cref = "SharpDX.Direct3D12.TileRegionSize"/></strong> structure that describes the size of the tiled region. </p> </dd></param>
        /// <param name = "bufferRef"><dd>  <p> A reference to an <strong><see cref = "SharpDX.Direct3D12.Resource"/></strong> that represents a default, dynamic, or staging buffer. </p> </dd></param>
        /// <param name = "bufferStartOffsetInBytes"><dd>  <p> The offset in bytes into the buffer at <em>pBuffer</em> to start the operation. </p> </dd></param>
        /// <param name = "flags"><dd>  <p> A combination of <strong><see cref = "SharpDX.Direct3D12.TileCopyFlags"/></strong>-typed values that are combined by using a bitwise OR operation and that identifies how to copy tiles. </p> </dd></param>
        /// <remarks>
        /// <p><strong>CopyTiles</strong> drops write operations to  unmapped areas and handles read operations from unmapped areas  (except on Tier_1 tiled resources,  where reading and writing unmapped areas is invalid - refer to <strong><see cref = "SharpDX.Direct3D12.TiledResourcesTier"/></strong>). </p><p>If a copy operation involves writing to the same memory location multiple times because multiple locations in the  destination resource are mapped to the same tile memory, the resulting write operations to multi-mapped tiles are  non-deterministic and non-repeatable; that is, accesses to the tile memory happen in whatever order the hardware  happens to execute the copy operation. </p><p> The tiles involved in the copy operation can't include tiles that contain packed mipmaps or results of the copy  operation are undefined. To transfer data to and from mipmaps that the hardware packs into one tile, you must  use the standard (that is, non-tile specific) copy APIs  like <strong>CopyTextureRegion</strong>.</p><p><strong>CopyTiles</strong> does copy data in a slightly different pattern than the standard copy methods.</p><p> The memory layout of the tiles in the non-tiled buffer resource side of the copy operation is linear in memory within 64 KB tiles, which the hardware and driver swizzle and de-swizzle per tile as appropriate when they transfer to and from a tiled resource. For multisample antialiasing (MSAA) surfaces, the hardware and driver traverse each pixel's samples in sample-index order before they move to the next pixel. For tiles that are partially filled on the right side (for a surface that has a width not a multiple of tile width in pixels), the pitch and stride to move down a row is the full size in bytes of the number pixels that would fit across the tile if the tile was full. So, there can be a gap between each row of pixels in memory. Mipmaps that are smaller than a tile are not packed together in the linear layout, which might seem to be a waste of memory space, but as mentioned you can't use <strong>CopyTiles</strong> to copy to mipmaps that the hardware packs together. You can just use generic copy APIs, like <strong>CopyTextureRegion</strong>, to copy small mipmaps individually.</p>
        /// </remarks>
        /// <doc-id>dn903865</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::CopyTiles([In] ID3D12Resource* pTiledResource,[In] const D3D12_TILED_RESOURCE_COORDINATE* pTileRegionStartCoordinate,[In] const D3D12_TILE_REGION_SIZE* pTileRegionSize,[In] ID3D12Resource* pBuffer,[In] unsigned longlong BufferStartOffsetInBytes,[In] D3D12_TILE_COPY_FLAGS Flags)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::CopyTiles</unmanaged-short>
        public unsafe void CopyTiles(SharpDX.Direct3D12.Resource tiledResourceRef, SharpDX.Direct3D12.TiledResourceCoordinate tileRegionStartCoordinateRef, SharpDX.Direct3D12.TileRegionSize tileRegionSizeRef, SharpDX.Direct3D12.Resource bufferRef, System.Int64 bufferStartOffsetInBytes, SharpDX.Direct3D12.TileCopyFlags flags)
        {
            System.IntPtr tiledResourceRef_ = System.IntPtr.Zero;
            System.IntPtr bufferRef_ = System.IntPtr.Zero;
            tiledResourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(tiledResourceRef);
            bufferRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(bufferRef);
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)tiledResourceRef_, &tileRegionStartCoordinateRef, &tileRegionSizeRef, (void *)bufferRef_, bufferStartOffsetInBytes, unchecked ((System.Int32)flags), (*(void ***)this._nativePointer)[18]);
        }

        /// <summary>
        /// <p>Copy a multi-sampled resource into a non-multi-sampled resource.</p>
        /// </summary>
        /// <param name = "dstResourceRef"><dd>  <p> Destination resource. Must be a created with the <strong>D3D11_USAGE_DEFAULT</strong> flag and be single-sampled. See <strong><see cref = "SharpDX.Direct3D12.Resource"/></strong>. </p> </dd></param>
        /// <param name = "dstSubresource"><dd>  <p> A zero-based index, that identifies the destination subresource. Use <strong>D3D12CalcSubresource</strong> to calculate the subresource index if the parent resource is complex. </p> </dd></param>
        /// <param name = "srcResourceRef"><dd>  <p> Source resource. Must be multisampled. </p> </dd></param>
        /// <param name = "srcSubresource"><dd>  <p> The source subresource of the source resource. </p> </dd></param>
        /// <param name = "format"><dd>  <p> A <strong><see cref = "SharpDX.DXGI.Format"/></strong> that indicates how the multisampled resource will be resolved to a single-sampled resource. See remarks. </p> </dd></param>
        /// <doc-id>dn903897</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::ResolveSubresource([In] ID3D12Resource* pDstResource,[In] unsigned int DstSubresource,[In] ID3D12Resource* pSrcResource,[In] unsigned int SrcSubresource,[In] DXGI_FORMAT Format)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::ResolveSubresource</unmanaged-short>
        public unsafe void ResolveSubresource(SharpDX.Direct3D12.Resource dstResourceRef, System.Int32 dstSubresource, SharpDX.Direct3D12.Resource srcResourceRef, System.Int32 srcSubresource, SharpDX.DXGI.Format format)
        {
            System.IntPtr dstResourceRef_ = System.IntPtr.Zero;
            System.IntPtr srcResourceRef_ = System.IntPtr.Zero;
            dstResourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(dstResourceRef);
            srcResourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(srcResourceRef);
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)dstResourceRef_, dstSubresource, (void *)srcResourceRef_, srcSubresource, unchecked ((System.Int32)format), (*(void ***)this._nativePointer)[19]);
        }

        /// <summary>
        /// <p>Bind information about the primitive type, and data order that describes input data for the input assembler stage.</p>
        /// </summary>
        /// <param name = "primitiveTopology"><dd>  <p> The type of primitive and ordering of the primitive data (see <strong><see cref = "SharpDX.Direct3D.PrimitiveTopology"/></strong>). </p> </dd></param>
        /// <doc-id>dn903885</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::IASetPrimitiveTopology([In] D3D_PRIMITIVE_TOPOLOGY PrimitiveTopology)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::IASetPrimitiveTopology</unmanaged-short>
        internal unsafe void SetPrimitiveTopology(SharpDX.Direct3D.PrimitiveTopology primitiveTopology)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, unchecked ((System.Int32)primitiveTopology), (*(void ***)this._nativePointer)[20]);
        }

        /// <summary>
        /// <p> Bind an array of viewports to the rasterizer stage of the pipeline. </p>
        /// </summary>
        /// <param name = "numViewports"><dd>  <p> Number of viewports to bind. The range of valid values is (0, D3D12_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE). </p> </dd></param>
        /// <param name = "viewportsRef"><dd>  <p> An array of <strong><see cref = "SharpDX.Direct3D12.Viewport"/></strong> structures to bind to the device. </p> </dd></param>
        /// <remarks>
        /// <p> All viewports must be set atomically as one operation. Any viewports not defined by the call are disabled. </p><p> Which viewport to use is determined by the SV_ViewportArrayIndex semantic output by a geometry shader; if a geometry shader does not specify the semantic, Direct3D will use the first viewport in the array. </p><strong>Note</strong>?? Even though you specify float values to the members of the <strong><see cref = "SharpDX.Direct3D12.Viewport"/></strong> structure for the <em>pViewports</em> array in a call to  <strong>RSSetViewports</strong> for feature levels 9_x, <strong>RSSetViewports</strong> uses DWORDs internally. Because of this behavior, when you use a negative top left corner for the viewport, the call to  <strong>RSSetViewports</strong> for feature levels 9_x fails. This failure occurs because <strong>RSSetViewports</strong> for 9_x casts the floating point values into unsigned integers without validation, which results in integer overflow.?
        /// </remarks>
        /// <doc-id>dn903900</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::RSSetViewports([In] unsigned int NumViewports,[In, Buffer] const D3D12_VIEWPORT* pViewports)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::RSSetViewports</unmanaged-short>
        public unsafe void SetViewports(System.Int32 numViewports, SharpDX.Direct3D12.Viewport[] viewportsRef)
        {
            fixed (void *viewportsRef_ = viewportsRef)
                SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, numViewports, viewportsRef_, (*(void ***)this._nativePointer)[21]);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "numRects">No documentation.</param>
        /// <param name = "rectsRef">No documentation.</param>
        /// <unmanaged>void ID3D12GraphicsCommandList::RSSetScissorRects([In] unsigned int NumRects,[In, Buffer] const RECT* pRects)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::RSSetScissorRects</unmanaged-short>
        public unsafe void SetScissorRectangles(System.Int32 numRects, SharpDX.Mathematics.Interop.RawRectangle[] rectsRef)
        {
            fixed (void *rectsRef_ = rectsRef)
                SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, numRects, rectsRef_, (*(void ***)this._nativePointer)[22]);
        }

        /// <summary>
        /// <p>Sets the blend factor that modulate values for a pixel shader, render target, or both.</p>
        /// </summary>
        /// <param name = "blendFactor"><dd>  <p> Array of blend factors, one for each RGBA component. </p> </dd></param>
        /// <remarks>
        /// <p> If you created the blend-state object with D3D11_BLEND_BLEND_FACTOR or D3D11_BLEND_INV_BLEND_FACTOR, the blending stage uses the non-<c>null</c> array of blend factors. </p><p> If you didn't create the blend-state object with D3D11_BLEND_BLEND_FACTOR or D3D11_BLEND_INV_BLEND_FACTOR, the blending stage does not use the non-<c>null</c> array of blend factors; the runtime stores the blend factors. </p><p> If you pass <c>null</c>, the runtime uses or stores a blend factor equal to { 1, 1, 1, 1 }. </p><p> D3D11_BLEND_BLEND_FACTOR and D3D11_BLEND_INV_BLEND_FACTOR are <strong><see cref = "SharpDX.Direct3D12.BlendOption"/></strong> enumeration constants. </p>
        /// </remarks>
        /// <doc-id>dn903886</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::OMSetBlendFactor([In] const SHARPDX_VECTOR4* BlendFactor)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::OMSetBlendFactor</unmanaged-short>
        internal unsafe void SetBlendFactor(SharpDX.Mathematics.Interop.RawVector4 blendFactor)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, &blendFactor, (*(void ***)this._nativePointer)[23]);
        }

        /// <summary>
        /// <p>Sets the reference value for depth stencil tests.</p>
        /// </summary>
        /// <param name = "stencilRef"><dd>  <p> Reference value to perform against when doing a depth-stencil test. </p> </dd></param>
        /// <doc-id>dn903887</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::OMSetStencilRef([In] unsigned int StencilRef)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::OMSetStencilRef</unmanaged-short>
        internal unsafe void SetStencilReference(System.Int32 stencilRef)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, stencilRef, (*(void ***)this._nativePointer)[24]);
        }

        /// <summary>
        /// <p> Sets all shaders and programs most of the fixed-function state of the graphics processing unit (GPU) pipeline. </p>
        /// </summary>
        /// <param name = "pipelineStateRef"><dd>  <p> Pointer to the <strong><see cref = "SharpDX.Direct3D12.PipelineState"/></strong> containing the pipeline state data. </p> </dd></param>
        /// <doc-id>dn903918</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::SetPipelineState([In] ID3D12PipelineState* pPipelineState)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::SetPipelineState</unmanaged-short>
        internal unsafe void SetPipelineState(SharpDX.Direct3D12.PipelineState pipelineStateRef)
        {
            System.IntPtr pipelineStateRef_ = System.IntPtr.Zero;
            pipelineStateRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.PipelineState>(pipelineStateRef);
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)pipelineStateRef_, (*(void ***)this._nativePointer)[25]);
        }

        /// <summary>
        /// <p> Notifies the driver that it needs to synchronize multiple accesses to resources. </p>
        /// </summary>
        /// <param name = "numBarriers"><dd>  <p> The number of submitted barrier descriptions. </p> </dd></param>
        /// <param name = "barriersRef"><dd>  <p> Pointer to an array of barrier descriptions. </p> </dd></param>
        /// <remarks>
        /// <p>There are three types of barrier descriptions:</p><ul> <li> <strong><see cref = "SharpDX.Direct3D12.ResourceTransitionBarrier"/></strong> -  Transition barriers  indicate that a set of subresources transition between different usages.  The caller must specify the <em>before</em> and <em>after</em> usages of the subresources.  The D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES flag is used to transition all subresources in a resource at the same time. </li> <li> <strong><see cref = "SharpDX.Direct3D12.ResourceAliasingBarrier"/></strong> - Aliasing barriers indicate a transition between usages of two different resources which have mappings into the same heap.  The application can specify both the before and the after resource.  Note that one or both resources can be <c>null</c> (indicating that any tiled resource could cause aliasing). </li> <li> <strong><see cref = "SharpDX.Direct3D12.ResourceUnorderedAccessViewBarrier"/></strong> - Unordered access view barriers indicate all UAV accesses (read or writes) to a particular resource must complete before any future UAV accesses (read or write) can begin.  The specified resource may be <c>null</c>.  It is not necessary to insert a UAV barrier between two draw or dispatch calls which only read a UAV.  Additionally, it is not necessary to insert a UAV barrier between two draw or dispatch calls which write to the same UAV if the application knows that it is safe to execute the UAV accesses in any order.  The resource can be <c>null</c> (indicating that any UAV access could require the barrier). </li> </ul><p> When <strong>ID3D12GraphicsCommandList::ResourceBarrier</strong> is passed an array of resource barrier descriptions, the API behaves as if it was called N times (1 for each array element), in the specified order. Transitions should be batched together into a single API call when possible, as a performance optimization.</p><p> For descriptions of the usage states a subresource can be in, see the <strong><see cref = "SharpDX.Direct3D12.ResourceStates"/></strong> enumeration and the Using Resource Barriers to Synchronize Resource States in Direct3D 12 section. </p><p> All subresources in a resource must be in the RENDER_TARGET state, or DEPTH_WRITE state, for render targets/depth-stencil resources respectively, when  <strong>ID3D12GraphicsCommandList::DiscardResource</strong> is called. </p><p> When a back buffer is presented, it must be in the D3D12_RESOURCE_STATE_PRESENT state.  If <strong>IDXGISwapChain1::Present1</strong> is called on a resource which is not in the PRESENT state, a debug layer warning will be emitted. </p><p>The resource usage bits are group into two categories, read-only and read/write.</p><p> The following usage bits are read-only: </p><ul> <li>D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER</li> <li>D3D12_RESOURCE_STATE_INDEX_BUFFER</li> <li>D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE</li> <li>D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE</li> <li>D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT</li> <li>D3D12_RESOURCE_STATE_COPY_SOURCE</li> <li>D3D12_RESOURCE_STATE_DEPTH_READ</li> </ul><p>The following usage bits are read/write:</p><ul> <li>D3D12_RESOURCE_STATE_UNORDERED_ACCESS</li> <li>D3D12_RESOURCE_STATE_DEPTH_WRITE</li> </ul><p>The following usage bits are write-only:</p><ul> <li>D3D12_RESOURCE_STATE_COPY_DEST</li> <li>D3D12_RESOURCE_STATE_RENDER_TARGET</li> <li>D3D12_RESOURCE_STATE_STREAM_OUT</li> </ul><p> At most one write bit can be set. If any write bit is set, then no read bit may be set. If no write bit is set, then any number of read bits may be set.  </p><p> At any given time, a subresource is in exactly one  state (determined by a set of flags).  The application must ensure that the states are matched when making a sequence of <strong>ResourceBarrier</strong> calls. In other words, the before and after states in consecutive calls to <strong>ResourceBarrier</strong> must agree. </p><p>To transition all subresources within a resource, the application can set the subresource index to D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES, which implies that all subresources are changed.</p><p> For improved performance, applications should use split barriers (refer to Synchronization and Multi-Engine). Applications should also batch multiple transitions into a single call whenever possible. </p>
        /// </remarks>
        /// <doc-id>dn903898</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::ResourceBarrier([In] unsigned int NumBarriers,[In, Buffer] const D3D12_RESOURCE_BARRIER* pBarriers)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::ResourceBarrier</unmanaged-short>
        private unsafe void ResourceBarrier(System.Int32 numBarriers, System.IntPtr barriersRef)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, numBarriers, (void *)barriersRef, (*(void ***)this._nativePointer)[26]);
        }

        /// <summary>
        /// <p> Executes a bundle. </p>
        /// </summary>
        /// <param name = "commandListRef"><dd>  <p> Specifies the <strong><see cref = "SharpDX.Direct3D12.GraphicsCommandList"/></strong> that determines the bundle to be executed. </p> </dd></param>
        /// <remarks>
        /// <p> Bundles inherit all state from the parent command list on which <strong>ExecuteBundle</strong> is called, except the pipeline state object and primitive topology. All of the state that is set in a bundle will affect the state of the parent command list. Note that <strong>ExecuteBundle</strong> is not a predicated operation. </p>
        /// </remarks>
        /// <doc-id>dn903882</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::ExecuteBundle([In] ID3D12GraphicsCommandList* pCommandList)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::ExecuteBundle</unmanaged-short>
        public unsafe void ExecuteBundle(SharpDX.Direct3D12.GraphicsCommandList commandListRef)
        {
            System.IntPtr commandListRef_ = System.IntPtr.Zero;
            commandListRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.GraphicsCommandList>(commandListRef);
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)commandListRef_, (*(void ***)this._nativePointer)[27]);
        }

        /// <summary>
        /// <p> Changes the currently bound descriptor heaps that are associated with a command list. </p>
        /// </summary>
        /// <param name = "numDescriptorHeaps"><dd>  <p> Number of descriptor heaps to bind. </p> </dd></param>
        /// <param name = "descriptorHeapsOut"><dd>  <p> A reference to an array of <strong><see cref = "SharpDX.Direct3D12.DescriptorHeap"/></strong> objects for the heaps to set on the command list. </p> </dd></param>
        /// <remarks>
        /// <p><strong>SetDescriptorHeaps</strong> can be called on a bundle, but the bundle descriptor heaps must match the calling command list descriptor heap. For more information on bundle restrictions, refer to Creating and Recording Command Lists and Bundles.</p>
        /// </remarks>
        /// <doc-id>Dn903908</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::SetDescriptorHeaps([In] unsigned int NumDescriptorHeaps,[In, Buffer] const ID3D12DescriptorHeap** ppDescriptorHeaps)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::SetDescriptorHeaps</unmanaged-short>
        public unsafe void SetDescriptorHeaps(System.Int32 numDescriptorHeaps, SharpDX.Direct3D12.DescriptorHeap[] descriptorHeapsOut)
        {
            System.IntPtr*descriptorHeapsOut_;
            descriptorHeapsOut_ = (System.IntPtr*)0;
            if (descriptorHeapsOut != null)
            {
                System.IntPtr*_descriptorHeapsOut = stackalloc System.IntPtr[descriptorHeapsOut.Length];
                descriptorHeapsOut_ = _descriptorHeapsOut;
            }

            if (descriptorHeapsOut != null)
                for (int i = 0; i < descriptorHeapsOut.Length; ++i)
                    (descriptorHeapsOut_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.DescriptorHeap>(descriptorHeapsOut[i]);
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, numDescriptorHeaps, (void *)descriptorHeapsOut_, (*(void ***)this._nativePointer)[28]);
        }

        /// <summary>
        /// <p> Sets the layout of the compute root signature. </p>
        /// </summary>
        /// <param name = "rootSignatureRef"><dd>  <p> A reference to the <strong><see cref = "SharpDX.Direct3D12.RootSignature"/></strong> object. </p> </dd></param>
        /// <doc-id>dn903906</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::SetComputeRootSignature([In, Optional] ID3D12RootSignature* pRootSignature)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::SetComputeRootSignature</unmanaged-short>
        public unsafe void SetComputeRootSignature(SharpDX.Direct3D12.RootSignature rootSignatureRef)
        {
            System.IntPtr rootSignatureRef_ = System.IntPtr.Zero;
            rootSignatureRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.RootSignature>(rootSignatureRef);
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)rootSignatureRef_, (*(void ***)this._nativePointer)[29]);
        }

        /// <summary>
        /// <p> Sets the layout of the graphics root signature. </p>
        /// </summary>
        /// <param name = "rootSignatureRef"><dd>  <p> A reference to the <strong><see cref = "SharpDX.Direct3D12.RootSignature"/></strong> object. </p> </dd></param>
        /// <doc-id>dn903914</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::SetGraphicsRootSignature([In, Optional] ID3D12RootSignature* pRootSignature)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::SetGraphicsRootSignature</unmanaged-short>
        public unsafe void SetGraphicsRootSignature(SharpDX.Direct3D12.RootSignature rootSignatureRef)
        {
            System.IntPtr rootSignatureRef_ = System.IntPtr.Zero;
            rootSignatureRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.RootSignature>(rootSignatureRef);
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)rootSignatureRef_, (*(void ***)this._nativePointer)[30]);
        }

        /// <summary>
        /// <p> Sets a descriptor table into the compute root signature.</p>
        /// </summary>
        /// <param name = "rootParameterIndex"><dd>  <p> The slot number for binding. </p> </dd></param>
        /// <param name = "baseDescriptor"><dd>  <p> A GPU_descriptor_handle object for the base descriptor to set. </p> </dd></param>
        /// <doc-id>dn903904</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::SetComputeRootDescriptorTable([In] unsigned int RootParameterIndex,[In] D3D12_GPU_DESCRIPTOR_HANDLE BaseDescriptor)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::SetComputeRootDescriptorTable</unmanaged-short>
        public unsafe void SetComputeRootDescriptorTable(System.Int32 rootParameterIndex, SharpDX.Direct3D12.GpuDescriptorHandle baseDescriptor)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid0(this._nativePointer, rootParameterIndex, baseDescriptor, (*(void ***)this._nativePointer)[31]);
        }

        /// <summary>
        /// <p> Sets a descriptor table into the graphics root signature. </p>
        /// </summary>
        /// <param name = "rootParameterIndex"><dd>  <p> The slot number for binding. </p> </dd></param>
        /// <param name = "baseDescriptor"><dd>  <p> A GPU_descriptor_handle object for the base descriptor to set. </p> </dd></param>
        /// <doc-id>dn903912</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::SetGraphicsRootDescriptorTable([In] unsigned int RootParameterIndex,[In] D3D12_GPU_DESCRIPTOR_HANDLE BaseDescriptor)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::SetGraphicsRootDescriptorTable</unmanaged-short>
        public unsafe void SetGraphicsRootDescriptorTable(System.Int32 rootParameterIndex, SharpDX.Direct3D12.GpuDescriptorHandle baseDescriptor)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid0(this._nativePointer, rootParameterIndex, baseDescriptor, (*(void ***)this._nativePointer)[32]);
        }

        /// <summary>
        /// <p> Sets a constant in the compute root signature. </p>
        /// </summary>
        /// <param name = "rootParameterIndex"><dd>  <p> The slot number for binding. </p> </dd></param>
        /// <param name = "srcData"><dd>  <p> The source data for the constant to set. </p> </dd></param>
        /// <param name = "destOffsetIn32BitValues"><dd>  <p> The offset, in 32-bit values, to set the constant in the root signature. </p> </dd></param>
        /// <doc-id>dn903901</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::SetComputeRoot32BitConstant([In] unsigned int RootParameterIndex,[In] unsigned int SrcData,[In] unsigned int DestOffsetIn32BitValues)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::SetComputeRoot32BitConstant</unmanaged-short>
        public unsafe void SetComputeRoot32BitConstant(System.Int32 rootParameterIndex, System.Int32 srcData, System.Int32 destOffsetIn32BitValues)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, rootParameterIndex, srcData, destOffsetIn32BitValues, (*(void ***)this._nativePointer)[33]);
        }

        /// <summary>
        /// <p> Sets a constant in the graphics root signature. </p>
        /// </summary>
        /// <param name = "rootParameterIndex"><dd>  <p> The slot number for binding. </p> </dd></param>
        /// <param name = "srcData"><dd>  <p> The source data for the constant to set. </p> </dd></param>
        /// <param name = "destOffsetIn32BitValues"><dd>  <p> The offset, in 32-bit values, to set the constant in the root signature. </p> </dd></param>
        /// <doc-id>dn903909</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::SetGraphicsRoot32BitConstant([In] unsigned int RootParameterIndex,[In] unsigned int SrcData,[In] unsigned int DestOffsetIn32BitValues)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::SetGraphicsRoot32BitConstant</unmanaged-short>
        public unsafe void SetGraphicsRoot32BitConstant(System.Int32 rootParameterIndex, System.Int32 srcData, System.Int32 destOffsetIn32BitValues)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, rootParameterIndex, srcData, destOffsetIn32BitValues, (*(void ***)this._nativePointer)[34]);
        }

        /// <summary>
        /// <p> Sets a group of constants in the compute root signature. </p>
        /// </summary>
        /// <param name = "rootParameterIndex"><dd>  <p>The slot number for binding.</p> </dd></param>
        /// <param name = "num32BitValuesToSet"><dd>  <p>The number of constants to set in the root signature.</p> </dd></param>
        /// <param name = "srcDataRef"><dd>  <p>The source data for the group of constants to set.</p> </dd></param>
        /// <param name = "destOffsetIn32BitValues"><dd>  <p>The offset, in 32-bit values, to set the first constant of the group in the root signature.</p> </dd></param>
        /// <doc-id>dn903902</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::SetComputeRoot32BitConstants([In] unsigned int RootParameterIndex,[In] unsigned int Num32BitValuesToSet,[In, Buffer] const void* pSrcData,[In] unsigned int DestOffsetIn32BitValues)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::SetComputeRoot32BitConstants</unmanaged-short>
        public unsafe void SetComputeRoot32BitConstants(System.Int32 rootParameterIndex, System.Int32 num32BitValuesToSet, System.IntPtr srcDataRef, System.Int32 destOffsetIn32BitValues)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, rootParameterIndex, num32BitValuesToSet, (void *)srcDataRef, destOffsetIn32BitValues, (*(void ***)this._nativePointer)[35]);
        }

        /// <summary>
        /// <p> Sets a group of constants in the graphics root signature. </p>
        /// </summary>
        /// <param name = "rootParameterIndex"><dd>  <p> The slot number for binding. </p> </dd></param>
        /// <param name = "num32BitValuesToSet"><dd>  <p> The number of constants to set in the root signature. </p> </dd></param>
        /// <param name = "srcDataRef"><dd>  <p> The source data for the group of constants to set. </p> </dd></param>
        /// <param name = "destOffsetIn32BitValues"><dd>  <p> The offset, in 32-bit values, to set the first constant of the group in the root signature. </p> </dd></param>
        /// <doc-id>dn903910</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::SetGraphicsRoot32BitConstants([In] unsigned int RootParameterIndex,[In] unsigned int Num32BitValuesToSet,[In, Buffer] const void* pSrcData,[In] unsigned int DestOffsetIn32BitValues)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::SetGraphicsRoot32BitConstants</unmanaged-short>
        public unsafe void SetGraphicsRoot32BitConstants(System.Int32 rootParameterIndex, System.Int32 num32BitValuesToSet, System.IntPtr srcDataRef, System.Int32 destOffsetIn32BitValues)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, rootParameterIndex, num32BitValuesToSet, (void *)srcDataRef, destOffsetIn32BitValues, (*(void ***)this._nativePointer)[36]);
        }

        /// <summary>
        /// <p> Sets a CPU descriptor handle for the constant buffer in the compute root signature. </p>
        /// </summary>
        /// <param name = "rootParameterIndex"><dd>  <p> The slot number for binding. </p> </dd></param>
        /// <param name = "bufferLocation"><dd>  <p> Specifies the D3D12_GPU_VIRTUAL_ADDRESS of the constant buffer. </p> </dd></param>
        /// <doc-id>dn903903</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::SetComputeRootConstantBufferView([In] unsigned int RootParameterIndex,[In] unsigned longlong BufferLocation)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::SetComputeRootConstantBufferView</unmanaged-short>
        public unsafe void SetComputeRootConstantBufferView(System.Int32 rootParameterIndex, System.Int64 bufferLocation)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, rootParameterIndex, bufferLocation, (*(void ***)this._nativePointer)[37]);
        }

        /// <summary>
        /// <p> Sets a CPU descriptor handle for the constant buffer in the graphics root signature. </p>
        /// </summary>
        /// <param name = "rootParameterIndex"><dd>  <p> The slot number for binding. </p> </dd></param>
        /// <param name = "bufferLocation"><dd>  <p> The GPU virtual address of the constant buffer. D3D12_GPU_VIRTUAL_ADDRESS is a typedef'd alias of UINT64. </p> </dd></param>
        /// <doc-id>dn903911</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::SetGraphicsRootConstantBufferView([In] unsigned int RootParameterIndex,[In] unsigned longlong BufferLocation)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::SetGraphicsRootConstantBufferView</unmanaged-short>
        public unsafe void SetGraphicsRootConstantBufferView(System.Int32 rootParameterIndex, System.Int64 bufferLocation)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, rootParameterIndex, bufferLocation, (*(void ***)this._nativePointer)[38]);
        }

        /// <summary>
        /// <p> Sets a CPU descriptor handle for the shader resource in the compute root signature. </p>
        /// </summary>
        /// <param name = "rootParameterIndex"><dd>  <p> The slot number for binding. </p> </dd></param>
        /// <param name = "bufferLocation"><dd>  <p> The GPU virtual address of the buffer. D3D12_GPU_VIRTUAL_ADDRESS is a typedef'd alias of UINT64. </p> </dd></param>
        /// <doc-id>dn903905</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::SetComputeRootShaderResourceView([In] unsigned int RootParameterIndex,[In] unsigned longlong BufferLocation)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::SetComputeRootShaderResourceView</unmanaged-short>
        public unsafe void SetComputeRootShaderResourceView(System.Int32 rootParameterIndex, System.Int64 bufferLocation)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, rootParameterIndex, bufferLocation, (*(void ***)this._nativePointer)[39]);
        }

        /// <summary>
        /// <p> Sets a CPU descriptor handle for the shader resource in the graphics root signature. </p>
        /// </summary>
        /// <param name = "rootParameterIndex"><dd>  <p> The slot number for binding. </p> </dd></param>
        /// <param name = "bufferLocation"><dd>  <p> The GPU virtual address of the Buffer. Textures are not supported. D3D12_GPU_VIRTUAL_ADDRESS is a typedef'd alias of UINT64. </p> </dd></param>
        /// <doc-id>dn903913</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::SetGraphicsRootShaderResourceView([In] unsigned int RootParameterIndex,[In] unsigned longlong BufferLocation)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::SetGraphicsRootShaderResourceView</unmanaged-short>
        public unsafe void SetGraphicsRootShaderResourceView(System.Int32 rootParameterIndex, System.Int64 bufferLocation)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, rootParameterIndex, bufferLocation, (*(void ***)this._nativePointer)[40]);
        }

        /// <summary>
        /// <p> Sets a CPU descriptor handle for the unordered-access-view resource in the compute root signature. </p>
        /// </summary>
        /// <param name = "rootParameterIndex"><dd>  <p> The slot number for binding. </p> </dd></param>
        /// <param name = "bufferLocation"><dd>  <p> The GPU virtual address of the buffer. D3D12_GPU_VIRTUAL_ADDRESS is a typedef'd alias of UINT64.   </p> </dd></param>
        /// <doc-id>dn903907</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::SetComputeRootUnorderedAccessView([In] unsigned int RootParameterIndex,[In] unsigned longlong BufferLocation)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::SetComputeRootUnorderedAccessView</unmanaged-short>
        public unsafe void SetComputeRootUnorderedAccessView(System.Int32 rootParameterIndex, System.Int64 bufferLocation)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, rootParameterIndex, bufferLocation, (*(void ***)this._nativePointer)[41]);
        }

        /// <summary>
        /// <p> Sets a CPU descriptor handle for the unordered-access-view resource in the graphics root signature. </p>
        /// </summary>
        /// <param name = "rootParameterIndex"><dd>  <p> The slot number for binding. </p> </dd></param>
        /// <param name = "bufferLocation"><dd>  <p> The GPU virtual address of the buffer. D3D12_GPU_VIRTUAL_ADDRESS is a typedef'd alias of UINT64. </p> </dd></param>
        /// <doc-id>dn903915</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::SetGraphicsRootUnorderedAccessView([In] unsigned int RootParameterIndex,[In] unsigned longlong BufferLocation)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::SetGraphicsRootUnorderedAccessView</unmanaged-short>
        public unsafe void SetGraphicsRootUnorderedAccessView(System.Int32 rootParameterIndex, System.Int64 bufferLocation)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, rootParameterIndex, bufferLocation, (*(void ***)this._nativePointer)[42]);
        }

        /// <summary>
        /// <p> Sets the view for the index buffer. </p>
        /// </summary>
        /// <param name = "viewRef"><dd>  <p> The view specifies the index buffer's address, size, and <strong><see cref = "SharpDX.DXGI.Format"/></strong>, as a reference to a <strong><see cref = "SharpDX.Direct3D12.IndexBufferView"/></strong> structure. </p> </dd></param>
        /// <remarks>
        /// <p>Only one index buffer can be bound to the graphics pipeline at any one time.</p>
        /// </remarks>
        /// <doc-id>dn986882</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::IASetIndexBuffer([In, Optional] const D3D12_INDEX_BUFFER_VIEW* pView)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::IASetIndexBuffer</unmanaged-short>
        public unsafe void SetIndexBuffer(SharpDX.Direct3D12.IndexBufferView? viewRef)
        {
            SharpDX.Direct3D12.IndexBufferView viewRef_;
            if (viewRef != null)
                viewRef_ = viewRef.Value;
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, viewRef == null ? (void *)0 : &viewRef_, (*(void ***)this._nativePointer)[43]);
        }

        /// <summary>
        /// <p>Sets a CPU descriptor handle for the vertex buffers.</p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p> Index into the device's zero-based array to begin setting vertex buffers. </p> </dd></param>
        /// <param name = "numViews"><dd>  <p> The number of views in the <em>pViews</em> array. </p> </dd></param>
        /// <param name = "viewsRef"><dd>  <p> Specifies the vertex buffer views in an array of <strong><see cref = "SharpDX.Direct3D12.VertexBufferView"/></strong> structures. </p> </dd></param>
        /// <doc-id>dn986883</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::IASetVertexBuffers([In] unsigned int StartSlot,[In] unsigned int NumViews,[In] const D3D12_VERTEX_BUFFER_VIEW* pViews)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::IASetVertexBuffers</unmanaged-short>
        private unsafe void SetVertexBuffers(System.Int32 startSlot, System.Int32 numViews, System.IntPtr viewsRef)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numViews, (void *)viewsRef, (*(void ***)this._nativePointer)[44]);
        }

        /// <summary>
        /// <p> Sets the stream output buffer views. </p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p> Index into the device's zero-based array to begin setting stream output buffers. </p> </dd></param>
        /// <param name = "numViews"><dd>  <p> The number of entries in the <em>pViews</em> array. </p> </dd></param>
        /// <param name = "viewsRef"><dd>  <p> Specifies an array of  <strong><see cref = "SharpDX.Direct3D12.StreamOutputBufferView"/></strong> structures. </p> </dd></param>
        /// <doc-id>dn986886</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::SOSetTargets([In] unsigned int StartSlot,[In] unsigned int NumViews,[In, Buffer, Optional] const D3D12_STREAM_OUTPUT_BUFFER_VIEW* pViews)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::SOSetTargets</unmanaged-short>
        public unsafe void SOSetTargets(System.Int32 startSlot, System.Int32 numViews, SharpDX.Direct3D12.StreamOutputBufferView[] viewsRef)
        {
            fixed (void *viewsRef_ = viewsRef)
                SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numViews, viewsRef_, (*(void ***)this._nativePointer)[45]);
        }

        /// <summary>
        /// <p> Sets CPU descriptor handles for the render targets and depth stencil. </p>
        /// </summary>
        /// <param name = "numRenderTargetDescriptors"><dd>  <p> The number of entries in the <em>pRenderTargetDescriptors</em> array. </p> </dd></param>
        /// <param name = "renderTargetDescriptorsRef"><dd>  <p> Specifies an array of <strong><see cref = "SharpDX.Direct3D12.CpuDescriptorHandle"/></strong> structures that describe the CPU descriptor handles that represents the start of the heap of render target descriptors. </p> </dd></param>
        /// <param name = "rTsSingleHandleToDescriptorRange"><dd>  <p><strong>True</strong> means the handle passed in is the reference to a contiguous range of <em>NumRenderTargetDescriptors</em> descriptors.  This case is useful if the set of descriptors to bind already happens to be contiguous in memory (so all that?s needed is a handle to the first one).  For example, if  <em>NumRenderTargetDescriptors</em> is 3 then the memory layout is taken as follows:</p><p>In this case the driver dereferences the handle and then increments the memory being pointed to.</p> <p><strong>False</strong> means that the handle is the first of an array of <em>NumRenderTargetDescriptors</em> handles.  The false case allows an application to bind a set of descriptors from different locations at once. Again assuming that <em>NumRenderTargetDescriptors</em> is 3, the memory layout is taken as follows:</p><p>In this case the driver dereferences three handles that are expected to be adjacent to each other in memory.</p> </dd></param>
        /// <param name = "depthStencilDescriptorRef"><dd>  <p> A reference to a <strong><see cref = "SharpDX.Direct3D12.CpuDescriptorHandle"/></strong> structure that describes the CPU descriptor handle that represents the start of the heap that holds the depth stencil descriptor. </p> </dd></param>
        /// <doc-id>dn986884</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::OMSetRenderTargets([In] unsigned int NumRenderTargetDescriptors,[In, Optional] const D3D12_CPU_DESCRIPTOR_HANDLE* pRenderTargetDescriptors,[In] BOOL RTsSingleHandleToDescriptorRange,[In, Optional] const D3D12_CPU_DESCRIPTOR_HANDLE* pDepthStencilDescriptor)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::OMSetRenderTargets</unmanaged-short>
        private unsafe void SetRenderTargets(System.Int32 numRenderTargetDescriptors, System.IntPtr renderTargetDescriptorsRef, SharpDX.Mathematics.Interop.RawBool rTsSingleHandleToDescriptorRange, SharpDX.Direct3D12.CpuDescriptorHandle? depthStencilDescriptorRef)
        {
            SharpDX.Direct3D12.CpuDescriptorHandle.__Native depthStencilDescriptorRef_ = default (SharpDX.Direct3D12.CpuDescriptorHandle.__Native);
            if (depthStencilDescriptorRef != null)
                depthStencilDescriptorRef.Value.__MarshalTo(ref depthStencilDescriptorRef_);
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid0(this._nativePointer, numRenderTargetDescriptors, (void *)renderTargetDescriptorsRef, rTsSingleHandleToDescriptorRange, depthStencilDescriptorRef == null ? (void *)0 : &depthStencilDescriptorRef_, (*(void ***)this._nativePointer)[46]);
            if (depthStencilDescriptorRef != null)
                depthStencilDescriptorRef.Value.__MarshalFree(ref depthStencilDescriptorRef_);
        }

        /// <summary>
        /// <p>Clears the depth-stencil resource.</p>
        /// </summary>
        /// <param name = "depthStencilView"><dd>  <p> Describes the CPU descriptor handle that represents the start of the heap for the depth stencil to be cleared. </p> </dd></param>
        /// <param name = "clearFlags"><dd>  <p> A combination of <strong><see cref = "SharpDX.Direct3D12.ClearFlags"/></strong> values that are combined by using a bitwise OR operation. The resulting value identifies the type of data to clear (depth buffer, stencil buffer, or both). </p> </dd></param>
        /// <param name = "depth"><dd>  <p> A value to clear the depth buffer with. This value will be clamped between 0 and 1. </p> </dd></param>
        /// <param name = "stencil"><dd>  <p> A value to clear the stencil buffer with. </p> </dd></param>
        /// <param name = "numRects"><dd>  <p> The number of rectangles in the array that the <em>pRects</em> parameter specifies. </p> </dd></param>
        /// <param name = "rectsRef"><dd>  <p> An array of <strong>D3D12_RECT</strong> structures for the rectangles in the resource view to clear. If <strong><c>null</c></strong>, <strong>ClearDepthStencilView</strong> clears the entire resource view. </p> </dd></param>
        /// <remarks>
        /// <p><strong>ClearDepthStencilView</strong> may be used to initialize resources which alias the same heap memory. See <strong>CreatePlacedResource</strong> for more details.</p>
        /// </remarks>
        /// <doc-id>dn903840</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::ClearDepthStencilView([In] D3D12_CPU_DESCRIPTOR_HANDLE DepthStencilView,[In] D3D12_CLEAR_FLAGS ClearFlags,[In] float Depth,[In] unsigned char Stencil,[In] unsigned int NumRects,[In, Buffer] const RECT* pRects)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::ClearDepthStencilView</unmanaged-short>
        public unsafe void ClearDepthStencilView(SharpDX.Direct3D12.CpuDescriptorHandle depthStencilView, SharpDX.Direct3D12.ClearFlags clearFlags, System.Single depth, System.Byte stencil, System.Int32 numRects, SharpDX.Mathematics.Interop.RawRectangle[] rectsRef)
        {
            SharpDX.Direct3D12.CpuDescriptorHandle.__Native depthStencilView_ = default (SharpDX.Direct3D12.CpuDescriptorHandle.__Native);
            depthStencilView.__MarshalTo(ref depthStencilView_);
            fixed (void *rectsRef_ = rectsRef)
                SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid0(this._nativePointer, depthStencilView_, unchecked ((System.Int32)clearFlags), depth, stencil, numRects, rectsRef_, (*(void ***)this._nativePointer)[47]);
            depthStencilView.__MarshalFree(ref depthStencilView_);
        }

        /// <summary>
        /// <p> Sets all the elements in a render target to one value. </p>
        /// </summary>
        /// <param name = "renderTargetView"><dd>  <p> Specifies a <see cref = "SharpDX.Direct3D12.CpuDescriptorHandle"/> structure that describes the CPU descriptor handle that represents the start of the heap for the render target to be cleared. </p> </dd></param>
        /// <param name = "colorRGBA"><dd>  <p> A 4-component array that represents the color to fill the render target with. </p> </dd></param>
        /// <param name = "numRects"><dd>  <p> The number of rectangles in the array that the <em>pRects</em> parameter specifies. </p> </dd></param>
        /// <param name = "rectsRef"><dd>  <p> An array of <strong>D3D12_RECT</strong> structures for the rectangles in the resource view to clear. If <strong><c>null</c></strong>, <strong>ClearRenderTargetView</strong> clears the entire resource view. </p> </dd></param>
        /// <remarks>
        /// <p><strong>ClearRenderTargetView</strong> may be used to initialize resources which alias the same heap memory. See <strong>CreatePlacedResource</strong> for more details.</p>
        /// </remarks>
        /// <doc-id>dn903842</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::ClearRenderTargetView([In] D3D12_CPU_DESCRIPTOR_HANDLE RenderTargetView,[In] const SHARPDX_COLOR4* ColorRGBA,[In] unsigned int NumRects,[In, Buffer] const RECT* pRects)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::ClearRenderTargetView</unmanaged-short>
        public unsafe void ClearRenderTargetView(SharpDX.Direct3D12.CpuDescriptorHandle renderTargetView, SharpDX.Mathematics.Interop.RawColor4 colorRGBA, System.Int32 numRects, SharpDX.Mathematics.Interop.RawRectangle[] rectsRef)
        {
            SharpDX.Direct3D12.CpuDescriptorHandle.__Native renderTargetView_ = default (SharpDX.Direct3D12.CpuDescriptorHandle.__Native);
            renderTargetView.__MarshalTo(ref renderTargetView_);
            fixed (void *rectsRef_ = rectsRef)
                SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid0(this._nativePointer, renderTargetView_, &colorRGBA, numRects, rectsRef_, (*(void ***)this._nativePointer)[48]);
            renderTargetView.__MarshalFree(ref renderTargetView_);
        }

        /// <summary>
        /// <p> Sets all the elements in a unordered-access view to the specified integer values. </p>
        /// </summary>
        /// <param name = "viewGPUHandleInCurrentHeap"><dd>  <p> A <strong><see cref = "SharpDX.Direct3D12.GpuDescriptorHandle"/></strong> structure that describes the GPU descriptor handle that represents the start of the heap for the unordered-access view to clear. </p> </dd></param>
        /// <param name = "viewCPUHandle"><dd>  <p> A <strong><see cref = "SharpDX.Direct3D12.CpuDescriptorHandle"/></strong> structure that describes the CPU descriptor handle that represents the start of the heap for the render target to clear. </p> </dd></param>
        /// <param name = "resourceRef"><dd>  <p> A reference to the <strong><see cref = "SharpDX.Direct3D12.Resource"/></strong> interface that represents the unordered-access-view resource to clear. </p> </dd></param>
        /// <param name = "values"><dd>  <p> A 4-component array that containing the values to fill the unordered-access-view resource with. </p> </dd></param>
        /// <param name = "numRects"><dd>  <p> The number of rectangles in the array that the <em>pRects</em> parameter specifies. </p> </dd></param>
        /// <param name = "rectsRef"><dd>  <p> An array of <strong>D3D12_RECT</strong> structures for the rectangles in the resource view to clear. If <strong><c>null</c></strong>, <strong>ClearUnorderedAccessViewUint</strong> clears the entire resource view. </p> </dd></param>
        /// <doc-id>dn903853</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::ClearUnorderedAccessViewUint([In] D3D12_GPU_DESCRIPTOR_HANDLE ViewGPUHandleInCurrentHeap,[In] D3D12_CPU_DESCRIPTOR_HANDLE ViewCPUHandle,[In] ID3D12Resource* pResource,[In] const SHARPDX_INT4* Values,[In] unsigned int NumRects,[In, Buffer] const RECT* pRects)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::ClearUnorderedAccessViewUint</unmanaged-short>
        public unsafe void ClearUnorderedAccessViewUint(SharpDX.Direct3D12.GpuDescriptorHandle viewGPUHandleInCurrentHeap, SharpDX.Direct3D12.CpuDescriptorHandle viewCPUHandle, SharpDX.Direct3D12.Resource resourceRef, SharpDX.Mathematics.Interop.RawInt4 values, System.Int32 numRects, SharpDX.Mathematics.Interop.RawRectangle[] rectsRef)
        {
            SharpDX.Direct3D12.CpuDescriptorHandle.__Native viewCPUHandle_ = default (SharpDX.Direct3D12.CpuDescriptorHandle.__Native);
            System.IntPtr resourceRef_ = System.IntPtr.Zero;
            viewCPUHandle.__MarshalTo(ref viewCPUHandle_);
            resourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(resourceRef);
            fixed (void *rectsRef_ = rectsRef)
                SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid0(this._nativePointer, viewGPUHandleInCurrentHeap, viewCPUHandle_, (void *)resourceRef_, &values, numRects, rectsRef_, (*(void ***)this._nativePointer)[49]);
            viewCPUHandle.__MarshalFree(ref viewCPUHandle_);
        }

        /// <summary>
        /// <p>Sets all the elements in a unordered access view to the specified float values.</p>
        /// </summary>
        /// <param name = "viewGPUHandleInCurrentHeap"><dd>  <p> Describes the GPU descriptor handle that represents the start of the heap for the unordered-access view to clear. </p> </dd></param>
        /// <param name = "viewCPUHandle"><dd>  <p> Describes the CPU descriptor handle that represents the start of the heap for the render target to clear. </p> </dd></param>
        /// <param name = "resourceRef"><dd>  <p> A reference to the <strong><see cref = "SharpDX.Direct3D12.Resource"/></strong> interface that represents the unordered-access-view resource to clear. </p> </dd></param>
        /// <param name = "values"><dd>  <p> A 4-component array that containing the values to fill the unordered-access-view resource with. </p> </dd></param>
        /// <param name = "numRects"><dd>  <p> The number of rectangles in the array that the <em>pRects</em> parameter specifies. </p> </dd></param>
        /// <param name = "rectsRef"><dd>  <p> An array of <strong>D3D12_RECT</strong> structures for the rectangles in the resource view to clear. If <strong><c>null</c></strong>, <strong>ClearUnorderedAccessViewFloat</strong> clears the entire resource view. </p> </dd></param>
        /// <doc-id>dn903849</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::ClearUnorderedAccessViewFloat([In] D3D12_GPU_DESCRIPTOR_HANDLE ViewGPUHandleInCurrentHeap,[In] D3D12_CPU_DESCRIPTOR_HANDLE ViewCPUHandle,[In] ID3D12Resource* pResource,[In] const SHARPDX_VECTOR4* Values,[In] unsigned int NumRects,[In, Buffer] const RECT* pRects)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::ClearUnorderedAccessViewFloat</unmanaged-short>
        public unsafe void ClearUnorderedAccessViewFloat(SharpDX.Direct3D12.GpuDescriptorHandle viewGPUHandleInCurrentHeap, SharpDX.Direct3D12.CpuDescriptorHandle viewCPUHandle, SharpDX.Direct3D12.Resource resourceRef, SharpDX.Mathematics.Interop.RawVector4 values, System.Int32 numRects, SharpDX.Mathematics.Interop.RawRectangle[] rectsRef)
        {
            SharpDX.Direct3D12.CpuDescriptorHandle.__Native viewCPUHandle_ = default (SharpDX.Direct3D12.CpuDescriptorHandle.__Native);
            System.IntPtr resourceRef_ = System.IntPtr.Zero;
            viewCPUHandle.__MarshalTo(ref viewCPUHandle_);
            resourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(resourceRef);
            fixed (void *rectsRef_ = rectsRef)
                SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid0(this._nativePointer, viewGPUHandleInCurrentHeap, viewCPUHandle_, (void *)resourceRef_, &values, numRects, rectsRef_, (*(void ***)this._nativePointer)[50]);
            viewCPUHandle.__MarshalFree(ref viewCPUHandle_);
        }

        /// <summary>
        /// <p>Discards a resource.</p>
        /// </summary>
        /// <param name = "resourceRef"><dd>  <p> A reference to the <strong><see cref = "SharpDX.Direct3D12.Resource"/></strong> interface for the resource to discard. </p> </dd></param>
        /// <param name = "regionRef"><dd>  <p> A reference to a <strong><see cref = "SharpDX.Direct3D12.DiscardRegion"/></strong> structure that describes details for the discard-resource operation. </p> </dd></param>
        /// <remarks>
        /// <p>The semantics of <strong>DiscardResource</strong> change based on the command list type.</p><p> For <strong>D3D12_COMMAND_LIST_TYPE_DIRECT</strong>, the following two rules apply:
        /// </p><ul> <li>When a resource has the <strong>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</strong> flag, <strong>DiscardResource</strong> must be called when the discarded subresource regions are in the <strong>D3D12_RESOURCE_STATE_RENDER_TARGET</strong> resource barrier state.</li> <li>When a resource has the <strong>D3D12_RESOURCE_FLAG _ALLOW_DEPTH_STENCIL</strong> flag, <strong>DiscardResource</strong> must be called when the discarded subresource regions are in the <strong>D3D12_RESOURCE_STATE_DEPTH_WRITE</strong>.
        /// </li> </ul><p>For <strong>D3D12_COMMAND_LIST_TYPE_COMPUTE</strong>, the following rule applies:
        /// </p><ul> <li>The resource must have the <strong>D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS</strong> flag, and <strong>DiscardResource</strong> must be called when the discarded subresource regions are in the <strong>D3D12_RESOURCE_STATE_UNORDERED_ACCESS</strong> resource barrier state.</li> </ul><p><strong>DiscardResource</strong> is not supported on command lists with either <strong>D3D12_COMMAND_LIST_TYPE_BUNDLE</strong> nor <strong>D3D12_COMMAND_LIST_TYPE_COPY</strong>.</p>
        /// </remarks>
        /// <doc-id>dn903869</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::DiscardResource([In] ID3D12Resource* pResource,[In, Optional] const D3D12_DISCARD_REGION* pRegion)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::DiscardResource</unmanaged-short>
        public unsafe void DiscardResource(SharpDX.Direct3D12.Resource resourceRef, SharpDX.Direct3D12.DiscardRegion? regionRef)
        {
            System.IntPtr resourceRef_ = System.IntPtr.Zero;
            SharpDX.Direct3D12.DiscardRegion regionRef_;
            resourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(resourceRef);
            if (regionRef != null)
                regionRef_ = regionRef.Value;
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)resourceRef_, regionRef == null ? (void *)0 : &regionRef_, (*(void ***)this._nativePointer)[51]);
        }

        /// <summary>
        /// <p>Starts a query running.</p>
        /// </summary>
        /// <param name = "queryHeapRef"><dd>  <p> Specifies the <strong><see cref = "SharpDX.Direct3D12.QueryHeap"/></strong> containing the query. </p> </dd></param>
        /// <param name = "type"><dd>  <p> Specifies one member of <strong><see cref = "SharpDX.Direct3D12.QueryType"/></strong>. </p> </dd></param>
        /// <param name = "index"><dd>  <p> Specifies the index of the query within the query heap. </p> </dd></param>
        /// <remarks>
        /// <p> In Direct3D 12, the usage of queries is more restricted than Direct3D 11.  The following scenarios are no longer supported: </p><ul> <li> A call to <strong>BeginQuery</strong> followed by another call to  <strong>BeginQuery</strong> without an intervening call to <strong>EndQuery</strong>. </li> <li> A call to <strong>EndQuery</strong> followed by <strong>EndQuery</strong> without an intervening call to <strong>BeginQuery</strong>. </li> </ul><p> Given these restrictions, there are 3 states that a query can be in: </p><ul> <li>Inactive (this is the initial state of all queries)</li> <li>Querying</li> <li>Predicating</li> </ul><p><strong>BeginQuery</strong> transitions a query from the inactive state to the querying state. <strong>EndQuery</strong> transitions a query from the querying state to the inactive state. <strong>SetPredication</strong> transitions the previous set query from the predicating state to the inactive state and transitions the newly set query from the inactive state to the predicating state. </p>
        /// </remarks>
        /// <doc-id>dn903838</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::BeginQuery([In] ID3D12QueryHeap* pQueryHeap,[In] D3D12_QUERY_TYPE Type,[In] unsigned int Index)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::BeginQuery</unmanaged-short>
        public unsafe void BeginQuery(SharpDX.Direct3D12.QueryHeap queryHeapRef, SharpDX.Direct3D12.QueryType type, System.Int32 index)
        {
            System.IntPtr queryHeapRef_ = System.IntPtr.Zero;
            queryHeapRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.QueryHeap>(queryHeapRef);
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)queryHeapRef_, unchecked ((System.Int32)type), index, (*(void ***)this._nativePointer)[52]);
        }

        /// <summary>
        /// <p> Ends a running query. </p>
        /// </summary>
        /// <param name = "queryHeapRef"><dd>  <p> Specifies the <strong><see cref = "SharpDX.Direct3D12.QueryHeap"/></strong> containing the query. </p> </dd></param>
        /// <param name = "type"><dd>  <p> Specifies one member of <strong><see cref = "SharpDX.Direct3D12.QueryType"/></strong>. </p> </dd></param>
        /// <param name = "index"><dd>  <p> Specifies the index of the query in the query heap. </p> </dd></param>
        /// <remarks>
        /// <p> Refer to the remarks for <strong>BeginQuery</strong>, and to Queries. </p>
        /// </remarks>
        /// <doc-id>dn903881</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::EndQuery([In] ID3D12QueryHeap* pQueryHeap,[In] D3D12_QUERY_TYPE Type,[In] unsigned int Index)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::EndQuery</unmanaged-short>
        public unsafe void EndQuery(SharpDX.Direct3D12.QueryHeap queryHeapRef, SharpDX.Direct3D12.QueryType type, System.Int32 index)
        {
            System.IntPtr queryHeapRef_ = System.IntPtr.Zero;
            queryHeapRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.QueryHeap>(queryHeapRef);
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)queryHeapRef_, unchecked ((System.Int32)type), index, (*(void ***)this._nativePointer)[53]);
        }

        /// <summary>
        /// <p> </p><p> Extracts data from a query. <strong>ResolveQueryData</strong> works with all heap types (default, upload, and readback).? </p>
        /// </summary>
        /// <param name = "queryHeapRef"><dd>  <p> Specifies the  <strong><see cref = "SharpDX.Direct3D12.QueryHeap"/></strong> containing the queries to resolve. </p> </dd></param>
        /// <param name = "type"><dd>  <p> Specifies the type of query, one member of <strong><see cref = "SharpDX.Direct3D12.QueryType"/></strong>. </p> </dd></param>
        /// <param name = "startIndex"><dd>  <p> Specifies an index of the first query to resolve. </p> </dd></param>
        /// <param name = "numQueries"><dd>  <p> Specifies the number of queries to resolve. </p> </dd></param>
        /// <param name = "destinationBufferRef"><dd>  <p> Specifies an <strong><see cref = "SharpDX.Direct3D12.Resource"/></strong> destination buffer, which must be in the state <strong>D3D12_RESOURCE_STATE_COPY_DEST</strong>. </p> </dd></param>
        /// <param name = "alignedDestinationBufferOffset"><dd>  <p> Specifies an alignment offset into the destination buffer. Must be a multiple of 8 bytes. </p> </dd></param>
        /// <remarks>
        /// <p><strong>ResolveQueryData</strong> performs a batched operation which writes query data into a destination buffer.  Query data is written contiguously to the destination buffer, and the parameter. </p><p> Binary occlusion queries write 64-bits per query.  The least significant bit is either 0 or 1.  The rest of the bits are 0. </p><p>The core runtime will validate the following:</p><ul> <li><em>StartIndex</em> and <em>NumQueries</em> are within range. </li> <li><em>AlignedDestinationBufferOffset</em> is a multiple of 8 bytes. </li> <li><em>DestinationBuffer</em> is a buffer. </li> <li> The written data will not overflow the output buffer. </li> <li> The query type must be supported by the command list type. </li> <li> The query type must be supported by the query heap. </li> </ul><p> The debug layer will issue a warning if the destination buffer is not in the D3D12_RESOURCE_STATE_COPY_DEST state. </p>
        /// </remarks>
        /// <doc-id>dn903896</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::ResolveQueryData([In] ID3D12QueryHeap* pQueryHeap,[In] D3D12_QUERY_TYPE Type,[In] unsigned int StartIndex,[In] unsigned int NumQueries,[In] ID3D12Resource* pDestinationBuffer,[In] unsigned longlong AlignedDestinationBufferOffset)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::ResolveQueryData</unmanaged-short>
        public unsafe void ResolveQueryData(SharpDX.Direct3D12.QueryHeap queryHeapRef, SharpDX.Direct3D12.QueryType type, System.Int32 startIndex, System.Int32 numQueries, SharpDX.Direct3D12.Resource destinationBufferRef, System.Int64 alignedDestinationBufferOffset)
        {
            System.IntPtr queryHeapRef_ = System.IntPtr.Zero;
            System.IntPtr destinationBufferRef_ = System.IntPtr.Zero;
            queryHeapRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.QueryHeap>(queryHeapRef);
            destinationBufferRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(destinationBufferRef);
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)queryHeapRef_, unchecked ((System.Int32)type), startIndex, numQueries, (void *)destinationBufferRef_, alignedDestinationBufferOffset, (*(void ***)this._nativePointer)[54]);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "bufferRef">No documentation.</param>
        /// <param name = "alignedBufferOffset">No documentation.</param>
        /// <param name = "operation">No documentation.</param>
        /// <unmanaged>void ID3D12GraphicsCommandList::SetPredication([In, Optional] ID3D12Resource* pBuffer,[In] unsigned longlong AlignedBufferOffset,[In] D3D12_PREDICATION_OP Operation)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::SetPredication</unmanaged-short>
        public unsafe void SetPredication(SharpDX.Direct3D12.Resource bufferRef, System.Int64 alignedBufferOffset, SharpDX.Direct3D12.PredicationOperation operation)
        {
            System.IntPtr bufferRef_ = System.IntPtr.Zero;
            bufferRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(bufferRef);
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)bufferRef_, alignedBufferOffset, unchecked ((System.Int32)operation), (*(void ***)this._nativePointer)[55]);
        }

        /// <summary>
        /// <p> Not intended to be called directly.? Use the PIX event runtime to insert events into a command list.</p>
        /// </summary>
        /// <param name = "metadata">No documentation.</param>
        /// <param name = "dataRef">No documentation.</param>
        /// <param name = "size">No documentation.</param>
        /// <remarks>
        /// <p>This is a support method used internally by the PIX event runtime.? It is not intended to be called directly.</p><p>To insert instrumentation markers at the current location within a D3D12 command list, use the <strong>PIXSetMarker</strong> function.? This is provided by the WinPixEventRuntime NuGet package.</p>
        /// </remarks>
        /// <doc-id>dn986885</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::SetMarker([In] unsigned int Metadata,[In, Buffer, Optional] const void* pData,[In] unsigned int Size)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::SetMarker</unmanaged-short>
        public unsafe void SetMarker(System.Int32 metadata, System.IntPtr dataRef, System.Int32 size)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, metadata, (void *)dataRef, size, (*(void ***)this._nativePointer)[56]);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "metadata">No documentation.</param>
        /// <param name = "dataRef">No documentation.</param>
        /// <param name = "size">No documentation.</param>
        /// <unmanaged>void ID3D12GraphicsCommandList::BeginEvent([In] unsigned int Metadata,[In, Buffer, Optional] const void* pData,[In] unsigned int Size)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::BeginEvent</unmanaged-short>
        internal unsafe void BeginEvent(System.Int32 metadata, System.IntPtr dataRef, System.Int32 size)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, metadata, (void *)dataRef, size, (*(void ***)this._nativePointer)[57]);
        }

        /// <summary>
        /// <p> Not intended to be called directly.? Use the PIX event runtime to insert events into a command list.</p>
        /// </summary>
        /// <remarks>
        /// <p>This is a support method used internally by the PIX event runtime.? It is not intended to be called directly.</p><p>To mark the end of an instrumentation region at the current location within a D3D12 command list, use the <strong>PIXEndEvent</strong> function or <strong>PIXScopedEvent</strong> macro.? These are provided by the WinPixEventRuntime NuGet package.</p>
        /// </remarks>
        /// <doc-id>dn903879</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::EndEvent()</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::EndEvent</unmanaged-short>
        public unsafe void EndEvent()
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (*(void ***)this._nativePointer)[58]);
        }

        /// <summary>
        /// <p> Apps perform indirect draws/dispatches using the <strong>ExecuteIndirect</strong> method. </p>
        /// </summary>
        /// <param name = "commandSignatureRef"><dd>  <p> Specifies a <strong><see cref = "SharpDX.Direct3D12.CommandSignature"/></strong>. The data referenced by <em>pArgumentBuffer</em> will be interpreted depending on the contents of the command signature. Refer to Indirect Drawing for the APIs that are used to create a command signature. </p> </dd></param>
        /// <param name = "maxCommandCount"><dd>  <p>There are two ways that command counts can be specified:</p> <ul> <li> If <em>pCountBuffer</em> is not <c>null</c>, then <em>MaxCommandCount</em> specifies the maximum number of operations which will be performed.  The actual number of operations to be performed are defined by the minimum of this value, and a 32-bit unsigned integer contained in <em>pCountBuffer</em> (at the byte offset specified by <em>CountBufferOffset</em>). </li> <li> If <em>pCountBuffer</em> is <c>null</c>, the <em>MaxCommandCount</em> specifies the exact number of operations which will be performed. </li> </ul> </dd></param>
        /// <param name = "argumentBufferRef"><dd>  <p> Specifies one or more <strong><see cref = "SharpDX.Direct3D12.Resource"/></strong> objects, containing the command arguments. </p> </dd></param>
        /// <param name = "argumentBufferOffset"><dd>  <p> Specifies an offset into <em>pArgumentBuffer</em> to identify the first command argument. </p> </dd></param>
        /// <param name = "countBufferRef"><dd>  <p> Specifies a reference to a <strong><see cref = "SharpDX.Direct3D12.Resource"/></strong>. </p> </dd></param>
        /// <param name = "countBufferOffset"><dd>  <p> Specifies a UINT64 that is the offset into <em>pCountBuffer</em>, identifying the argument count. </p> </dd></param>
        /// <remarks>
        /// <p>The semantics of this API are defined with the following pseudo-code:</p><p>Non-<c>null</c> pCountBuffer:</p><code>// Read draw count out of count buffer
        /// UINT CommandCount = pCountBuffer-&gt;ReadUINT32(CountBufferOffset); CommandCount = min(CommandCount, MaxCommandCount) // Get reference to first Commanding argument
        /// BYTE* Arguments = pArgumentBuffer-&gt;GetBase() + ArgumentBufferOffset; for(UINT CommandIndex = 0; CommandIndex &lt; CommandCount; CommandIndex++)
        /// { // Interpret the data contained in *Arguments // according to the command signature pCommandSignature-&gt;Interpret(Arguments); Arguments += pCommandSignature -&gt;GetByteStride();
        /// }
        /// </code><p><c>null</c> pCountBuffer:</p><code>// Get reference to first Commanding argument
        /// BYTE* Arguments = pArgumentBuffer-&gt;GetBase() + ArgumentBufferOffset; for(UINT CommandIndex = 0; CommandIndex &lt; MaxCommandCount; CommandIndex++)
        /// { // Interpret the data contained in *Arguments // according to the command signature pCommandSignature-&gt;Interpret(Arguments); Arguments += pCommandSignature -&gt;GetByteStride();
        /// }
        /// </code><p>The debug layer will issue an error if either the count buffer or the argument buffer are not in the D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT state. The core runtime will validate:</p><ul> <li><em>CountBufferOffset</em> and <em>ArgumentBufferOffset</em> are 4-byte aligned </li> <li><em>pCountBuffer</em> and <em>pArgumentBuffer</em> are buffer resources (any heap type) </li> <li> The offset implied by <em>MaxCommandCount</em>, <em>ArgumentBufferOffset</em>, and the drawing program stride do not exceed the bounds of <em>pArgumentBuffer</em> (similarly for count buffer) </li> <li>The command list is a direct command list or a compute command list (not a copy or JPEG decode command list)</li> <li>The root signature of the command list matches the root signature of the command signature</li> </ul><p> The functionality of two APIs from earlier versions of Direct3D, <code>DrawInstancedIndirect</code> and <code>DrawIndexedInstancedIndirect</code>, are encompassed by  <strong>ExecuteIndirect</strong>. </p>
        /// </remarks>
        /// <doc-id>dn903884</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::ExecuteIndirect([In] ID3D12CommandSignature* pCommandSignature,[In] unsigned int MaxCommandCount,[In] ID3D12Resource* pArgumentBuffer,[In] unsigned longlong ArgumentBufferOffset,[In, Optional] ID3D12Resource* pCountBuffer,[In] unsigned longlong CountBufferOffset)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::ExecuteIndirect</unmanaged-short>
        public unsafe void ExecuteIndirect(SharpDX.Direct3D12.CommandSignature commandSignatureRef, System.Int32 maxCommandCount, SharpDX.Direct3D12.Resource argumentBufferRef, System.Int64 argumentBufferOffset, SharpDX.Direct3D12.Resource countBufferRef, System.Int64 countBufferOffset)
        {
            System.IntPtr commandSignatureRef_ = System.IntPtr.Zero;
            System.IntPtr argumentBufferRef_ = System.IntPtr.Zero;
            System.IntPtr countBufferRef_ = System.IntPtr.Zero;
            commandSignatureRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.CommandSignature>(commandSignatureRef);
            argumentBufferRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(argumentBufferRef);
            countBufferRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(countBufferRef);
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)commandSignatureRef_, maxCommandCount, (void *)argumentBufferRef_, argumentBufferOffset, (void *)countBufferRef_, countBufferOffset, (*(void ***)this._nativePointer)[59]);
        }

        /// <summary>
        /// <p> Bind an array of viewports to the rasterizer stage of the pipeline. </p>
        /// </summary>
        /// <param name = "numViewports"><dd>  <p> Number of viewports to bind. The range of valid values is (0, D3D12_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE). </p> </dd></param>
        /// <param name = "viewportsRef"><dd>  <p> An array of <strong><see cref = "SharpDX.Direct3D12.Viewport"/></strong> structures to bind to the device. </p> </dd></param>
        /// <remarks>
        /// <p> All viewports must be set atomically as one operation. Any viewports not defined by the call are disabled. </p><p> Which viewport to use is determined by the SV_ViewportArrayIndex semantic output by a geometry shader; if a geometry shader does not specify the semantic, Direct3D will use the first viewport in the array. </p><strong>Note</strong>?? Even though you specify float values to the members of the <strong><see cref = "SharpDX.Direct3D12.Viewport"/></strong> structure for the <em>pViewports</em> array in a call to  <strong>RSSetViewports</strong> for feature levels 9_x, <strong>RSSetViewports</strong> uses DWORDs internally. Because of this behavior, when you use a negative top left corner for the viewport, the call to  <strong>RSSetViewports</strong> for feature levels 9_x fails. This failure occurs because <strong>RSSetViewports</strong> for 9_x casts the floating point values into unsigned integers without validation, which results in integer overflow.?
        /// </remarks>
        /// <doc-id>dn903900</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::RSSetViewports([In] unsigned int NumViewports,[In, Buffer] const D3D12_VIEWPORT* pViewports)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::RSSetViewports</unmanaged-short>
        private unsafe void SetViewports(System.Int32 numViewports, System.IntPtr viewportsRef)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, numViewports, (void *)viewportsRef, (*(void ***)this._nativePointer)[21]);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "numRects">No documentation.</param>
        /// <param name = "rectsRef">No documentation.</param>
        /// <unmanaged>void ID3D12GraphicsCommandList::RSSetScissorRects([In] unsigned int NumRects,[In, Buffer] const RECT* pRects)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::RSSetScissorRects</unmanaged-short>
        private unsafe void SetScissorRectangles(System.Int32 numRects, System.IntPtr rectsRef)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, numRects, (void *)rectsRef, (*(void ***)this._nativePointer)[22]);
        }

        /// <summary>
        /// <p> Changes the currently bound descriptor heaps that are associated with a command list. </p>
        /// </summary>
        /// <param name = "numDescriptorHeaps"><dd>  <p> Number of descriptor heaps to bind. </p> </dd></param>
        /// <param name = "descriptorHeapsOut"><dd>  <p> A reference to an array of <strong><see cref = "SharpDX.Direct3D12.DescriptorHeap"/></strong> objects for the heaps to set on the command list. </p> </dd></param>
        /// <remarks>
        /// <p><strong>SetDescriptorHeaps</strong> can be called on a bundle, but the bundle descriptor heaps must match the calling command list descriptor heap. For more information on bundle restrictions, refer to Creating and Recording Command Lists and Bundles.</p>
        /// </remarks>
        /// <doc-id>Dn903908</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::SetDescriptorHeaps([In] unsigned int NumDescriptorHeaps,[In, Buffer] const ID3D12DescriptorHeap** ppDescriptorHeaps)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::SetDescriptorHeaps</unmanaged-short>
        public unsafe void SetDescriptorHeaps(System.Int32 numDescriptorHeaps, SharpDX.ComArray<SharpDX.Direct3D12.DescriptorHeap> descriptorHeapsOut)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, numDescriptorHeaps, (void *)(descriptorHeapsOut?.NativePointer ?? System.IntPtr.Zero), (*(void ***)this._nativePointer)[28]);
        }

        /// <summary>
        /// <p> Changes the currently bound descriptor heaps that are associated with a command list. </p>
        /// </summary>
        /// <param name = "numDescriptorHeaps"><dd>  <p> Number of descriptor heaps to bind. </p> </dd></param>
        /// <param name = "descriptorHeapsOut"><dd>  <p> A reference to an array of <strong><see cref = "SharpDX.Direct3D12.DescriptorHeap"/></strong> objects for the heaps to set on the command list. </p> </dd></param>
        /// <remarks>
        /// <p><strong>SetDescriptorHeaps</strong> can be called on a bundle, but the bundle descriptor heaps must match the calling command list descriptor heap. For more information on bundle restrictions, refer to Creating and Recording Command Lists and Bundles.</p>
        /// </remarks>
        /// <doc-id>Dn903908</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList::SetDescriptorHeaps([In] unsigned int NumDescriptorHeaps,[In, Buffer] const ID3D12DescriptorHeap** ppDescriptorHeaps)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList::SetDescriptorHeaps</unmanaged-short>
        private unsafe void SetDescriptorHeaps(System.Int32 numDescriptorHeaps, System.IntPtr descriptorHeapsOut)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, numDescriptorHeaps, (void *)descriptorHeapsOut, (*(void ***)this._nativePointer)[28]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("553103fb-1fe7-4557-bb38-946d7d0e7ca7")]
    public partial class GraphicsCommandList1 : SharpDX.Direct3D12.GraphicsCommandList
    {
        public GraphicsCommandList1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator GraphicsCommandList1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new GraphicsCommandList1(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>SetViewInstanceMask</unmanaged>
        /// <unmanaged-short>SetViewInstanceMask</unmanaged-short>
        public System.Int32 ViewInstanceMask
        {
            set => SetViewInstanceMask(value);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "dstBufferRef">No documentation.</param>
        /// <param name = "dstOffset">No documentation.</param>
        /// <param name = "srcBufferRef">No documentation.</param>
        /// <param name = "srcOffset">No documentation.</param>
        /// <param name = "dependencies">No documentation.</param>
        /// <param name = "dependentResourcesOut">No documentation.</param>
        /// <param name = "dependentSubresourceRangesRef">No documentation.</param>
        /// <unmanaged>void ID3D12GraphicsCommandList1::AtomicCopyBufferUINT([In] ID3D12Resource* pDstBuffer,[In] unsigned longlong DstOffset,[In] ID3D12Resource* pSrcBuffer,[In] unsigned longlong SrcOffset,[In] unsigned int Dependencies,[In, Buffer] const ID3D12Resource** ppDependentResources,[In, Buffer] const D3D12_SUBRESOURCE_RANGE_UINT64* pDependentSubresourceRanges)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList1::AtomicCopyBufferUINT</unmanaged-short>
        public unsafe void AtomicCopyBufferUINT(SharpDX.Direct3D12.Resource dstBufferRef, System.Int64 dstOffset, SharpDX.Direct3D12.Resource srcBufferRef, System.Int64 srcOffset, System.Int32 dependencies, SharpDX.Direct3D12.Resource[] dependentResourcesOut, SharpDX.Direct3D12.SubResourceRangeUInt64[] dependentSubresourceRangesRef)
        {
            System.IntPtr dstBufferRef_ = System.IntPtr.Zero;
            System.IntPtr srcBufferRef_ = System.IntPtr.Zero;
            System.IntPtr*dependentResourcesOut_;
            dependentResourcesOut_ = (System.IntPtr*)0;
            if (dependentResourcesOut != null)
            {
                System.IntPtr*_dependentResourcesOut = stackalloc System.IntPtr[dependentResourcesOut.Length];
                dependentResourcesOut_ = _dependentResourcesOut;
            }

            dstBufferRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(dstBufferRef);
            srcBufferRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(srcBufferRef);
            if (dependentResourcesOut != null)
                for (int i = 0; i < dependentResourcesOut.Length; ++i)
                    (dependentResourcesOut_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(dependentResourcesOut[i]);
            fixed (void *dependentSubresourceRangesRef_ = dependentSubresourceRangesRef)
                SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)dstBufferRef_, dstOffset, (void *)srcBufferRef_, srcOffset, dependencies, (void *)dependentResourcesOut_, dependentSubresourceRangesRef_, (*(void ***)this._nativePointer)[60]);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "dstBufferRef">No documentation.</param>
        /// <param name = "dstOffset">No documentation.</param>
        /// <param name = "srcBufferRef">No documentation.</param>
        /// <param name = "srcOffset">No documentation.</param>
        /// <param name = "dependencies">No documentation.</param>
        /// <param name = "dependentResourcesOut">No documentation.</param>
        /// <param name = "dependentSubresourceRangesRef">No documentation.</param>
        /// <unmanaged>void ID3D12GraphicsCommandList1::AtomicCopyBufferUINT64([In] ID3D12Resource* pDstBuffer,[In] unsigned longlong DstOffset,[In] ID3D12Resource* pSrcBuffer,[In] unsigned longlong SrcOffset,[In] unsigned int Dependencies,[In, Buffer] const ID3D12Resource** ppDependentResources,[In, Buffer] const D3D12_SUBRESOURCE_RANGE_UINT64* pDependentSubresourceRanges)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList1::AtomicCopyBufferUINT64</unmanaged-short>
        public unsafe void AtomicCopyBufferUINT64(SharpDX.Direct3D12.Resource dstBufferRef, System.Int64 dstOffset, SharpDX.Direct3D12.Resource srcBufferRef, System.Int64 srcOffset, System.Int32 dependencies, SharpDX.Direct3D12.Resource[] dependentResourcesOut, SharpDX.Direct3D12.SubResourceRangeUInt64[] dependentSubresourceRangesRef)
        {
            System.IntPtr dstBufferRef_ = System.IntPtr.Zero;
            System.IntPtr srcBufferRef_ = System.IntPtr.Zero;
            System.IntPtr*dependentResourcesOut_;
            dependentResourcesOut_ = (System.IntPtr*)0;
            if (dependentResourcesOut != null)
            {
                System.IntPtr*_dependentResourcesOut = stackalloc System.IntPtr[dependentResourcesOut.Length];
                dependentResourcesOut_ = _dependentResourcesOut;
            }

            dstBufferRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(dstBufferRef);
            srcBufferRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(srcBufferRef);
            if (dependentResourcesOut != null)
                for (int i = 0; i < dependentResourcesOut.Length; ++i)
                    (dependentResourcesOut_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(dependentResourcesOut[i]);
            fixed (void *dependentSubresourceRangesRef_ = dependentSubresourceRangesRef)
                SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)dstBufferRef_, dstOffset, (void *)srcBufferRef_, srcOffset, dependencies, (void *)dependentResourcesOut_, dependentSubresourceRangesRef_, (*(void ***)this._nativePointer)[61]);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "min">No documentation.</param>
        /// <param name = "max">No documentation.</param>
        /// <unmanaged>void ID3D12GraphicsCommandList1::OMSetDepthBounds([In] float Min,[In] float Max)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList1::OMSetDepthBounds</unmanaged-short>
        public unsafe void SetDepthsBounds(System.Single min, System.Single max)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, min, max, (*(void ***)this._nativePointer)[62]);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "numSamplesPerPixel">No documentation.</param>
        /// <param name = "numPixels">No documentation.</param>
        /// <param name = "samplePositionsRef">No documentation.</param>
        /// <unmanaged>void ID3D12GraphicsCommandList1::SetSamplePositions([In] unsigned int NumSamplesPerPixel,[In] unsigned int NumPixels,[In, Buffer] D3D12_SAMPLE_POSITION* pSamplePositions)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList1::SetSamplePositions</unmanaged-short>
        public unsafe void SetSamplePositions(System.Int32 numSamplesPerPixel, System.Int32 numPixels, SharpDX.Direct3D12.SamplePosition[] samplePositionsRef)
        {
            fixed (void *samplePositionsRef_ = samplePositionsRef)
                SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, numSamplesPerPixel, numPixels, samplePositionsRef_, (*(void ***)this._nativePointer)[63]);
        }

        /// <summary>
        /// <p>This method configures the sample positions used by subsequent draw, copy, resolve, and similar operations.</p>
        /// </summary>
        /// <param name = "dstResourceRef"><dd>  <p>SAL: <code>_In_</code></p> <p>Specifies the number of samples to take, per pixel. This value can be 1, 2, 4, 8, or 16, otherwise the SetSamplePosition call is dropped. The number of samples must match the sample count configured in the PSO at draw time, otherwise the behavior is undefined.</p> </dd></param>
        /// <param name = "dstSubresource"><dd>  <p>SAL: <code>_In_</code></p> <p>Specifies the number of pixels that sample patterns are being specified for. This value can be either 1 or 4, otherwise the SetSamplePosition call is dropped. A value of 1 configures a single sample pattern to be used for each pixel; a value of 4 configures separate sample patterns for each pixel in a 2x2 pixel grid which is repeated over the render-target or viewport space, aligned to even coordintes.</p> <p>Note that the maximum number of combined samples can't exceed 16, otherwise the call is dropped. If NumPixels is set to 4, NumSamplesPerPixel can specify no more than 4 samples.</p> </dd></param>
        /// <param name = "dstX"><dd>  <p>SAL: <code>_In_reads_(NumSamplesPerPixel*NumPixels)</code></p> <p>Specifies an array of <see cref = "SharpDX.Direct3D12.SamplePosition"/> elements. The size of the array is NumPixels * NumSamplesPerPixel. If NumPixels is set to 4, then the first group of sample positions corresponds to the upper-left pixel in the 2x2 grid of pixels; the next group of sample positions corresponds to the upper-right pixel, the next group to the lower-left pixel, and the final group to the lower-right pixel.</p> <p>If centroid interpolation is used during rendering, the order of positions for each pixel determines centroid-sampling prioritiy. That is, the first covered sample in the order specified is chosen as the centroid sample location.</p> </dd></param>
        /// <param name = "dstY">No documentation.</param>
        /// <param name = "srcResourceRef">No documentation.</param>
        /// <param name = "srcSubresource">No documentation.</param>
        /// <param name = "srcRectRef">No documentation.</param>
        /// <param name = "format">No documentation.</param>
        /// <param name = "resolveMode">No documentation.</param>
        /// <remarks>
        /// <p>The operational semantics of sample positions are determined by the various draw, copy, resolve, and other operations that can occur.</p><p><strong>CommandList:</strong> In the absense of any prior calls to SetSamplePositions in a CommandList, samples assume the default position based on the Pipeline State Object (PSO). The default positions are determined either by the SAMPLE_DESC portion of the PSO if it is present, or by the standard sample positions if the RASTERIZER_DESC portion of the PSO has ForcedSampleCount set to a value greater than 0.</p><p>After SetSamplePosition has been called, subsequent draw calls must use a PSO that specifies a matching sample count either using the SAMPLE_DESC portion of the PSO, or ForcedSampleCount in the RASTERIZER_DESC portion of the PSO.</p><p>SetSamplePositions can only be called on a graphics CommandList. It can't be called in a bundle; bundles inherit sample position state from the calling CommandList and don't modify it.</p><p>Calling SetSamplePositions(0, 0, <c>null</c>) reverts the sample positions to their default values.</p><p><strong>Clear RenderTarget:</strong> Sample positions are ignored when clearing a render target.</p><p><strong>Clear DepthStencil:</strong> When clearing the depth portion of a depth-stencil surface or any region of it, the sample positions must be set to match those of future rendering to the cleared surface or region; the contents of any uncleared regions produced using different sample positions become undefined.</p><p>When clearing the stencil portion of a depth-stencil surface or any region of it, the sample positions are ignored.</p><p><strong>Draw to RenderTarget:</strong> When drawing to a render target the sample positions can be changed for each draw call, even when drawing to a region that overlaps previous draw calls. The current sample positions determine the operational semantics of each draw call and samples are taken from taken from the stored contents of the render target, even if the contents were produced using different sample positions.</p><p><strong>Draw using DepthStencil:</strong> When drawing to a depth-stencil surface (read or write) or any region of it, the sample positions must be set to match those used to clear the affected region previously. To use a different sample position, the target region must be cleared first. The pixels outside the clear region are unaffected.</p><p>Hardware may store the depth portion or a depth-stencil surface as plane equations, and evaluate them to produce depth values when the application issues a read. Only the rasterizer and output-merger are required to suport programmable sample positions of the depth portion of a depth-stencil surface. Any other read or write of the depth portion that has been rendered with sample positions set may ignore them and instead sample at the standard positions.</p><p><strong>Resolve RenderTarget:</strong> When resolving a render target or any region of it, the sample positions are ignored; these APIs operate only on stored color values.</p><p><strong>Resolve DepthStencil:</strong> When resolving the depth portion of a depth-stencil surface or any region of it, the sample positions must be set to match those of past rendering to the resolved surface or region. To use a different sample position, the target region must be cleared first.</p><p>When resolving the stencil portion of a depth-stencil surface or any region of it, the sample positions are ignored; stencil resolves operate only on stored stencil values.</p><p><strong>Copy RenderTarget:</strong> When copying from a render target, the sample positions are ignored regardless of whether it is a full or partial copy.</p><p><strong>Copy DepthStencil (Full Subresource):</strong> When copying a full subresource from a depth-stencil surface, the sample positions must be set to match the sample positions used to generate the source surface. To use a different sample position, the target region must be cleared first.</p><p>On some hardware properties of the source surface (such as stored plane equations for depth values) transfer to the destination. Therefore, if the destination surface is subsequently drawn to, the sample positions originally used to generate the source content need to be used with the destination surface. The API requires this on all hardware for consistency even if it may only apply to some.</p><p><strong>Copy DepthStencil (Partial Subresource):</strong> When copying a partial subresource from a depth-stencil surface, the sample positions must be set to match the sample positions used to generate the source surface, similarly to copying a full subresource. However, if the content of an affected destination subresources is only partially covered by the copy, the contents of the uncovered portion within those subresources becomes undefined unless all of it was generated using the same sample positions as the copy source. To use a different sample position, the target region must be cleared first.</p><p>When copying a partial subresource from the stencil portion of a depth-stencil surface, the sample postions are ignored. It doesn?t matter what sample positions were used to generate content for any other areas of the destination buffer not covered by the copy ? those contents remain valid.</p><p><strong>Shader SamplePos:</strong> The HLSL SamplePos intrinsic is not aware of programmable sample positions and results returned to shaders calling this on a surface rendered with programmable positions is undefined. Applications must pass coordinates into their shader manually if needed. Similarly evaluating attributes by sample index is undefined with programmable sample positions.</p><p><strong>Transitioning out of DEPTH_READ or DEPTH_WRITE state:</strong> If a subresource in DEPTH_READ or DEPTH_WRITE state is transitioned to any other state, including COPY_SOURCE or RESOLVE_SOURCE, some hardware might need to decompress the surface. Therefore, the sample positions must be set on the command list to match those used to generate the content in the source surface. Furthermore, for any subsequent transitions of the surface while the same depth data remains in it, the sample positions must continue to match those set on the command list. To use a different sample position, the target region must be cleared first.</p><p>If an application wants to minimize the decompressed area when only a portion needs to be used, or just to preserve compression, ResolveSubresourceRegion() can be called in DECOMPRESS mode with a rect specified.  This will decompress just the relevant area to a separate resource leaving the source intact on some hardware, though on other hardware even the source area is decompressed. The separate explicitly decompressed resource can then be transitioned to the desired state (such as SHADER_RESOURCE).</p><p><strong>Transitioning out of RENDER_TARGET state:</strong> If a subresource in RENDER_TARGET state is transitioned to anything other than COPY_SOURCE or RESOLVE_SOURCE, some implementations may need to decompress the surface. This decompression is agnostic to sample positions.</p><p>If an application wants to minimize the decompressed area when only a portion needs to be used, or just to preserve compression, ResolveSubresourceRegion() can be called in DECOMPRESS mode with a rect specified.  This will decompress just the relevant area to a separate resource leaving the source intact on some hardware, though on other hardware even the source area is decompressed. The separate explicitly decompressed resource can then be transitioned to the desired state (such as SHADER_RESOURCE).</p>
        /// </remarks>
        /// <doc-id>mt492660</doc-id>
        /// <unmanaged>void ID3D12GraphicsCommandList1::ResolveSubresourceRegion([In] ID3D12Resource* pDstResource,[In] unsigned int DstSubresource,[In] unsigned int DstX,[In] unsigned int DstY,[In] ID3D12Resource* pSrcResource,[In] unsigned int SrcSubresource,[In, Optional] RECT* pSrcRect,[In] DXGI_FORMAT Format,[In] D3D12_RESOLVE_MODE ResolveMode)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList1::ResolveSubresourceRegion</unmanaged-short>
        public unsafe void ResolveSubresourceRegion(SharpDX.Direct3D12.Resource dstResourceRef, System.Int32 dstSubresource, System.Int32 dstX, System.Int32 dstY, SharpDX.Direct3D12.Resource srcResourceRef, System.Int32 srcSubresource, SharpDX.Mathematics.Interop.RawRectangle? srcRectRef, SharpDX.DXGI.Format format, SharpDX.Direct3D12.ResolveMode resolveMode)
        {
            System.IntPtr dstResourceRef_ = System.IntPtr.Zero;
            System.IntPtr srcResourceRef_ = System.IntPtr.Zero;
            SharpDX.Mathematics.Interop.RawRectangle srcRectRef_;
            dstResourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(dstResourceRef);
            srcResourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(srcResourceRef);
            if (srcRectRef != null)
                srcRectRef_ = srcRectRef.Value;
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)dstResourceRef_, dstSubresource, dstX, dstY, (void *)srcResourceRef_, srcSubresource, srcRectRef == null ? (void *)0 : &srcRectRef_, unchecked ((System.Int32)format), unchecked ((System.Int32)resolveMode), (*(void ***)this._nativePointer)[64]);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "mask">No documentation.</param>
        /// <unmanaged>void ID3D12GraphicsCommandList1::SetViewInstanceMask([In] unsigned int Mask)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList1::SetViewInstanceMask</unmanaged-short>
        internal unsafe void SetViewInstanceMask(System.Int32 mask)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, mask, (*(void ***)this._nativePointer)[65]);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "dstBufferRef">No documentation.</param>
        /// <param name = "dstOffset">No documentation.</param>
        /// <param name = "srcBufferRef">No documentation.</param>
        /// <param name = "srcOffset">No documentation.</param>
        /// <param name = "dependencies">No documentation.</param>
        /// <param name = "dependentResourcesOut">No documentation.</param>
        /// <param name = "dependentSubresourceRangesRef">No documentation.</param>
        /// <unmanaged>void ID3D12GraphicsCommandList1::AtomicCopyBufferUINT([In] ID3D12Resource* pDstBuffer,[In] unsigned longlong DstOffset,[In] ID3D12Resource* pSrcBuffer,[In] unsigned longlong SrcOffset,[In] unsigned int Dependencies,[In, Buffer] const ID3D12Resource** ppDependentResources,[In, Buffer] const D3D12_SUBRESOURCE_RANGE_UINT64* pDependentSubresourceRanges)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList1::AtomicCopyBufferUINT</unmanaged-short>
        public unsafe void AtomicCopyBufferUINT(SharpDX.Direct3D12.Resource dstBufferRef, System.Int64 dstOffset, SharpDX.Direct3D12.Resource srcBufferRef, System.Int64 srcOffset, System.Int32 dependencies, SharpDX.ComArray<SharpDX.Direct3D12.Resource> dependentResourcesOut, SharpDX.Direct3D12.SubResourceRangeUInt64[] dependentSubresourceRangesRef)
        {
            System.IntPtr dstBufferRef_ = System.IntPtr.Zero;
            System.IntPtr srcBufferRef_ = System.IntPtr.Zero;
            dstBufferRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(dstBufferRef);
            srcBufferRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(srcBufferRef);
            fixed (void *dependentSubresourceRangesRef_ = dependentSubresourceRangesRef)
                SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)dstBufferRef_, dstOffset, (void *)srcBufferRef_, srcOffset, dependencies, (void *)(dependentResourcesOut?.NativePointer ?? System.IntPtr.Zero), dependentSubresourceRangesRef_, (*(void ***)this._nativePointer)[60]);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "dstBufferRef">No documentation.</param>
        /// <param name = "dstOffset">No documentation.</param>
        /// <param name = "srcBufferRef">No documentation.</param>
        /// <param name = "srcOffset">No documentation.</param>
        /// <param name = "dependencies">No documentation.</param>
        /// <param name = "dependentResourcesOut">No documentation.</param>
        /// <param name = "dependentSubresourceRangesRef">No documentation.</param>
        /// <unmanaged>void ID3D12GraphicsCommandList1::AtomicCopyBufferUINT([In] ID3D12Resource* pDstBuffer,[In] unsigned longlong DstOffset,[In] ID3D12Resource* pSrcBuffer,[In] unsigned longlong SrcOffset,[In] unsigned int Dependencies,[In, Buffer] const ID3D12Resource** ppDependentResources,[In, Buffer] const D3D12_SUBRESOURCE_RANGE_UINT64* pDependentSubresourceRanges)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList1::AtomicCopyBufferUINT</unmanaged-short>
        private unsafe void AtomicCopyBufferUINT(System.IntPtr dstBufferRef, System.Int64 dstOffset, System.IntPtr srcBufferRef, System.Int64 srcOffset, System.Int32 dependencies, System.IntPtr dependentResourcesOut, System.IntPtr dependentSubresourceRangesRef)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)dstBufferRef, dstOffset, (void *)srcBufferRef, srcOffset, dependencies, (void *)dependentResourcesOut, (void *)dependentSubresourceRangesRef, (*(void ***)this._nativePointer)[60]);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "dstBufferRef">No documentation.</param>
        /// <param name = "dstOffset">No documentation.</param>
        /// <param name = "srcBufferRef">No documentation.</param>
        /// <param name = "srcOffset">No documentation.</param>
        /// <param name = "dependencies">No documentation.</param>
        /// <param name = "dependentResourcesOut">No documentation.</param>
        /// <param name = "dependentSubresourceRangesRef">No documentation.</param>
        /// <unmanaged>void ID3D12GraphicsCommandList1::AtomicCopyBufferUINT64([In] ID3D12Resource* pDstBuffer,[In] unsigned longlong DstOffset,[In] ID3D12Resource* pSrcBuffer,[In] unsigned longlong SrcOffset,[In] unsigned int Dependencies,[In, Buffer] const ID3D12Resource** ppDependentResources,[In, Buffer] const D3D12_SUBRESOURCE_RANGE_UINT64* pDependentSubresourceRanges)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList1::AtomicCopyBufferUINT64</unmanaged-short>
        public unsafe void AtomicCopyBufferUINT64(SharpDX.Direct3D12.Resource dstBufferRef, System.Int64 dstOffset, SharpDX.Direct3D12.Resource srcBufferRef, System.Int64 srcOffset, System.Int32 dependencies, SharpDX.ComArray<SharpDX.Direct3D12.Resource> dependentResourcesOut, SharpDX.Direct3D12.SubResourceRangeUInt64[] dependentSubresourceRangesRef)
        {
            System.IntPtr dstBufferRef_ = System.IntPtr.Zero;
            System.IntPtr srcBufferRef_ = System.IntPtr.Zero;
            dstBufferRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(dstBufferRef);
            srcBufferRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(srcBufferRef);
            fixed (void *dependentSubresourceRangesRef_ = dependentSubresourceRangesRef)
                SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)dstBufferRef_, dstOffset, (void *)srcBufferRef_, srcOffset, dependencies, (void *)(dependentResourcesOut?.NativePointer ?? System.IntPtr.Zero), dependentSubresourceRangesRef_, (*(void ***)this._nativePointer)[61]);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "dstBufferRef">No documentation.</param>
        /// <param name = "dstOffset">No documentation.</param>
        /// <param name = "srcBufferRef">No documentation.</param>
        /// <param name = "srcOffset">No documentation.</param>
        /// <param name = "dependencies">No documentation.</param>
        /// <param name = "dependentResourcesOut">No documentation.</param>
        /// <param name = "dependentSubresourceRangesRef">No documentation.</param>
        /// <unmanaged>void ID3D12GraphicsCommandList1::AtomicCopyBufferUINT64([In] ID3D12Resource* pDstBuffer,[In] unsigned longlong DstOffset,[In] ID3D12Resource* pSrcBuffer,[In] unsigned longlong SrcOffset,[In] unsigned int Dependencies,[In, Buffer] const ID3D12Resource** ppDependentResources,[In, Buffer] const D3D12_SUBRESOURCE_RANGE_UINT64* pDependentSubresourceRanges)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList1::AtomicCopyBufferUINT64</unmanaged-short>
        private unsafe void AtomicCopyBufferUINT64(System.IntPtr dstBufferRef, System.Int64 dstOffset, System.IntPtr srcBufferRef, System.Int64 srcOffset, System.Int32 dependencies, System.IntPtr dependentResourcesOut, System.IntPtr dependentSubresourceRangesRef)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)dstBufferRef, dstOffset, (void *)srcBufferRef, srcOffset, dependencies, (void *)dependentResourcesOut, (void *)dependentSubresourceRangesRef, (*(void ***)this._nativePointer)[61]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("38C3E585-FF17-412C-9150-4FC6F9D72A28")]
    public partial class GraphicsCommandList2 : SharpDX.Direct3D12.GraphicsCommandList1
    {
        public GraphicsCommandList2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator GraphicsCommandList2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new GraphicsCommandList2(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "count">No documentation.</param>
        /// <param name = "paramsRef">No documentation.</param>
        /// <param name = "modesRef">No documentation.</param>
        /// <unmanaged>void ID3D12GraphicsCommandList2::WriteBufferImmediate([In] unsigned int Count,[In, Buffer] const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER* pParams,[In, Buffer, Optional] const D3D12_WRITEBUFFERIMMEDIATE_MODE* pModes)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList2::WriteBufferImmediate</unmanaged-short>
        public unsafe void WriteBufferImmediate(System.Int32 count, SharpDX.Direct3D12.WriteBufferImmediateParameter[] paramsRef, SharpDX.Direct3D12.WriteBufferImmediateMode[] modesRef)
        {
            fixed (void *modesRef_ = modesRef)
                fixed (void *paramsRef_ = paramsRef)
                    SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, count, paramsRef_, modesRef_, (*(void ***)this._nativePointer)[66]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("6FDA83A7-B84C-4E38-9AC8-C7BD22016B3D")]
    public partial class GraphicsCommandList3 : SharpDX.Direct3D12.GraphicsCommandList2
    {
        public GraphicsCommandList3(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator GraphicsCommandList3(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new GraphicsCommandList3(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>SetProtectedResourceSession</unmanaged>
        /// <unmanaged-short>SetProtectedResourceSession</unmanaged-short>
        public SharpDX.Direct3D12.ProtectedResourceSession ProtectedResourceSession
        {
            set => SetProtectedResourceSession(value);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "protectedResourceSessionRef">No documentation.</param>
        /// <unmanaged>void ID3D12GraphicsCommandList3::SetProtectedResourceSession([In, Optional] ID3D12ProtectedResourceSession* pProtectedResourceSession)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList3::SetProtectedResourceSession</unmanaged-short>
        internal unsafe void SetProtectedResourceSession(SharpDX.Direct3D12.ProtectedResourceSession protectedResourceSessionRef)
        {
            System.IntPtr protectedResourceSessionRef_ = System.IntPtr.Zero;
            protectedResourceSessionRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.ProtectedResourceSession>(protectedResourceSessionRef);
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)protectedResourceSessionRef_, (*(void ***)this._nativePointer)[67]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("8754318e-d3a9-4541-98cf-645b50dc4874")]
    public partial class GraphicsCommandList4 : SharpDX.Direct3D12.GraphicsCommandList3
    {
        public GraphicsCommandList4(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator GraphicsCommandList4(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new GraphicsCommandList4(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>SetPipelineState1</unmanaged>
        /// <unmanaged-short>SetPipelineState1</unmanaged-short>
        public SharpDX.Direct3D12.StateObject PipelineState1
        {
            set => SetPipelineState1(value);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "numRenderTargets">No documentation.</param>
        /// <param name = "renderTargetsRef">No documentation.</param>
        /// <param name = "depthStencilRef">No documentation.</param>
        /// <param name = "flags">No documentation.</param>
        /// <unmanaged>void ID3D12GraphicsCommandList4::BeginRenderPass([In] unsigned int NumRenderTargets,[In, Buffer, Optional] const D3D12_RENDER_PASS_RENDER_TARGET_DESC* pRenderTargets,[In, Optional] const D3D12_RENDER_PASS_DEPTH_STENCIL_DESC* pDepthStencil,[In] D3D12_RENDER_PASS_FLAGS Flags)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList4::BeginRenderPass</unmanaged-short>
        public unsafe void BeginRenderPass(System.Int32 numRenderTargets, SharpDX.Direct3D12.RenderPassRenderTargetDescription[] renderTargetsRef, SharpDX.Direct3D12.RenderPassDepthStencilDescription? depthStencilRef, SharpDX.Direct3D12.RenderPassFlags flags)
        {
            SharpDX.Direct3D12.RenderPassRenderTargetDescription.__Native[] renderTargetsRef_ = renderTargetsRef == null ? null : new SharpDX.Direct3D12.RenderPassRenderTargetDescription.__Native[renderTargetsRef.Length];
            SharpDX.Direct3D12.RenderPassDepthStencilDescription.__Native depthStencilRef_ = default (SharpDX.Direct3D12.RenderPassDepthStencilDescription.__Native);
            if (renderTargetsRef != null)
                for (int i = 0; i < renderTargetsRef.Length; ++i)
                    if (renderTargetsRef != null)
                        renderTargetsRef[i].__MarshalTo(ref (renderTargetsRef_)[i]);
            if (depthStencilRef != null)
                depthStencilRef.Value.__MarshalTo(ref depthStencilRef_);
            fixed (void *_renderTargetsRef = renderTargetsRef_)
                SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, numRenderTargets, _renderTargetsRef, depthStencilRef == null ? (void *)0 : &depthStencilRef_, unchecked ((System.Int32)flags), (*(void ***)this._nativePointer)[68]);
            if (renderTargetsRef != null)
                for (int i = 0; i < renderTargetsRef.Length; ++i)
                    if (renderTargetsRef != null)
                        renderTargetsRef[i].__MarshalFree(ref (renderTargetsRef_)[i]);
            if (depthStencilRef != null)
                depthStencilRef.Value.__MarshalFree(ref depthStencilRef_);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>void ID3D12GraphicsCommandList4::EndRenderPass()</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList4::EndRenderPass</unmanaged-short>
        public unsafe void EndRenderPass()
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (*(void ***)this._nativePointer)[69]);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "metaCommandRef">No documentation.</param>
        /// <param name = "initializationParametersDataRef">No documentation.</param>
        /// <param name = "initializationParametersDataSizeInBytes">No documentation.</param>
        /// <unmanaged>void ID3D12GraphicsCommandList4::InitializeMetaCommand([In] ID3D12MetaCommand* pMetaCommand,[In, Buffer, Optional] const void* pInitializationParametersData,[In] SIZE_T InitializationParametersDataSizeInBytes)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList4::InitializeMetaCommand</unmanaged-short>
        public unsafe void InitializeMetaCommand(SharpDX.Direct3D12.MetaCommand metaCommandRef, System.IntPtr initializationParametersDataRef, SharpDX.PointerSize initializationParametersDataSizeInBytes)
        {
            System.IntPtr metaCommandRef_ = System.IntPtr.Zero;
            metaCommandRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.MetaCommand>(metaCommandRef);
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)metaCommandRef_, (void *)initializationParametersDataRef, (void *)initializationParametersDataSizeInBytes, (*(void ***)this._nativePointer)[70]);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "metaCommandRef">No documentation.</param>
        /// <param name = "executionParametersDataRef">No documentation.</param>
        /// <param name = "executionParametersDataSizeInBytes">No documentation.</param>
        /// <unmanaged>void ID3D12GraphicsCommandList4::ExecuteMetaCommand([In] ID3D12MetaCommand* pMetaCommand,[In, Buffer, Optional] const void* pExecutionParametersData,[In] SIZE_T ExecutionParametersDataSizeInBytes)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList4::ExecuteMetaCommand</unmanaged-short>
        public unsafe void ExecuteMetaCommand(SharpDX.Direct3D12.MetaCommand metaCommandRef, System.IntPtr executionParametersDataRef, SharpDX.PointerSize executionParametersDataSizeInBytes)
        {
            System.IntPtr metaCommandRef_ = System.IntPtr.Zero;
            metaCommandRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.MetaCommand>(metaCommandRef);
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)metaCommandRef_, (void *)executionParametersDataRef, (void *)executionParametersDataSizeInBytes, (*(void ***)this._nativePointer)[71]);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "descRef">No documentation.</param>
        /// <param name = "numPostbuildInfoDescs">No documentation.</param>
        /// <param name = "postbuildInfoDescsRef">No documentation.</param>
        /// <unmanaged>void ID3D12GraphicsCommandList4::BuildRaytracingAccelerationStructure([In] const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC* pDesc,[In] unsigned int NumPostbuildInfoDescs,[In, Buffer, Optional] const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC* pPostbuildInfoDescs)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList4::BuildRaytracingAccelerationStructure</unmanaged-short>
        public unsafe void BuildRaytracingAccelerationStructure(ref SharpDX.Direct3D12.BuildRaytracingAccelerationStructureDescription descRef, System.Int32 numPostbuildInfoDescs, SharpDX.Direct3D12.RaytracingAccelerationStructurePostbuildInformationDescription[] postbuildInfoDescsRef)
        {
            SharpDX.Direct3D12.BuildRaytracingAccelerationStructureDescription.__Native descRef_ = default (SharpDX.Direct3D12.BuildRaytracingAccelerationStructureDescription.__Native);
            descRef.__MarshalTo(ref descRef_);
            fixed (void *postbuildInfoDescsRef_ = postbuildInfoDescsRef)
                SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, &descRef_, numPostbuildInfoDescs, postbuildInfoDescsRef_, (*(void ***)this._nativePointer)[72]);
            descRef.__MarshalFree(ref descRef_);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "descRef">No documentation.</param>
        /// <param name = "numSourceAccelerationStructures">No documentation.</param>
        /// <param name = "sourceAccelerationStructureDataRef">No documentation.</param>
        /// <unmanaged>void ID3D12GraphicsCommandList4::EmitRaytracingAccelerationStructurePostbuildInfo([In] const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC* pDesc,[In] unsigned int NumSourceAccelerationStructures,[In, Buffer] const unsigned longlong* pSourceAccelerationStructureData)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList4::EmitRaytracingAccelerationStructurePostbuildInfo</unmanaged-short>
        public unsafe void EmitRaytracingAccelerationStructurePostbuildInfo(SharpDX.Direct3D12.RaytracingAccelerationStructurePostbuildInformationDescription descRef, System.Int32 numSourceAccelerationStructures, System.Int64[] sourceAccelerationStructureDataRef)
        {
            fixed (void *sourceAccelerationStructureDataRef_ = sourceAccelerationStructureDataRef)
                SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, &descRef, numSourceAccelerationStructures, sourceAccelerationStructureDataRef_, (*(void ***)this._nativePointer)[73]);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "destAccelerationStructureData">No documentation.</param>
        /// <param name = "sourceAccelerationStructureData">No documentation.</param>
        /// <param name = "mode">No documentation.</param>
        /// <unmanaged>void ID3D12GraphicsCommandList4::CopyRaytracingAccelerationStructure([In] unsigned longlong DestAccelerationStructureData,[In] unsigned longlong SourceAccelerationStructureData,[In] D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE Mode)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList4::CopyRaytracingAccelerationStructure</unmanaged-short>
        public unsafe void CopyRaytracingAccelerationStructure(System.Int64 destAccelerationStructureData, System.Int64 sourceAccelerationStructureData, SharpDX.Direct3D12.RaytracingAccelerationStructureCopyMode mode)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, destAccelerationStructureData, sourceAccelerationStructureData, unchecked ((System.Int32)mode), (*(void ***)this._nativePointer)[74]);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "stateObjectRef">No documentation.</param>
        /// <unmanaged>void ID3D12GraphicsCommandList4::SetPipelineState1([In] ID3D12StateObject* pStateObject)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList4::SetPipelineState1</unmanaged-short>
        internal unsafe void SetPipelineState1(SharpDX.Direct3D12.StateObject stateObjectRef)
        {
            System.IntPtr stateObjectRef_ = System.IntPtr.Zero;
            stateObjectRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.StateObject>(stateObjectRef);
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)stateObjectRef_, (*(void ***)this._nativePointer)[75]);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "descRef">No documentation.</param>
        /// <unmanaged>void ID3D12GraphicsCommandList4::DispatchRays([In] const D3D12_DISPATCH_RAYS_DESC* pDesc)</unmanaged>
        /// <unmanaged-short>ID3D12GraphicsCommandList4::DispatchRays</unmanaged-short>
        public unsafe void DispatchRays(ref SharpDX.Direct3D12.DispatchRaysDescription descRef)
        {
            fixed (void *descRef_ = &descRef)
                SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, descRef_, (*(void ***)this._nativePointer)[76]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("6b3b2502-6e51-45b3-90ee-9884265e8df3")]
    public partial class Heap : SharpDX.Direct3D12.Pageable
    {
        public Heap(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Heap(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Heap(nativePtr);
        /// <summary>
        /// <p>Gets the heap description.</p>
        /// </summary>
        /// <doc-id>dn788689</doc-id>
        /// <unmanaged>GetDesc</unmanaged>
        /// <unmanaged-short>GetDesc</unmanaged-short>
        public SharpDX.Direct3D12.HeapDescription Description
        {
            get => GetDescription();
        }

        /// <summary>
        /// <p>Gets the heap description.</p>
        /// </summary>
        /// <returns><p>Returns the <strong><see cref = "SharpDX.Direct3D12.HeapDescription"/></strong> structure that describes the heap.</p></returns>
        /// <doc-id>dn788689</doc-id>
        /// <unmanaged>D3D12_HEAP_DESC ID3D12Heap::GetDesc()</unmanaged>
        /// <unmanaged-short>ID3D12Heap::GetDesc</unmanaged-short>
        internal unsafe SharpDX.Direct3D12.HeapDescription GetDescription()
        {
            SharpDX.Direct3D12.HeapDescription __result__;
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoidPtr(this._nativePointer, &__result__, (*(void ***)this._nativePointer)[8]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("572F7389-2168-49E3-9693-D6DF5871BF6D")]
    public partial class Heap1 : SharpDX.Direct3D12.Heap
    {
        public Heap1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Heap1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Heap1(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "riid">No documentation.</param>
        /// <param name = "protectedSessionOut">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D12Heap1::GetProtectedResourceSession([In] const GUID&amp; riid,[Out, Optional] void** ppProtectedSession)</unmanaged>
        /// <unmanaged-short>ID3D12Heap1::GetProtectedResourceSession</unmanaged-short>
        public unsafe void GetProtectedResourceSession(System.Guid riid, out System.IntPtr protectedSessionOut)
        {
            SharpDX.Result __result__;
            fixed (void *protectedSessionOut_ = &protectedSessionOut)
                __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, &riid, protectedSessionOut_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("0742a90b-c387-483f-b946-30a7e4e61458")]
    public partial class InfoQueue : SharpDX.ComObject
    {
        public InfoQueue(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator InfoQueue(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new InfoQueue(nativePtr);
        /// <summary>
        /// <p>Get or sets the maximum number of messages that can be added to the message queue. </p>
        /// </summary>
        /// <doc-id>dn950175</doc-id>
        /// <unmanaged>GetMessageCountLimit / SetMessageCountLimit</unmanaged>
        /// <unmanaged-short>GetMessageCountLimit</unmanaged-short>
        public System.Int64 MessageCountLimit
        {
            get => GetMessageCountLimit();
            set => SetMessageCountLimit(value);
        }

        /// <summary>
        /// <p> Get the number of messages that were allowed to pass through a storage filter. </p>
        /// </summary>
        /// <doc-id>dn950177</doc-id>
        /// <unmanaged>GetNumMessagesAllowedByStorageFilter</unmanaged>
        /// <unmanaged-short>GetNumMessagesAllowedByStorageFilter</unmanaged-short>
        public System.Int64 NumMessagesAllowedByStorageFilter
        {
            get => GetNumMessagesAllowedByStorageFilter();
        }

        /// <summary>
        /// <p>Get the number of messages that were denied passage through a storage filter. </p>
        /// </summary>
        /// <doc-id>dn950178</doc-id>
        /// <unmanaged>GetNumMessagesDeniedByStorageFilter</unmanaged>
        /// <unmanaged-short>GetNumMessagesDeniedByStorageFilter</unmanaged-short>
        public System.Int64 NumMessagesDeniedByStorageFilter
        {
            get => GetNumMessagesDeniedByStorageFilter();
        }

        /// <summary>
        /// <p> Get the number of messages currently stored in the message queue. </p>
        /// </summary>
        /// <doc-id>dn950180</doc-id>
        /// <unmanaged>GetNumStoredMessages</unmanaged>
        /// <unmanaged-short>GetNumStoredMessages</unmanaged-short>
        public System.Int64 NumStoredMessages
        {
            get => GetNumStoredMessages();
        }

        /// <summary>
        /// <p> Get the number of messages that are able to pass through a retrieval filter. </p>
        /// </summary>
        /// <doc-id>dn950181</doc-id>
        /// <unmanaged>GetNumStoredMessagesAllowedByRetrievalFilter</unmanaged>
        /// <unmanaged-short>GetNumStoredMessagesAllowedByRetrievalFilter</unmanaged-short>
        public System.Int64 NumStoredMessagesAllowedByRetrievalFilter
        {
            get => GetNumStoredMessagesAllowedByRetrievalFilter();
        }

        /// <summary>
        /// <p> Get the number of messages that were discarded due to the message count limit. </p>
        /// </summary>
        /// <remarks>
        /// <p>Get and set the message count limit with <strong>GetMessageCountLimit</strong> and <strong>SetMessageCountLimit</strong>, respectively. </p>
        /// </remarks>
        /// <doc-id>dn950179</doc-id>
        /// <unmanaged>GetNumMessagesDiscardedByMessageCountLimit</unmanaged>
        /// <unmanaged-short>GetNumMessagesDiscardedByMessageCountLimit</unmanaged-short>
        public System.Int64 NumMessagesDiscardedByMessageCountLimit
        {
            get => GetNumMessagesDiscardedByMessageCountLimit();
        }

        /// <summary>
        /// <p> Get the size of the storage-filter stack in bytes. </p>
        /// </summary>
        /// <doc-id>dn950185</doc-id>
        /// <unmanaged>GetStorageFilterStackSize</unmanaged>
        /// <unmanaged-short>GetStorageFilterStackSize</unmanaged-short>
        public System.Int32 StorageFilterStackSize
        {
            get => GetStorageFilterStackSize();
        }

        /// <summary>
        /// <p> Get the size of the retrieval-filter stack in bytes. </p>
        /// </summary>
        /// <doc-id>dn950183</doc-id>
        /// <unmanaged>GetRetrievalFilterStackSize</unmanaged>
        /// <unmanaged-short>GetRetrievalFilterStackSize</unmanaged-short>
        public System.Int32 RetrievalFilterStackSize
        {
            get => GetRetrievalFilterStackSize();
        }

        /// <summary>
        /// <p>Get or sets a boolean that determines if debug output is on or off. </p>
        /// </summary>
        /// <doc-id>dn950176</doc-id>
        /// <unmanaged>GetMuteDebugOutput / SetMuteDebugOutput</unmanaged>
        /// <unmanaged-short>GetMuteDebugOutput</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool MuteDebugOutput
        {
            get => GetMuteDebugOutput();
            set => SetMuteDebugOutput(value);
        }

        /// <summary>
        /// <p> Set the maximum number of messages that can be added to the message queue. </p>
        /// </summary>
        /// <param name = "messageCountLimit"><dd>  <p> Maximum number of messages that can be added to the message queue. -1 means no limit. When the number of messages in the message queue has reached the maximum limit, new messages coming in will push old messages out. </p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.  </p></returns>
        /// <doc-id>dn950198</doc-id>
        /// <unmanaged>HRESULT ID3D12InfoQueue::SetMessageCountLimit([In] unsigned longlong MessageCountLimit)</unmanaged>
        /// <unmanaged-short>ID3D12InfoQueue::SetMessageCountLimit</unmanaged-short>
        internal unsafe void SetMessageCountLimit(System.Int64 messageCountLimit)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, messageCountLimit, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Clear all messages from the message queue. </p>
        /// </summary>
        /// <doc-id>dn950170</doc-id>
        /// <unmanaged>void ID3D12InfoQueue::ClearStoredMessages()</unmanaged>
        /// <unmanaged-short>ID3D12InfoQueue::ClearStoredMessages</unmanaged-short>
        public unsafe void ClearStoredMessages()
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (*(void ***)this._nativePointer)[4]);
        }

        /// <summary>
        /// <p> Get a message from the message queue. </p>
        /// </summary>
        /// <param name = "messageIndex"><dd>  <p>Index into message queue after an optional retrieval filter has been applied. This can be between 0 and the number of messages in the message queue that pass through the retrieval filter (which can be obtained with <strong>GetNumStoredMessagesAllowedByRetrievalFilter</strong>). 0 is the message at the front of the message queue. </p> </dd></param>
        /// <param name = "messageRef"><dd>  <p> Returned message.</p> </dd></param>
        /// <param name = "messageByteLengthRef"><dd>  <p>Size of <em>pMessage</em> in bytes. </p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.  </p></returns>
        /// <remarks>
        /// <p>This method does not remove any messages from the message queue. </p><p>This method gets messages from the message queue after an optional retrieval filter has been applied. </p><p>Applications should call this method twice to retrieve a message - first to obtain the size of the message and second to get the message. Here is a typical example: </p><code> // Get the size of the message
        /// <see cref = "SharpDX.PointerSize"/> messageLength = 0;
        /// <see cref = "SharpDX.Result"/> hr = pInfoQueue-&gt;GetMessage(0, <c>null</c>, &amp;messageLength); // Allocate space and get the message
        /// <see cref = "SharpDX.Direct3D12.Message"/> * pMessage = (<see cref = "SharpDX.Direct3D12.Message"/>*)malloc(messageLength);
        /// hr = pInfoQueue-&gt;GetMessage(0, pMessage, &amp;messageLength); 
        /// </code>
        /// </remarks>
        /// <doc-id>dn950174</doc-id>
        /// <unmanaged>HRESULT ID3D12InfoQueue::GetMessageW([In] unsigned longlong MessageIndex,[In] D3D12_MESSAGE* pMessage,[InOut] SIZE_T* pMessageByteLength)</unmanaged>
        /// <unmanaged-short>ID3D12InfoQueue::GetMessageW</unmanaged-short>
        internal unsafe void GetMessage(System.Int64 messageIndex, System.IntPtr messageRef, ref SharpDX.PointerSize messageByteLengthRef)
        {
            SharpDX.Result __result__;
            fixed (void *messageByteLengthRef_ = &messageByteLengthRef)
                __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, messageIndex, (void *)messageRef, messageByteLengthRef_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Get the number of messages that were allowed to pass through a storage filter. </p>
        /// </summary>
        /// <returns><p> Number of messages allowed by a storage filter. </p></returns>
        /// <doc-id>dn950177</doc-id>
        /// <unmanaged>unsigned longlong ID3D12InfoQueue::GetNumMessagesAllowedByStorageFilter()</unmanaged>
        /// <unmanaged-short>ID3D12InfoQueue::GetNumMessagesAllowedByStorageFilter</unmanaged-short>
        internal unsafe System.Int64 GetNumMessagesAllowedByStorageFilter()
        {
            System.Int64 __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCalllong(this._nativePointer, (*(void ***)this._nativePointer)[6]);
            return __result__;
        }

        /// <summary>
        /// <p>Get the number of messages that were denied passage through a storage filter. </p>
        /// </summary>
        /// <returns><p> Number of messages denied by a storage filter. </p></returns>
        /// <doc-id>dn950178</doc-id>
        /// <unmanaged>unsigned longlong ID3D12InfoQueue::GetNumMessagesDeniedByStorageFilter()</unmanaged>
        /// <unmanaged-short>ID3D12InfoQueue::GetNumMessagesDeniedByStorageFilter</unmanaged-short>
        internal unsafe System.Int64 GetNumMessagesDeniedByStorageFilter()
        {
            System.Int64 __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCalllong(this._nativePointer, (*(void ***)this._nativePointer)[7]);
            return __result__;
        }

        /// <summary>
        /// <p> Get the number of messages currently stored in the message queue. </p>
        /// </summary>
        /// <returns><p> Number of messages currently stored in the message queue. </p></returns>
        /// <doc-id>dn950180</doc-id>
        /// <unmanaged>unsigned longlong ID3D12InfoQueue::GetNumStoredMessages()</unmanaged>
        /// <unmanaged-short>ID3D12InfoQueue::GetNumStoredMessages</unmanaged-short>
        internal unsafe System.Int64 GetNumStoredMessages()
        {
            System.Int64 __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCalllong(this._nativePointer, (*(void ***)this._nativePointer)[8]);
            return __result__;
        }

        /// <summary>
        /// <p> Get the number of messages that are able to pass through a retrieval filter. </p>
        /// </summary>
        /// <returns><p>Number of messages allowed by a retrieval filter. </p></returns>
        /// <doc-id>dn950181</doc-id>
        /// <unmanaged>unsigned longlong ID3D12InfoQueue::GetNumStoredMessagesAllowedByRetrievalFilter()</unmanaged>
        /// <unmanaged-short>ID3D12InfoQueue::GetNumStoredMessagesAllowedByRetrievalFilter</unmanaged-short>
        internal unsafe System.Int64 GetNumStoredMessagesAllowedByRetrievalFilter()
        {
            System.Int64 __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCalllong(this._nativePointer, (*(void ***)this._nativePointer)[9]);
            return __result__;
        }

        /// <summary>
        /// <p> Get the number of messages that were discarded due to the message count limit. </p>
        /// </summary>
        /// <returns><p> Number of messages discarded. </p></returns>
        /// <remarks>
        /// <p>Get and set the message count limit with <strong>GetMessageCountLimit</strong> and <strong>SetMessageCountLimit</strong>, respectively. </p>
        /// </remarks>
        /// <doc-id>dn950179</doc-id>
        /// <unmanaged>unsigned longlong ID3D12InfoQueue::GetNumMessagesDiscardedByMessageCountLimit()</unmanaged>
        /// <unmanaged-short>ID3D12InfoQueue::GetNumMessagesDiscardedByMessageCountLimit</unmanaged-short>
        internal unsafe System.Int64 GetNumMessagesDiscardedByMessageCountLimit()
        {
            System.Int64 __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCalllong(this._nativePointer, (*(void ***)this._nativePointer)[10]);
            return __result__;
        }

        /// <summary>
        /// <p> Get the maximum number of messages that can be added to the message queue. </p>
        /// </summary>
        /// <returns><p> Maximum number of messages that can be added to the queue. -1 means no limit. When the number of messages in the message queue has reached the maximum limit, new messages coming in will push old messages out. </p></returns>
        /// <doc-id>dn950175</doc-id>
        /// <unmanaged>unsigned longlong ID3D12InfoQueue::GetMessageCountLimit()</unmanaged>
        /// <unmanaged-short>ID3D12InfoQueue::GetMessageCountLimit</unmanaged-short>
        internal unsafe System.Int64 GetMessageCountLimit()
        {
            System.Int64 __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCalllong(this._nativePointer, (*(void ***)this._nativePointer)[11]);
            return __result__;
        }

        /// <summary>
        /// <p> Add storage filters to the top of the storage-filter stack. </p>
        /// </summary>
        /// <param name = "filterRef"><dd>  <p> Array of storage filters.</p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.  </p></returns>
        /// <doc-id>dn950167</doc-id>
        /// <unmanaged>HRESULT ID3D12InfoQueue::AddStorageFilterEntries([In] D3D12_INFO_QUEUE_FILTER* pFilter)</unmanaged>
        /// <unmanaged-short>ID3D12InfoQueue::AddStorageFilterEntries</unmanaged-short>
        public unsafe void AddStorageFilterEntries(SharpDX.Direct3D12.InfoQueueFilter filterRef)
        {
            SharpDX.Direct3D12.InfoQueueFilter.__Native filterRef_ = default (SharpDX.Direct3D12.InfoQueueFilter.__Native);
            SharpDX.Result __result__;
            filterRef.__MarshalTo(ref filterRef_);
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, &filterRef_, (*(void ***)this._nativePointer)[12]);
            filterRef.__MarshalFree(ref filterRef_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Get the storage filter at the top of the storage-filter stack. </p>
        /// </summary>
        /// <param name = "filterRef"><dd>  <p> Storage filter at the top of the storage-filter stack. </p> </dd></param>
        /// <param name = "filterByteLengthRef"><dd>  <p> Size of the storage filter in bytes. If <em>pFilter</em> is <c>null</c>, the size of the storage filter will be output to this parameter. </p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.  </p></returns>
        /// <doc-id>dn950184</doc-id>
        /// <unmanaged>HRESULT ID3D12InfoQueue::GetStorageFilter([In] D3D12_INFO_QUEUE_FILTER* pFilter,[InOut] SIZE_T* pFilterByteLength)</unmanaged>
        /// <unmanaged-short>ID3D12InfoQueue::GetStorageFilter</unmanaged-short>
        internal unsafe void GetStorageFilter(System.IntPtr filterRef, ref SharpDX.PointerSize filterByteLengthRef)
        {
            SharpDX.Result __result__;
            fixed (void *filterByteLengthRef_ = &filterByteLengthRef)
                __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, (void *)filterRef, filterByteLengthRef_, (*(void ***)this._nativePointer)[13]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Remove a storage filter from the top of the storage-filter stack. </p>
        /// </summary>
        /// <doc-id>dn950169</doc-id>
        /// <unmanaged>void ID3D12InfoQueue::ClearStorageFilter()</unmanaged>
        /// <unmanaged-short>ID3D12InfoQueue::ClearStorageFilter</unmanaged-short>
        public unsafe void ClearStorageFilter()
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (*(void ***)this._nativePointer)[14]);
        }

        /// <summary>
        /// <p> Push an empty storage filter onto the storage-filter stack. </p>
        /// </summary>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.  </p></returns>
        /// <remarks>
        /// <p>An empty storage filter allows all messages to pass through. </p>
        /// </remarks>
        /// <doc-id>dn950191</doc-id>
        /// <unmanaged>HRESULT ID3D12InfoQueue::PushEmptyStorageFilter()</unmanaged>
        /// <unmanaged-short>ID3D12InfoQueue::PushEmptyStorageFilter</unmanaged-short>
        public unsafe void PushEmptyStorageFilter()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[15]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Push a copy of storage filter currently on the top of the storage-filter stack onto the storage-filter stack. </p>
        /// </summary>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.  </p></returns>
        /// <doc-id>dn950189</doc-id>
        /// <unmanaged>HRESULT ID3D12InfoQueue::PushCopyOfStorageFilter()</unmanaged>
        /// <unmanaged-short>ID3D12InfoQueue::PushCopyOfStorageFilter</unmanaged-short>
        public unsafe void PushCopyOfStorageFilter()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[16]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Push a storage filter onto the storage-filter stack. </p>
        /// </summary>
        /// <param name = "filterRef"><dd>  <p> Pointer to a storage filter.</p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.  </p></returns>
        /// <doc-id>dn950193</doc-id>
        /// <unmanaged>HRESULT ID3D12InfoQueue::PushStorageFilter([In] D3D12_INFO_QUEUE_FILTER* pFilter)</unmanaged>
        /// <unmanaged-short>ID3D12InfoQueue::PushStorageFilter</unmanaged-short>
        public unsafe void PushStorageFilter(SharpDX.Direct3D12.InfoQueueFilter filterRef)
        {
            SharpDX.Direct3D12.InfoQueueFilter.__Native filterRef_ = default (SharpDX.Direct3D12.InfoQueueFilter.__Native);
            SharpDX.Result __result__;
            filterRef.__MarshalTo(ref filterRef_);
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, &filterRef_, (*(void ***)this._nativePointer)[17]);
            filterRef.__MarshalFree(ref filterRef_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Pop a storage filter from the top of the storage-filter stack. </p>
        /// </summary>
        /// <doc-id>dn950187</doc-id>
        /// <unmanaged>void ID3D12InfoQueue::PopStorageFilter()</unmanaged>
        /// <unmanaged-short>ID3D12InfoQueue::PopStorageFilter</unmanaged-short>
        public unsafe void PopStorageFilter()
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (*(void ***)this._nativePointer)[18]);
        }

        /// <summary>
        /// <p> Get the size of the storage-filter stack in bytes. </p>
        /// </summary>
        /// <returns><p> Size of the storage-filter stack in bytes. </p></returns>
        /// <doc-id>dn950185</doc-id>
        /// <unmanaged>unsigned int ID3D12InfoQueue::GetStorageFilterStackSize()</unmanaged>
        /// <unmanaged-short>ID3D12InfoQueue::GetStorageFilterStackSize</unmanaged-short>
        internal unsafe System.Int32 GetStorageFilterStackSize()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[19]);
            return __result__;
        }

        /// <summary>
        /// <p> Add storage filters to the top of the retrieval-filter stack. </p>
        /// </summary>
        /// <param name = "filterRef"><dd>  <p>Array of retrieval filters. </p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.  </p></returns>
        /// <remarks>
        /// <p>The following code example shows how to use this method: </p><code> <see cref = "SharpDX.Direct3D12.MessageCategory"/> cats[] = { ..., ..., ... };
        /// <see cref = "SharpDX.Direct3D12.MessageSeverity"/> sevs[] = { ..., ..., ... };
        /// UINT ids[] = { ..., ..., ... }; <see cref = "SharpDX.Direct3D12.InfoQueueFilter"/> filter;
        /// memset( &amp;filter, 0, sizeof(filter) ); // To set the type of messages to allow, 
        /// // set filter.AllowList as follows:
        /// filter.AllowList.NumCategories = sizeof(cats / sizeof(<see cref = "SharpDX.Direct3D12.MessageCategory"/>)); 
        /// filter.AllowList.pCategoryList = cats;
        /// filter.AllowList.NumSeverities = sizeof(sevs / sizeof(<see cref = "SharpDX.Direct3D12.MessageSeverity"/>)); 
        /// filter.AllowList.pSeverityList = sevs;
        /// filter.AllowList.NumIDs = sizeof(ids) / sizeof(UINT);
        /// filter.AllowList.pIDList = ids; // To set the type of messages to deny, set filter.DenyList 
        /// // similarly to the preceding filter.AllowList. // The following single call sets all of the preceding information.
        /// hr = infoQueue-&gt;AddRetrievalFilterEntries( &amp;filter ); </code>
        /// </remarks>
        /// <doc-id>dn950166</doc-id>
        /// <unmanaged>HRESULT ID3D12InfoQueue::AddRetrievalFilterEntries([In] D3D12_INFO_QUEUE_FILTER* pFilter)</unmanaged>
        /// <unmanaged-short>ID3D12InfoQueue::AddRetrievalFilterEntries</unmanaged-short>
        public unsafe void AddRetrievalFilterEntries(SharpDX.Direct3D12.InfoQueueFilter filterRef)
        {
            SharpDX.Direct3D12.InfoQueueFilter.__Native filterRef_ = default (SharpDX.Direct3D12.InfoQueueFilter.__Native);
            SharpDX.Result __result__;
            filterRef.__MarshalTo(ref filterRef_);
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, &filterRef_, (*(void ***)this._nativePointer)[20]);
            filterRef.__MarshalFree(ref filterRef_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Get the retrieval filter at the top of the retrieval-filter stack. </p>
        /// </summary>
        /// <param name = "filterRef"><dd>  <p> Retrieval filter at the top of the retrieval-filter stack. </p> </dd></param>
        /// <param name = "filterByteLengthRef"><dd>  <p> Size of the retrieval filter in bytes. If <em>pFilter</em> is <c>null</c>, the size of the retrieval filter will be output to this parameter. </p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.  </p></returns>
        /// <doc-id>dn950182</doc-id>
        /// <unmanaged>HRESULT ID3D12InfoQueue::GetRetrievalFilter([In] D3D12_INFO_QUEUE_FILTER* pFilter,[InOut] SIZE_T* pFilterByteLength)</unmanaged>
        /// <unmanaged-short>ID3D12InfoQueue::GetRetrievalFilter</unmanaged-short>
        internal unsafe void GetRetrievalFilter(System.IntPtr filterRef, ref SharpDX.PointerSize filterByteLengthRef)
        {
            SharpDX.Result __result__;
            fixed (void *filterByteLengthRef_ = &filterByteLengthRef)
                __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, (void *)filterRef, filterByteLengthRef_, (*(void ***)this._nativePointer)[21]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Remove a retrieval filter from the top of the retrieval-filter stack. </p>
        /// </summary>
        /// <doc-id>dn950168</doc-id>
        /// <unmanaged>void ID3D12InfoQueue::ClearRetrievalFilter()</unmanaged>
        /// <unmanaged-short>ID3D12InfoQueue::ClearRetrievalFilter</unmanaged-short>
        public unsafe void ClearRetrievalFilter()
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (*(void ***)this._nativePointer)[22]);
        }

        /// <summary>
        /// <p> Push an empty retrieval filter onto the retrieval-filter stack. </p>
        /// </summary>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.  </p></returns>
        /// <remarks>
        /// <p>An empty retrieval filter allows all messages to pass through. </p>
        /// </remarks>
        /// <doc-id>dn950190</doc-id>
        /// <unmanaged>HRESULT ID3D12InfoQueue::PushEmptyRetrievalFilter()</unmanaged>
        /// <unmanaged-short>ID3D12InfoQueue::PushEmptyRetrievalFilter</unmanaged-short>
        public unsafe void PushEmptyRetrievalFilter()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[23]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Push a copy of retrieval filter currently on the top of the retrieval-filter stack onto the retrieval-filter stack. </p>
        /// </summary>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.  </p></returns>
        /// <doc-id>dn950188</doc-id>
        /// <unmanaged>HRESULT ID3D12InfoQueue::PushCopyOfRetrievalFilter()</unmanaged>
        /// <unmanaged-short>ID3D12InfoQueue::PushCopyOfRetrievalFilter</unmanaged-short>
        public unsafe void PushCopyOfRetrievalFilter()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[24]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Push a retrieval filter onto the retrieval-filter stack. </p>
        /// </summary>
        /// <param name = "filterRef"><dd>  <p> Pointer to a retrieval filter.</p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.  </p></returns>
        /// <doc-id>dn950192</doc-id>
        /// <unmanaged>HRESULT ID3D12InfoQueue::PushRetrievalFilter([In] D3D12_INFO_QUEUE_FILTER* pFilter)</unmanaged>
        /// <unmanaged-short>ID3D12InfoQueue::PushRetrievalFilter</unmanaged-short>
        public unsafe void PushRetrievalFilter(SharpDX.Direct3D12.InfoQueueFilter filterRef)
        {
            SharpDX.Direct3D12.InfoQueueFilter.__Native filterRef_ = default (SharpDX.Direct3D12.InfoQueueFilter.__Native);
            SharpDX.Result __result__;
            filterRef.__MarshalTo(ref filterRef_);
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, &filterRef_, (*(void ***)this._nativePointer)[25]);
            filterRef.__MarshalFree(ref filterRef_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Pop a retrieval filter from the top of the retrieval-filter stack. </p>
        /// </summary>
        /// <doc-id>dn950186</doc-id>
        /// <unmanaged>void ID3D12InfoQueue::PopRetrievalFilter()</unmanaged>
        /// <unmanaged-short>ID3D12InfoQueue::PopRetrievalFilter</unmanaged-short>
        public unsafe void PopRetrievalFilter()
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (*(void ***)this._nativePointer)[26]);
        }

        /// <summary>
        /// <p> Get the size of the retrieval-filter stack in bytes. </p>
        /// </summary>
        /// <returns><p> Size of the retrieval-filter stack in bytes. </p></returns>
        /// <doc-id>dn950183</doc-id>
        /// <unmanaged>unsigned int ID3D12InfoQueue::GetRetrievalFilterStackSize()</unmanaged>
        /// <unmanaged-short>ID3D12InfoQueue::GetRetrievalFilterStackSize</unmanaged-short>
        internal unsafe System.Int32 GetRetrievalFilterStackSize()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[27]);
            return __result__;
        }

        /// <summary>
        /// <p>Adds a debug message to the message queue and sends that message to debug output. </p>
        /// </summary>
        /// <param name = "category"><dd>  <p> Category of a message. </p> </dd></param>
        /// <param name = "severity"><dd>  <p> Severity of a message. </p> </dd></param>
        /// <param name = "id"><dd>  <p> Unique identifier of a message. </p> </dd></param>
        /// <param name = "descriptionRef"><dd>  <p> User-defined message. </p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.  </p></returns>
        /// <remarks>
        /// <p>This method is used by the runtime's internal mechanisms to add debug messages to the message queue and send them to debug output. For applications to add their own custom messages to the message queue and send them to debug output, call <strong>ID3D12InfoQueue::AddApplicationMessage</strong>. </p>
        /// </remarks>
        /// <doc-id>dn950165</doc-id>
        /// <unmanaged>HRESULT ID3D12InfoQueue::AddMessage([In] D3D12_MESSAGE_CATEGORY Category,[In] D3D12_MESSAGE_SEVERITY Severity,[In] D3D12_MESSAGE_ID ID,[In] const char* pDescription)</unmanaged>
        /// <unmanaged-short>ID3D12InfoQueue::AddMessage</unmanaged-short>
        public unsafe void AddMessage(SharpDX.Direct3D12.MessageCategory category, SharpDX.Direct3D12.MessageSeverity severity, SharpDX.Direct3D12.MessageId id, System.String descriptionRef)
        {
            System.IntPtr descriptionRef_;
            SharpDX.Result __result__;
            descriptionRef_ = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(descriptionRef);
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)category), unchecked ((System.Int32)severity), unchecked ((System.Int32)id), (void *)descriptionRef_, (*(void ***)this._nativePointer)[28]);
            System.Runtime.InteropServices.Marshal.FreeHGlobal(descriptionRef_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Adds a user-defined message to the message queue and sends that message to debug output. </p>
        /// </summary>
        /// <param name = "severity"><dd>  <p> Severity of a message.</p> </dd></param>
        /// <param name = "descriptionRef"><dd>  <p> Specifies the message string. </p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.  </p></returns>
        /// <doc-id>dn950164</doc-id>
        /// <unmanaged>HRESULT ID3D12InfoQueue::AddApplicationMessage([In] D3D12_MESSAGE_SEVERITY Severity,[In] const char* pDescription)</unmanaged>
        /// <unmanaged-short>ID3D12InfoQueue::AddApplicationMessage</unmanaged-short>
        public unsafe void AddApplicationMessage(SharpDX.Direct3D12.MessageSeverity severity, System.String descriptionRef)
        {
            System.IntPtr descriptionRef_;
            SharpDX.Result __result__;
            descriptionRef_ = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(descriptionRef);
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)severity), (void *)descriptionRef_, (*(void ***)this._nativePointer)[29]);
            System.Runtime.InteropServices.Marshal.FreeHGlobal(descriptionRef_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Set a message category to break on when a message with that category passes through the storage filter. </p>
        /// </summary>
        /// <param name = "category"><dd>  <p> Message category to break on. </p> </dd></param>
        /// <param name = "bEnable"><dd>  <p> Turns this breaking condition on or off (true for on, false for off). </p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.  </p></returns>
        /// <doc-id>dn950195</doc-id>
        /// <unmanaged>HRESULT ID3D12InfoQueue::SetBreakOnCategory([In] D3D12_MESSAGE_CATEGORY Category,[In] BOOL bEnable)</unmanaged>
        /// <unmanaged-short>ID3D12InfoQueue::SetBreakOnCategory</unmanaged-short>
        public unsafe void SetBreakOnCategory(SharpDX.Direct3D12.MessageCategory category, SharpDX.Mathematics.Interop.RawBool bEnable)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint0(this._nativePointer, unchecked ((System.Int32)category), bEnable, (*(void ***)this._nativePointer)[30]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Set a message severity level to break on when a message with that severity level passes through the storage filter. </p>
        /// </summary>
        /// <param name = "severity"><dd>  <p> A message severity level to break on. </p> </dd></param>
        /// <param name = "bEnable"><dd>  <p> Turns this breaking condition on or off (true for on, false for off). </p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.  </p></returns>
        /// <doc-id>dn950197</doc-id>
        /// <unmanaged>HRESULT ID3D12InfoQueue::SetBreakOnSeverity([In] D3D12_MESSAGE_SEVERITY Severity,[In] BOOL bEnable)</unmanaged>
        /// <unmanaged-short>ID3D12InfoQueue::SetBreakOnSeverity</unmanaged-short>
        public unsafe void SetBreakOnSeverity(SharpDX.Direct3D12.MessageSeverity severity, SharpDX.Mathematics.Interop.RawBool bEnable)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint0(this._nativePointer, unchecked ((System.Int32)severity), bEnable, (*(void ***)this._nativePointer)[31]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Set a message identifier to break on when a message with that identifier passes through the storage filter. </p>
        /// </summary>
        /// <param name = "id"><dd>  <p> Message identifier to break on. </p> </dd></param>
        /// <param name = "bEnable"><dd>  <p> Turns this breaking condition on or off (true for on, false for off). </p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.  </p></returns>
        /// <doc-id>dn950196</doc-id>
        /// <unmanaged>HRESULT ID3D12InfoQueue::SetBreakOnID([In] D3D12_MESSAGE_ID ID,[In] BOOL bEnable)</unmanaged>
        /// <unmanaged-short>ID3D12InfoQueue::SetBreakOnID</unmanaged-short>
        public unsafe void SetBreakOnID(SharpDX.Direct3D12.MessageId id, SharpDX.Mathematics.Interop.RawBool bEnable)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint0(this._nativePointer, unchecked ((System.Int32)id), bEnable, (*(void ***)this._nativePointer)[32]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Get a message category to break on when a message with that category passes through the storage filter. </p>
        /// </summary>
        /// <param name = "category"><dd>  <p> Message category to break on. </p> </dd></param>
        /// <returns><p> Whether this breaking condition is turned on or off (true for on, false for off). </p></returns>
        /// <doc-id>dn950171</doc-id>
        /// <unmanaged>BOOL ID3D12InfoQueue::GetBreakOnCategory([In] D3D12_MESSAGE_CATEGORY Category)</unmanaged>
        /// <unmanaged-short>ID3D12InfoQueue::GetBreakOnCategory</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool GetBreakOnCategory(SharpDX.Direct3D12.MessageCategory category)
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, unchecked ((System.Int32)category), (*(void ***)this._nativePointer)[33]);
            return __result__;
        }

        /// <summary>
        /// <p>Get a message severity level to break on when a message with that severity level passes through the storage filter. </p>
        /// </summary>
        /// <param name = "severity"><dd>  <p> Message severity level to break on.</p> </dd></param>
        /// <returns><p> Whether this breaking condition is turned on or off (true for on, false for off). </p></returns>
        /// <doc-id>dn950173</doc-id>
        /// <unmanaged>BOOL ID3D12InfoQueue::GetBreakOnSeverity([In] D3D12_MESSAGE_SEVERITY Severity)</unmanaged>
        /// <unmanaged-short>ID3D12InfoQueue::GetBreakOnSeverity</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool GetBreakOnSeverity(SharpDX.Direct3D12.MessageSeverity severity)
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, unchecked ((System.Int32)severity), (*(void ***)this._nativePointer)[34]);
            return __result__;
        }

        /// <summary>
        /// <p> Get a message identifier to break on when a message with that identifier passes through the storage filter. </p>
        /// </summary>
        /// <param name = "id"><dd>  <p> Message identifier to break on. </p> </dd></param>
        /// <returns><p> Whether this breaking condition is turned on or off (true for on, false for off). </p></returns>
        /// <doc-id>dn950172</doc-id>
        /// <unmanaged>BOOL ID3D12InfoQueue::GetBreakOnID([In] D3D12_MESSAGE_ID ID)</unmanaged>
        /// <unmanaged-short>ID3D12InfoQueue::GetBreakOnID</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool GetBreakOnID(SharpDX.Direct3D12.MessageId id)
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, unchecked ((System.Int32)id), (*(void ***)this._nativePointer)[35]);
            return __result__;
        }

        /// <summary>
        /// <p> Set a boolean that turns the debug output on or off. </p>
        /// </summary>
        /// <param name = "bMute"><dd>  <p> Disable/Enable the debug output (true to disable or mute the output, false to enable the output). </p> </dd></param>
        /// <remarks>
        /// <p>This will stop messages that pass the storage filter from being printed out in the debug output, however those messages will still be added to the message queue. </p>
        /// </remarks>
        /// <doc-id>dn950199</doc-id>
        /// <unmanaged>void ID3D12InfoQueue::SetMuteDebugOutput([In] BOOL bMute)</unmanaged>
        /// <unmanaged-short>ID3D12InfoQueue::SetMuteDebugOutput</unmanaged-short>
        internal unsafe void SetMuteDebugOutput(SharpDX.Mathematics.Interop.RawBool bMute)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid0(this._nativePointer, bMute, (*(void ***)this._nativePointer)[36]);
        }

        /// <summary>
        /// <p> Get a boolean that determines if debug output is on or off. </p>
        /// </summary>
        /// <returns><p> Whether the debug output is on or off (true for on, false for off). </p></returns>
        /// <doc-id>dn950176</doc-id>
        /// <unmanaged>BOOL ID3D12InfoQueue::GetMuteDebugOutput()</unmanaged>
        /// <unmanaged-short>ID3D12InfoQueue::GetMuteDebugOutput</unmanaged-short>
        internal unsafe SharpDX.Mathematics.Interop.RawBool GetMuteDebugOutput()
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, (*(void ***)this._nativePointer)[37]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("e667af9f-cd56-4f46-83ce-032e595d70a8")]
    public partial class LifetimeOwner : SharpDX.ComObject
    {
        public LifetimeOwner(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator LifetimeOwner(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new LifetimeOwner(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "newState">No documentation.</param>
        /// <unmanaged>void ID3D12LifetimeOwner::LifetimeStateUpdated([In] D3D12_LIFETIME_STATE NewState)</unmanaged>
        /// <unmanaged-short>ID3D12LifetimeOwner::LifetimeStateUpdated</unmanaged-short>
        public unsafe void LifetimeStateUpdated(SharpDX.Direct3D12.LifetimeState newState)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, unchecked ((System.Int32)newState), (*(void ***)this._nativePointer)[3]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("3fd03d36-4eb1-424a-a582-494ecb8ba813")]
    public partial class LifetimeTracker : SharpDX.Direct3D12.DeviceChild
    {
        public LifetimeTracker(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator LifetimeTracker(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new LifetimeTracker(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "objectRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D12LifetimeTracker::DestroyOwnedObject([In] ID3D12DeviceChild* pObject)</unmanaged>
        /// <unmanaged-short>ID3D12LifetimeTracker::DestroyOwnedObject</unmanaged-short>
        public unsafe void DestroyOwnedObject(SharpDX.Direct3D12.DeviceChild objectRef)
        {
            System.IntPtr objectRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            objectRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.DeviceChild>(objectRef);
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, (void *)objectRef_, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("DBB84C27-36CE-4FC9-B801-F048C46AC570")]
    public partial class MetaCommand : SharpDX.Direct3D12.Pageable
    {
        public MetaCommand(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator MetaCommand(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new MetaCommand(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "stage">No documentation.</param>
        /// <param name = "parameterIndex">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>unsigned longlong ID3D12MetaCommand::GetRequiredParameterResourceSize([In] D3D12_META_COMMAND_PARAMETER_STAGE Stage,[In] unsigned int ParameterIndex)</unmanaged>
        /// <unmanaged-short>ID3D12MetaCommand::GetRequiredParameterResourceSize</unmanaged-short>
        public unsafe System.Int64 GetRequiredParameterResourceSize(SharpDX.Direct3D12.MetaCommandParameterStage stage, System.Int32 parameterIndex)
        {
            System.Int64 __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCalllong(this._nativePointer, unchecked ((System.Int32)stage), parameterIndex, (*(void ***)this._nativePointer)[8]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("c4fec28f-7966-4e95-9f94-f431cb56c3b8")]
    public partial class Object : SharpDX.ComObject
    {
        public Object(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Object(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Object(nativePtr);
        /// <summary>
        /// <p> Associates a name with the device object. This name is for use in debug diagnostics and tools. </p>
        /// </summary>
        /// <remarks>
        /// <p> This method takes UNICODE names. The older Direct3D 11 debug object naming system through <strong>ID3D12Object::SetPrivateData</strong> with <strong><see cref = "DebugObjectName"/></strong> used ASCII. </p>
        /// </remarks>
        /// <doc-id>dn788701</doc-id>
        /// <unmanaged>SetName</unmanaged>
        /// <unmanaged-short>SetName</unmanaged-short>
        public System.String Name
        {
            set => SetName(value);
        }

        /// <summary>
        /// <p>Gets application-defined data from a device object.</p>
        /// </summary>
        /// <param name = "guid"><dd>  <p> The <strong><see cref = "System.Guid"/></strong> that is associated with the data. </p> </dd></param>
        /// <param name = "dataSizeRef"><dd>  <p> A reference to a variable that on input contains the size, in bytes, of the buffer that <em>pData</em> points to, and on output contains the size, in bytes, of the amount of data that <strong>GetPrivateData</strong> retrieved. </p> </dd></param>
        /// <param name = "dataRef"><dd>  <p> A reference to a memory block that receives the data from the device object if <em>pDataSize</em> points to a value that specifies a buffer large enough to hold the data. </p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. </p></returns>
        /// <doc-id>dn788700</doc-id>
        /// <unmanaged>HRESULT ID3D12Object::GetPrivateData([In] const GUID&amp; guid,[InOut] unsigned int* pDataSize,[Out, Buffer, Optional] void* pData)</unmanaged>
        /// <unmanaged-short>ID3D12Object::GetPrivateData</unmanaged-short>
        public unsafe SharpDX.Result GetPrivateData(System.Guid guid, ref System.Int32 dataSizeRef, System.IntPtr dataRef)
        {
            SharpDX.Result __result__;
            fixed (void *dataSizeRef_ = &dataSizeRef)
                __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, &guid, dataSizeRef_, (void *)dataRef, (*(void ***)this._nativePointer)[3]);
            return __result__;
        }

        /// <summary>
        /// <p> Sets application-defined data to a device object and associates that data with an application-defined <strong><see cref = "System.Guid"/></strong>. </p>
        /// </summary>
        /// <param name = "guid"><dd>  <p> The <strong><see cref = "System.Guid"/></strong> to associate with the data. </p> </dd></param>
        /// <param name = "dataSize"><dd>  <p> The size in bytes of the data. </p> </dd></param>
        /// <param name = "dataRef"><dd>  <p> A reference to a memory block that contains the data to be stored with this device object. If <em>pData</em> is <strong><c>null</c></strong>, <em>DataSize</em> must also be 0, and any data that was previously associated with the <strong><see cref = "System.Guid"/></strong> specified in <em>guid</em> will be destroyed. </p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. </p></returns>
        /// <remarks>
        /// <p> Rather than using the Direct3D 11 debug object naming scheme of calling <strong>ID3D12Object::SetPrivateData</strong> using <strong><see cref = "DebugObjectName"/></strong> with an ASCII name, call <strong>ID3D12Object::SetName</strong> with a UNICODE name. </p>
        /// </remarks>
        /// <doc-id>dn788702</doc-id>
        /// <unmanaged>HRESULT ID3D12Object::SetPrivateData([In] const GUID&amp; guid,[In] unsigned int DataSize,[In, Buffer, Optional] const void* pData)</unmanaged>
        /// <unmanaged-short>ID3D12Object::SetPrivateData</unmanaged-short>
        public unsafe void SetPrivateData(System.Guid guid, System.Int32 dataSize, System.IntPtr dataRef)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, &guid, dataSize, (void *)dataRef, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Associates an <strong><see cref = "SharpDX.IUnknown"/></strong>-derived interface with the device object and associates that interface with an application-defined <strong><see cref = "System.Guid"/></strong>. </p>
        /// </summary>
        /// <param name = "guid">No documentation.</param>
        /// <param name = "dataRef">No documentation.</param>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. </p></returns>
        /// <doc-id>dn788703</doc-id>
        /// <unmanaged>HRESULT ID3D12Object::SetPrivateDataInterface([In] const GUID&amp; guid,[In, Optional] const IUnknown* pData)</unmanaged>
        /// <unmanaged-short>ID3D12Object::SetPrivateDataInterface</unmanaged-short>
        public unsafe void SetPrivateDataInterface(System.Guid guid, SharpDX.IUnknown dataRef)
        {
            System.IntPtr dataRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            dataRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(dataRef);
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, &guid, (void *)dataRef_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Associates a name with the device object. This name is for use in debug diagnostics and tools. </p>
        /// </summary>
        /// <param name = "name"><dd>  <p> A <strong><c>null</c></strong>-terminated <strong>UNICODE</strong> string that contains the name to associate with the device object. </p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. </p></returns>
        /// <remarks>
        /// <p> This method takes UNICODE names. The older Direct3D 11 debug object naming system through <strong>ID3D12Object::SetPrivateData</strong> with <strong><see cref = "DebugObjectName"/></strong> used ASCII. </p>
        /// </remarks>
        /// <doc-id>dn788701</doc-id>
        /// <unmanaged>HRESULT ID3D12Object::SetName([In] const wchar_t* Name)</unmanaged>
        /// <unmanaged-short>ID3D12Object::SetName</unmanaged-short>
        internal unsafe void SetName(System.String name)
        {
            SharpDX.Result __result__;
            fixed (char *name_ = name)
                __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, (void *)name_, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("63ee58fb-1268-4835-86da-f008ce62f0d6")]
    public partial class Pageable : SharpDX.Direct3D12.DeviceChild
    {
        public Pageable(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Pageable(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Pageable(nativePtr);
    }

    [System.Runtime.InteropServices.GuidAttribute("c64226a8-9201-46af-b4cc-53fb9ff7414f")]
    public partial class PipelineLibrary : SharpDX.Direct3D12.DeviceChild
    {
        public PipelineLibrary(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator PipelineLibrary(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new PipelineLibrary(nativePtr);
        /// <summary>
        /// <p>Returns the amount of memory required to serialize the current contents of the database. 
        /// </p>
        /// </summary>
        /// <remarks>
        /// <p>Refer to the remarks and examples for <strong>CreatePipelineLibrary</strong>. </p>
        /// </remarks>
        /// <doc-id>mt709146</doc-id>
        /// <unmanaged>GetSerializedSize</unmanaged>
        /// <unmanaged-short>GetSerializedSize</unmanaged-short>
        public SharpDX.PointerSize SerializedSize
        {
            get => GetSerializedSize();
        }

        /// <summary>
        /// <p>Adds the input PSO to an internal database with the corresponding name.</p>
        /// </summary>
        /// <param name = "nameRef"><dd>  <p>Specifies a unique name for the library. Overwriting is not supported.</p> </dd></param>
        /// <param name = "pipelineRef"><dd>  <p>Specifies the <strong><see cref = "SharpDX.Direct3D12.PipelineState"/></strong> to add.</p> </dd></param>
        /// <returns><p>This method returns an <see cref = "SharpDX.Result"/> success or error code, including E_INVALIDARG if the name already exists, E_OUTOFMEMORY if unable to allocate storage in the library. </p></returns>
        /// <remarks>
        /// <p>Refer to the remarks and examples for <strong>CreatePipelineLibrary</strong>. </p>
        /// </remarks>
        /// <doc-id>mt709150</doc-id>
        /// <unmanaged>HRESULT ID3D12PipelineLibrary::StorePipeline([In, Optional] const wchar_t* pName,[In] ID3D12PipelineState* pPipeline)</unmanaged>
        /// <unmanaged-short>ID3D12PipelineLibrary::StorePipeline</unmanaged-short>
        public unsafe void StorePipeline(System.String nameRef, SharpDX.Direct3D12.PipelineState pipelineRef)
        {
            System.IntPtr pipelineRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            pipelineRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.PipelineState>(pipelineRef);
            fixed (char *nameRef_ = nameRef)
                __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, (void *)nameRef_, (void *)pipelineRef_, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the requested PSO from the library. </p>
        /// </summary>
        /// <param name = "nameRef"><dd>  <p>The unique name of the PSO.</p> </dd></param>
        /// <param name = "descRef"><dd>  <p>Specifies a description of the required PSO in a <strong><see cref = "SharpDX.Direct3D12.GraphicsPipelineStateDescription"/></strong> structure. This input description is matched against the data in the current library database, and stored in order to prevent duplication of PSO contents.</p> </dd></param>
        /// <param name = "riid"><dd>  <p>Specifies a REFIID for the <strong><see cref = "SharpDX.Direct3D12.PipelineState"/></strong> object. Typically set this, and the following parameter, with the macro <code>IID_PPV_ARGS(&amp;PSO1)</code>, where <em>PSO1</em> is the name of the object.</p> </dd></param>
        /// <param name = "pipelineStateOut"><dd>  <p>Specifies a reference that will reference the returned PSO.</p> </dd></param>
        /// <returns><p>This method returns an <see cref = "SharpDX.Result"/> success or error code, which can include E_INVALIDARG if the name doesn?t exist, or if the input description doesn?t match the data in the library, and E_OUTOFMEMORY if unable to allocate the return PSO. </p></returns>
        /// <remarks>
        /// <p>Refer to the remarks and examples for <strong>CreatePipelineLibrary</strong>. </p>
        /// </remarks>
        /// <doc-id>mt709148</doc-id>
        /// <unmanaged>HRESULT ID3D12PipelineLibrary::LoadGraphicsPipeline([In] const wchar_t* pName,[In] const D3D12_GRAPHICS_PIPELINE_STATE_DESC* pDesc,[In] const GUID&amp; riid,[Out] void** ppPipelineState)</unmanaged>
        /// <unmanaged-short>ID3D12PipelineLibrary::LoadGraphicsPipeline</unmanaged-short>
        public unsafe void LoadGraphicsPipeline(System.String nameRef, SharpDX.Direct3D12.GraphicsPipelineStateDescription descRef, System.Guid riid, out System.IntPtr pipelineStateOut)
        {
            SharpDX.Direct3D12.GraphicsPipelineStateDescription.__Native descRef_ = default (SharpDX.Direct3D12.GraphicsPipelineStateDescription.__Native);
            SharpDX.Result __result__;
            descRef.__MarshalTo(ref descRef_);
            fixed (void *pipelineStateOut_ = &pipelineStateOut)
                fixed (char *nameRef_ = nameRef)
                    __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, (void *)nameRef_, &descRef_, &riid, pipelineStateOut_, (*(void ***)this._nativePointer)[9]);
            descRef.__MarshalFree(ref descRef_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the requested PSO from the library. The input desc is matched against the data in the current library database, and remembered in order to prevent duplication of PSO contents. 
        /// </p>
        /// </summary>
        /// <param name = "nameRef"><dd>  <p>The unique name of the PSO.</p> </dd></param>
        /// <param name = "descRef"><dd>  <p>Specifies a description of the required PSO in a <strong><see cref = "SharpDX.Direct3D12.ComputePipelineStateDescription"/></strong> structure. This input description is matched against the data in the current library database, and stored in order to prevent duplication of PSO contents.</p> </dd></param>
        /// <param name = "riid"><dd>  <p>Specifies a REFIID for the <strong><see cref = "SharpDX.Direct3D12.PipelineState"/></strong> object. Typically set this, and the following parameter, with the macro <code>IID_PPV_ARGS(&amp;PSO1)</code>, where <em>PSO1</em> is the name of the object.</p> </dd></param>
        /// <param name = "pipelineStateOut"><dd>  <p>Specifies a reference that will reference the returned PSO.</p> </dd></param>
        /// <returns><p>This method returns an <see cref = "SharpDX.Result"/> success or error code, which can include E_INVALIDARG if the name doesn?t exist, or if the input description doesn?t match the data in the library, and E_OUTOFMEMORY if unable to allocate the return PSO. </p></returns>
        /// <remarks>
        /// <p>Refer to the remarks and examples for <strong>CreatePipelineLibrary</strong>. </p>
        /// </remarks>
        /// <doc-id>mt709147</doc-id>
        /// <unmanaged>HRESULT ID3D12PipelineLibrary::LoadComputePipeline([In] const wchar_t* pName,[In] const D3D12_COMPUTE_PIPELINE_STATE_DESC* pDesc,[In] const GUID&amp; riid,[Out] void** ppPipelineState)</unmanaged>
        /// <unmanaged-short>ID3D12PipelineLibrary::LoadComputePipeline</unmanaged-short>
        public unsafe void LoadComputePipeline(System.String nameRef, SharpDX.Direct3D12.ComputePipelineStateDescription descRef, System.Guid riid, out System.IntPtr pipelineStateOut)
        {
            SharpDX.Direct3D12.ComputePipelineStateDescription.__Native descRef_ = default (SharpDX.Direct3D12.ComputePipelineStateDescription.__Native);
            SharpDX.Result __result__;
            descRef.__MarshalTo(ref descRef_);
            fixed (void *pipelineStateOut_ = &pipelineStateOut)
                fixed (char *nameRef_ = nameRef)
                    __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, (void *)nameRef_, &descRef_, &riid, pipelineStateOut_, (*(void ***)this._nativePointer)[10]);
            descRef.__MarshalFree(ref descRef_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Returns the amount of memory required to serialize the current contents of the database. 
        /// </p>
        /// </summary>
        /// <returns><p>This method returns a <see cref = "SharpDX.PointerSize"/> object, containing the size required in bytes.</p></returns>
        /// <remarks>
        /// <p>Refer to the remarks and examples for <strong>CreatePipelineLibrary</strong>. </p>
        /// </remarks>
        /// <doc-id>mt709146</doc-id>
        /// <unmanaged>SIZE_T ID3D12PipelineLibrary::GetSerializedSize()</unmanaged>
        /// <unmanaged-short>ID3D12PipelineLibrary::GetSerializedSize</unmanaged-short>
        internal unsafe SharpDX.PointerSize GetSerializedSize()
        {
            SharpDX.PointerSize __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallvoidPtr(this._nativePointer, (*(void ***)this._nativePointer)[11]);
            return __result__;
        }

        /// <summary>
        /// <p>Writes the contents of the library to the provided memory, to be provided back to the runtime at a later time. 
        /// </p>
        /// </summary>
        /// <param name = "dataRef"><dd>  <p>Specifies a reference to the data. This memory must be readable and writeable up to the input size. This data can be saved and provided to <strong>CreatePipelineLibrary</strong> at a later time, including future instances of this or other processes. The data becomes invalidated if the runtime or driver is updated, and is not portable to other hardware or devices.</p> </dd></param>
        /// <param name = "dataSizeInBytes"><dd>  <p>The size provided must be at least the size returned from <strong>GetSerializedSize</strong>. </p> </dd></param>
        /// <returns><p>This method returns an <see cref = "SharpDX.Result"/> success or error code, including E_INVALIDARG if the buffer provided isn?t big enough. </p></returns>
        /// <remarks>
        /// <p>Refer to the remarks and examples for <strong>CreatePipelineLibrary</strong>. </p>
        /// </remarks>
        /// <doc-id>mt709149</doc-id>
        /// <unmanaged>HRESULT ID3D12PipelineLibrary::Serialize([Out, Buffer] void* pData,[In] SIZE_T DataSizeInBytes)</unmanaged>
        /// <unmanaged-short>ID3D12PipelineLibrary::Serialize</unmanaged-short>
        public unsafe void Serialize(System.IntPtr dataRef, SharpDX.PointerSize dataSizeInBytes)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, (void *)dataRef, (void *)dataSizeInBytes, (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("80eabf42-2568-4e5e-bd82-c37f86961dc3")]
    public partial class PipelineLibrary1 : SharpDX.Direct3D12.PipelineLibrary
    {
        public PipelineLibrary1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator PipelineLibrary1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new PipelineLibrary1(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "nameRef">No documentation.</param>
        /// <param name = "descRef">No documentation.</param>
        /// <param name = "riid">No documentation.</param>
        /// <param name = "pipelineStateOut">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D12PipelineLibrary1::LoadPipeline([In] const wchar_t* pName,[In] const D3D12_PIPELINE_STATE_STREAM_DESC* pDesc,[In] const GUID&amp; riid,[Out] void** ppPipelineState)</unmanaged>
        /// <unmanaged-short>ID3D12PipelineLibrary1::LoadPipeline</unmanaged-short>
        public unsafe void LoadPipeline(System.String nameRef, ref SharpDX.Direct3D12.PipelineStateStreamDescription descRef, System.Guid riid, out System.IntPtr pipelineStateOut)
        {
            SharpDX.Direct3D12.PipelineStateStreamDescription.__Native descRef_ = default (SharpDX.Direct3D12.PipelineStateStreamDescription.__Native);
            SharpDX.Result __result__;
            descRef.__MarshalTo(ref descRef_);
            fixed (void *pipelineStateOut_ = &pipelineStateOut)
                fixed (char *nameRef_ = nameRef)
                    __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, (void *)nameRef_, &descRef_, &riid, pipelineStateOut_, (*(void ***)this._nativePointer)[13]);
            descRef.__MarshalFree(ref descRef_);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("765a30f3-f624-4c6f-a828-ace948622445")]
    public partial class PipelineState : SharpDX.Direct3D12.Pageable
    {
        public PipelineState(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator PipelineState(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new PipelineState(nativePtr);
        /// <summary>
        /// <p> Gets the cached blob representing the pipeline state. </p>
        /// </summary>
        /// <remarks>
        /// <p>Refer to the remarks for <strong><see cref = "SharpDX.Direct3D12.CachedPipelineState"/></strong>.</p>
        /// </remarks>
        /// <doc-id>dn914413</doc-id>
        /// <unmanaged>GetCachedBlob</unmanaged>
        /// <unmanaged-short>GetCachedBlob</unmanaged-short>
        public SharpDX.Direct3D.Blob CachedBlob
        {
            get
            {
                GetCachedBlob(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p> Gets the cached blob representing the pipeline state. </p>
        /// </summary>
        /// <param name = "blobOut"><dd>  <p> After this method returns, points to the cached blob representing the pipeline state. </p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. </p></returns>
        /// <remarks>
        /// <p>Refer to the remarks for <strong><see cref = "SharpDX.Direct3D12.CachedPipelineState"/></strong>.</p>
        /// </remarks>
        /// <doc-id>dn914413</doc-id>
        /// <unmanaged>HRESULT ID3D12PipelineState::GetCachedBlob([Out] ID3D10Blob** ppBlob)</unmanaged>
        /// <unmanaged-short>ID3D12PipelineState::GetCachedBlob</unmanaged-short>
        internal unsafe void GetCachedBlob(out SharpDX.Direct3D.Blob blobOut)
        {
            System.IntPtr blobOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, &blobOut_, (*(void ***)this._nativePointer)[8]);
            if (blobOut_ != System.IntPtr.Zero)
                blobOut = new SharpDX.Direct3D.Blob(blobOut_);
            else
                blobOut = null;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("6CD696F4-F289-40CC-8091-5A6C0A099C3D")]
    public partial class ProtectedResourceSession : SharpDX.Direct3D12.ProtectedSession
    {
        public ProtectedResourceSession(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ProtectedResourceSession(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ProtectedResourceSession(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>GetDesc</unmanaged>
        /// <unmanaged-short>GetDesc</unmanaged-short>
        public SharpDX.Direct3D12.ProtectedResourceSessionDescription Description
        {
            get => GetDescription();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <returns>No documentation.</returns>
        /// <unmanaged>D3D12_PROTECTED_RESOURCE_SESSION_DESC ID3D12ProtectedResourceSession::GetDesc()</unmanaged>
        /// <unmanaged-short>ID3D12ProtectedResourceSession::GetDesc</unmanaged-short>
        internal unsafe SharpDX.Direct3D12.ProtectedResourceSessionDescription GetDescription()
        {
            SharpDX.Direct3D12.ProtectedResourceSessionDescription __result__;
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoidPtr(this._nativePointer, &__result__, (*(void ***)this._nativePointer)[10]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("A1533D18-0AC1-4084-85B9-89A96116806B")]
    public partial class ProtectedSession : SharpDX.Direct3D12.DeviceChild
    {
        public ProtectedSession(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ProtectedSession(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ProtectedSession(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>GetSessionStatus</unmanaged>
        /// <unmanaged-short>GetSessionStatus</unmanaged-short>
        public SharpDX.Direct3D12.ProtectedSessionStatus SessionStatus
        {
            get => GetSessionStatus();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "riid">No documentation.</param>
        /// <param name = "fenceOut">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D12ProtectedSession::GetStatusFence([In] const GUID&amp; riid,[Out, Optional] void** ppFence)</unmanaged>
        /// <unmanaged-short>ID3D12ProtectedSession::GetStatusFence</unmanaged-short>
        public unsafe void GetStatusFence(System.Guid riid, out System.IntPtr fenceOut)
        {
            SharpDX.Result __result__;
            fixed (void *fenceOut_ = &fenceOut)
                __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, &riid, fenceOut_, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <returns>No documentation.</returns>
        /// <unmanaged>D3D12_PROTECTED_SESSION_STATUS ID3D12ProtectedSession::GetSessionStatus()</unmanaged>
        /// <unmanaged-short>ID3D12ProtectedSession::GetSessionStatus</unmanaged-short>
        internal unsafe SharpDX.Direct3D12.ProtectedSessionStatus GetSessionStatus()
        {
            SharpDX.Direct3D12.ProtectedSessionStatus __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallSharpDXDirect3D12ProtectedSessionStatus(this._nativePointer, (*(void ***)this._nativePointer)[9]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("0d9658ae-ed45-469e-a61d-970ec583cab4")]
    public partial class QueryHeap : SharpDX.Direct3D12.Pageable
    {
        public QueryHeap(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator QueryHeap(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new QueryHeap(nativePtr);
    }

    [System.Runtime.InteropServices.GuidAttribute("696442be-a72e-4059-bc79-5b5c98040fad")]
    public partial class Resource : SharpDX.Direct3D12.Pageable
    {
        public Resource(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Resource(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Resource(nativePtr);
        /// <summary>
        /// <p>Gets the resource description.</p>
        /// </summary>
        /// <doc-id>dn788710</doc-id>
        /// <unmanaged>GetDesc</unmanaged>
        /// <unmanaged-short>GetDesc</unmanaged-short>
        public SharpDX.Direct3D12.ResourceDescription Description
        {
            get => GetDescription();
        }

        /// <summary>
        /// <p> This method returns the GPU virtual address of a buffer resource. </p>
        /// </summary>
        /// <remarks>
        /// <p>This method is only useful for buffer resources, it will return zero for all texture resources.</p><p> For more information on the use of GPU virtual addresses, refer to Indirect Drawing.  </p>
        /// </remarks>
        /// <doc-id>dn903923</doc-id>
        /// <unmanaged>GetGPUVirtualAddress</unmanaged>
        /// <unmanaged-short>GetGPUVirtualAddress</unmanaged-short>
        public System.Int64 GPUVirtualAddress
        {
            get => GetGPUVirtualAddress();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "subresource">No documentation.</param>
        /// <param name = "readRangeRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D12Resource::Map([In] unsigned int Subresource,[In, Optional] const D3D12_RANGE* pReadRange,[Out] void** ppData)</unmanaged>
        /// <unmanaged-short>ID3D12Resource::Map</unmanaged-short>
        public unsafe System.IntPtr Map(System.Int32 subresource, SharpDX.Direct3D12.Range? readRangeRef = null)
        {
            SharpDX.Direct3D12.Range.__Native readRangeRef_ = default (SharpDX.Direct3D12.Range.__Native);
            System.IntPtr dataOut;
            SharpDX.Result __result__;
            if (readRangeRef != null)
                readRangeRef.Value.__MarshalTo(ref readRangeRef_);
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, subresource, readRangeRef == null ? (void *)0 : &readRangeRef_, &dataOut, (*(void ***)this._nativePointer)[8]);
            if (readRangeRef != null)
                readRangeRef.Value.__MarshalFree(ref readRangeRef_);
            __result__.CheckError();
            return dataOut;
        }

        /// <summary>
        /// <p>Invalidates the CPU reference to the specified subresource in the resource. <strong>Unmap</strong> also flushes the CPU cache, when necessary, so that GPU reads to this address reflect any modifications made by the CPU.
        /// </p>
        /// </summary>
        /// <param name = "subresource"><dd>  <p>Specifies the index of the subresource.</p> </dd></param>
        /// <param name = "writtenRangeRef"><dd>  <p>A reference to a <strong><see cref = "SharpDX.Direct3D12.Range"/></strong> structure that describes the range of memory to unmap.</p> <p>This indicates the region the CPU might have modified, and the coordinates are subresource-relative. A null reference indicates the entire subresource might have been modified by the CPU. It is valid to specify the CPU didn't write any data by passing a range where <strong>End</strong> is less than or equal to <strong>Begin</strong>.</p> </dd></param>
        /// <remarks>
        /// <p>Refer to the extensive Remarks and Examples for the <strong>Map</strong> method.</p>
        /// </remarks>
        /// <doc-id>dn788713</doc-id>
        /// <unmanaged>void ID3D12Resource::Unmap([In] unsigned int Subresource,[In, Optional] const D3D12_RANGE* pWrittenRange)</unmanaged>
        /// <unmanaged-short>ID3D12Resource::Unmap</unmanaged-short>
        public unsafe void Unmap(System.Int32 subresource, SharpDX.Direct3D12.Range? writtenRangeRef = null)
        {
            SharpDX.Direct3D12.Range.__Native writtenRangeRef_ = default (SharpDX.Direct3D12.Range.__Native);
            if (writtenRangeRef != null)
                writtenRangeRef.Value.__MarshalTo(ref writtenRangeRef_);
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, subresource, writtenRangeRef == null ? (void *)0 : &writtenRangeRef_, (*(void ***)this._nativePointer)[9]);
            if (writtenRangeRef != null)
                writtenRangeRef.Value.__MarshalFree(ref writtenRangeRef_);
        }

        /// <summary>
        /// <p>Gets the resource description.</p>
        /// </summary>
        /// <returns><p>A Direct3D 12 resource description structure.</p></returns>
        /// <doc-id>dn788710</doc-id>
        /// <unmanaged>D3D12_RESOURCE_DESC ID3D12Resource::GetDesc()</unmanaged>
        /// <unmanaged-short>ID3D12Resource::GetDesc</unmanaged-short>
        internal unsafe SharpDX.Direct3D12.ResourceDescription GetDescription()
        {
            SharpDX.Direct3D12.ResourceDescription __result__;
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoidPtr(this._nativePointer, &__result__, (*(void ***)this._nativePointer)[10]);
            return __result__;
        }

        /// <summary>
        /// <p> This method returns the GPU virtual address of a buffer resource. </p>
        /// </summary>
        /// <returns><p> This method returns the GPU virtual address. D3D12_GPU_VIRTUAL_ADDRESS is a typedef'd synonym of UINT64. </p></returns>
        /// <remarks>
        /// <p>This method is only useful for buffer resources, it will return zero for all texture resources.</p><p> For more information on the use of GPU virtual addresses, refer to Indirect Drawing.  </p>
        /// </remarks>
        /// <doc-id>dn903923</doc-id>
        /// <unmanaged>unsigned longlong ID3D12Resource::GetGPUVirtualAddress()</unmanaged>
        /// <unmanaged-short>ID3D12Resource::GetGPUVirtualAddress</unmanaged-short>
        internal unsafe System.Int64 GetGPUVirtualAddress()
        {
            System.Int64 __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCalllong(this._nativePointer, (*(void ***)this._nativePointer)[11]);
            return __result__;
        }

        /// <summary>
        /// <p>Uses the CPU to copy data into a subresource, enabling the CPU to modify the contents of most textures with undefined layouts.</p>
        /// </summary>
        /// <param name = "dstSubresource"><dd>  <p> Specifies the index of the subresource. </p> </dd></param>
        /// <param name = "dstBoxRef"><dd>  <p> A reference to a box that defines the portion of the destination subresource to copy the resource data into. If <c>null</c>, the data is written to the destination subresource with no offset. The dimensions of the source must fit the destination (see <strong><see cref = "SharpDX.Direct3D12.ResourceRegion"/></strong>). </p> <p> An empty box results in a no-op. A box is empty if the top value is greater than or equal to the bottom value, or the left value is greater than or equal to the right value,  or the front value is greater than or equal to the back value. When the box is empty, this method doesn't perform any operation. </p> </dd></param>
        /// <param name = "srcDataRef"><dd>  <p> A reference to the source data in memory. </p> </dd></param>
        /// <param name = "srcRowPitch"><dd>  <p>The distance from one row of source data to the next row. </p> </dd></param>
        /// <param name = "srcDepthPitch"><dd>  <p> The distance from one depth slice of source data to the next. </p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. </p></returns>
        /// <remarks>
        /// <p>The resource should first be mapped using <strong>Map</strong>. Textures must be in the <strong>D3D12_RESOURCE_STATE_COMMON</strong> state for CPU access through <strong>WriteToSubresource</strong> and <strong>ReadFromSubresource</strong> to be legal; but buffers do not.</p><p> For efficiency, ensure the bounds and alignment of the extents within the box are ( 64 / [bytes per pixel] ) pixels horizontally. Vertical bounds and alignment should be 2 rows, except when 1-byte-per-pixel formats are used, in which case 4 rows are recommended. Single depth slices per call are handled efficiently. It is recommended but not necessary to provide references and strides which are 128-byte aligned. </p><p> When writing to sub mipmap levels, it is recommended to use larger width and heights than described above. This is because small mipmap levels may actually be stored within a larger block of memory, with an opaque amount of offsetting which can interfere with alignment to cache lines. </p><p><strong>WriteToSubresource</strong> and <strong>ReadFromSubresource</strong> enable near zero-copy optimizations for UMA adapters, but can prohibitively impair the efficiency of discrete/ NUMA adapters as the texture data cannot reside in local video memory. Typical applications should stick to discrete-friendly upload techniques, unless they recognize the adapter architecture is UMA. For more details on uploading, refer to <strong>CopyTextureRegion</strong>, and for more details on UMA, refer to <strong><see cref = "SharpDX.Direct3D12.FeatureDataArchitecture"/></strong>. </p><p>On UMA systems, this routine can be used to minimize the cost of memory copying through the loop optimization known as loop tiling. By breaking up the upload into chucks that comfortably fit in the CPU cache, the effective bandwidth between the CPU and main memory more closely achieves theoretical maximums.
        /// </p>
        /// </remarks>
        /// <doc-id>dn914416</doc-id>
        /// <unmanaged>HRESULT ID3D12Resource::WriteToSubresource([In] unsigned int DstSubresource,[In, Optional] const D3D12_BOX* pDstBox,[In] const void* pSrcData,[In] unsigned int SrcRowPitch,[In] unsigned int SrcDepthPitch)</unmanaged>
        /// <unmanaged-short>ID3D12Resource::WriteToSubresource</unmanaged-short>
        public unsafe void WriteToSubresource(System.Int32 dstSubresource, SharpDX.Direct3D12.ResourceRegion? dstBoxRef, System.IntPtr srcDataRef, System.Int32 srcRowPitch, System.Int32 srcDepthPitch)
        {
            SharpDX.Direct3D12.ResourceRegion dstBoxRef_;
            SharpDX.Result __result__;
            if (dstBoxRef != null)
                dstBoxRef_ = dstBoxRef.Value;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, dstSubresource, dstBoxRef == null ? (void *)0 : &dstBoxRef_, (void *)srcDataRef, srcRowPitch, srcDepthPitch, (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Uses the CPU to copy data from a subresource, enabling the CPU to read the contents of most textures with undefined layouts. </p>
        /// </summary>
        /// <param name = "dstDataRef"><dd>  <p> A reference to the destination data in memory. </p> </dd></param>
        /// <param name = "dstRowPitch"><dd>  <p> The distance from one row of destination data to the next row. </p> </dd></param>
        /// <param name = "dstDepthPitch"><dd>  <p> The distance from one depth slice of destination data to the next. </p> </dd></param>
        /// <param name = "srcSubresource"><dd>  <p> Specifies the index of the subresource to read from. </p> </dd></param>
        /// <param name = "srcBoxRef"><dd>  <p> A reference to a box that defines the portion of the destination subresource to copy the resource data from. If <c>null</c>, the data is read from the destination subresource with no offset. The dimensions of the destination must fit the destination (see <strong><see cref = "SharpDX.Direct3D12.ResourceRegion"/></strong>). </p> <p> An empty box results in a no-op. A box is empty if the top value is greater than or equal to the bottom value, or the left value is greater than or equal to the right value, or the front value is greater than or equal to the back value. When the box is empty, this method doesn't perform any operation. </p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. </p></returns>
        /// <remarks>
        /// <p> See the Remarks section for <strong>WriteToSubresource</strong>. </p>
        /// </remarks>
        /// <doc-id>dn914415</doc-id>
        /// <unmanaged>HRESULT ID3D12Resource::ReadFromSubresource([In, Value] void* pDstData,[In] unsigned int DstRowPitch,[In] unsigned int DstDepthPitch,[In] unsigned int SrcSubresource,[In, Optional] const D3D12_BOX* pSrcBox)</unmanaged>
        /// <unmanaged-short>ID3D12Resource::ReadFromSubresource</unmanaged-short>
        public unsafe void ReadFromSubresource(System.IntPtr dstDataRef, System.Int32 dstRowPitch, System.Int32 dstDepthPitch, System.Int32 srcSubresource, SharpDX.Direct3D12.ResourceRegion? srcBoxRef)
        {
            SharpDX.Direct3D12.ResourceRegion srcBoxRef_;
            SharpDX.Result __result__;
            if (srcBoxRef != null)
                srcBoxRef_ = srcBoxRef.Value;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, (void *)dstDataRef, dstRowPitch, dstDepthPitch, srcSubresource, srcBoxRef == null ? (void *)0 : &srcBoxRef_, (*(void ***)this._nativePointer)[13]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Retrieves the properties of the resource heap, for placed and committed resources. </p>
        /// </summary>
        /// <param name = "heapPropertiesRef"><dd>  <p> Pointer to a <strong><see cref = "SharpDX.Direct3D12.HeapProperties"/></strong> structure, that on successful completion of the method will contain the resource heap properties. </p> </dd></param>
        /// <param name = "heapFlagsRef"><dd>  <p> Specifies a <strong><see cref = "SharpDX.Direct3D12.HeapFlags"/></strong> variable, that on successful completion of the method will contain any miscellaneous heap flags. </p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. If the resource was created as reserved, E_INVALIDARG is returned. </p></returns>
        /// <remarks>
        /// <p> This method only works on placed and committed resources, not on reserved resources. If the resource was created as reserved, E_INVALIDARG is returned. The pages could be mapped to none, one, or more heaps. </p><p> For more information, refer to Memory Management in Direct3D 12. </p>
        /// </remarks>
        /// <doc-id>dn914414</doc-id>
        /// <unmanaged>HRESULT ID3D12Resource::GetHeapProperties([Out, Optional] D3D12_HEAP_PROPERTIES* pHeapProperties,[Out, Optional] D3D12_HEAP_FLAGS* pHeapFlags)</unmanaged>
        /// <unmanaged-short>ID3D12Resource::GetHeapProperties</unmanaged-short>
        public unsafe void GetHeapProperties(out SharpDX.Direct3D12.HeapProperties heapPropertiesRef, out SharpDX.Direct3D12.HeapFlags heapFlagsRef)
        {
            heapPropertiesRef = default (SharpDX.Direct3D12.HeapProperties);
            SharpDX.Result __result__;
            fixed (void *heapFlagsRef_ = &heapFlagsRef)
                fixed (void *heapPropertiesRef_ = &heapPropertiesRef)
                    __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, heapPropertiesRef_, heapFlagsRef_, (*(void ***)this._nativePointer)[14]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("9D5E227A-4430-4161-88B3-3ECA6BB16E19")]
    public partial class Resource1 : SharpDX.Direct3D12.Resource
    {
        public Resource1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Resource1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Resource1(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "riid">No documentation.</param>
        /// <param name = "protectedSessionOut">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D12Resource1::GetProtectedResourceSession([In] const GUID&amp; riid,[Out, Optional] void** ppProtectedSession)</unmanaged>
        /// <unmanaged-short>ID3D12Resource1::GetProtectedResourceSession</unmanaged-short>
        public unsafe void GetProtectedResourceSession(System.Guid riid, out System.IntPtr protectedSessionOut)
        {
            SharpDX.Result __result__;
            fixed (void *protectedSessionOut_ = &protectedSessionOut)
                __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, &riid, protectedSessionOut_, (*(void ***)this._nativePointer)[15]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("c54a6b66-72df-4ee8-8be5-a946a1429214")]
    public partial class RootSignature : SharpDX.Direct3D12.DeviceChild
    {
        public RootSignature(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator RootSignature(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new RootSignature(nativePtr);
    }

    [System.Runtime.InteropServices.GuidAttribute("34AB647B-3CC8-46AC-841B-C0965645C046")]
    public partial class RootSignatureDeserializer : SharpDX.ComObject
    {
        public RootSignatureDeserializer(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator RootSignatureDeserializer(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new RootSignatureDeserializer(nativePtr);
        /// <summary>
        /// <p> Gets the layout of the root signature. </p>
        /// </summary>
        /// <returns><p> This method returns a deserialized root signature in a <strong><see cref = "SharpDX.Direct3D12.RootSignatureDescription"/></strong> structure that describes the layout of the root signature. </p></returns>
        /// <doc-id>dn986887</doc-id>
        /// <unmanaged>const D3D12_ROOT_SIGNATURE_DESC* ID3D12RootSignatureDeserializer::GetRootSignatureDesc()</unmanaged>
        /// <unmanaged-short>ID3D12RootSignatureDeserializer::GetRootSignatureDesc</unmanaged-short>
        private unsafe System.IntPtr GetRootSignatureDescription()
        {
            System.IntPtr __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallSystemIntPtr(this._nativePointer, (*(void ***)this._nativePointer)[3]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("0adf7d52-929c-4e61-addb-ffed30de66ef")]
    public partial class SharingContract : SharpDX.ComObject
    {
        public SharingContract(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator SharingContract(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new SharingContract(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "resourceRef">No documentation.</param>
        /// <param name = "subresource">No documentation.</param>
        /// <param name = "window">No documentation.</param>
        /// <unmanaged>void ID3D12SharingContract::Present([In] ID3D12Resource* pResource,[In] unsigned int Subresource,[In] HWND window)</unmanaged>
        /// <unmanaged-short>ID3D12SharingContract::Present</unmanaged-short>
        public unsafe void Present(SharpDX.Direct3D12.Resource resourceRef, System.Int32 subresource, System.IntPtr window)
        {
            System.IntPtr resourceRef_ = System.IntPtr.Zero;
            resourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(resourceRef);
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)resourceRef_, subresource, (void *)window, (*(void ***)this._nativePointer)[3]);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "fenceRef">No documentation.</param>
        /// <param name = "fenceValue">No documentation.</param>
        /// <unmanaged>void ID3D12SharingContract::SharedFenceSignal([In] ID3D12Fence* pFence,[In] unsigned longlong FenceValue)</unmanaged>
        /// <unmanaged-short>ID3D12SharingContract::SharedFenceSignal</unmanaged-short>
        public unsafe void SharedFenceSignal(SharpDX.Direct3D12.Fence fenceRef, System.Int64 fenceValue)
        {
            System.IntPtr fenceRef_ = System.IntPtr.Zero;
            fenceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Fence>(fenceRef);
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)fenceRef_, fenceValue, (*(void ***)this._nativePointer)[4]);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "guid">No documentation.</param>
        /// <unmanaged>void ID3D12SharingContract::BeginCapturableWork([In] const GUID&amp; guid)</unmanaged>
        /// <unmanaged-short>ID3D12SharingContract::BeginCapturableWork</unmanaged-short>
        public unsafe void BeginCapturableWork(System.Guid guid)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, &guid, (*(void ***)this._nativePointer)[5]);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "guid">No documentation.</param>
        /// <unmanaged>void ID3D12SharingContract::EndCapturableWork([In] const GUID&amp; guid)</unmanaged>
        /// <unmanaged-short>ID3D12SharingContract::EndCapturableWork</unmanaged-short>
        public unsafe void EndCapturableWork(System.Guid guid)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, &guid, (*(void ***)this._nativePointer)[6]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("47016943-fca8-4594-93ea-af258b55346d")]
    public partial class StateObject : SharpDX.Direct3D12.Pageable
    {
        public StateObject(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator StateObject(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new StateObject(nativePtr);
    }

    [System.Runtime.InteropServices.GuidAttribute("de5fa827-9bf9-4f26-89ff-d7f56fde3860")]
    public partial class StateObjectProperties : SharpDX.ComObject
    {
        public StateObjectProperties(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator StateObjectProperties(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new StateObjectProperties(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>GetPipelineStackSize / SetPipelineStackSize</unmanaged>
        /// <unmanaged-short>GetPipelineStackSize</unmanaged-short>
        public System.Int64 PipelineStackSize
        {
            get => GetPipelineStackSize();
            set => SetPipelineStackSize(value);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "exportNameRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>void* ID3D12StateObjectProperties::GetShaderIdentifier([In] const wchar_t* pExportName)</unmanaged>
        /// <unmanaged-short>ID3D12StateObjectProperties::GetShaderIdentifier</unmanaged-short>
        public unsafe System.IntPtr GetShaderIdentifier(System.String exportNameRef)
        {
            System.IntPtr __result__;
            fixed (char *exportNameRef_ = exportNameRef)
                __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallSystemIntPtr(this._nativePointer, (void *)exportNameRef_, (*(void ***)this._nativePointer)[3]);
            return __result__;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "exportNameRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>unsigned longlong ID3D12StateObjectProperties::GetShaderStackSize([In] const wchar_t* pExportName)</unmanaged>
        /// <unmanaged-short>ID3D12StateObjectProperties::GetShaderStackSize</unmanaged-short>
        public unsafe System.Int64 GetShaderStackSize(System.String exportNameRef)
        {
            System.Int64 __result__;
            fixed (char *exportNameRef_ = exportNameRef)
                __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCalllong(this._nativePointer, (void *)exportNameRef_, (*(void ***)this._nativePointer)[4]);
            return __result__;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <returns>No documentation.</returns>
        /// <unmanaged>unsigned longlong ID3D12StateObjectProperties::GetPipelineStackSize()</unmanaged>
        /// <unmanaged-short>ID3D12StateObjectProperties::GetPipelineStackSize</unmanaged-short>
        internal unsafe System.Int64 GetPipelineStackSize()
        {
            System.Int64 __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCalllong(this._nativePointer, (*(void ***)this._nativePointer)[5]);
            return __result__;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "pipelineStackSizeInBytes">No documentation.</param>
        /// <unmanaged>void ID3D12StateObjectProperties::SetPipelineStackSize([In] unsigned longlong PipelineStackSizeInBytes)</unmanaged>
        /// <unmanaged-short>ID3D12StateObjectProperties::SetPipelineStackSize</unmanaged-short>
        internal unsafe void SetPipelineStackSize(System.Int64 pipelineStackSizeInBytes)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid(this._nativePointer, pipelineStackSizeInBytes, (*(void ***)this._nativePointer)[6]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("f1df64b6-57fd-49cd-8807-c0eb88b45c8f")]
    public partial class SwapChainAssistant : SharpDX.ComObject
    {
        public SwapChainAssistant(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator SwapChainAssistant(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new SwapChainAssistant(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>GetLUID</unmanaged>
        /// <unmanaged-short>GetLUID</unmanaged-short>
        public System.Int64 LUID
        {
            get => GetLUID();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <returns>No documentation.</returns>
        /// <unmanaged>LUID ID3D12SwapChainAssistant::GetLUID()</unmanaged>
        /// <unmanaged-short>ID3D12SwapChainAssistant::GetLUID</unmanaged-short>
        internal unsafe System.Int64 GetLUID()
        {
            System.Int64 __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCalllong(this._nativePointer, (*(void ***)this._nativePointer)[3]);
            return __result__;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "riid">No documentation.</param>
        /// <param name = "vOut">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D12SwapChainAssistant::GetSwapChainObject([In] const GUID&amp; riid,[Out] void** ppv)</unmanaged>
        /// <unmanaged-short>ID3D12SwapChainAssistant::GetSwapChainObject</unmanaged-short>
        public unsafe void GetSwapChainObject(System.Guid riid, out System.IntPtr vOut)
        {
            SharpDX.Result __result__;
            fixed (void *vOut_ = &vOut)
                __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, &riid, vOut_, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "riidResource">No documentation.</param>
        /// <param name = "vResourceOut">No documentation.</param>
        /// <param name = "riidQueue">No documentation.</param>
        /// <param name = "vQueueOut">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D12SwapChainAssistant::GetCurrentResourceAndCommandQueue([In] const GUID&amp; riidResource,[Out] void** ppvResource,[In] const GUID&amp; riidQueue,[Out] void** ppvQueue)</unmanaged>
        /// <unmanaged-short>ID3D12SwapChainAssistant::GetCurrentResourceAndCommandQueue</unmanaged-short>
        public unsafe void GetCurrentResourceAndCommandQueue(System.Guid riidResource, out System.IntPtr vResourceOut, System.Guid riidQueue, out System.IntPtr vQueueOut)
        {
            SharpDX.Result __result__;
            fixed (void *vQueueOut_ = &vQueueOut)
                fixed (void *vResourceOut_ = &vResourceOut)
                    __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, &riidResource, vResourceOut_, &riidQueue, vQueueOut_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D12SwapChainAssistant::InsertImplicitSync()</unmanaged>
        /// <unmanaged-short>ID3D12SwapChainAssistant::InsertImplicitSync</unmanaged-short>
        public unsafe void InsertImplicitSync()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("7071e1f0-e84b-4b33-974f-12fa49de65c5")]
    public partial class Tools : SharpDX.ComObject
    {
        public Tools(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Tools(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Tools(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "bEnable">No documentation.</param>
        /// <unmanaged>void ID3D12Tools::EnableShaderInstrumentation([In] BOOL bEnable)</unmanaged>
        /// <unmanaged-short>ID3D12Tools::EnableShaderInstrumentation</unmanaged-short>
        public unsafe void EnableShaderInstrumentation(SharpDX.Mathematics.Interop.RawBool bEnable)
        {
            SharpDX.Direct3D12.LocalInterop.CalliStdCallvoid0(this._nativePointer, bEnable, (*(void ***)this._nativePointer)[3]);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <returns>No documentation.</returns>
        /// <unmanaged>BOOL ID3D12Tools::ShaderInstrumentationEnabled()</unmanaged>
        /// <unmanaged-short>ID3D12Tools::ShaderInstrumentationEnabled</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool ShaderInstrumentationEnabled()
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.Direct3D12.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, (*(void ***)this._nativePointer)[4]);
            return __result__;
        }
    }
}
// <auto-generated/>

namespace SharpDX.Direct3D12
{
    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_AUTO_BREADCRUMB_NODE</unmanaged>
    /// <unmanaged-short>D3D12_AUTO_BREADCRUMB_NODE</unmanaged-short>
    public partial struct AutoBreadcrumbNode
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>pCommandListDebugNameA</unmanaged>
        /// <unmanaged-short>pCommandListDebugNameA</unmanaged-short>
        public System.String CommandListDebugNameAPointer;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>pCommandListDebugNameW</unmanaged>
        /// <unmanaged-short>pCommandListDebugNameW</unmanaged-short>
        public System.String CommandListDebugNameWPointer;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>pCommandQueueDebugNameA</unmanaged>
        /// <unmanaged-short>pCommandQueueDebugNameA</unmanaged-short>
        public System.String CommandQueueDebugNameAPointer;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>pCommandQueueDebugNameW</unmanaged>
        /// <unmanaged-short>pCommandQueueDebugNameW</unmanaged-short>
        public System.String CommandQueueDebugNameWPointer;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>pCommandList</unmanaged>
        /// <unmanaged-short>pCommandList</unmanaged-short>
        public SharpDX.Direct3D12.GraphicsCommandList CommandListPointer;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>pCommandQueue</unmanaged>
        /// <unmanaged-short>pCommandQueue</unmanaged-short>
        public SharpDX.Direct3D12.CommandQueue CommandQueuePointer;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>BreadcrumbCount</unmanaged>
        /// <unmanaged-short>BreadcrumbCount</unmanaged-short>
        public System.Int32 BreadcrumbCount;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>pLastBreadcrumbValue</unmanaged>
        /// <unmanaged-short>pLastBreadcrumbValue</unmanaged-short>
        public System.IntPtr LastBreadcrumbValuePointer;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>pCommandHistory</unmanaged>
        /// <unmanaged-short>pCommandHistory</unmanaged-short>
        public System.IntPtr CommandHistoryPointer;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>pNext</unmanaged>
        /// <unmanaged-short>pNext</unmanaged-short>
        public System.IntPtr NextPointer;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.IntPtr CommandListDebugNameAPointer;
            public System.IntPtr CommandListDebugNameWPointer;
            public System.IntPtr CommandQueueDebugNameAPointer;
            public System.IntPtr CommandQueueDebugNameWPointer;
            public System.IntPtr CommandListPointer;
            public System.IntPtr CommandQueuePointer;
            public System.Int32 BreadcrumbCount;
            public System.IntPtr LastBreadcrumbValuePointer;
            public System.IntPtr CommandHistoryPointer;
            public System.IntPtr NextPointer;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.CommandListDebugNameAPointer);
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.CommandListDebugNameWPointer);
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.CommandQueueDebugNameAPointer);
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.CommandQueueDebugNameWPointer);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            CommandListDebugNameAPointer = System.Runtime.InteropServices.Marshal.PtrToStringAnsi(@ref.CommandListDebugNameAPointer);
            CommandListDebugNameWPointer = System.Runtime.InteropServices.Marshal.PtrToStringUni(@ref.CommandListDebugNameWPointer);
            CommandQueueDebugNameAPointer = System.Runtime.InteropServices.Marshal.PtrToStringAnsi(@ref.CommandQueueDebugNameAPointer);
            CommandQueueDebugNameWPointer = System.Runtime.InteropServices.Marshal.PtrToStringUni(@ref.CommandQueueDebugNameWPointer);
            if (@ref.CommandListPointer != System.IntPtr.Zero)
                CommandListPointer = new SharpDX.Direct3D12.GraphicsCommandList(@ref.CommandListPointer);
            else
                CommandListPointer = null;
            if (@ref.CommandQueuePointer != System.IntPtr.Zero)
                CommandQueuePointer = new SharpDX.Direct3D12.CommandQueue(@ref.CommandQueuePointer);
            else
                CommandQueuePointer = null;
            BreadcrumbCount = @ref.BreadcrumbCount;
            LastBreadcrumbValuePointer = @ref.LastBreadcrumbValuePointer;
            CommandHistoryPointer = @ref.CommandHistoryPointer;
            NextPointer = @ref.NextPointer;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.CommandListDebugNameAPointer = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(CommandListDebugNameAPointer);
            @ref.CommandListDebugNameWPointer = System.Runtime.InteropServices.Marshal.StringToHGlobalUni(CommandListDebugNameWPointer);
            @ref.CommandQueueDebugNameAPointer = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(CommandQueueDebugNameAPointer);
            @ref.CommandQueueDebugNameWPointer = System.Runtime.InteropServices.Marshal.StringToHGlobalUni(CommandQueueDebugNameWPointer);
            @ref.CommandListPointer = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.GraphicsCommandList>(CommandListPointer);
            @ref.CommandQueuePointer = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.CommandQueue>(CommandQueuePointer);
            @ref.BreadcrumbCount = BreadcrumbCount;
            @ref.LastBreadcrumbValuePointer = LastBreadcrumbValuePointer;
            @ref.CommandHistoryPointer = CommandHistoryPointer;
            @ref.NextPointer = NextPointer;
        }
    }

    /// <summary>
    /// <p>Describes the blend state.</p>
    /// </summary>
    /// <remarks>
    /// <p> A <strong><see cref = "SharpDX.Direct3D12.GraphicsPipelineStateDescription"/></strong> object contains a blend-state structure that controls blending by the output-merger stage. </p><p> Here are the default values for blend state. </p><table> <tr><th>State</th><th>Default Value</th></tr> <tr><td>AlphaToCoverageEnable</td><td><strong><see cref = "SharpDX.Result.False"/></strong></td></tr> <tr><td>IndependentBlendEnable</td><td><strong><see cref = "SharpDX.Result.False"/></strong></td></tr> <tr><td>RenderTarget[0].BlendEnable</td><td><strong><see cref = "SharpDX.Result.False"/></strong></td></tr> <tr><td>RenderTarget[0].LogicOpEnable</td><td><strong><see cref = "SharpDX.Result.False"/></strong></td></tr> <tr><td>RenderTarget[0].SrcBlend</td><td>D3D12_BLEND_ONE</td></tr> <tr><td>RenderTarget[0].DestBlend</td><td>D3D12_BLEND_ZERO</td></tr> <tr><td>RenderTarget[0].BlendOp</td><td>D3D12_BLEND_OP_ADD</td></tr> <tr><td>RenderTarget[0].SrcBlendAlpha</td><td>D3D12_BLEND_ONE</td></tr> <tr><td>RenderTarget[0].DestBlendAlpha</td><td>D3D12_BLEND_ZERO</td></tr> <tr><td>RenderTarget[0].BlendOpAlpha</td><td>D3D12_BLEND_OP_ADD</td></tr> <tr><td>RenderTarget[0].LogicOp</td><td>D3D12_LOGIC_OP_NOOP</td></tr> <tr><td>RenderTarget[0].RenderTargetWriteMask</td><td>D3D12_COLOR_WRITE_ENABLE_ALL</td></tr> </table><p>?</p><p> When you set the <strong>LogicOpEnable</strong> member of the first element of the <strong>RenderTarget</strong> array (<strong>RenderTarget</strong>[0]) to <strong>TRUE</strong>, you must also set the <strong>BlendEnable</strong> member of  <strong>RenderTarget</strong>[0] to <strong><see cref = "SharpDX.Result.False"/></strong>, and the <strong>IndependentBlendEnable</strong> member of  this structure to <strong><see cref = "SharpDX.Result.False"/></strong>.  This reflects the limitation in hardware that you can't mix logic operations with blending across multiple render targets, and that when you use a logic operation, you must apply the same logic operation to all render targets. </p><p> Note the helper structure, <strong>CD3DX12_BLEND_DESC</strong>. </p>
    /// </remarks>
    /// <doc-id>dn770339</doc-id>
    /// <unmanaged>D3D12_BLEND_DESC</unmanaged>
    /// <unmanaged-short>D3D12_BLEND_DESC</unmanaged-short>
    public partial struct BlendStateDescription
    {
        /// <summary>
        /// <dd> <p> Specifies whether to use alpha-to-coverage as a multisampling technique when setting a pixel to a render target. For more info about using alpha-to-coverage, see Alpha-To-Coverage. </p> </dd>
        /// </summary>
        /// <doc-id>dn770339</doc-id>
        /// <unmanaged>AlphaToCoverageEnable</unmanaged>
        /// <unmanaged-short>AlphaToCoverageEnable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool AlphaToCoverageEnable;
        /// <summary>
        /// <dd> <p> Specifies whether to enable independent blending in simultaneous render targets.  Set to <strong>TRUE</strong> to enable independent blending. If set to <strong><see cref = "SharpDX.Result.False"/></strong>, only the <strong>RenderTarget</strong>[0] members are used; <strong>RenderTarget</strong>[1..7] are ignored. </p> </dd>
        /// </summary>
        /// <doc-id>dn770339</doc-id>
        /// <unmanaged>IndependentBlendEnable</unmanaged>
        /// <unmanaged-short>IndependentBlendEnable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IndependentBlendEnable;
        /// <summary>
        /// <dd> <p> An array of  <strong><see cref = "SharpDX.Direct3D12.RenderTargetBlendDescription"/></strong> structures that describe the blend states for render targets; these correspond to the eight render targets that can be bound to the output-merger stage at one time. </p> </dd>
        /// </summary>
        /// <doc-id>dn770339</doc-id>
        /// <unmanaged>RenderTarget</unmanaged>
        /// <unmanaged-short>RenderTarget</unmanaged-short>
        public SharpDX.Direct3D12.RenderTargetBlendDescription[] RenderTarget
        {
            get => _RenderTarget ?? (_RenderTarget = new SharpDX.Direct3D12.RenderTargetBlendDescription[8]);
            private set => _RenderTarget = value;
        }

        internal SharpDX.Direct3D12.RenderTargetBlendDescription[] _RenderTarget;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.Mathematics.Interop.RawBool AlphaToCoverageEnable;
            public SharpDX.Mathematics.Interop.RawBool IndependentBlendEnable;
            public SharpDX.Direct3D12.RenderTargetBlendDescription RenderTarget;
            public SharpDX.Direct3D12.RenderTargetBlendDescription __RenderTarget1;
            public SharpDX.Direct3D12.RenderTargetBlendDescription __RenderTarget2;
            public SharpDX.Direct3D12.RenderTargetBlendDescription __RenderTarget3;
            public SharpDX.Direct3D12.RenderTargetBlendDescription __RenderTarget4;
            public SharpDX.Direct3D12.RenderTargetBlendDescription __RenderTarget5;
            public SharpDX.Direct3D12.RenderTargetBlendDescription __RenderTarget6;
            public SharpDX.Direct3D12.RenderTargetBlendDescription __RenderTarget7;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            AlphaToCoverageEnable = @ref.AlphaToCoverageEnable;
            IndependentBlendEnable = @ref.IndependentBlendEnable;
            fixed (void *__to = &RenderTarget[0], __from = &@ref.RenderTarget)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 8 * sizeof (SharpDX.Direct3D12.RenderTargetBlendDescription));
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.AlphaToCoverageEnable = AlphaToCoverageEnable;
            @ref.IndependentBlendEnable = IndependentBlendEnable;
            fixed (void *__from = &RenderTarget[0], __to = &@ref.RenderTarget)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 8 * sizeof (SharpDX.Direct3D12.RenderTargetBlendDescription));
        }
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC</unmanaged>
    /// <unmanaged-short>D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC</unmanaged-short>
    public partial struct BuildRaytracingAccelerationStructureDescription
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>DestAccelerationStructureData</unmanaged>
        /// <unmanaged-short>DestAccelerationStructureData</unmanaged-short>
        public System.Int64 DestAccelerationStructureData;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Inputs</unmanaged>
        /// <unmanaged-short>Inputs</unmanaged-short>
        public SharpDX.Direct3D12.BuildRaytracingAccelerationStructureInputs Inputs;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>SourceAccelerationStructureData</unmanaged>
        /// <unmanaged-short>SourceAccelerationStructureData</unmanaged-short>
        public System.Int64 SourceAccelerationStructureData;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>ScratchAccelerationStructureData</unmanaged>
        /// <unmanaged-short>ScratchAccelerationStructureData</unmanaged-short>
        public System.Int64 ScratchAccelerationStructureData;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.Int64 DestAccelerationStructureData;
            public SharpDX.Direct3D12.BuildRaytracingAccelerationStructureInputs.__Native Inputs;
            public System.Int64 SourceAccelerationStructureData;
            public System.Int64 ScratchAccelerationStructureData;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            Inputs.__MarshalFree(ref @ref.Inputs);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            DestAccelerationStructureData = @ref.DestAccelerationStructureData;
            {
                Inputs = new SharpDX.Direct3D12.BuildRaytracingAccelerationStructureInputs();
                Inputs.__MarshalFrom(ref @ref.Inputs);
            }

            SourceAccelerationStructureData = @ref.SourceAccelerationStructureData;
            ScratchAccelerationStructureData = @ref.ScratchAccelerationStructureData;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.DestAccelerationStructureData = DestAccelerationStructureData;
            Inputs.__MarshalTo(ref @ref.Inputs);
            @ref.SourceAccelerationStructureData = SourceAccelerationStructureData;
            @ref.ScratchAccelerationStructureData = ScratchAccelerationStructureData;
        }
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS</unmanaged>
    /// <unmanaged-short>D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS</unmanaged-short>
    public partial class BuildRaytracingAccelerationStructureInputs
    {
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_TOOLS_VISUALIZATION_HEADER</unmanaged>
    /// <unmanaged-short>D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_TOOLS_VISUALIZATION_HEADER</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct BuildRaytracingAccelerationStructureToolSVisualizationHeader
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Type</unmanaged>
        /// <unmanaged-short>Type</unmanaged-short>
        public SharpDX.Direct3D12.RaytracingAccelerationStructureType Type;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>NumDescs</unmanaged>
        /// <unmanaged-short>NumDescs</unmanaged-short>
        public System.Int32 DescCount;
    }

    /// <summary>
    /// <p>Stores a pipeline state.</p>
    /// </summary>
    /// <remarks>
    /// <p> This structure is used by the <strong><see cref = "SharpDX.Direct3D12.GraphicsPipelineStateDescription"/></strong> structure, and the <strong><see cref = "SharpDX.Direct3D12.ComputePipelineStateDescription"/></strong> structure.</p><p>This structure is intended to be filled with the data retrieved from <strong>ID3D12PipelineState::GetCachedBlob</strong>. This cached PSO contains data specific to the hardware, driver, and machine that it was retrieved from. Compilation using this data should be faster than compilation without. The rest of the data in the PSO needs to still be valid, and needs to match the cached PSO, otherwise E_INVALIDARG might be returned.</p><p>If the driver has been upgraded to a D3D12 driver after the PSO was cached, you might see a D3D12_ERROR_DRIVER_VERSION_MISMATCH return code, or if you?re running on a different GPU, the D3D12_ERROR_ADAPTER_NOT_FOUND return code.</p>
    /// </remarks>
    /// <doc-id>dn914407</doc-id>
    /// <unmanaged>D3D12_CACHED_PIPELINE_STATE</unmanaged>
    /// <unmanaged-short>D3D12_CACHED_PIPELINE_STATE</unmanaged-short>
    public partial struct CachedPipelineState
    {
        /// <summary>
        /// <dd> <p> Specifies reference that references the memory location of the cache. </p> </dd>
        /// </summary>
        /// <doc-id>dn914407</doc-id>
        /// <unmanaged>pCachedBlob</unmanaged>
        /// <unmanaged-short>pCachedBlob</unmanaged-short>
        public System.IntPtr CachedBlobPointer;
        /// <summary>
        /// <dd> <p> Specifies the size of the cache in bytes. </p> </dd>
        /// </summary>
        /// <doc-id>dn914407</doc-id>
        /// <unmanaged>CachedBlobSizeInBytes</unmanaged>
        /// <unmanaged-short>CachedBlobSizeInBytes</unmanaged-short>
        public SharpDX.PointerSize CachedBlobSizeInBytes;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.IntPtr CachedBlobPointer;
            public System.IntPtr CachedBlobSizeInBytes;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            CachedBlobPointer = @ref.CachedBlobPointer;
            CachedBlobSizeInBytes = (SharpDX.PointerSize)@ref.CachedBlobSizeInBytes;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.CachedBlobPointer = CachedBlobPointer;
            @ref.CachedBlobSizeInBytes = (System.IntPtr)CachedBlobSizeInBytes;
        }
    }

    /// <summary>
    /// <p>Describes a value used to optimize clear operations for a particular resource.</p>
    /// </summary>
    /// <remarks>
    /// <p> This structure is optionally passed into the following methods: </p><ul> <li> <strong>ID3D12Device::CreateCommittedResource</strong> </li> <li> <strong>ID3D12Device::CreatePlacedResource</strong> </li> <li> <strong>ID3D12Device::CreateReservedResource</strong> </li> </ul>
    /// </remarks>
    /// <doc-id>dn903795</doc-id>
    /// <unmanaged>D3D12_CLEAR_VALUE</unmanaged>
    /// <unmanaged-short>D3D12_CLEAR_VALUE</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Explicit, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct ClearValue
    {
        /// <summary>
        /// <dd> <p>Specifies one member of the <strong><see cref = "SharpDX.DXGI.Format"/></strong> enum.</p> <p>The format of the commonly cleared color follows the same validation rules as a view/ descriptor creation. In general, the format of the clear color can be any format in the same typeless group that the resource format belongs to.</p> <p>This <em>Format</em> must match the format of the view used during the clear operation. It indicates whether the <em>Color</em> or the <em>DepthStencil</em> member is valid and how to convert the values for usage with the resource.</p> </dd>
        /// </summary>
        /// <doc-id>dn903795</doc-id>
        /// <unmanaged>Format</unmanaged>
        /// <unmanaged-short>Format</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(0)]
        public SharpDX.DXGI.Format Format;
        /// <summary>
        /// <dd> <p>Specifies a 4-entry array of float values (each value in the range 0.0 to 1.0), determining the RGBA value. The order of RGBA matches the order used with <strong>ClearRenderTargetView</strong>.</p> </dd>
        /// </summary>
        /// <doc-id>dn903795</doc-id>
        /// <unmanaged>Color</unmanaged>
        /// <unmanaged-short>Color</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(4)]
        public SharpDX.Mathematics.Interop.RawVector4 Color;
        /// <summary>
        /// <dd> <p>Specifies one member of <strong><see cref = "SharpDX.Direct3D12.DepthStencilValue"/></strong>. These values match the semantics of <em>Depth</em> and <em>Stencil</em> in <strong>ClearDepthStencilView</strong>.</p> </dd>
        /// </summary>
        /// <doc-id>dn903795</doc-id>
        /// <unmanaged>DepthStencil</unmanaged>
        /// <unmanaged-short>DepthStencil</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(4)]
        public SharpDX.Direct3D12.DepthStencilValue DepthStencil;
    }

    /// <summary>
    /// <p>Describes a command queue.</p>
    /// </summary>
    /// <remarks>
    /// <p> This structure is passed into <strong>CreateCommandQueue</strong>. </p><p> This structure is returned by <strong>ID3D12CommandQueue::GetDesc</strong>. </p>
    /// </remarks>
    /// <doc-id>dn903796</doc-id>
    /// <unmanaged>D3D12_COMMAND_QUEUE_DESC</unmanaged>
    /// <unmanaged-short>D3D12_COMMAND_QUEUE_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct CommandQueueDescription
    {
        /// <summary>
        /// <dd> <p> Specifies one member of <strong><see cref = "SharpDX.Direct3D12.CommandListType"/></strong>. </p> </dd>
        /// </summary>
        /// <doc-id>dn903796</doc-id>
        /// <unmanaged>Type</unmanaged>
        /// <unmanaged-short>Type</unmanaged-short>
        public SharpDX.Direct3D12.CommandListType Type;
        /// <summary>
        /// <dd> <p> The priority for the command queue, as a  <strong><see cref = "SharpDX.Direct3D12.CommandQueuePriority"/></strong> enumeration constant to select normal or high priority. </p> </dd>
        /// </summary>
        /// <doc-id>dn903796</doc-id>
        /// <unmanaged>Priority</unmanaged>
        /// <unmanaged-short>Priority</unmanaged-short>
        public System.Int32 Priority;
        /// <summary>
        /// <dd> <p> Specifies any flags from the <strong><see cref = "SharpDX.Direct3D12.CommandQueueFlags"/></strong> enumeration. </p> </dd>
        /// </summary>
        /// <doc-id>dn903796</doc-id>
        /// <unmanaged>Flags</unmanaged>
        /// <unmanaged-short>Flags</unmanaged-short>
        public SharpDX.Direct3D12.CommandQueueFlags Flags;
        /// <summary>
        /// <dd> <p> For single GPU operation, set this to zero. If there are multiple GPU nodes, set a bit to identify the node (the  device's physical adapter) to which the command queue applies. Each bit in the mask corresponds to a single node. Only 1 bit must be set. Refer to Multi-Adapter.</p> </dd>
        /// </summary>
        /// <doc-id>dn903796</doc-id>
        /// <unmanaged>NodeMask</unmanaged>
        /// <unmanaged-short>NodeMask</unmanaged-short>
        public System.Int32 NodeMask;
    }

    /// <summary>
    /// <p> Describes the arguments (parameters) of a command signature. </p>
    /// </summary>
    /// <remarks>
    /// <p> Use this structure by <strong>CreateCommandSignature</strong>. </p>
    /// </remarks>
    /// <doc-id>dn986724</doc-id>
    /// <unmanaged>D3D12_COMMAND_SIGNATURE_DESC</unmanaged>
    /// <unmanaged-short>D3D12_COMMAND_SIGNATURE_DESC</unmanaged-short>
    public partial class CommandSignatureDescription
    {
        /// <summary>
        /// <dd> <p> Specifies the size of each argument of a command signature, in bytes. </p> </dd>
        /// </summary>
        /// <doc-id>dn986724</doc-id>
        /// <unmanaged>ByteStride</unmanaged>
        /// <unmanaged-short>ByteStride</unmanaged-short>
        public System.Int32 ByteStride;
        /// <summary>
        /// <dd> <p> Specifies the number of arguments in the command signature. </p> </dd>
        /// </summary>
        /// <doc-id>dn986724</doc-id>
        /// <unmanaged>NumArgumentDescs</unmanaged>
        /// <unmanaged-short>NumArgumentDescs</unmanaged-short>
        internal System.Int32 ArgumentDescCount;
        /// <summary>
        /// <dd> <p> An array of <strong><see cref = "SharpDX.Direct3D12.IndirectArgumentDescription"/></strong> structures, containing details of the arguments, including whether the argument is a vertex buffer, constant, constant buffer view, shader resource view, or unordered access view. </p> </dd>
        /// </summary>
        /// <doc-id>dn986724</doc-id>
        /// <unmanaged>pArgumentDescs</unmanaged>
        /// <unmanaged-short>pArgumentDescs</unmanaged-short>
        internal System.IntPtr ArgumentDescsPointer;
        /// <summary>
        /// <dd> <p> For single GPU operation, set this to zero. If there are multiple GPU nodes, set bits to identify the nodes (the  device's physical adapters) for which the command signature is to apply. Each bit in the mask corresponds to a single node. Refer to Multi-Adapter.</p> </dd>
        /// </summary>
        /// <doc-id>dn986724</doc-id>
        /// <unmanaged>NodeMask</unmanaged>
        /// <unmanaged-short>NodeMask</unmanaged-short>
        public System.Int32 NodeMask;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.Int32 ByteStride;
            public System.Int32 ArgumentDescCount;
            public System.IntPtr ArgumentDescsPointer;
            public System.Int32 NodeMask;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            ByteStride = @ref.ByteStride;
            ArgumentDescCount = @ref.ArgumentDescCount;
            ArgumentDescsPointer = @ref.ArgumentDescsPointer;
            NodeMask = @ref.NodeMask;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.ByteStride = ByteStride;
            @ref.ArgumentDescCount = ArgumentDescCount;
            @ref.ArgumentDescsPointer = ArgumentDescsPointer;
            @ref.NodeMask = NodeMask;
        }
    }

    /// <summary>
    /// <p>Describes a compute pipeline state object.</p>
    /// </summary>
    /// <remarks>
    /// <p> This structure is used by <strong>CreateComputePipelineState</strong>. </p>
    /// </remarks>
    /// <doc-id>dn770350</doc-id>
    /// <unmanaged>D3D12_COMPUTE_PIPELINE_STATE_DESC</unmanaged>
    /// <unmanaged-short>D3D12_COMPUTE_PIPELINE_STATE_DESC</unmanaged-short>
    public partial class ComputePipelineStateDescription
    {
        /// <summary>
        /// <dd> <p> A reference to the <strong><see cref = "SharpDX.Direct3D12.RootSignature"/></strong> object. </p> </dd>
        /// </summary>
        /// <doc-id>dn770350</doc-id>
        /// <unmanaged>pRootSignature</unmanaged>
        /// <unmanaged-short>pRootSignature</unmanaged-short>
        public SharpDX.Direct3D12.RootSignature RootSignaturePointer;
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.ShaderBytecode"/></strong> structure that describes the compute shader. </p> </dd>
        /// </summary>
        /// <doc-id>dn770350</doc-id>
        /// <unmanaged>CS</unmanaged>
        /// <unmanaged-short>CS</unmanaged-short>
        public SharpDX.Direct3D12.ShaderBytecode ComputeShader;
        /// <summary>
        /// <dd> <p> For single GPU operation, set this to zero. If there are multiple GPU nodes, set bits to identify the nodes (the  device's physical adapters) for which the compute pipeline state is to apply. Each bit in the mask corresponds to a single node. Refer to Multi-Adapter.</p> </dd>
        /// </summary>
        /// <doc-id>dn770350</doc-id>
        /// <unmanaged>NodeMask</unmanaged>
        /// <unmanaged-short>NodeMask</unmanaged-short>
        public System.Int32 NodeMask;
        /// <summary>
        /// <dd> <p> A cached pipeline state object, as a <strong><see cref = "SharpDX.Direct3D12.CachedPipelineState"/></strong> structure. </p> </dd>
        /// </summary>
        /// <doc-id>dn770350</doc-id>
        /// <unmanaged>CachedPSO</unmanaged>
        /// <unmanaged-short>CachedPSO</unmanaged-short>
        public SharpDX.Direct3D12.CachedPipelineState CachedPSO;
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.PipelineStateFlags"/></strong> enumeration constant such as for "tool debug". </p> </dd>
        /// </summary>
        /// <doc-id>dn770350</doc-id>
        /// <unmanaged>Flags</unmanaged>
        /// <unmanaged-short>Flags</unmanaged-short>
        public SharpDX.Direct3D12.PipelineStateFlags Flags;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.IntPtr RootSignaturePointer;
            public SharpDX.Direct3D12.ShaderBytecode.__Native ComputeShader;
            public System.Int32 NodeMask;
            public SharpDX.Direct3D12.CachedPipelineState.__Native CachedPSO;
            public SharpDX.Direct3D12.PipelineStateFlags Flags;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            ComputeShader.__MarshalFree(ref @ref.ComputeShader);
            CachedPSO.__MarshalFree(ref @ref.CachedPSO);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            if (@ref.RootSignaturePointer != System.IntPtr.Zero)
                RootSignaturePointer = new SharpDX.Direct3D12.RootSignature(@ref.RootSignaturePointer);
            else
                RootSignaturePointer = null;
            ComputeShader.__MarshalFrom(ref @ref.ComputeShader);
            NodeMask = @ref.NodeMask;
            CachedPSO.__MarshalFrom(ref @ref.CachedPSO);
            Flags = @ref.Flags;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.RootSignaturePointer = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.RootSignature>(RootSignaturePointer);
            ComputeShader.__MarshalTo(ref @ref.ComputeShader);
            @ref.NodeMask = NodeMask;
            CachedPSO.__MarshalTo(ref @ref.CachedPSO);
            @ref.Flags = Flags;
        }
    }

    /// <summary>
    /// <p>Describes a constant buffer to view.</p>
    /// </summary>
    /// <remarks>
    /// <p>This structure is used by <strong>CreateConstantBufferView</strong>.</p>
    /// </remarks>
    /// <doc-id>dn770351</doc-id>
    /// <unmanaged>D3D12_CONSTANT_BUFFER_VIEW_DESC</unmanaged>
    /// <unmanaged-short>D3D12_CONSTANT_BUFFER_VIEW_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct ConstantBufferViewDescription
    {
        /// <summary>
        /// <dd> <p> The D3D12_GPU_VIRTUAL_ADDRESS of the constant buffer. D3D12_GPU_VIRTUAL_ADDRESS is a typedef'd alias of UINT64. </p> </dd>
        /// </summary>
        /// <doc-id>dn770351</doc-id>
        /// <unmanaged>BufferLocation</unmanaged>
        /// <unmanaged-short>BufferLocation</unmanaged-short>
        public System.Int64 BufferLocation;
        /// <summary>
        /// <dd> <p>The size in bytes of the constant buffer.</p> </dd>
        /// </summary>
        /// <doc-id>dn770351</doc-id>
        /// <unmanaged>SizeInBytes</unmanaged>
        /// <unmanaged-short>SizeInBytes</unmanaged-short>
        public System.Int32 SizeInBytes;
    }

    /// <summary>
    /// <p> Describes a CPU descriptor handle. </p>
    /// </summary>
    /// <remarks>
    /// <p> This structure is returned by the following methods: </p><ul> <li> <strong>ID3D12DescriptorHeap::GetCPUDescriptorHandleForHeapStart</strong> </li> </ul><p> This structure is passed into the following methods: </p><ul> <li> <strong>ID3D12Device::CopyDescriptors</strong> </li> <li> <strong>ID3D12Device::CopyDescriptorsSimple</strong> </li> <li> <strong>ID3D12Device::CreateConstantBufferView</strong> </li> <li> <strong>ID3D12Device::CreateShaderResourceView</strong> </li> <li> <strong>ID3D12Device::CreateUnorderedAccessView</strong> </li> <li> <strong>ID3D12Device::CreateRenderTargetView</strong> </li> <li> <strong>ID3D12Device::CreateDepthStencilView</strong> </li> <li> <strong>ID3D12Device::CreateSampler</strong> </li> <li> <strong>ID3D12GraphicsCommandList::ClearDepthStencilView</strong> </li> <li> <strong>ID3D12GraphicsCommandList::ClearRenderTargetView</strong> </li> <li> <strong>ID3D12GraphicsCommandList::ClearUnorderedAccessViewUint</strong> </li> <li> <strong>ID3D12GraphicsCommandList::ClearUnorderedAccessViewFloat</strong> </li> <li> <strong>ID3D12GraphicsCommandList::OMSetRenderTargets</strong> </li> </ul>
    /// </remarks>
    /// <doc-id>dn859369</doc-id>
    /// <unmanaged>D3D12_CPU_DESCRIPTOR_HANDLE</unmanaged>
    /// <unmanaged-short>D3D12_CPU_DESCRIPTOR_HANDLE</unmanaged-short>
    public partial struct CpuDescriptorHandle
    {
        /// <summary>
        /// <dd> <p> The address of  the descriptor. </p> </dd>
        /// </summary>
        /// <doc-id>dn859369</doc-id>
        /// <unmanaged>ptr</unmanaged>
        /// <unmanaged-short>ptr</unmanaged-short>
        public SharpDX.PointerSize Ptr;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.IntPtr Ptr;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Ptr = (SharpDX.PointerSize)@ref.Ptr;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Ptr = (System.IntPtr)Ptr;
        }
    }

    /// <summary>
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Describes per-command-list settings used by GPU-Based Validation.  </p>
    /// </summary>
    /// <remarks>
    /// <p> Point to an object using this structure with the <em>pData</em> member of <strong>ID3D12DebugCommandList1::SetDebugParameter</strong> to configure per-command-list GPU-Based Validation settings.  </p>
    /// </remarks>
    /// <doc-id>mt762979</doc-id>
    /// <unmanaged>D3D12_DEBUG_COMMAND_LIST_GPU_BASED_VALIDATION_SETTINGS</unmanaged>
    /// <unmanaged-short>D3D12_DEBUG_COMMAND_LIST_GPU_BASED_VALIDATION_SETTINGS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct DebugCommandListGpuBasedValidationSettings
    {
        /// <summary>
        /// <dd> <p>Specifies a <strong><see cref = "SharpDX.Direct3D12.GpuBasedValidationShaderPatchMode"/></strong> that overrides the default device-level shader patch mode (see <strong>ID3D12DebugDevice1::SetDebugParameter</strong>).  By default this value is initialized to the <em>DefaultShaderPatchMode</em> assigned to the device (see <strong><see cref = "SharpDX.Direct3D12.DebugDeviceGpuBasedValidationSettings"/></strong>.</p> </dd>
        /// </summary>
        /// <doc-id>mt762979</doc-id>
        /// <unmanaged>ShaderPatchMode</unmanaged>
        /// <unmanaged-short>ShaderPatchMode</unmanaged-short>
        public SharpDX.Direct3D12.GpuBasedValidationShaderPatchMode ShaderPatchMode;
    }

    /// <summary>
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Describes settings used by GPU-Based Validation.  </p>
    /// </summary>
    /// <remarks>
    /// <p>Point to an object using this structure with the <em>pData</em> member of <strong>ID3D12DebugDevice1::SetDebugParameter</strong> to configure device-wide GPU-Based Validation settings.  </p><p>Individual command lists can override the default shader patch mode using <strong>ID3D12DebugCommandList1::SetDebugParameter</strong>.</p>
    /// </remarks>
    /// <doc-id>mt762981</doc-id>
    /// <unmanaged>D3D12_DEBUG_DEVICE_GPU_BASED_VALIDATION_SETTINGS</unmanaged>
    /// <unmanaged-short>D3D12_DEBUG_DEVICE_GPU_BASED_VALIDATION_SETTINGS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct DebugDeviceGpuBasedValidationSettings
    {
        /// <summary>
        /// <dd> <p>Specifies a UINT that limits the number of messages that can be stored in the GPU-Based Validation message log.  The default value is 256.  Since many identical errors can be produced in a single Draw/Dispatch call it may be useful to increase this number.  Note this can become a memory burden if a large number of command lists are used as there is a committed message log per command list.</p> </dd>
        /// </summary>
        /// <doc-id>mt762981</doc-id>
        /// <unmanaged>MaxMessagesPerCommandList</unmanaged>
        /// <unmanaged-short>MaxMessagesPerCommandList</unmanaged-short>
        public System.Int32 MaxMessagesPerCommandList;
        /// <summary>
        /// <dd> <p>Specifies the <strong><see cref = "SharpDX.Direct3D12.GpuBasedValidationShaderPatchMode"/></strong> that GPU-Based Validation uses when injecting validation code into shaders, except when overridden by per-command-list GPU-Based Validation settings (see <strong><see cref = "SharpDX.Direct3D12.DebugCommandListGpuBasedValidationSettings"/></strong>).  The default value is D3D12_GPU_BASED_VALIDATION_SHADER_PATCH_MODE_UNGUARDED_VALIDATION.</p> </dd>
        /// </summary>
        /// <doc-id>mt762981</doc-id>
        /// <unmanaged>DefaultShaderPatchMode</unmanaged>
        /// <unmanaged-short>DefaultShaderPatchMode</unmanaged-short>
        public SharpDX.Direct3D12.GpuBasedValidationShaderPatchMode DefaultShaderPatchMode;
        /// <summary>
        /// <dd> <p>Specifies one of the <strong><see cref = "SharpDX.Direct3D12.GpuBasedValidationPipelineStateCreateFlags"/></strong> that indicates how GPU-Based Validation handles patching pipeline states.  The default value is D3D12_GPU_BASED_VALIDATION_PIPELINE_STATE_CREATE_FLAG_NONE.</p> </dd>
        /// </summary>
        /// <doc-id>mt762981</doc-id>
        /// <unmanaged>PipelineStateCreateFlags</unmanaged>
        /// <unmanaged-short>PipelineStateCreateFlags</unmanaged-short>
        public SharpDX.Direct3D12.GpuBasedValidationPipelineStateCreateFlags PipelineStateCreateFlags;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_DEBUG_DEVICE_GPU_SLOWDOWN_PERFORMANCE_FACTOR</unmanaged>
    /// <unmanaged-short>D3D12_DEBUG_DEVICE_GPU_SLOWDOWN_PERFORMANCE_FACTOR</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct DebugDeviceGpuSlowdownPerformanceFactor
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>SlowdownFactor</unmanaged>
        /// <unmanaged-short>SlowdownFactor</unmanaged-short>
        public System.Single SlowdownFactor;
    }

    /// <summary>
    /// <p>Describes depth-stencil state.</p>
    /// </summary>
    /// <remarks>
    /// <p>Pass a reference to <strong><see cref = "SharpDX.Direct3D11.DepthStencilStateDescription"/></strong> to the  <strong>ID3D11Device::CreateDepthStencilState</strong> method to create the depth-stencil state object.</p><p>Depth-stencil state controls how depth-stencil testing is performed by the output-merger stage.</p><p>The following table shows the default values of depth-stencil states.</p><table> <tr><th>State</th><th>Default Value</th></tr> <tr><td>DepthEnable</td><td>TRUE</td></tr> <tr><td>DepthWriteMask</td><td>D3D11_DEPTH_WRITE_MASK_ALL</td></tr> <tr><td>DepthFunc</td><td>D3D11_COMPARISON_LESS</td></tr> <tr><td>StencilEnable</td><td><see cref = "SharpDX.Result.False"/></td></tr> <tr><td>StencilReadMask</td><td>D3D11_DEFAULT_STENCIL_READ_MASK</td></tr> <tr><td>StencilWriteMask</td><td>D3D11_DEFAULT_STENCIL_WRITE_MASK</td></tr> <tr><td> <p>FrontFace.StencilFunc</p> <p>and</p> <p>BackFace.StencilFunc</p> </td><td>D3D11_COMPARISON_ALWAYS</td></tr> <tr><td> <p>FrontFace.StencilDepthFailOp</p> <p>and</p> <p>BackFace.StencilDepthFailOp</p> </td><td>D3D11_STENCIL_OP_KEEP</td></tr> <tr><td> <p>FrontFace.StencilPassOp</p> <p>and</p> <p>BackFace.StencilPassOp</p> </td><td>D3D11_STENCIL_OP_KEEP</td></tr> <tr><td> <p>FrontFace.StencilFailOp</p> <p>and</p> <p>BackFace.StencilFailOp</p> </td><td>D3D11_STENCIL_OP_KEEP</td></tr> </table><p>?</p><p>The formats that support stenciling are DXGI_FORMAT_D24_UNORM_S8_UINT and DXGI_FORMAT_D32_FLOAT_S8X24_UINT.</p>
    /// </remarks>
    /// <doc-id>ff476110</doc-id>
    /// <unmanaged>D3D12_DEPTH_STENCIL_DESC1</unmanaged>
    /// <unmanaged-short>D3D12_DEPTH_STENCIL_DESC1</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct DepthStencilDescription1
    {
        /// <summary>
        /// <dd> <p>Enable depth testing.</p> </dd>
        /// </summary>
        /// <doc-id>ff476110</doc-id>
        /// <unmanaged>DepthEnable</unmanaged>
        /// <unmanaged-short>DepthEnable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool DepthEnable;
        /// <summary>
        /// <dd> <p>Identify a portion of the depth-stencil buffer that can be modified by depth data (see <strong><see cref = "SharpDX.Direct3D11.DepthWriteMask"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476110</doc-id>
        /// <unmanaged>DepthWriteMask</unmanaged>
        /// <unmanaged-short>DepthWriteMask</unmanaged-short>
        public SharpDX.Direct3D12.DepthWriteMask DepthWriteMask;
        /// <summary>
        /// <dd> <p>A function that compares depth data against existing depth data. The function options are listed in <strong><see cref = "SharpDX.Direct3D11.Comparison"/></strong>.</p> </dd>
        /// </summary>
        /// <doc-id>ff476110</doc-id>
        /// <unmanaged>DepthFunc</unmanaged>
        /// <unmanaged-short>DepthFunc</unmanaged-short>
        public SharpDX.Direct3D12.Comparison DepthFunc;
        /// <summary>
        /// <dd> <p>Enable stencil testing.</p> </dd>
        /// </summary>
        /// <doc-id>ff476110</doc-id>
        /// <unmanaged>StencilEnable</unmanaged>
        /// <unmanaged-short>StencilEnable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool StencilEnable;
        /// <summary>
        /// <dd> <p>Identify a portion of the depth-stencil buffer for reading stencil data.</p> </dd>
        /// </summary>
        /// <doc-id>ff476110</doc-id>
        /// <unmanaged>StencilReadMask</unmanaged>
        /// <unmanaged-short>StencilReadMask</unmanaged-short>
        public System.Byte StencilReadMask;
        /// <summary>
        /// <dd> <p>Identify a portion of the depth-stencil buffer for writing stencil data.</p> </dd>
        /// </summary>
        /// <doc-id>ff476110</doc-id>
        /// <unmanaged>StencilWriteMask</unmanaged>
        /// <unmanaged-short>StencilWriteMask</unmanaged-short>
        public System.Byte StencilWriteMask;
        /// <summary>
        /// <dd> <p>Identify how to use the results of the depth test and the stencil test for pixels whose surface normal is facing towards the camera (see <strong><see cref = "SharpDX.Direct3D11.DepthStencilOperationDescription"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476110</doc-id>
        /// <unmanaged>FrontFace</unmanaged>
        /// <unmanaged-short>FrontFace</unmanaged-short>
        public SharpDX.Direct3D12.DepthStencilOperationDescription FrontFace;
        /// <summary>
        /// <dd> <p>Identify how to use the results of the depth test and the stencil test for pixels whose surface normal is facing away from the camera (see <strong><see cref = "SharpDX.Direct3D11.DepthStencilOperationDescription"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476110</doc-id>
        /// <unmanaged>BackFace</unmanaged>
        /// <unmanaged-short>BackFace</unmanaged-short>
        public SharpDX.Direct3D12.DepthStencilOperationDescription BackFace;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ff476110</doc-id>
        /// <unmanaged>DepthBoundsTestEnable</unmanaged>
        /// <unmanaged-short>DepthBoundsTestEnable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool DepthBoundsTestEnable;
    }

    /// <summary>
    /// <p>Describes stencil operations that can be performed based on the results of stencil test.</p>
    /// </summary>
    /// <remarks>
    /// <p>All stencil operations are specified as a <strong><see cref = "SharpDX.Direct3D12.StencilOperation"/></strong>-typed value. Each stencil operation can be set differently based on the outcome of the stencil test, which is referred to as <strong>StencilFunc</strong>, in the stencil test portion of depth-stencil testing.</p><p>Members of <strong><see cref = "SharpDX.Direct3D12.DepthStencilStateDescription"/></strong> have this structure for their data type. </p>
    /// </remarks>
    /// <doc-id>dn770355</doc-id>
    /// <unmanaged>D3D12_DEPTH_STENCILOP_DESC</unmanaged>
    /// <unmanaged-short>D3D12_DEPTH_STENCILOP_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct DepthStencilOperationDescription
    {
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D12.StencilOperation"/></strong>-typed value that identifies the stencil operation to perform when stencil testing fails.</p> </dd>
        /// </summary>
        /// <doc-id>dn770355</doc-id>
        /// <unmanaged>StencilFailOp</unmanaged>
        /// <unmanaged-short>StencilFailOp</unmanaged-short>
        public SharpDX.Direct3D12.StencilOperation FailOperation;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D12.StencilOperation"/></strong>-typed value that identifies the stencil operation to perform when stencil testing passes and depth testing fails.</p> </dd>
        /// </summary>
        /// <doc-id>dn770355</doc-id>
        /// <unmanaged>StencilDepthFailOp</unmanaged>
        /// <unmanaged-short>StencilDepthFailOp</unmanaged-short>
        public SharpDX.Direct3D12.StencilOperation DepthFailOperation;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D12.StencilOperation"/></strong>-typed value that identifies the stencil operation to perform when stencil testing and depth testing both pass.</p> </dd>
        /// </summary>
        /// <doc-id>dn770355</doc-id>
        /// <unmanaged>StencilPassOp</unmanaged>
        /// <unmanaged-short>StencilPassOp</unmanaged-short>
        public SharpDX.Direct3D12.StencilOperation PassOperation;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D12.Comparison"/></strong>-typed value that identifies the function that compares stencil data against existing stencil data. </p> </dd>
        /// </summary>
        /// <doc-id>dn770355</doc-id>
        /// <unmanaged>StencilFunc</unmanaged>
        /// <unmanaged-short>StencilFunc</unmanaged-short>
        public SharpDX.Direct3D12.Comparison Comparison;
    }

    /// <summary>
    /// <p>Describes depth-stencil state.</p>
    /// </summary>
    /// <remarks>
    /// <p> A <strong><see cref = "SharpDX.Direct3D12.GraphicsPipelineStateDescription"/></strong> object contains a depth-stencil-state structure that controls how depth-stencil testing is performed by the output-merger stage. </p><p>This table shows the default values of depth-stencil states.</p><table> <tr><th>State</th><th>Default Value</th></tr> <tr><td>DepthEnable</td><td>TRUE</td></tr> <tr><td>DepthWriteMask</td><td>D3D12_DEPTH_WRITE_MASK_ALL</td></tr> <tr><td>DepthFunc</td><td>D3D12_COMPARISON_LESS</td></tr> <tr><td>StencilEnable</td><td><see cref = "SharpDX.Result.False"/></td></tr> <tr><td>StencilReadMask</td><td>D3D12_DEFAULT_STENCIL_READ_MASK</td></tr> <tr><td>StencilWriteMask</td><td>D3D12_DEFAULT_STENCIL_WRITE_MASK</td></tr> <tr><td> <p>FrontFace.StencilFunc</p> <p>and</p> <p>BackFace.StencilFunc</p> </td><td>D3D12_COMPARISON_ALWAYS</td></tr> <tr><td> <p>FrontFace.StencilDepthFailOp</p> <p>and</p> <p>BackFace.StencilDepthFailOp</p> </td><td>D3D12_STENCIL_OP_KEEP</td></tr> <tr><td> <p>FrontFace.StencilPassOp</p> <p>and</p> <p>BackFace.StencilPassOp</p> </td><td>D3D12_STENCIL_OP_KEEP</td></tr> <tr><td> <p>FrontFace.StencilFailOp</p> <p>and</p> <p>BackFace.StencilFailOp</p> </td><td>D3D12_STENCIL_OP_KEEP</td></tr> </table><p>?</p><p>The formats that support stenciling are DXGI_FORMAT_D24_UNORM_S8_UINT and DXGI_FORMAT_D32_FLOAT_S8X24_UINT.</p>
    /// </remarks>
    /// <doc-id>dn770356</doc-id>
    /// <unmanaged>D3D12_DEPTH_STENCIL_DESC</unmanaged>
    /// <unmanaged-short>D3D12_DEPTH_STENCIL_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct DepthStencilStateDescription
    {
        /// <summary>
        /// <dd> <p> Specifies whether to enable depth testing. Set this member to <strong>TRUE</strong> to enable depth testing. </p> </dd>
        /// </summary>
        /// <doc-id>dn770356</doc-id>
        /// <unmanaged>DepthEnable</unmanaged>
        /// <unmanaged-short>DepthEnable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsDepthEnabled;
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.DepthWriteMask"/></strong>-typed value that identifies a portion of the depth-stencil buffer that can be modified by depth data. </p> </dd>
        /// </summary>
        /// <doc-id>dn770356</doc-id>
        /// <unmanaged>DepthWriteMask</unmanaged>
        /// <unmanaged-short>DepthWriteMask</unmanaged-short>
        public SharpDX.Direct3D12.DepthWriteMask DepthWriteMask;
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.Comparison"/></strong>-typed value that identifies a function that compares depth data against existing depth data. </p> </dd>
        /// </summary>
        /// <doc-id>dn770356</doc-id>
        /// <unmanaged>DepthFunc</unmanaged>
        /// <unmanaged-short>DepthFunc</unmanaged-short>
        public SharpDX.Direct3D12.Comparison DepthComparison;
        /// <summary>
        /// <dd> <p> Specifies whether to enable stencil testing. Set this member to <strong>TRUE</strong> to enable stencil testing. </p> </dd>
        /// </summary>
        /// <doc-id>dn770356</doc-id>
        /// <unmanaged>StencilEnable</unmanaged>
        /// <unmanaged-short>StencilEnable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsStencilEnabled;
        /// <summary>
        /// <dd> <p>Identify a portion of the depth-stencil buffer for reading stencil data.</p> </dd>
        /// </summary>
        /// <doc-id>dn770356</doc-id>
        /// <unmanaged>StencilReadMask</unmanaged>
        /// <unmanaged-short>StencilReadMask</unmanaged-short>
        public System.Byte StencilReadMask;
        /// <summary>
        /// <dd> <p>Identify a portion of the depth-stencil buffer for writing stencil data.</p> </dd>
        /// </summary>
        /// <doc-id>dn770356</doc-id>
        /// <unmanaged>StencilWriteMask</unmanaged>
        /// <unmanaged-short>StencilWriteMask</unmanaged-short>
        public System.Byte StencilWriteMask;
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.DepthStencilOperationDescription"/></strong> structure that describes how to use the results of the depth test and the stencil test for pixels whose surface normal is facing towards the camera. </p> </dd>
        /// </summary>
        /// <doc-id>dn770356</doc-id>
        /// <unmanaged>FrontFace</unmanaged>
        /// <unmanaged-short>FrontFace</unmanaged-short>
        public SharpDX.Direct3D12.DepthStencilOperationDescription FrontFace;
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.DepthStencilOperationDescription"/></strong> structure that describes how to use the results of the depth test and the stencil test for pixels whose surface normal is facing away from the camera. </p> </dd>
        /// </summary>
        /// <doc-id>dn770356</doc-id>
        /// <unmanaged>BackFace</unmanaged>
        /// <unmanaged-short>BackFace</unmanaged-short>
        public SharpDX.Direct3D12.DepthStencilOperationDescription BackFace;
    }

    /// <summary>
    /// <p>Specifies a depth and stencil value.</p>
    /// </summary>
    /// <remarks>
    /// <p>This structure is used in the <strong><see cref = "SharpDX.Direct3D12.ClearValue"/></strong> structure.</p>
    /// </remarks>
    /// <doc-id>dn903799</doc-id>
    /// <unmanaged>D3D12_DEPTH_STENCIL_VALUE</unmanaged>
    /// <unmanaged-short>D3D12_DEPTH_STENCIL_VALUE</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct DepthStencilValue
    {
        /// <summary>
        /// <dd> <p>Specifies the depth value.</p> </dd>
        /// </summary>
        /// <doc-id>dn903799</doc-id>
        /// <unmanaged>Depth</unmanaged>
        /// <unmanaged-short>Depth</unmanaged-short>
        public System.Single Depth;
        /// <summary>
        /// <dd> <p>Specifies the stencil value.</p> </dd>
        /// </summary>
        /// <doc-id>dn903799</doc-id>
        /// <unmanaged>Stencil</unmanaged>
        /// <unmanaged-short>Stencil</unmanaged-short>
        public System.Byte Stencil;
    }

    /// <summary>
    /// <p>Describes the subresources of a texture that are accessible from a depth-stencil view.</p>
    /// </summary>
    /// <remarks>
    /// <p> These are valid formats for a depth-stencil view: </p><ul> <li>DXGI_FORMAT_D16_UNORM</li> <li>DXGI_FORMAT_D24_UNORM_S8_UINT</li> <li>DXGI_FORMAT_D32_FLOAT</li> <li>DXGI_FORMAT_D32_FLOAT_S8X24_UINT</li> <li>DXGI_FORMAT_UNKNOWN</li> </ul><p> A depth-stencil view can't use a typeless format.  If the format chosen is DXGI_FORMAT_UNKNOWN, the format of the parent resource is used. </p><p> Pass a depth-stencil-view description into <strong>ID3D12Device::CreateDepthStencilView</strong> to create a depth-stencil view. </p>
    /// </remarks>
    /// <doc-id>dn770357</doc-id>
    /// <unmanaged>D3D12_DEPTH_STENCIL_VIEW_DESC</unmanaged>
    /// <unmanaged-short>D3D12_DEPTH_STENCIL_VIEW_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Explicit, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct DepthStencilViewDescription
    {
        /// <summary>
        /// <p>Describes the subresource from a 1D texture that is accessible to a depth-stencil view.</p>
        /// </summary>
        /// <remarks>
        /// <p>Use this structure with a <strong><see cref = "SharpDX.Direct3D12.DepthStencilViewDescription"/></strong> structure to view the resource as a 1D texture.</p>
        /// </remarks>
        /// <doc-id>dn770418</doc-id>
        /// <unmanaged>D3D12_TEX1D_DSV</unmanaged>
        /// <unmanaged-short>D3D12_TEX1D_DSV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture1DResource
        {
            /// <summary>
            /// <dd> <p>The index of the first mipmap level to use.</p> </dd>
            /// </summary>
            /// <doc-id>dn770418</doc-id>
            /// <unmanaged>MipSlice</unmanaged>
            /// <unmanaged-short>MipSlice</unmanaged-short>
            public System.Int32 MipSlice;
        }

        /// <summary>
        /// <p>Describes the subresources from an array of 1D textures to use in a depth-stencil view.</p>
        /// </summary>
        /// <remarks>
        /// <p>Use this structure with a <strong><see cref = "SharpDX.Direct3D12.DepthStencilViewDescription"/></strong> structure to view the resource as an array of 1D textures.</p>
        /// </remarks>
        /// <doc-id>dn770414</doc-id>
        /// <unmanaged>D3D12_TEX1D_ARRAY_DSV</unmanaged>
        /// <unmanaged-short>D3D12_TEX1D_ARRAY_DSV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture1DArrayResource
        {
            /// <summary>
            /// <dd> <p>The index of the first mipmap level to use.</p> </dd>
            /// </summary>
            /// <doc-id>dn770414</doc-id>
            /// <unmanaged>MipSlice</unmanaged>
            /// <unmanaged-short>MipSlice</unmanaged-short>
            public System.Int32 MipSlice;
            /// <summary>
            /// <dd> <p>The index of the first texture to use in an array of textures.</p> </dd>
            /// </summary>
            /// <doc-id>dn770414</doc-id>
            /// <unmanaged>FirstArraySlice</unmanaged>
            /// <unmanaged-short>FirstArraySlice</unmanaged-short>
            public System.Int32 FirstArraySlice;
            /// <summary>
            /// <dd> <p>Number of textures to use.</p> </dd>
            /// </summary>
            /// <doc-id>dn770414</doc-id>
            /// <unmanaged>ArraySize</unmanaged>
            /// <unmanaged-short>ArraySize</unmanaged-short>
            public System.Int32 ArraySize;
        }

        /// <summary>
        /// <p>Describes the subresource from a 2D texture that is accessible to a depth-stencil view.</p>
        /// </summary>
        /// <remarks>
        /// <p>Use this structure with a <strong><see cref = "SharpDX.Direct3D12.DepthStencilViewDescription"/></strong> structure to view the resource as a 2D texture.</p>
        /// </remarks>
        /// <doc-id>dn770432</doc-id>
        /// <unmanaged>D3D12_TEX2D_DSV</unmanaged>
        /// <unmanaged-short>D3D12_TEX2D_DSV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture2DResource
        {
            /// <summary>
            /// <dd> <p>The index of the first mipmap level to use.</p> </dd>
            /// </summary>
            /// <doc-id>dn770432</doc-id>
            /// <unmanaged>MipSlice</unmanaged>
            /// <unmanaged-short>MipSlice</unmanaged-short>
            public System.Int32 MipSlice;
        }

        /// <summary>
        /// <p>Describes the subresources from an array of 2D textures that are accessible to a depth-stencil view.</p>
        /// </summary>
        /// <remarks>
        /// <p>Use this structure with a <strong><see cref = "SharpDX.Direct3D12.DepthStencilViewDescription"/></strong> structure to view the resource as an array of 2D textures.</p>
        /// </remarks>
        /// <doc-id>dn770428</doc-id>
        /// <unmanaged>D3D12_TEX2D_ARRAY_DSV</unmanaged>
        /// <unmanaged-short>D3D12_TEX2D_ARRAY_DSV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture2DArrayResource
        {
            /// <summary>
            /// <dd> <p>The index of the first mipmap level to use.</p> </dd>
            /// </summary>
            /// <doc-id>dn770428</doc-id>
            /// <unmanaged>MipSlice</unmanaged>
            /// <unmanaged-short>MipSlice</unmanaged-short>
            public System.Int32 MipSlice;
            /// <summary>
            /// <dd> <p>The index of the first texture to use in an array of textures.</p> </dd>
            /// </summary>
            /// <doc-id>dn770428</doc-id>
            /// <unmanaged>FirstArraySlice</unmanaged>
            /// <unmanaged-short>FirstArraySlice</unmanaged-short>
            public System.Int32 FirstArraySlice;
            /// <summary>
            /// <dd> <p>Number of textures to use.</p> </dd>
            /// </summary>
            /// <doc-id>dn770428</doc-id>
            /// <unmanaged>ArraySize</unmanaged>
            /// <unmanaged-short>ArraySize</unmanaged-short>
            public System.Int32 ArraySize;
        }

        /// <summary>
        /// <p>Describes the subresource from a multi sampled 2D texture that is accessible to a depth-stencil view.</p>
        /// </summary>
        /// <remarks>
        /// <p>This structure is a member of the <strong><see cref = "SharpDX.Direct3D12.DepthStencilViewDescription"/></strong> structure.</p><p>Because a multi sampled 2D texture contains a single subresource, there is nothing to specify in <strong><see cref = "SharpDX.Direct3D12.Texture2DMultisampledResource"/></strong>. Consequently, <strong>UnusedField_NothingToDefine</strong> is included so that this structure will compile in C. </p>
        /// </remarks>
        /// <doc-id>dn770425</doc-id>
        /// <unmanaged>D3D12_TEX2DMS_DSV</unmanaged>
        /// <unmanaged-short>D3D12_TEX2DMS_DSV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture2DMultisampledResource
        {
            /// <summary>
            /// <dd> <p>Unused.</p> </dd>
            /// </summary>
            /// <doc-id>dn770425</doc-id>
            /// <unmanaged>UnusedField_NothingToDefine</unmanaged>
            /// <unmanaged-short>UnusedField_NothingToDefine</unmanaged-short>
            public System.Int32 UnusedFieldNothingToDefine;
        }

        /// <summary>
        /// <p>Describes the subresources from an array of multi sampled 2D textures for a depth-stencil view.</p>
        /// </summary>
        /// <remarks>
        /// <p>Use this structure with a <strong><see cref = "SharpDX.Direct3D12.DepthStencilViewDescription"/></strong> structure to view the resource as an array of multi sampled 2D textures.</p>
        /// </remarks>
        /// <doc-id>dn770422</doc-id>
        /// <unmanaged>D3D12_TEX2DMS_ARRAY_DSV</unmanaged>
        /// <unmanaged-short>D3D12_TEX2DMS_ARRAY_DSV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture2DMultisampledArrayResource
        {
            /// <summary>
            /// <dd> <p>The index of the first texture to use in an array of textures.</p> </dd>
            /// </summary>
            /// <doc-id>dn770422</doc-id>
            /// <unmanaged>FirstArraySlice</unmanaged>
            /// <unmanaged-short>FirstArraySlice</unmanaged-short>
            public System.Int32 FirstArraySlice;
            /// <summary>
            /// <dd> <p>Number of textures to use.</p> </dd>
            /// </summary>
            /// <doc-id>dn770422</doc-id>
            /// <unmanaged>ArraySize</unmanaged>
            /// <unmanaged-short>ArraySize</unmanaged-short>
            public System.Int32 ArraySize;
        }

        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.DXGI.Format"/></strong>-typed value that specifies the viewing format.  For allowable formats, see Remarks. </p> </dd>
        /// </summary>
        /// <doc-id>dn770357</doc-id>
        /// <unmanaged>Format</unmanaged>
        /// <unmanaged-short>Format</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(0)]
        public SharpDX.DXGI.Format Format;
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.DepthStencilViewDimension"/></strong>-typed value that specifies how the depth-stencil resource will be accessed. This member also determines which _DSV to use in the following union. </p> </dd>
        /// </summary>
        /// <doc-id>dn770357</doc-id>
        /// <unmanaged>ViewDimension</unmanaged>
        /// <unmanaged-short>ViewDimension</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(4)]
        public SharpDX.Direct3D12.DepthStencilViewDimension Dimension;
        /// <summary>
        /// <dd> <p> A combination of <strong><see cref = "SharpDX.Direct3D12.DepthStencilViewFlags"/></strong> enumeration constants that are combined by using a bitwise OR operation.  The resulting value specifies whether the texture is read only.   Pass 0 to specify that it isn't read only; otherwise, pass one or more of the members of the <strong><see cref = "SharpDX.Direct3D12.DepthStencilViewFlags"/></strong> enumerated type. </p> </dd>
        /// </summary>
        /// <doc-id>dn770357</doc-id>
        /// <unmanaged>Flags</unmanaged>
        /// <unmanaged-short>Flags</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D12.DepthStencilViewFlags Flags;
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.Texture1DResource"/></strong> structure that specifies a 1D texture subresource. </p> </dd>
        /// </summary>
        /// <doc-id>dn770357</doc-id>
        /// <unmanaged>Texture1D</unmanaged>
        /// <unmanaged-short>Texture1D</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(12)]
        public SharpDX.Direct3D12.DepthStencilViewDescription.Texture1DResource Texture1D;
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.Texture1DArrayResource"/></strong> structure that specifies an array of 1D texture subresources. </p> </dd>
        /// </summary>
        /// <doc-id>dn770357</doc-id>
        /// <unmanaged>Texture1DArray</unmanaged>
        /// <unmanaged-short>Texture1DArray</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(12)]
        public SharpDX.Direct3D12.DepthStencilViewDescription.Texture1DArrayResource Texture1DArray;
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.Texture2DResource"/></strong> structure that specifies a 2D texture subresource. </p> </dd>
        /// </summary>
        /// <doc-id>dn770357</doc-id>
        /// <unmanaged>Texture2D</unmanaged>
        /// <unmanaged-short>Texture2D</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(12)]
        public SharpDX.Direct3D12.DepthStencilViewDescription.Texture2DResource Texture2D;
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.Texture2DArrayResource"/></strong> structure that specifies an array of 2D texture subresources. </p> </dd>
        /// </summary>
        /// <doc-id>dn770357</doc-id>
        /// <unmanaged>Texture2DArray</unmanaged>
        /// <unmanaged-short>Texture2DArray</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(12)]
        public SharpDX.Direct3D12.DepthStencilViewDescription.Texture2DArrayResource Texture2DArray;
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.Texture2DMultisampledResource"/></strong> structure that specifies a multisampled 2D texture. </p> </dd>
        /// </summary>
        /// <doc-id>dn770357</doc-id>
        /// <unmanaged>Texture2DMS</unmanaged>
        /// <unmanaged-short>Texture2DMS</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(12)]
        public SharpDX.Direct3D12.DepthStencilViewDescription.Texture2DMultisampledResource Texture2DMS;
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.Texture2DMultisampledArrayResource"/></strong> structure that specifies an array of multisampled 2D textures. </p> </dd>
        /// </summary>
        /// <doc-id>dn770357</doc-id>
        /// <unmanaged>Texture2DMSArray</unmanaged>
        /// <unmanaged-short>Texture2DMSArray</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(12)]
        public SharpDX.Direct3D12.DepthStencilViewDescription.Texture2DMultisampledArrayResource Texture2DMSArray;
    }

    /// <summary>
    /// <p>Describes the descriptor heap.</p>
    /// </summary>
    /// <remarks>
    /// <p> This structure is used by the following: </p><ul> <li> <strong>ID3D12DescriptorHeap::GetDesc</strong> </li> <li> <strong>ID3D12Device::CreateDescriptorHeap</strong> </li> </ul>
    /// </remarks>
    /// <doc-id>dn770359</doc-id>
    /// <unmanaged>D3D12_DESCRIPTOR_HEAP_DESC</unmanaged>
    /// <unmanaged-short>D3D12_DESCRIPTOR_HEAP_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct DescriptorHeapDescription
    {
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.DescriptorHeapType"/></strong>-typed value that specifies the types of descriptors in the heap. </p> </dd>
        /// </summary>
        /// <doc-id>dn770359</doc-id>
        /// <unmanaged>Type</unmanaged>
        /// <unmanaged-short>Type</unmanaged-short>
        public SharpDX.Direct3D12.DescriptorHeapType Type;
        /// <summary>
        /// <dd> <p> The number of descriptors in the heap. </p> </dd>
        /// </summary>
        /// <doc-id>dn770359</doc-id>
        /// <unmanaged>NumDescriptors</unmanaged>
        /// <unmanaged-short>NumDescriptors</unmanaged-short>
        public System.Int32 DescriptorCount;
        /// <summary>
        /// <dd> <p> A combination of <strong><see cref = "SharpDX.Direct3D12.DescriptorHeapFlags"/></strong>-typed values that are combined by using a bitwise OR operation. The resulting value specifies options for the heap. </p> </dd>
        /// </summary>
        /// <doc-id>dn770359</doc-id>
        /// <unmanaged>Flags</unmanaged>
        /// <unmanaged-short>Flags</unmanaged-short>
        public SharpDX.Direct3D12.DescriptorHeapFlags Flags;
        /// <summary>
        /// <dd> <p> For single-adapter operation, set this to zero. If there are multiple adapter nodes, set a bit to identify the node (one of the device's physical adapters) to which the descriptor heap applies. Each bit in the mask corresponds to a single node. Only one bit must be set. See Multi-Adapter. </p> </dd>
        /// </summary>
        /// <doc-id>dn770359</doc-id>
        /// <unmanaged>NodeMask</unmanaged>
        /// <unmanaged-short>NodeMask</unmanaged-short>
        public System.Int32 NodeMask;
    }

    /// <summary>
    /// <p>Describes a descriptor range.</p>
    /// </summary>
    /// <remarks>
    /// <p> This structure is a member of the <strong><see cref = "SharpDX.Direct3D12.RootDescriptorTable"/></strong> structure. </p>
    /// </remarks>
    /// <doc-id>dn859380</doc-id>
    /// <unmanaged>D3D12_DESCRIPTOR_RANGE</unmanaged>
    /// <unmanaged-short>D3D12_DESCRIPTOR_RANGE</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct DescriptorRange
    {
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.DescriptorRangeType"/></strong>-typed value that specifies the type of descriptor range. </p> </dd>
        /// </summary>
        /// <doc-id>dn859380</doc-id>
        /// <unmanaged>RangeType</unmanaged>
        /// <unmanaged-short>RangeType</unmanaged-short>
        public SharpDX.Direct3D12.DescriptorRangeType RangeType;
        /// <summary>
        /// <dd> <p> The number of descriptors in the range. Use -1 or UINT_MAX to specify unbounded size. Only the last entry in a table can have unbounded size. </p> </dd>
        /// </summary>
        /// <doc-id>dn859380</doc-id>
        /// <unmanaged>NumDescriptors</unmanaged>
        /// <unmanaged-short>NumDescriptors</unmanaged-short>
        public System.Int32 DescriptorCount;
        /// <summary>
        /// <dd> <p> The base shader register in the range. For example, for shader-resource views (SRVs), 3 maps to ": register(t3);" in HLSL. </p> </dd>
        /// </summary>
        /// <doc-id>dn859380</doc-id>
        /// <unmanaged>BaseShaderRegister</unmanaged>
        /// <unmanaged-short>BaseShaderRegister</unmanaged-short>
        public System.Int32 BaseShaderRegister;
        /// <summary>
        /// <dd> <p> The register space. Can typically be 0, but allows multiple descriptor  arrays of unknown size to not appear to overlap. For example, for SRVs, by extending the example in the <strong>BaseShaderRegister</strong> member description, 5 maps to ": register(t3,space5);" in HLSL. </p> </dd>
        /// </summary>
        /// <doc-id>dn859380</doc-id>
        /// <unmanaged>RegisterSpace</unmanaged>
        /// <unmanaged-short>RegisterSpace</unmanaged-short>
        public System.Int32 RegisterSpace;
        /// <summary>
        /// <dd> <p> The offset in descriptors from the start of the root signature. This value can be <strong>D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND</strong>, which indicates this range should immediately follow the preceding range.</p> </dd>
        /// </summary>
        /// <doc-id>dn859380</doc-id>
        /// <unmanaged>OffsetInDescriptorsFromTableStart</unmanaged>
        /// <unmanaged-short>OffsetInDescriptorsFromTableStart</unmanaged-short>
        public System.Int32 OffsetInDescriptorsFromTableStart;
    }

    /// <summary>
    /// <p>Describes a descriptor range, with flags to determine their volatility.</p>
    /// </summary>
    /// <remarks>
    /// <p> This structure is a member of the <strong><see cref = "SharpDX.Direct3D12.RootDescriptorTable1"/></strong> structure. </p><p>Refer to the helper structure <strong>CD3DX12_DESCRIPTOR_RANGE1</strong>.</p>
    /// </remarks>
    /// <doc-id>mt709112</doc-id>
    /// <unmanaged>D3D12_DESCRIPTOR_RANGE1</unmanaged>
    /// <unmanaged-short>D3D12_DESCRIPTOR_RANGE1</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct DescriptorRange1
    {
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.DescriptorRangeType"/></strong>-typed value that specifies the type of descriptor range. </p> </dd>
        /// </summary>
        /// <doc-id>mt709112</doc-id>
        /// <unmanaged>RangeType</unmanaged>
        /// <unmanaged-short>RangeType</unmanaged-short>
        public SharpDX.Direct3D12.DescriptorRangeType RangeType;
        /// <summary>
        /// <dd> <p> The number of descriptors in the range. Use -1 or UINT_MAX to specify unbounded size. Only the last entry in a table can have unbounded size. </p> </dd>
        /// </summary>
        /// <doc-id>mt709112</doc-id>
        /// <unmanaged>NumDescriptors</unmanaged>
        /// <unmanaged-short>NumDescriptors</unmanaged-short>
        public System.Int32 DescriptorCount;
        /// <summary>
        /// <dd> <p> The base shader register in the range. For example, for shader-resource views (SRVs), 3 maps to ": register(t3);" in HLSL. </p> </dd>
        /// </summary>
        /// <doc-id>mt709112</doc-id>
        /// <unmanaged>BaseShaderRegister</unmanaged>
        /// <unmanaged-short>BaseShaderRegister</unmanaged-short>
        public System.Int32 BaseShaderRegister;
        /// <summary>
        /// <dd> <p> The register space. Can typically be 0, but allows multiple descriptor  arrays of unknown size to not appear to overlap. For example, for SRVs, by extending the example in the <strong>BaseShaderRegister</strong> member description, 5 maps to ": register(t3,space5);" in HLSL. </p> </dd>
        /// </summary>
        /// <doc-id>mt709112</doc-id>
        /// <unmanaged>RegisterSpace</unmanaged>
        /// <unmanaged-short>RegisterSpace</unmanaged-short>
        public System.Int32 RegisterSpace;
        /// <summary>
        /// <dd> <p>Specifies the <strong><see cref = "SharpDX.Direct3D12.DescriptorRangeFlags"/></strong> that determine descriptor and data volatility.</p> </dd>
        /// </summary>
        /// <doc-id>mt709112</doc-id>
        /// <unmanaged>Flags</unmanaged>
        /// <unmanaged-short>Flags</unmanaged-short>
        public SharpDX.Direct3D12.DescriptorRangeFlags Flags;
        /// <summary>
        /// <dd> <p> The offset in descriptors from the start of the root signature. This value can be <strong>D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND</strong>, which indicates this range should immediately follow the preceding range.</p> </dd>
        /// </summary>
        /// <doc-id>mt709112</doc-id>
        /// <unmanaged>OffsetInDescriptorsFromTableStart</unmanaged>
        /// <unmanaged-short>OffsetInDescriptorsFromTableStart</unmanaged-short>
        public System.Int32 OffsetInDescriptorsFromTableStart;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_DEVICE_REMOVED_EXTENDED_DATA</unmanaged>
    /// <unmanaged-short>D3D12_DEVICE_REMOVED_EXTENDED_DATA</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct DeviceRemovedExtendedData
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Flags</unmanaged>
        /// <unmanaged-short>Flags</unmanaged-short>
        public SharpDX.Direct3D12.DredFlags Flags;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>pHeadAutoBreadcrumbNode</unmanaged>
        /// <unmanaged-short>pHeadAutoBreadcrumbNode</unmanaged-short>
        public System.IntPtr HeadAutoBreadcrumbNodePointer;
    }

    /// <summary>
    /// <p> Describes details for the discard-resource operation. </p>
    /// </summary>
    /// <remarks>
    /// <p> This structure is used by the <strong>ID3D12GraphicsCommandList::DiscardResource</strong> method. </p><p> If rectangles are supplied in this structure, the resource must have 2D subresources with all specified subresources the same dimension. </p>
    /// </remarks>
    /// <doc-id>dn986726</doc-id>
    /// <unmanaged>D3D12_DISCARD_REGION</unmanaged>
    /// <unmanaged-short>D3D12_DISCARD_REGION</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct DiscardRegion
    {
        /// <summary>
        /// <dd> <p> The number of rectangles in the array that the <strong>pRects</strong> member specifies. </p> </dd>
        /// </summary>
        /// <doc-id>dn986726</doc-id>
        /// <unmanaged>NumRects</unmanaged>
        /// <unmanaged-short>NumRects</unmanaged-short>
        public System.Int32 RectCount;
        /// <summary>
        /// <dd> <p> An array of <strong>D3D12_RECT</strong> structures for the rectangles in the resource to discard. If <strong><c>null</c></strong>, <strong>DiscardResource</strong> discards the entire resource. </p> </dd>
        /// </summary>
        /// <doc-id>dn986726</doc-id>
        /// <unmanaged>pRects</unmanaged>
        /// <unmanaged-short>pRects</unmanaged-short>
        public System.IntPtr RectsPointer;
        /// <summary>
        /// <dd> <p> Index of the first subresource in the resource to discard. </p> </dd>
        /// </summary>
        /// <doc-id>dn986726</doc-id>
        /// <unmanaged>FirstSubresource</unmanaged>
        /// <unmanaged-short>FirstSubresource</unmanaged-short>
        public System.Int32 FirstSubresource;
        /// <summary>
        /// <dd> <p> The number of subresources in the resource to discard. </p> </dd>
        /// </summary>
        /// <doc-id>dn986726</doc-id>
        /// <unmanaged>NumSubresources</unmanaged>
        /// <unmanaged-short>NumSubresources</unmanaged-short>
        public System.Int32 SubresourceCount;
    }

    /// <summary>
    /// <p>Describes dispatch parameters, for use by the compute shader.</p>
    /// </summary>
    /// <remarks>
    /// <p>The members of this structure serve the same purpose as the parameters of <strong>Dispatch</strong>.</p><p> A compiled compute shader defines the set of instructions to execute per thread and the number of threads to run per group. The thread-group parameters  indicate how many thread groups to execute. Each thread group contains the same number of threads, as defined by the compiled compute shader. The thread groups are organized in a three-dimensional grid. The total number of thread groups that the compiled compute shader executes is determined by the following calculation:</p><code>ThreadGroupCountX * ThreadGroupCountY * ThreadGroupCountZ</code><p>In particular, if any of the values in the thread-group parameters are 0, nothing will happen. 
    /// </p><p>The maximum size of any dimension is 65535.</p>
    /// </remarks>
    /// <doc-id>dn903800</doc-id>
    /// <unmanaged>D3D12_DISPATCH_ARGUMENTS</unmanaged>
    /// <unmanaged-short>D3D12_DISPATCH_ARGUMENTS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct DispatchArgumentS
    {
        /// <summary>
        /// <dd> <p>The size, in thread groups, of the x-dimension of the thread-group grid. </p> </dd>
        /// </summary>
        /// <doc-id>dn903800</doc-id>
        /// <unmanaged>ThreadGroupCountX</unmanaged>
        /// <unmanaged-short>ThreadGroupCountX</unmanaged-short>
        public System.Int32 ThreadGroupCountX;
        /// <summary>
        /// <dd> <p>The size, in thread groups, of the y-dimension of the thread-group grid.</p> </dd>
        /// </summary>
        /// <doc-id>dn903800</doc-id>
        /// <unmanaged>ThreadGroupCountY</unmanaged>
        /// <unmanaged-short>ThreadGroupCountY</unmanaged-short>
        public System.Int32 ThreadGroupCountY;
        /// <summary>
        /// <dd> <p>The size, in thread groups, of the z-dimension of the thread-group grid.  </p> </dd>
        /// </summary>
        /// <doc-id>dn903800</doc-id>
        /// <unmanaged>ThreadGroupCountZ</unmanaged>
        /// <unmanaged-short>ThreadGroupCountZ</unmanaged-short>
        public System.Int32 ThreadGroupCountZ;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_DISPATCH_RAYS_DESC</unmanaged>
    /// <unmanaged-short>D3D12_DISPATCH_RAYS_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct DispatchRaysDescription
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>RayGenerationShaderRecord</unmanaged>
        /// <unmanaged-short>RayGenerationShaderRecord</unmanaged-short>
        public SharpDX.Direct3D12.GpuVirtualAddressRange RayGenerationShaderRecord;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MissShaderTable</unmanaged>
        /// <unmanaged-short>MissShaderTable</unmanaged-short>
        public SharpDX.Direct3D12.GpuVirtualAddressRangeAndStride MissShaderTable;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>HitGroupTable</unmanaged>
        /// <unmanaged-short>HitGroupTable</unmanaged-short>
        public SharpDX.Direct3D12.GpuVirtualAddressRangeAndStride HitGroupTable;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>CallableShaderTable</unmanaged>
        /// <unmanaged-short>CallableShaderTable</unmanaged-short>
        public SharpDX.Direct3D12.GpuVirtualAddressRangeAndStride CallableShaderTable;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Width</unmanaged>
        /// <unmanaged-short>Width</unmanaged-short>
        public System.Int32 Width;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Height</unmanaged>
        /// <unmanaged-short>Height</unmanaged-short>
        public System.Int32 Height;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Depth</unmanaged>
        /// <unmanaged-short>Depth</unmanaged-short>
        public System.Int32 Depth;
    }

    /// <summary>
    /// <p>Describes parameters for drawing instances.</p>
    /// </summary>
    /// <remarks>
    /// <p>The members of this structure serve the same purpose as the parameters of  <strong>DrawInstanced</strong>.</p>
    /// </remarks>
    /// <doc-id>dn903801</doc-id>
    /// <unmanaged>D3D12_DRAW_ARGUMENTS</unmanaged>
    /// <unmanaged-short>D3D12_DRAW_ARGUMENTS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct DrawArgumentS
    {
        /// <summary>
        /// <dd> <p>Specifies the number of vertices to draw, per instance.</p> </dd>
        /// </summary>
        /// <doc-id>dn903801</doc-id>
        /// <unmanaged>VertexCountPerInstance</unmanaged>
        /// <unmanaged-short>VertexCountPerInstance</unmanaged-short>
        public System.Int32 VertexCountPerInstance;
        /// <summary>
        /// <dd> <p>Specifies the number of instances.</p> </dd>
        /// </summary>
        /// <doc-id>dn903801</doc-id>
        /// <unmanaged>InstanceCount</unmanaged>
        /// <unmanaged-short>InstanceCount</unmanaged-short>
        public System.Int32 InstanceCount;
        /// <summary>
        /// <dd> <p>Specifies an index to the first vertex to start drawing from.</p> </dd>
        /// </summary>
        /// <doc-id>dn903801</doc-id>
        /// <unmanaged>StartVertexLocation</unmanaged>
        /// <unmanaged-short>StartVertexLocation</unmanaged-short>
        public System.Int32 StartVertexLocation;
        /// <summary>
        /// <dd> <p>Specifies an index to the first instance to start drawing from.</p> </dd>
        /// </summary>
        /// <doc-id>dn903801</doc-id>
        /// <unmanaged>StartInstanceLocation</unmanaged>
        /// <unmanaged-short>StartInstanceLocation</unmanaged-short>
        public System.Int32 StartInstanceLocation;
    }

    /// <summary>
    /// <p>Describes parameters for drawing indexed instances.</p>
    /// </summary>
    /// <remarks>
    /// <p>The members of this structure serve the same purpose as the parameters of <strong>DrawIndexedInstanced</strong>. </p>
    /// </remarks>
    /// <doc-id>dn903802</doc-id>
    /// <unmanaged>D3D12_DRAW_INDEXED_ARGUMENTS</unmanaged>
    /// <unmanaged-short>D3D12_DRAW_INDEXED_ARGUMENTS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct DrawIndexedArgumentS
    {
        /// <summary>
        /// <dd> <p>The number of indices read from the index buffer for each instance.</p> </dd>
        /// </summary>
        /// <doc-id>dn903802</doc-id>
        /// <unmanaged>IndexCountPerInstance</unmanaged>
        /// <unmanaged-short>IndexCountPerInstance</unmanaged-short>
        public System.Int32 IndexCountPerInstance;
        /// <summary>
        /// <dd> <p> The number of instances to draw.</p> </dd>
        /// </summary>
        /// <doc-id>dn903802</doc-id>
        /// <unmanaged>InstanceCount</unmanaged>
        /// <unmanaged-short>InstanceCount</unmanaged-short>
        public System.Int32 InstanceCount;
        /// <summary>
        /// <dd> <p>The location of the first index read by the GPU from the index buffer.</p> </dd>
        /// </summary>
        /// <doc-id>dn903802</doc-id>
        /// <unmanaged>StartIndexLocation</unmanaged>
        /// <unmanaged-short>StartIndexLocation</unmanaged-short>
        public System.Int32 StartIndexLocation;
        /// <summary>
        /// <dd> <p>A value added to each index before reading a vertex from the vertex buffer.</p> </dd>
        /// </summary>
        /// <doc-id>dn903802</doc-id>
        /// <unmanaged>BaseVertexLocation</unmanaged>
        /// <unmanaged-short>BaseVertexLocation</unmanaged-short>
        public System.Int32 BaseVertexLocation;
        /// <summary>
        /// <dd> <p> A value added to each index before reading per-instance data from a vertex buffer.</p> </dd>
        /// </summary>
        /// <doc-id>dn903802</doc-id>
        /// <unmanaged>StartInstanceLocation</unmanaged>
        /// <unmanaged-short>StartInstanceLocation</unmanaged-short>
        public System.Int32 StartInstanceLocation;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_DXIL_LIBRARY_DESC</unmanaged>
    /// <unmanaged-short>D3D12_DXIL_LIBRARY_DESC</unmanaged-short>
    public partial struct DxilLibraryDescription
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>DXILLibrary</unmanaged>
        /// <unmanaged-short>DXILLibrary</unmanaged-short>
        public SharpDX.Direct3D12.ShaderBytecode DXILLibrary;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>NumExports</unmanaged>
        /// <unmanaged-short>NumExports</unmanaged-short>
        public System.Int32 ExportCount;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>pExports</unmanaged>
        /// <unmanaged-short>pExports</unmanaged-short>
        public System.IntPtr ExportsPointer;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.Direct3D12.ShaderBytecode.__Native DXILLibrary;
            public System.Int32 ExportCount;
            public System.IntPtr ExportsPointer;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            DXILLibrary.__MarshalFree(ref @ref.DXILLibrary);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            DXILLibrary.__MarshalFrom(ref @ref.DXILLibrary);
            ExportCount = @ref.ExportCount;
            ExportsPointer = @ref.ExportsPointer;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            DXILLibrary.__MarshalTo(ref @ref.DXILLibrary);
            @ref.ExportCount = ExportCount;
            @ref.ExportsPointer = ExportsPointer;
        }
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_DXIL_SUBOBJECT_TO_EXPORTS_ASSOCIATION</unmanaged>
    /// <unmanaged-short>D3D12_DXIL_SUBOBJECT_TO_EXPORTS_ASSOCIATION</unmanaged-short>
    public partial struct DxilSubObjectToExportsAssociation
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>SubobjectToAssociate</unmanaged>
        /// <unmanaged-short>SubobjectToAssociate</unmanaged-short>
        public System.String SubobjectToAssociate;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>NumExports</unmanaged>
        /// <unmanaged-short>NumExports</unmanaged-short>
        public System.Int32 ExportCount;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>pExports</unmanaged>
        /// <unmanaged-short>pExports</unmanaged-short>
        public System.String ExportsPointer;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.IntPtr SubobjectToAssociate;
            public System.Int32 ExportCount;
            public System.IntPtr ExportsPointer;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.SubobjectToAssociate);
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.ExportsPointer);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            SubobjectToAssociate = System.Runtime.InteropServices.Marshal.PtrToStringUni(@ref.SubobjectToAssociate);
            ExportCount = @ref.ExportCount;
            ExportsPointer = System.Runtime.InteropServices.Marshal.PtrToStringUni(@ref.ExportsPointer);
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.SubobjectToAssociate = System.Runtime.InteropServices.Marshal.StringToHGlobalUni(SubobjectToAssociate);
            @ref.ExportCount = ExportCount;
            @ref.ExportsPointer = System.Runtime.InteropServices.Marshal.StringToHGlobalUni(ExportsPointer);
        }
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_EXISTING_COLLECTION_DESC</unmanaged>
    /// <unmanaged-short>D3D12_EXISTING_COLLECTION_DESC</unmanaged-short>
    public partial struct ExistingCollectionDescription
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>pExistingCollection</unmanaged>
        /// <unmanaged-short>pExistingCollection</unmanaged-short>
        public SharpDX.Direct3D12.StateObject ExistingCollectionPointer;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>NumExports</unmanaged>
        /// <unmanaged-short>NumExports</unmanaged-short>
        public System.Int32 ExportCount;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>pExports</unmanaged>
        /// <unmanaged-short>pExports</unmanaged-short>
        public System.IntPtr ExportsPointer;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.IntPtr ExistingCollectionPointer;
            public System.Int32 ExportCount;
            public System.IntPtr ExportsPointer;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            if (@ref.ExistingCollectionPointer != System.IntPtr.Zero)
                ExistingCollectionPointer = new SharpDX.Direct3D12.StateObject(@ref.ExistingCollectionPointer);
            else
                ExistingCollectionPointer = null;
            ExportCount = @ref.ExportCount;
            ExportsPointer = @ref.ExportsPointer;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.ExistingCollectionPointer = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.StateObject>(ExistingCollectionPointer);
            @ref.ExportCount = ExportCount;
            @ref.ExportsPointer = ExportsPointer;
        }
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_EXPORT_DESC</unmanaged>
    /// <unmanaged-short>D3D12_EXPORT_DESC</unmanaged-short>
    public partial struct ExportDescription
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Name</unmanaged>
        /// <unmanaged-short>Name</unmanaged-short>
        public System.String Name;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>ExportToRename</unmanaged>
        /// <unmanaged-short>ExportToRename</unmanaged-short>
        public System.String ExportToRename;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Flags</unmanaged>
        /// <unmanaged-short>Flags</unmanaged-short>
        public SharpDX.Direct3D12.ExportFlags Flags;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.IntPtr Name;
            public System.IntPtr ExportToRename;
            public SharpDX.Direct3D12.ExportFlags Flags;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.Name);
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.ExportToRename);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Name = System.Runtime.InteropServices.Marshal.PtrToStringUni(@ref.Name);
            ExportToRename = System.Runtime.InteropServices.Marshal.PtrToStringUni(@ref.ExportToRename);
            Flags = @ref.Flags;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Name = System.Runtime.InteropServices.Marshal.StringToHGlobalUni(Name);
            @ref.ExportToRename = System.Runtime.InteropServices.Marshal.StringToHGlobalUni(ExportToRename);
            @ref.Flags = Flags;
        }
    }

    /// <summary>
    /// <p>Provide detail about the adapter architecture, helping applications better optimize for certain adapter properties.</p>
    /// </summary>
    /// <doc-id>dn859384</doc-id>
    /// <unmanaged>D3D12_FEATURE_DATA_ARCHITECTURE</unmanaged>
    /// <unmanaged-short>D3D12_FEATURE_DATA_ARCHITECTURE</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct FeatureDataArchitecture
    {
        /// <summary>
        /// <dd> <p> In multi-adapter operation, this indicates which physical adapter of the device is relevant. See Multi-Adapter. <strong>NodeIndex</strong> is filled out by the application before calling <strong>CheckFeatureSupport</strong>, as the application can retrieve details about the architecture of each adapter. </p> </dd>
        /// </summary>
        /// <doc-id>dn859384</doc-id>
        /// <unmanaged>NodeIndex</unmanaged>
        /// <unmanaged-short>NodeIndex</unmanaged-short>
        public System.Int32 NodeIndex;
        /// <summary>
        /// <dd> <p> Specifies whether the hardware and driver support a tile-based renderer. The runtime sets this member to <strong>TRUE</strong> if the hardware and driver support a tile-based renderer. </p> </dd>
        /// </summary>
        /// <doc-id>dn859384</doc-id>
        /// <unmanaged>TileBasedRenderer</unmanaged>
        /// <unmanaged-short>TileBasedRenderer</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool TileBasedRenderer;
        /// <summary>
        /// <dd> <p> Specifies whether the hardware and driver support UMA. The runtime sets this member to <strong>TRUE</strong> if the hardware and driver support UMA. </p> </dd>
        /// </summary>
        /// <doc-id>dn859384</doc-id>
        /// <unmanaged>UMA</unmanaged>
        /// <unmanaged-short>UMA</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool Uma;
        /// <summary>
        /// <dd> <p> Specifies whether the hardware and driver support cache-coherent UMA. The runtime sets this member to <strong>TRUE</strong> if the hardware and driver support cache-coherent UMA. </p> </dd>
        /// </summary>
        /// <doc-id>dn859384</doc-id>
        /// <unmanaged>CacheCoherentUMA</unmanaged>
        /// <unmanaged-short>CacheCoherentUMA</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool CacheCoherentUMA;
    }

    /// <summary>
    /// <p> Describes the DXGI data format. </p>
    /// </summary>
    /// <remarks>
    /// <p> See <strong><see cref = "SharpDX.Direct3D12.Feature"/></strong>. </p>
    /// </remarks>
    /// <doc-id>dn986728</doc-id>
    /// <unmanaged>D3D12_FEATURE_DATA_ARCHITECTURE1</unmanaged>
    /// <unmanaged-short>D3D12_FEATURE_DATA_ARCHITECTURE1</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct FeatureDataArchitecture1
    {
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.DXGI.Format"/></strong>-typed value for the format to return info about. </p> </dd>
        /// </summary>
        /// <doc-id>dn986728</doc-id>
        /// <unmanaged>NodeIndex</unmanaged>
        /// <unmanaged-short>NodeIndex</unmanaged-short>
        public System.Int32 NodeIndex;
        /// <summary>
        /// <dd> <p> The number of planes to provide information about. </p> </dd>
        /// </summary>
        /// <doc-id>dn986728</doc-id>
        /// <unmanaged>TileBasedRenderer</unmanaged>
        /// <unmanaged-short>TileBasedRenderer</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool TileBasedRenderer;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn986728</doc-id>
        /// <unmanaged>UMA</unmanaged>
        /// <unmanaged-short>UMA</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool Uma;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn986728</doc-id>
        /// <unmanaged>CacheCoherentUMA</unmanaged>
        /// <unmanaged-short>CacheCoherentUMA</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool CacheCoherentUMA;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn986728</doc-id>
        /// <unmanaged>IsolatedMMU</unmanaged>
        /// <unmanaged-short>IsolatedMMU</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsolatedMMU;
    }

    /// <summary>
    /// <p> Describes the DXGI data format. </p>
    /// </summary>
    /// <remarks>
    /// <p> See <strong><see cref = "SharpDX.Direct3D12.Feature"/></strong>. </p>
    /// </remarks>
    /// <doc-id>dn986728</doc-id>
    /// <unmanaged>D3D12_FEATURE_DATA_COMMAND_QUEUE_PRIORITY</unmanaged>
    /// <unmanaged-short>D3D12_FEATURE_DATA_COMMAND_QUEUE_PRIORITY</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct FeatureDataCommandQueuePriority
    {
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.DXGI.Format"/></strong>-typed value for the format to return info about. </p> </dd>
        /// </summary>
        /// <doc-id>dn986728</doc-id>
        /// <unmanaged>CommandListType</unmanaged>
        /// <unmanaged-short>CommandListType</unmanaged-short>
        public SharpDX.Direct3D12.CommandListType CommandListType;
        /// <summary>
        /// <dd> <p> The number of planes to provide information about. </p> </dd>
        /// </summary>
        /// <doc-id>dn986728</doc-id>
        /// <unmanaged>Priority</unmanaged>
        /// <unmanaged-short>Priority</unmanaged-short>
        public System.Int32 Priority;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn986728</doc-id>
        /// <unmanaged>PriorityForTypeIsSupported</unmanaged>
        /// <unmanaged-short>PriorityForTypeIsSupported</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool PriorityForTypeIsSupported;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_FEATURE_DATA_CROSS_NODE</unmanaged>
    /// <unmanaged-short>D3D12_FEATURE_DATA_CROSS_NODE</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct FeatureDataCrossNode
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>SharingTier</unmanaged>
        /// <unmanaged-short>SharingTier</unmanaged-short>
        public SharpDX.Direct3D12.CrossNodeSharingTier SharingTier;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>AtomicShaderInstructions</unmanaged>
        /// <unmanaged-short>AtomicShaderInstructions</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool AtomicShaderInstructions;
    }

    /// <summary>
    /// <p> Describes Direct3D 12 feature options in the current graphics driver. </p>
    /// </summary>
    /// <remarks>
    /// <p> See <strong><see cref = "SharpDX.Direct3D12.Feature"/></strong>. </p>
    /// </remarks>
    /// <doc-id>dn770364</doc-id>
    /// <unmanaged>D3D12_FEATURE_DATA_D3D12_OPTIONS</unmanaged>
    /// <unmanaged-short>D3D12_FEATURE_DATA_D3D12_OPTIONS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct FeatureDataD3D12Options
    {
        /// <summary>
        /// <dd> <p> Specifies whether <strong>double</strong> types are allowed for shader operations. If <strong>TRUE</strong>, double types are allowed; otherwise <strong><see cref = "SharpDX.Result.False"/></strong>. The supported operations are equivalent to Direct3D 11's <strong>ExtendedDoublesShaderInstructions</strong> member of the <strong><see cref = "SharpDX.Direct3D11.FeatureDataD3D11Options"/></strong> structure. </p> <p> To use any HLSL shader that is compiled with a <strong>double</strong> type, the runtime must set <strong>DoublePrecisionFloatShaderOps</strong> to <strong>TRUE</strong>. </p> </dd>
        /// </summary>
        /// <doc-id>dn770364</doc-id>
        /// <unmanaged>DoublePrecisionFloatShaderOps</unmanaged>
        /// <unmanaged-short>DoublePrecisionFloatShaderOps</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool DoublePrecisionFloatShaderOps;
        /// <summary>
        /// <dd> <p> Specifies whether logic operations are available in blend state. The runtime sets this member to <strong>TRUE</strong> if logic operations are available in blend state and <strong><see cref = "SharpDX.Result.False"/></strong> otherwise. This member is <strong><see cref = "SharpDX.Result.False"/></strong> for feature level 9.1, 9.2, and 9.3.  This member is optional for feature level 10, 10.1, and 11.  This member is <strong>TRUE</strong> for feature level 11.1 and 12. </p> </dd>
        /// </summary>
        /// <doc-id>dn770364</doc-id>
        /// <unmanaged>OutputMergerLogicOp</unmanaged>
        /// <unmanaged-short>OutputMergerLogicOp</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool OutputMergerLogicOp;
        /// <summary>
        /// <dd> <p> A combination of <strong><see cref = "SharpDX.Direct3D12.ShaderMinimumPrecisionSupport"/></strong>-typed values that are combined by using a bitwise OR operation. The resulting value specifies minimum precision levels that the driver supports for shader stages. A value of zero indicates that the driver supports only full 32-bit precision for all shader stages. </p> </dd>
        /// </summary>
        /// <doc-id>dn770364</doc-id>
        /// <unmanaged>MinPrecisionSupport</unmanaged>
        /// <unmanaged-short>MinPrecisionSupport</unmanaged-short>
        public SharpDX.Direct3D12.ShaderMinimumPrecisionSupport MinPrecisionSupport;
        /// <summary>
        /// <dd> <p> Specifies whether the hardware and driver support tiled resources. The runtime sets this member to a <strong><see cref = "SharpDX.Direct3D12.TiledResourcesTier"/></strong>-typed value that indicates if the hardware and driver support tiled resources and at what tier level. </p> </dd>
        /// </summary>
        /// <doc-id>dn770364</doc-id>
        /// <unmanaged>TiledResourcesTier</unmanaged>
        /// <unmanaged-short>TiledResourcesTier</unmanaged-short>
        public SharpDX.Direct3D12.TiledResourcesTier TiledResourcesTier;
        /// <summary>
        /// <dd> <p> Specifies the level at which the hardware and driver support resource binding. The runtime sets this member to a <strong><see cref = "SharpDX.Direct3D12.ResourceBindingTier"/></strong>-typed value that indicates the tier level. </p> </dd>
        /// </summary>
        /// <doc-id>dn770364</doc-id>
        /// <unmanaged>ResourceBindingTier</unmanaged>
        /// <unmanaged-short>ResourceBindingTier</unmanaged-short>
        public SharpDX.Direct3D12.ResourceBindingTier ResourceBindingTier;
        /// <summary>
        /// <dd> <p> Specifies whether pixel shader stencil ref is supported. If <strong>TRUE</strong>, it's supported; otherwise <strong><see cref = "SharpDX.Result.False"/></strong>. </p> </dd>
        /// </summary>
        /// <doc-id>dn770364</doc-id>
        /// <unmanaged>PSSpecifiedStencilRefSupported</unmanaged>
        /// <unmanaged-short>PSSpecifiedStencilRefSupported</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool PSSpecifiedStencilRefSupported;
        /// <summary>
        /// <dd> <p> Specifies whether the loading of additional formats for typed unordered-access views (UAVs) is supported. If <strong>TRUE</strong>, it's supported; otherwise <strong><see cref = "SharpDX.Result.False"/></strong>. </p> </dd>
        /// </summary>
        /// <doc-id>dn770364</doc-id>
        /// <unmanaged>TypedUAVLoadAdditionalFormats</unmanaged>
        /// <unmanaged-short>TypedUAVLoadAdditionalFormats</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool TypedUAVLoadAdditionalFormats;
        /// <summary>
        /// <dd> <p> Specifies whether <em>Rasterizer Order Views</em> (ROVs) are supported. If <strong>TRUE</strong>, they're supported; otherwise <strong><see cref = "SharpDX.Result.False"/></strong>. </p> </dd>
        /// </summary>
        /// <doc-id>dn770364</doc-id>
        /// <unmanaged>ROVsSupported</unmanaged>
        /// <unmanaged-short>ROVsSupported</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool ROVsSupported;
        /// <summary>
        /// <dd> <p> Specifies the level at which the hardware and driver support conservative rasterization. The runtime sets this member to a <strong><see cref = "SharpDX.Direct3D12.ConservativeRasterizationTier"/></strong>-typed value that indicates the tier level. </p> </dd>
        /// </summary>
        /// <doc-id>dn770364</doc-id>
        /// <unmanaged>ConservativeRasterizationTier</unmanaged>
        /// <unmanaged-short>ConservativeRasterizationTier</unmanaged-short>
        public SharpDX.Direct3D12.ConservativeRasterizationTier ConservativeRasterizationTier;
        /// <summary>
        /// <dd> <p> Don't use this field; instead, use the <strong><see cref = "SharpDX.Direct3D12.FeatureDataGpuVirtualAddressSupport"/></strong> query (a structure with a <strong>MaxGPUVirtualAddressBitsPerResource</strong> member), which is more accurate. </p> </dd>
        /// </summary>
        /// <doc-id>dn770364</doc-id>
        /// <unmanaged>MaxGPUVirtualAddressBitsPerResource</unmanaged>
        /// <unmanaged-short>MaxGPUVirtualAddressBitsPerResource</unmanaged-short>
        public System.Int32 MaxGPUVirtualAddressBitsPerResource;
        /// <summary>
        /// <dd> <p> TRUE if the hardware supports textures with the 64KB standard swizzle pattern. Support for this pattern enables zero-copy texture optimizations while providing near-equilateral locality for each dimension within the texture. For texture swizzle options and restrictions, see <strong><see cref = "SharpDX.Direct3D12.TextureLayout"/></strong>. </p> </dd>
        /// </summary>
        /// <doc-id>dn770364</doc-id>
        /// <unmanaged>StandardSwizzle64KBSupported</unmanaged>
        /// <unmanaged-short>StandardSwizzle64KBSupported</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool StandardSwizzle64KBSupported;
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.CrossNodeSharingTier"/></strong> enumeration constant that specifies the level of sharing across nodes of an adapter that has multiple nodes, such as Tier 1 Emulated, Tier 1, or Tier 2. </p> </dd>
        /// </summary>
        /// <doc-id>dn770364</doc-id>
        /// <unmanaged>CrossNodeSharingTier</unmanaged>
        /// <unmanaged-short>CrossNodeSharingTier</unmanaged-short>
        public SharpDX.Direct3D12.CrossNodeSharingTier CrossNodeSharingTier;
        /// <summary>
        /// <dd> <p> <see cref = "SharpDX.Result.False"/> means the device only supports copy operations to and from cross-adapter row-major textures. TRUE means the device supports shader resource views, unordered access views, and render target views of cross-adapter row-major textures. "Cross-adapter" means between multiple adapters (even from different IHVs). </p> </dd>
        /// </summary>
        /// <doc-id>dn770364</doc-id>
        /// <unmanaged>CrossAdapterRowMajorTextureSupported</unmanaged>
        /// <unmanaged-short>CrossAdapterRowMajorTextureSupported</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool CrossAdapterRowMajorTextureSupported;
        /// <summary>
        /// <dd> <p> Whether the viewport (VP) and Render Target (RT) array index from any shader feeding the rasterizer are supported without geometry shader emulation. Compare the <strong>VPAndRTArrayIndexFromAnyShaderFeedingRasterizer</strong> member of the <strong><see cref = "SharpDX.Direct3D11.FeatureDataD3D11Options3"/></strong> structure. In <strong>ID3D12ShaderReflection::GetRequiresFlags</strong>, see the #define D3D_SHADER_REQUIRES_VIEWPORT_AND_RT_ARRAY_INDEX_FROM_ANY_SHADER_FEEDING_RASTERIZER. </p> </dd>
        /// </summary>
        /// <doc-id>dn770364</doc-id>
        /// <unmanaged>VPAndRTArrayIndexFromAnyShaderFeedingRasterizerSupportedWithoutGSEmulation</unmanaged>
        /// <unmanaged-short>VPAndRTArrayIndexFromAnyShaderFeedingRasterizerSupportedWithoutGSEmulation</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool VPAndRTArrayIndexFromAnyShaderFeedingRasterizerSupportedWithoutGSEmulation;
        /// <summary>
        /// <dd> <p> Specifies the level at which the hardware and driver require heap attribution related to resource type. The runtime sets this member to a <strong><see cref = "SharpDX.Direct3D12.ResourceHeapTier"/></strong> enumeration constant. </p> </dd>
        /// </summary>
        /// <doc-id>dn770364</doc-id>
        /// <unmanaged>ResourceHeapTier</unmanaged>
        /// <unmanaged-short>ResourceHeapTier</unmanaged-short>
        public SharpDX.Direct3D12.ResourceHeapTier ResourceHeapTier;
    }

    /// <summary>
    /// <p>Describes the level of support for HLSL 6.0 wave operations.</p>
    /// </summary>
    /// <remarks>
    /// <p>A "lane" is  single thread of execution. The shader models before version 6.0 expose only one of these at the language level, leaving expansion to parallel SIMD processing entirely up to the implementation.  A "wave" is  set of lanes (threads) executed simultaneously in the processor. No explicit barriers are required to guarantee that they execute in parallel. Similar concepts include "warp" and "wavefront". 
    /// </p><p> This structure is used with the D3D12_FEATURE_D3D12_OPTIONS1 member of  <strong><see cref = "SharpDX.Direct3D12.Feature"/></strong>. </p>
    /// </remarks>
    /// <doc-id>mt709115</doc-id>
    /// <unmanaged>D3D12_FEATURE_DATA_D3D12_OPTIONS1</unmanaged>
    /// <unmanaged-short>D3D12_FEATURE_DATA_D3D12_OPTIONS1</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct FeatureDataD3D12Options1
    {
        /// <summary>
        /// <dd> <p>True if the driver supports HLSL 6.0 wave operations.</p> </dd>
        /// </summary>
        /// <doc-id>mt709115</doc-id>
        /// <unmanaged>WaveOps</unmanaged>
        /// <unmanaged-short>WaveOps</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool WaveOps;
        /// <summary>
        /// <dd> <p>Specifies the baseline number of lanes in the SIMD wave that this implementation can support. This term is sometimes known as "wavefront size" or "warp width". Currently apps should rely only on this minimum value for sizing workloads. 
        /// </p> </dd>
        /// </summary>
        /// <doc-id>mt709115</doc-id>
        /// <unmanaged>WaveLaneCountMin</unmanaged>
        /// <unmanaged-short>WaveLaneCountMin</unmanaged-short>
        public System.Int32 WaveLaneCountMin;
        /// <summary>
        /// <dd> <p>Specifies the maximum number of lanes in the SIMD wave that this implementation can support. This capability is reserved for future expansion, and is not expected to be used by current applications. 
        /// </p> </dd>
        /// </summary>
        /// <doc-id>mt709115</doc-id>
        /// <unmanaged>WaveLaneCountMax</unmanaged>
        /// <unmanaged-short>WaveLaneCountMax</unmanaged-short>
        public System.Int32 WaveLaneCountMax;
        /// <summary>
        /// <dd> <p>Specifies the total number of SIMD lanes on the hardware.</p> </dd>
        /// </summary>
        /// <doc-id>mt709115</doc-id>
        /// <unmanaged>TotalLaneCount</unmanaged>
        /// <unmanaged-short>TotalLaneCount</unmanaged-short>
        public System.Int32 TotalLaneCount;
        /// <summary>
        /// <dd> <p>Indicates transitions are possible  in and out of the CBV, and indirect argument states, on compute command lists. If <strong>CheckFeatureSupport</strong> succeeds this value will always be true. </p> </dd>
        /// </summary>
        /// <doc-id>mt709115</doc-id>
        /// <unmanaged>ExpandedComputeResourceStates</unmanaged>
        /// <unmanaged-short>ExpandedComputeResourceStates</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool ExpandedComputeResourceStates;
        /// <summary>
        /// <dd> <p>Indicates that 64bit integer operations are supported.</p> </dd>
        /// </summary>
        /// <doc-id>mt709115</doc-id>
        /// <unmanaged>Int64ShaderOps</unmanaged>
        /// <unmanaged-short>Int64ShaderOps</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool Int64ShaderOps;
    }

    /// <summary>
    /// <p> Describes the DXGI data format. </p>
    /// </summary>
    /// <remarks>
    /// <p> See <strong><see cref = "SharpDX.Direct3D12.Feature"/></strong>. </p>
    /// </remarks>
    /// <doc-id>dn986728</doc-id>
    /// <unmanaged>D3D12_FEATURE_DATA_D3D12_OPTIONS2</unmanaged>
    /// <unmanaged-short>D3D12_FEATURE_DATA_D3D12_OPTIONS2</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct FeatureDataD3D12Options2
    {
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.DXGI.Format"/></strong>-typed value for the format to return info about. </p> </dd>
        /// </summary>
        /// <doc-id>dn986728</doc-id>
        /// <unmanaged>DepthBoundsTestSupported</unmanaged>
        /// <unmanaged-short>DepthBoundsTestSupported</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool DepthBoundsTestSupported;
        /// <summary>
        /// <dd> <p> The number of planes to provide information about. </p> </dd>
        /// </summary>
        /// <doc-id>dn986728</doc-id>
        /// <unmanaged>ProgrammableSamplePositionsTier</unmanaged>
        /// <unmanaged-short>ProgrammableSamplePositionsTier</unmanaged-short>
        public SharpDX.Direct3D12.ProgrammableSamplePositionsTier ProgrammableSamplePositionsTier;
    }

    /// <summary>
    /// <p>Used to indicate the level of support that the adapter provides for optional features of Direct3D 12.</p>
    /// </summary>
    /// <remarks>
    /// <p></p>
    /// </remarks>
    /// <doc-id>mt844807</doc-id>
    /// <unmanaged>D3D12_FEATURE_DATA_D3D12_OPTIONS3</unmanaged>
    /// <unmanaged-short>D3D12_FEATURE_DATA_D3D12_OPTIONS3</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct FeatureDataD3D12Options3
    {
        /// <summary>
        /// <dd> <p> Indicates whether timestamp queries are supported on copy queues. </p> </dd>
        /// </summary>
        /// <doc-id>mt844807</doc-id>
        /// <unmanaged>CopyQueueTimestampQueriesSupported</unmanaged>
        /// <unmanaged-short>CopyQueueTimestampQueriesSupported</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool CopyQueueTimestampQueriesSupported;
        /// <summary>
        /// <dd> <p> Indicates whether casting from one fully typed format to another, compatible, format is supported. </p> </dd>
        /// </summary>
        /// <doc-id>mt844807</doc-id>
        /// <unmanaged>CastingFullyTypedFormatSupported</unmanaged>
        /// <unmanaged-short>CastingFullyTypedFormatSupported</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool CastingFullyTypedFormatSupported;
        /// <summary>
        /// <dd> <p> Indicates the kinds of command lists that support the ability to write an immediate value directly from the command stream into a specified buffer. </p> </dd>
        /// </summary>
        /// <doc-id>mt844807</doc-id>
        /// <unmanaged>WriteBufferImmediateSupportFlags</unmanaged>
        /// <unmanaged-short>WriteBufferImmediateSupportFlags</unmanaged-short>
        public SharpDX.Direct3D12.CommandListSupportFlags WriteBufferImmediateSupportFlags;
        /// <summary>
        /// <dd> <p> Indicates the level of support the adapter has for view instancing. </p> </dd>
        /// </summary>
        /// <doc-id>mt844807</doc-id>
        /// <unmanaged>ViewInstancingTier</unmanaged>
        /// <unmanaged-short>ViewInstancingTier</unmanaged-short>
        public SharpDX.Direct3D12.ViewInstancingTier ViewInstancingTier;
        /// <summary>
        /// <dd> <p> Indicates whether barycentrics are supported. </p> </dd>
        /// </summary>
        /// <doc-id>mt844807</doc-id>
        /// <unmanaged>BarycentricsSupported</unmanaged>
        /// <unmanaged-short>BarycentricsSupported</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool BarycentricsSupported;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_FEATURE_DATA_D3D12_OPTIONS4</unmanaged>
    /// <unmanaged-short>D3D12_FEATURE_DATA_D3D12_OPTIONS4</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct FeatureDataD3D12Options4
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MSAA64KBAlignedTextureSupported</unmanaged>
        /// <unmanaged-short>MSAA64KBAlignedTextureSupported</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool MSAA64KBAlignedTextureSupported;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>SharedResourceCompatibilityTier</unmanaged>
        /// <unmanaged-short>SharedResourceCompatibilityTier</unmanaged-short>
        public SharpDX.Direct3D12.SharedResourceCompatibilityTier SharedResourceCompatibilityTier;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Native16BitShaderOpsSupported</unmanaged>
        /// <unmanaged-short>Native16BitShaderOpsSupported</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool Native16BitShaderOpsSupported;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_FEATURE_DATA_D3D12_OPTIONS5</unmanaged>
    /// <unmanaged-short>D3D12_FEATURE_DATA_D3D12_OPTIONS5</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct FeatureDataD3D12Options5
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>SRVOnlyTiledResourceTier3</unmanaged>
        /// <unmanaged-short>SRVOnlyTiledResourceTier3</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool SRVOnlyTiledResourceTier3;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>RenderPassesTier</unmanaged>
        /// <unmanaged-short>RenderPassesTier</unmanaged-short>
        public SharpDX.Direct3D12.RenderPassTier RenderPassesTier;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>RaytracingTier</unmanaged>
        /// <unmanaged-short>RaytracingTier</unmanaged-short>
        public SharpDX.Direct3D12.RaytracingTier RaytracingTier;
    }

    /// <summary>
    /// <p>Used to determinine whether the adapter supports creating heaps from existing system memory. Such heaps are not intended for general use, but are exceptionally useful for diagnostic purposes because they are guaranteed to persist even after the adapter faults or experiences a device-removal event. Persistence is not guaranteed for heaps returned by CreateHeap or CreateCommittedResource, even when the heap resides in system memory.</p>
    /// </summary>
    /// <remarks>
    /// <p>For a variety of performance and compatibility reasons, applications should not make use of this feature except for diagnostic purposes. In particular, heaps created using this feature only support system-memory heaps with cross-adapter properties, which precludes many optimization opportunities that typical application scenarios could otherwise take advantage of.</p>
    /// </remarks>
    /// <doc-id>mt844808</doc-id>
    /// <unmanaged>D3D12_FEATURE_DATA_EXISTING_HEAPS</unmanaged>
    /// <unmanaged-short>D3D12_FEATURE_DATA_EXISTING_HEAPS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct FeatureDataExistingHeaps
    {
        /// <summary>
        /// <dd> <p>True if the adapter can create a heap from existing system memory. Otherwise, false.</p> </dd>
        /// </summary>
        /// <doc-id>mt844808</doc-id>
        /// <unmanaged>Supported</unmanaged>
        /// <unmanaged-short>Supported</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool Supported;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_FEATURE_DATA_FEATURE_LEVELS</unmanaged>
    /// <unmanaged-short>D3D12_FEATURE_DATA_FEATURE_LEVELS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct FeatureDataFeatureLevels
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>NumFeatureLevels</unmanaged>
        /// <unmanaged-short>NumFeatureLevels</unmanaged-short>
        public System.Int32 FeatureLevelCount;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>pFeatureLevelsRequested</unmanaged>
        /// <unmanaged-short>pFeatureLevelsRequested</unmanaged-short>
        public System.IntPtr FeatureLevelsRequestedPointer;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MaxSupportedFeatureLevel</unmanaged>
        /// <unmanaged-short>MaxSupportedFeatureLevel</unmanaged-short>
        public SharpDX.Direct3D.FeatureLevel MaxSupportedFeatureLevel;
    }

    /// <summary>
    /// <p> Describes the DXGI data format. </p>
    /// </summary>
    /// <remarks>
    /// <p> See <strong><see cref = "SharpDX.Direct3D12.Feature"/></strong>. </p>
    /// </remarks>
    /// <doc-id>dn986728</doc-id>
    /// <unmanaged>D3D12_FEATURE_DATA_FORMAT_INFO</unmanaged>
    /// <unmanaged-short>D3D12_FEATURE_DATA_FORMAT_INFO</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct FeatureDataFormatInformation
    {
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.DXGI.Format"/></strong>-typed value for the format to return info about. </p> </dd>
        /// </summary>
        /// <doc-id>dn986728</doc-id>
        /// <unmanaged>Format</unmanaged>
        /// <unmanaged-short>Format</unmanaged-short>
        public SharpDX.DXGI.Format Format;
        /// <summary>
        /// <dd> <p> The number of planes to provide information about. </p> </dd>
        /// </summary>
        /// <doc-id>dn986728</doc-id>
        /// <unmanaged>PlaneCount</unmanaged>
        /// <unmanaged-short>PlaneCount</unmanaged-short>
        public System.Byte PlaneCount;
    }

    /// <summary>
    /// <p> Describes which resources are supported by the current graphics driver for a given format. </p>
    /// </summary>
    /// <remarks>
    /// <p> Refer to the enum <strong><see cref = "SharpDX.Direct3D12.Feature"/></strong>. </p>
    /// </remarks>
    /// <doc-id>dn859386</doc-id>
    /// <unmanaged>D3D12_FEATURE_DATA_FORMAT_SUPPORT</unmanaged>
    /// <unmanaged-short>D3D12_FEATURE_DATA_FORMAT_SUPPORT</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct FeatureDataFormatSupport
    {
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.DXGI.Format"/></strong>-typed value for the format to return info about. </p> </dd>
        /// </summary>
        /// <doc-id>dn859386</doc-id>
        /// <unmanaged>Format</unmanaged>
        /// <unmanaged-short>Format</unmanaged-short>
        public SharpDX.DXGI.Format Format;
        /// <summary>
        /// <dd> <p> A combination of <strong><see cref = "SharpDX.Direct3D12.FormatSupport1"/></strong>-typed values that are combined by using a bitwise OR operation. The resulting value specifies which resources are supported. </p> </dd>
        /// </summary>
        /// <doc-id>dn859386</doc-id>
        /// <unmanaged>Support1</unmanaged>
        /// <unmanaged-short>Support1</unmanaged-short>
        public SharpDX.Direct3D12.FormatSupport1 Support1;
        /// <summary>
        /// <dd> <p> A combination of <strong><see cref = "SharpDX.Direct3D12.FormatSupport2"/></strong>-typed values that are combined by using a bitwise OR operation. The resulting value specifies which unordered resource options are supported. </p> </dd>
        /// </summary>
        /// <doc-id>dn859386</doc-id>
        /// <unmanaged>Support2</unmanaged>
        /// <unmanaged-short>Support2</unmanaged-short>
        public SharpDX.Direct3D12.FormatSupport2 Support2;
    }

    /// <summary>
    /// <p> Details the adapter's GPU virtual address space limitations, including maximum address bits per resource and per process. </p>
    /// </summary>
    /// <remarks>
    /// <p> See the enumeration constant D3D12_FEATURE_GPU_VIRTUAL_ADDRESS_SUPPORT in the <strong><see cref = "SharpDX.Direct3D12.Feature"/></strong> enumeration. </p>
    /// </remarks>
    /// <doc-id>mt186607</doc-id>
    /// <unmanaged>D3D12_FEATURE_DATA_GPU_VIRTUAL_ADDRESS_SUPPORT</unmanaged>
    /// <unmanaged-short>D3D12_FEATURE_DATA_GPU_VIRTUAL_ADDRESS_SUPPORT</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct FeatureDataGpuVirtualAddressSupport
    {
        /// <summary>
        /// <dd> <p>The maximum GPU virtual address bits per resource.</p> <p>Some adapters have significantly less bits available per resource than per process, while other adapters have significantly greater bits available per resource than per process. The latter scenario tends to happen in less common scenarios, like when running a 32-bit process on certain UMA adapters.
        /// When per resource capabilities are greater than per process, the greater per resource capabilities can only be leveraged by reserved resources or <c>null</c> mapped pages.
        /// </p> </dd>
        /// </summary>
        /// <doc-id>mt186607</doc-id>
        /// <unmanaged>MaxGPUVirtualAddressBitsPerResource</unmanaged>
        /// <unmanaged-short>MaxGPUVirtualAddressBitsPerResource</unmanaged-short>
        public System.Int32 MaxGPUVirtualAddressBitsPerResource;
        /// <summary>
        /// <dd> <p> The maximum GPU virtual address bits per process.</p> <p>When this value is nearly equal to the available residency budget, <strong>Evict</strong> will not be a feasible option to manage residency. See <strong>MakeResident</strong> for more details.</p> </dd>
        /// </summary>
        /// <doc-id>mt186607</doc-id>
        /// <unmanaged>MaxGPUVirtualAddressBitsPerProcess</unmanaged>
        /// <unmanaged-short>MaxGPUVirtualAddressBitsPerProcess</unmanaged-short>
        public System.Int32 MaxGPUVirtualAddressBitsPerProcess;
    }

    /// <summary>
    /// <p> Describes the image quality levels for a given format and sample count. </p>
    /// </summary>
    /// <remarks>
    /// <p> See <strong><see cref = "SharpDX.Direct3D12.Feature"/></strong>. </p>
    /// </remarks>
    /// <doc-id>dn859387</doc-id>
    /// <unmanaged>D3D12_FEATURE_DATA_MULTISAMPLE_QUALITY_LEVELS</unmanaged>
    /// <unmanaged-short>D3D12_FEATURE_DATA_MULTISAMPLE_QUALITY_LEVELS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct FeatureDataMultisampleQualityLevels
    {
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.DXGI.Format"/></strong>-typed value for the format to return info about. </p> </dd>
        /// </summary>
        /// <doc-id>dn859387</doc-id>
        /// <unmanaged>Format</unmanaged>
        /// <unmanaged-short>Format</unmanaged-short>
        public SharpDX.DXGI.Format Format;
        /// <summary>
        /// <dd> <p> The number of multi-samples per pixel to return info about. </p> </dd>
        /// </summary>
        /// <doc-id>dn859387</doc-id>
        /// <unmanaged>SampleCount</unmanaged>
        /// <unmanaged-short>SampleCount</unmanaged-short>
        public System.Int32 SampleCount;
        /// <summary>
        /// <dd> <p> Flags to control quality levels, as a bitwise-OR'd combination of <strong><see cref = "SharpDX.Direct3D12.MultisampleQualityLevelFlags"/></strong> enumeration constants. The resulting value specifies options for determining quality levels. </p> </dd>
        /// </summary>
        /// <doc-id>dn859387</doc-id>
        /// <unmanaged>Flags</unmanaged>
        /// <unmanaged-short>Flags</unmanaged-short>
        public SharpDX.Direct3D12.MultisampleQualityLevelFlags Flags;
        /// <summary>
        /// <dd> <p> The number of quality levels. </p> </dd>
        /// </summary>
        /// <doc-id>dn859387</doc-id>
        /// <unmanaged>NumQualityLevels</unmanaged>
        /// <unmanaged-short>NumQualityLevels</unmanaged-short>
        public System.Int32 QualityLevelCount;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_FEATURE_DATA_PROTECTED_RESOURCE_SESSION_SUPPORT</unmanaged>
    /// <unmanaged-short>D3D12_FEATURE_DATA_PROTECTED_RESOURCE_SESSION_SUPPORT</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct FeatureDataProtectedResourceSessionSupport
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>NodeIndex</unmanaged>
        /// <unmanaged-short>NodeIndex</unmanaged-short>
        public System.Int32 NodeIndex;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Support</unmanaged>
        /// <unmanaged-short>Support</unmanaged-short>
        public SharpDX.Direct3D12.ProtectedResourceSessionSupportFlags Support;
    }

    /// <summary>
    /// <p>Pass this structure to <strong>CheckFeatureSupport</strong> to check for root signature version support.</p>
    /// </summary>
    /// <doc-id>mt709116</doc-id>
    /// <unmanaged>D3D12_FEATURE_DATA_ROOT_SIGNATURE</unmanaged>
    /// <unmanaged-short>D3D12_FEATURE_DATA_ROOT_SIGNATURE</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct FeatureDataRootSignature
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>mt709116</doc-id>
        /// <unmanaged>HighestVersion</unmanaged>
        /// <unmanaged-short>HighestVersion</unmanaged-short>
        public SharpDX.Direct3D12.RootSignatureVersion HighestVersion;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_FEATURE_DATA_SERIALIZATION</unmanaged>
    /// <unmanaged-short>D3D12_FEATURE_DATA_SERIALIZATION</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct FeatureDataSerialization
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>NodeIndex</unmanaged>
        /// <unmanaged-short>NodeIndex</unmanaged-short>
        public System.Int32 NodeIndex;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>HeapSerializationTier</unmanaged>
        /// <unmanaged-short>HeapSerializationTier</unmanaged-short>
        public SharpDX.Direct3D12.HeapSerializationTier HeapSerializationTier;
    }

    /// <summary>
    /// <p> Describes the layout of a root signature version 1.0. </p>
    /// </summary>
    /// <remarks>
    /// <p> This structure is used by the <strong>D3D12SerializeRootSignature</strong> function and is returned by the <strong>ID3D12RootSignatureDeserializer::GetRootSignatureDesc</strong> method. </p><p> There is one graphics root signature, and one compute root signature. </p>
    /// </remarks>
    /// <doc-id>dn986747</doc-id>
    /// <unmanaged>D3D12_FEATURE_DATA_SHADER_CACHE</unmanaged>
    /// <unmanaged-short>D3D12_FEATURE_DATA_SHADER_CACHE</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct FeatureDataShaderCache
    {
        /// <summary>
        /// <dd> <p> The number of slots in the root signature. This number is also the number of elements in the <em>pParameters</em> array. </p> </dd>
        /// </summary>
        /// <doc-id>dn986747</doc-id>
        /// <unmanaged>SupportFlags</unmanaged>
        /// <unmanaged-short>SupportFlags</unmanaged-short>
        public SharpDX.Direct3D12.ShaderCacheSupportFlags SupportFlags;
    }

    /// <summary>
    /// <p>Contains the supported shader model.</p>
    /// </summary>
    /// <remarks>
    /// <p> Refer to  the enumeration constant D3D12_FEATURE_SHADER_MODEL in the <strong><see cref = "SharpDX.Direct3D12.Feature"/></strong> enumeration. </p>
    /// </remarks>
    /// <doc-id>mt709117</doc-id>
    /// <unmanaged>D3D12_FEATURE_DATA_SHADER_MODEL</unmanaged>
    /// <unmanaged-short>D3D12_FEATURE_DATA_SHADER_MODEL</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct FeatureDataShaderModel
    {
        /// <summary>
        /// <dd> <p>Specifies one member of  <strong><see cref = "SharpDX.Direct3D12.ShaderModel"/></strong> that indicates the maximum supported shader model.</p> </dd>
        /// </summary>
        /// <doc-id>mt709117</doc-id>
        /// <unmanaged>HighestShaderModel</unmanaged>
        /// <unmanaged-short>HighestShaderModel</unmanaged-short>
        public SharpDX.Direct3D12.ShaderModel HighestShaderModel;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_GLOBAL_ROOT_SIGNATURE</unmanaged>
    /// <unmanaged-short>D3D12_GLOBAL_ROOT_SIGNATURE</unmanaged-short>
    public partial struct GlobalRootSignature
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>pGlobalRootSignature</unmanaged>
        /// <unmanaged-short>pGlobalRootSignature</unmanaged-short>
        public SharpDX.Direct3D12.RootSignature GlobalRootSignaturePointer;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.IntPtr GlobalRootSignaturePointer;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            if (@ref.GlobalRootSignaturePointer != System.IntPtr.Zero)
                GlobalRootSignaturePointer = new SharpDX.Direct3D12.RootSignature(@ref.GlobalRootSignaturePointer);
            else
                GlobalRootSignaturePointer = null;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.GlobalRootSignaturePointer = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.RootSignature>(GlobalRootSignaturePointer);
        }
    }

    /// <summary>
    /// <p> Describes a GPU descriptor handle. </p>
    /// </summary>
    /// <remarks>
    /// <p> This structure is returned by <strong>ID3D12DescriptorHeap::GetGPUDescriptorHandleForHeapStart</strong>. </p><p> This structure is passed into the following methods: </p><ul> <li> <strong>ID3D12GraphicsCommandList::ClearUnorderedAccessViewFloat</strong> </li> <li> <strong>ID3D12GraphicsCommandList::ClearUnorderedAccessViewUint</strong> </li> <li> <strong>ID3D12GraphicsCommandList:SetComputeRootDescriptorTable</strong> </li> <li> <strong>ID3D12GraphicsCommandList::SetGraphicsRootDescriptorTable</strong> </li> </ul>
    /// </remarks>
    /// <doc-id>dn859391</doc-id>
    /// <unmanaged>D3D12_GPU_DESCRIPTOR_HANDLE</unmanaged>
    /// <unmanaged-short>D3D12_GPU_DESCRIPTOR_HANDLE</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct GpuDescriptorHandle
    {
        /// <summary>
        /// <dd> <p> The address of the descriptor. </p> </dd>
        /// </summary>
        /// <doc-id>dn859391</doc-id>
        /// <unmanaged>ptr</unmanaged>
        /// <unmanaged-short>ptr</unmanaged-short>
        public System.Int64 Ptr;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_GPU_VIRTUAL_ADDRESS_AND_STRIDE</unmanaged>
    /// <unmanaged-short>D3D12_GPU_VIRTUAL_ADDRESS_AND_STRIDE</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct GpuVirtualAddressAndStride
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>StartAddress</unmanaged>
        /// <unmanaged-short>StartAddress</unmanaged-short>
        public System.Int64 StartAddress;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>StrideInBytes</unmanaged>
        /// <unmanaged-short>StrideInBytes</unmanaged-short>
        public System.Int64 StrideInBytes;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_GPU_VIRTUAL_ADDRESS_RANGE</unmanaged>
    /// <unmanaged-short>D3D12_GPU_VIRTUAL_ADDRESS_RANGE</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct GpuVirtualAddressRange
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>StartAddress</unmanaged>
        /// <unmanaged-short>StartAddress</unmanaged-short>
        public System.Int64 StartAddress;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>SizeInBytes</unmanaged>
        /// <unmanaged-short>SizeInBytes</unmanaged-short>
        public System.Int64 SizeInBytes;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_GPU_VIRTUAL_ADDRESS_RANGE_AND_STRIDE</unmanaged>
    /// <unmanaged-short>D3D12_GPU_VIRTUAL_ADDRESS_RANGE_AND_STRIDE</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct GpuVirtualAddressRangeAndStride
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>StartAddress</unmanaged>
        /// <unmanaged-short>StartAddress</unmanaged-short>
        public System.Int64 StartAddress;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>SizeInBytes</unmanaged>
        /// <unmanaged-short>SizeInBytes</unmanaged-short>
        public System.Int64 SizeInBytes;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>StrideInBytes</unmanaged>
        /// <unmanaged-short>StrideInBytes</unmanaged-short>
        public System.Int64 StrideInBytes;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_GRAPHICS_PIPELINE_STATE_DESC</unmanaged>
    /// <unmanaged-short>D3D12_GRAPHICS_PIPELINE_STATE_DESC</unmanaged-short>
    public partial class GraphicsPipelineStateDescription
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>pRootSignature</unmanaged>
        /// <unmanaged-short>pRootSignature</unmanaged-short>
        public SharpDX.Direct3D12.RootSignature RootSignature;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>VS</unmanaged>
        /// <unmanaged-short>VS</unmanaged-short>
        public SharpDX.Direct3D12.ShaderBytecode VertexShader;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>PS</unmanaged>
        /// <unmanaged-short>PS</unmanaged-short>
        public SharpDX.Direct3D12.ShaderBytecode PixelShader;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>DS</unmanaged>
        /// <unmanaged-short>DS</unmanaged-short>
        public SharpDX.Direct3D12.ShaderBytecode DomainShader;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>HS</unmanaged>
        /// <unmanaged-short>HS</unmanaged-short>
        public SharpDX.Direct3D12.ShaderBytecode HullShader;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>GS</unmanaged>
        /// <unmanaged-short>GS</unmanaged-short>
        public SharpDX.Direct3D12.ShaderBytecode GeometryShader;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>StreamOutput</unmanaged>
        /// <unmanaged-short>StreamOutput</unmanaged-short>
        public SharpDX.Direct3D12.StreamOutputDescription StreamOutput;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>BlendState</unmanaged>
        /// <unmanaged-short>BlendState</unmanaged-short>
        public SharpDX.Direct3D12.BlendStateDescription BlendState;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>SampleMask</unmanaged>
        /// <unmanaged-short>SampleMask</unmanaged-short>
        public System.Int32 SampleMask;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>RasterizerState</unmanaged>
        /// <unmanaged-short>RasterizerState</unmanaged-short>
        public SharpDX.Direct3D12.RasterizerStateDescription RasterizerState;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>DepthStencilState</unmanaged>
        /// <unmanaged-short>DepthStencilState</unmanaged-short>
        public SharpDX.Direct3D12.DepthStencilStateDescription DepthStencilState;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>InputLayout</unmanaged>
        /// <unmanaged-short>InputLayout</unmanaged-short>
        public SharpDX.Direct3D12.InputLayoutDescription InputLayout;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>IBStripCutValue</unmanaged>
        /// <unmanaged-short>IBStripCutValue</unmanaged-short>
        public SharpDX.Direct3D12.IndexBufferStripCutValue IBStripCutValue;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>PrimitiveTopologyType</unmanaged>
        /// <unmanaged-short>PrimitiveTopologyType</unmanaged-short>
        public SharpDX.Direct3D12.PrimitiveTopologyType PrimitiveTopologyType;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>NumRenderTargets</unmanaged>
        /// <unmanaged-short>NumRenderTargets</unmanaged-short>
        public System.Int32 RenderTargetCount;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>RTVFormats</unmanaged>
        /// <unmanaged-short>RTVFormats</unmanaged-short>
        public SharpDX.DXGI.Format[] RenderTargetFormats
        {
            get => _RenderTargetFormats ?? (_RenderTargetFormats = new SharpDX.DXGI.Format[8]);
            private set => _RenderTargetFormats = value;
        }

        internal SharpDX.DXGI.Format[] _RenderTargetFormats;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>DSVFormat</unmanaged>
        /// <unmanaged-short>DSVFormat</unmanaged-short>
        public SharpDX.DXGI.Format DepthStencilFormat;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>SampleDesc</unmanaged>
        /// <unmanaged-short>SampleDesc</unmanaged-short>
        public SharpDX.DXGI.SampleDescription SampleDescription;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>NodeMask</unmanaged>
        /// <unmanaged-short>NodeMask</unmanaged-short>
        public System.Int32 NodeMask;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>CachedPSO</unmanaged>
        /// <unmanaged-short>CachedPSO</unmanaged-short>
        public SharpDX.Direct3D12.CachedPipelineState CachedPSO;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Flags</unmanaged>
        /// <unmanaged-short>Flags</unmanaged-short>
        public SharpDX.Direct3D12.PipelineStateFlags Flags;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.IntPtr RootSignature;
            public SharpDX.Direct3D12.ShaderBytecode.__Native VertexShader;
            public SharpDX.Direct3D12.ShaderBytecode.__Native PixelShader;
            public SharpDX.Direct3D12.ShaderBytecode.__Native DomainShader;
            public SharpDX.Direct3D12.ShaderBytecode.__Native HullShader;
            public SharpDX.Direct3D12.ShaderBytecode.__Native GeometryShader;
            public SharpDX.Direct3D12.StreamOutputDescription.__Native StreamOutput;
            public SharpDX.Direct3D12.BlendStateDescription.__Native BlendState;
            public System.Int32 SampleMask;
            public SharpDX.Direct3D12.RasterizerStateDescription RasterizerState;
            public SharpDX.Direct3D12.DepthStencilStateDescription DepthStencilState;
            public SharpDX.Direct3D12.InputLayoutDescription.__Native InputLayout;
            public SharpDX.Direct3D12.IndexBufferStripCutValue IBStripCutValue;
            public SharpDX.Direct3D12.PrimitiveTopologyType PrimitiveTopologyType;
            public System.Int32 RenderTargetCount;
            public SharpDX.DXGI.Format RenderTargetFormats;
            public SharpDX.DXGI.Format __RenderTargetFormats1;
            public SharpDX.DXGI.Format __RenderTargetFormats2;
            public SharpDX.DXGI.Format __RenderTargetFormats3;
            public SharpDX.DXGI.Format __RenderTargetFormats4;
            public SharpDX.DXGI.Format __RenderTargetFormats5;
            public SharpDX.DXGI.Format __RenderTargetFormats6;
            public SharpDX.DXGI.Format __RenderTargetFormats7;
            public SharpDX.DXGI.Format DepthStencilFormat;
            public SharpDX.DXGI.SampleDescription SampleDescription;
            public System.Int32 NodeMask;
            public SharpDX.Direct3D12.CachedPipelineState.__Native CachedPSO;
            public SharpDX.Direct3D12.PipelineStateFlags Flags;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            VertexShader.__MarshalFree(ref @ref.VertexShader);
            PixelShader.__MarshalFree(ref @ref.PixelShader);
            DomainShader.__MarshalFree(ref @ref.DomainShader);
            HullShader.__MarshalFree(ref @ref.HullShader);
            GeometryShader.__MarshalFree(ref @ref.GeometryShader);
            StreamOutput.__MarshalFree(ref @ref.StreamOutput);
            BlendState.__MarshalFree(ref @ref.BlendState);
            InputLayout.__MarshalFree(ref @ref.InputLayout);
            CachedPSO.__MarshalFree(ref @ref.CachedPSO);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            if (@ref.RootSignature != System.IntPtr.Zero)
                RootSignature = new SharpDX.Direct3D12.RootSignature(@ref.RootSignature);
            else
                RootSignature = null;
            VertexShader.__MarshalFrom(ref @ref.VertexShader);
            PixelShader.__MarshalFrom(ref @ref.PixelShader);
            DomainShader.__MarshalFrom(ref @ref.DomainShader);
            HullShader.__MarshalFrom(ref @ref.HullShader);
            GeometryShader.__MarshalFrom(ref @ref.GeometryShader);
            {
                StreamOutput = new SharpDX.Direct3D12.StreamOutputDescription();
                StreamOutput.__MarshalFrom(ref @ref.StreamOutput);
            }

            BlendState.__MarshalFrom(ref @ref.BlendState);
            SampleMask = @ref.SampleMask;
            RasterizerState = @ref.RasterizerState;
            DepthStencilState = @ref.DepthStencilState;
            {
                InputLayout = new SharpDX.Direct3D12.InputLayoutDescription();
                InputLayout.__MarshalFrom(ref @ref.InputLayout);
            }

            IBStripCutValue = @ref.IBStripCutValue;
            PrimitiveTopologyType = @ref.PrimitiveTopologyType;
            RenderTargetCount = @ref.RenderTargetCount;
            fixed (void *__to = &RenderTargetFormats[0], __from = &@ref.RenderTargetFormats)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 8 * sizeof (SharpDX.DXGI.Format));
            DepthStencilFormat = @ref.DepthStencilFormat;
            SampleDescription = @ref.SampleDescription;
            NodeMask = @ref.NodeMask;
            CachedPSO.__MarshalFrom(ref @ref.CachedPSO);
            Flags = @ref.Flags;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.RootSignature = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.RootSignature>(RootSignature);
            VertexShader.__MarshalTo(ref @ref.VertexShader);
            PixelShader.__MarshalTo(ref @ref.PixelShader);
            DomainShader.__MarshalTo(ref @ref.DomainShader);
            HullShader.__MarshalTo(ref @ref.HullShader);
            GeometryShader.__MarshalTo(ref @ref.GeometryShader);
            StreamOutput.__MarshalTo(ref @ref.StreamOutput);
            BlendState.__MarshalTo(ref @ref.BlendState);
            @ref.SampleMask = SampleMask;
            @ref.RasterizerState = RasterizerState;
            @ref.DepthStencilState = DepthStencilState;
            InputLayout.__MarshalTo(ref @ref.InputLayout);
            @ref.IBStripCutValue = IBStripCutValue;
            @ref.PrimitiveTopologyType = PrimitiveTopologyType;
            @ref.RenderTargetCount = RenderTargetCount;
            fixed (void *__from = &RenderTargetFormats[0], __to = &@ref.RenderTargetFormats)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 8 * sizeof (SharpDX.DXGI.Format));
            @ref.DepthStencilFormat = DepthStencilFormat;
            @ref.SampleDescription = SampleDescription;
            @ref.NodeMask = NodeMask;
            CachedPSO.__MarshalTo(ref @ref.CachedPSO);
            @ref.Flags = Flags;
        }
    }

    /// <summary>
    /// <p>Describes a heap.</p>
    /// </summary>
    /// <remarks>
    /// <p> This structure is used by the <strong>CreateHeap</strong> method, and returned by the <strong>GetDesc</strong> method. </p>
    /// </remarks>
    /// <doc-id>dn770371</doc-id>
    /// <unmanaged>D3D12_HEAP_DESC</unmanaged>
    /// <unmanaged-short>D3D12_HEAP_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct HeapDescription
    {
        /// <summary>
        /// <dd> <p> The size, in bytes, of the heap. To avoid wasting memory, applications should pass <em>SizeInBytes</em> values which are multiples of the effective <em>Alignment</em>; but non-aligned <em>SizeInBytes</em> is also supported, for convenience. To find out how large a heap must be to support textures with undefined layouts and adapter-specific sizes, call <strong>ID3D12Device::GetResourceAllocationInfo</strong>. </p> </dd>
        /// </summary>
        /// <doc-id>dn770371</doc-id>
        /// <unmanaged>SizeInBytes</unmanaged>
        /// <unmanaged-short>SizeInBytes</unmanaged-short>
        public System.Int64 SizeInBytes;
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.HeapProperties"/></strong> structure that describes the heap properties. </p> </dd>
        /// </summary>
        /// <doc-id>dn770371</doc-id>
        /// <unmanaged>Properties</unmanaged>
        /// <unmanaged-short>Properties</unmanaged-short>
        public SharpDX.Direct3D12.HeapProperties Properties;
        /// <summary>
        /// <dd> <p> The alignment value for the heap.  Valid values: </p> <table> <tr><th>Value</th><th>Description</th></tr> <tr><td> 0 </td><td> An alias for 64KB. </td></tr> <tr><td> D3D12_DEFAULT_RESOURCE_PLACEMENT_ALIGNMENT </td><td> #defined as 64KB. </td></tr> <tr><td> D3D12_DEFAULT_MSAA_RESOURCE_PLACEMENT_ALIGNMENT </td><td> #defined as 4MB. An application must decide whether the heap will contain multi-sample anti-aliasing (MSAA), in which case, the application must choose D3D12_DEFAULT_MSAA_RESOURCE_PLACEMENT_ALIGNMENT. </td></tr> </table> <p>?</p> </dd>
        /// </summary>
        /// <doc-id>dn770371</doc-id>
        /// <unmanaged>Alignment</unmanaged>
        /// <unmanaged-short>Alignment</unmanaged-short>
        public System.Int64 Alignment;
        /// <summary>
        /// <dd> <p> A combination of <strong><see cref = "SharpDX.Direct3D12.HeapFlags"/></strong>-typed values that are combined by using a bitwise-OR operation. The resulting value identifies heap options. When creating heaps to support adapters with resource heap tier 1, an application must choose some flags. </p> </dd>
        /// </summary>
        /// <doc-id>dn770371</doc-id>
        /// <unmanaged>Flags</unmanaged>
        /// <unmanaged-short>Flags</unmanaged-short>
        public SharpDX.Direct3D12.HeapFlags Flags;
    }

    /// <summary>
    /// <p>Describes heap properties.</p>
    /// </summary>
    /// <remarks>
    /// <p> This structure is used by the following: </p><ul> <li> <strong><see cref = "SharpDX.Direct3D12.HeapDescription"/></strong> structure </li> <li> <strong>ID3D12Resource::GetHeapProperties</strong> </li> <li> <strong>ID3D12Device::GetCustomHeapProperties</strong> </li> <li> <strong>ID3D12Device::CreateCommittedResource</strong> </li> </ul><p> Valid combinations of struct member values: </p><ul> <li> When <strong>Type</strong> is <strong><see cref = "SharpDX.Direct3D12.HeapType"/></strong>_CUSTOM, <strong>CPUPageProperty</strong> and <strong>MemoryPoolPreference</strong> must not be ..._UNKNOWN. </li> <li> When <strong>Type</strong> is not D3D12_HEAP_TYPE_CUSTOM, <strong>CPUPageProperty</strong> and <strong>MemoryPoolPreference</strong> must be ..._UNKNOWN. </li> <li> When using D3D12_HEAP_TYPE_CUSTOM and <strong><see cref = "SharpDX.Direct3D12.MemoryPool"/></strong>_L1, on NUMA adapters, <strong>CPUPageProperty</strong> must be <strong><see cref = "SharpDX.Direct3D12.CpuPageProperty"/></strong>_NOT_AVAILABLE. To differentiate NUMA from UMA adapters, see <strong><see cref = "SharpDX.Direct3D12.Feature"/></strong>_ARCHITECTURE and <strong><see cref = "SharpDX.Direct3D12.FeatureDataArchitecture"/></strong>. </li> </ul>
    /// </remarks>
    /// <doc-id>dn770373</doc-id>
    /// <unmanaged>D3D12_HEAP_PROPERTIES</unmanaged>
    /// <unmanaged-short>D3D12_HEAP_PROPERTIES</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct HeapProperties
    {
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.HeapType"/></strong>-typed value that specifies the type of heap. </p> </dd>
        /// </summary>
        /// <doc-id>dn770373</doc-id>
        /// <unmanaged>Type</unmanaged>
        /// <unmanaged-short>Type</unmanaged-short>
        public SharpDX.Direct3D12.HeapType Type;
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.CpuPageProperty"/></strong>-typed value that specifies the CPU-page properties for the heap. </p> </dd>
        /// </summary>
        /// <doc-id>dn770373</doc-id>
        /// <unmanaged>CPUPageProperty</unmanaged>
        /// <unmanaged-short>CPUPageProperty</unmanaged-short>
        public SharpDX.Direct3D12.CpuPageProperty CPUPageProperty;
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.MemoryPool"/></strong>-typed value that specifies the memory pool for the heap. </p> </dd>
        /// </summary>
        /// <doc-id>dn770373</doc-id>
        /// <unmanaged>MemoryPoolPreference</unmanaged>
        /// <unmanaged-short>MemoryPoolPreference</unmanaged-short>
        public SharpDX.Direct3D12.MemoryPool MemoryPoolPreference;
        /// <summary>
        /// <dd> <p> For multi-adapter operation, this indicates the node where the resource should be created. Exactly one bit of this UINT must be set. See Multi-Adapter. </p> <p> Passing zero is equivalent to passing one, in order to simplify the usage of single-GPU adapters. </p> </dd>
        /// </summary>
        /// <doc-id>dn770373</doc-id>
        /// <unmanaged>CreationNodeMask</unmanaged>
        /// <unmanaged-short>CreationNodeMask</unmanaged-short>
        public System.Int32 CreationNodeMask;
        /// <summary>
        /// <dd> <p> For multi-adapter operation, this indicates the set of nodes where the resource is visible. <em>VisibleNodeMask</em> must have the same bits set as <em>CreationNodeMask</em> has. See Multi-Adapter. </p> <p> Passing zero is equivalent to passing one, in order to simplify the usage of single-GPU adapters. </p> </dd>
        /// </summary>
        /// <doc-id>dn770373</doc-id>
        /// <unmanaged>VisibleNodeMask</unmanaged>
        /// <unmanaged-short>VisibleNodeMask</unmanaged-short>
        public System.Int32 VisibleNodeMask;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_HIT_GROUP_DESC</unmanaged>
    /// <unmanaged-short>D3D12_HIT_GROUP_DESC</unmanaged-short>
    public partial struct HitGroupDescription
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>HitGroupExport</unmanaged>
        /// <unmanaged-short>HitGroupExport</unmanaged-short>
        public System.String HitGroupExport;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Type</unmanaged>
        /// <unmanaged-short>Type</unmanaged-short>
        public SharpDX.Direct3D12.HitGroupType Type;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>AnyHitShaderImport</unmanaged>
        /// <unmanaged-short>AnyHitShaderImport</unmanaged-short>
        public System.String AnyHitShaderImport;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>ClosestHitShaderImport</unmanaged>
        /// <unmanaged-short>ClosestHitShaderImport</unmanaged-short>
        public System.String ClosestHitShaderImport;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>IntersectionShaderImport</unmanaged>
        /// <unmanaged-short>IntersectionShaderImport</unmanaged-short>
        public System.String IntersectionShaderImport;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.IntPtr HitGroupExport;
            public SharpDX.Direct3D12.HitGroupType Type;
            public System.IntPtr AnyHitShaderImport;
            public System.IntPtr ClosestHitShaderImport;
            public System.IntPtr IntersectionShaderImport;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.HitGroupExport);
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.AnyHitShaderImport);
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.ClosestHitShaderImport);
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.IntersectionShaderImport);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            HitGroupExport = System.Runtime.InteropServices.Marshal.PtrToStringUni(@ref.HitGroupExport);
            Type = @ref.Type;
            AnyHitShaderImport = System.Runtime.InteropServices.Marshal.PtrToStringUni(@ref.AnyHitShaderImport);
            ClosestHitShaderImport = System.Runtime.InteropServices.Marshal.PtrToStringUni(@ref.ClosestHitShaderImport);
            IntersectionShaderImport = System.Runtime.InteropServices.Marshal.PtrToStringUni(@ref.IntersectionShaderImport);
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.HitGroupExport = System.Runtime.InteropServices.Marshal.StringToHGlobalUni(HitGroupExport);
            @ref.Type = Type;
            @ref.AnyHitShaderImport = System.Runtime.InteropServices.Marshal.StringToHGlobalUni(AnyHitShaderImport);
            @ref.ClosestHitShaderImport = System.Runtime.InteropServices.Marshal.StringToHGlobalUni(ClosestHitShaderImport);
            @ref.IntersectionShaderImport = System.Runtime.InteropServices.Marshal.StringToHGlobalUni(IntersectionShaderImport);
        }
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_INDEX_BUFFER_VIEW</unmanaged>
    /// <unmanaged-short>D3D12_INDEX_BUFFER_VIEW</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct IndexBufferView
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>BufferLocation</unmanaged>
        /// <unmanaged-short>BufferLocation</unmanaged-short>
        public System.Int64 BufferLocation;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>SizeInBytes</unmanaged>
        /// <unmanaged-short>SizeInBytes</unmanaged-short>
        public System.Int32 SizeInBytes;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Format</unmanaged>
        /// <unmanaged-short>Format</unmanaged-short>
        public SharpDX.DXGI.Format Format;
    }

    /// <summary>
    /// <p> Describes an indirect argument (an indirect parameter), for use with a command signature. </p>
    /// </summary>
    /// <remarks>
    /// <p> Use this structure with the <strong><see cref = "SharpDX.Direct3D12.CommandSignatureDescription"/></strong> structure. </p>
    /// </remarks>
    /// <doc-id>dn986733</doc-id>
    /// <unmanaged>D3D12_INDIRECT_ARGUMENT_DESC</unmanaged>
    /// <unmanaged-short>D3D12_INDIRECT_ARGUMENT_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Explicit, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct IndirectArgumentDescription
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>D3D12_INDIRECT_ARGUMENT_DESC_INNER_0_INNER_0</unmanaged>
        /// <unmanaged-short>D3D12_INDIRECT_ARGUMENT_DESC_INNER_0_INNER_0</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct VertexBufferArgument
        {
            /// <summary>
            /// No documentation.
            /// </summary>
            /// <unmanaged>Slot</unmanaged>
            /// <unmanaged-short>Slot</unmanaged-short>
            public System.Int32 Slot;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>D3D12_INDIRECT_ARGUMENT_DESC_INNER_0_INNER_1</unmanaged>
        /// <unmanaged-short>D3D12_INDIRECT_ARGUMENT_DESC_INNER_0_INNER_1</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct ConstantArgument
        {
            /// <summary>
            /// No documentation.
            /// </summary>
            /// <unmanaged>RootParameterIndex</unmanaged>
            /// <unmanaged-short>RootParameterIndex</unmanaged-short>
            public System.Int32 RootParameterIndex;
            /// <summary>
            /// No documentation.
            /// </summary>
            /// <unmanaged>DestOffsetIn32BitValues</unmanaged>
            /// <unmanaged-short>DestOffsetIn32BitValues</unmanaged-short>
            public System.Int32 DestOffsetIn32BitValues;
            /// <summary>
            /// No documentation.
            /// </summary>
            /// <unmanaged>Num32BitValuesToSet</unmanaged>
            /// <unmanaged-short>Num32BitValuesToSet</unmanaged-short>
            public System.Int32 Num32BitValuesToSet;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>D3D12_INDIRECT_ARGUMENT_DESC_INNER_0_INNER_2</unmanaged>
        /// <unmanaged-short>D3D12_INDIRECT_ARGUMENT_DESC_INNER_0_INNER_2</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct ConstantBufferArgument
        {
            /// <summary>
            /// No documentation.
            /// </summary>
            /// <unmanaged>RootParameterIndex</unmanaged>
            /// <unmanaged-short>RootParameterIndex</unmanaged-short>
            public System.Int32 RootParameterIndex;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>D3D12_INDIRECT_ARGUMENT_DESC_INNER_0_INNER_3</unmanaged>
        /// <unmanaged-short>D3D12_INDIRECT_ARGUMENT_DESC_INNER_0_INNER_3</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct ShaderResourceViewArgument
        {
            /// <summary>
            /// No documentation.
            /// </summary>
            /// <unmanaged>RootParameterIndex</unmanaged>
            /// <unmanaged-short>RootParameterIndex</unmanaged-short>
            public System.Int32 RootParameterIndex;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>D3D12_INDIRECT_ARGUMENT_DESC_INNER_0_INNER_4</unmanaged>
        /// <unmanaged-short>D3D12_INDIRECT_ARGUMENT_DESC_INNER_0_INNER_4</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct UnorderedAccessViewArgument
        {
            /// <summary>
            /// No documentation.
            /// </summary>
            /// <unmanaged>RootParameterIndex</unmanaged>
            /// <unmanaged-short>RootParameterIndex</unmanaged-short>
            public System.Int32 RootParameterIndex;
        }

        /// <summary>
        /// <dd> <p> A single <strong><see cref = "SharpDX.Direct3D12.IndirectArgumentType"/></strong> enumeration constant. </p> </dd>
        /// </summary>
        /// <doc-id>dn986733</doc-id>
        /// <unmanaged>Type</unmanaged>
        /// <unmanaged-short>Type</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(0)]
        public SharpDX.Direct3D12.IndirectArgumentType Type;
        /// <summary>
        /// <dd> <dl> <dt><strong>Slot</strong></dt> <dd> <p> Specifies the slot containing the vertex buffer address. </p> </dd> </dl> </dd>
        /// </summary>
        /// <doc-id>dn986733</doc-id>
        /// <unmanaged>VertexBuffer</unmanaged>
        /// <unmanaged-short>VertexBuffer</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(4)]
        public SharpDX.Direct3D12.IndirectArgumentDescription.VertexBufferArgument VertexBuffer;
        /// <summary>
        /// <dd> <dl> <dt><strong>RootParameterIndex</strong></dt> <dd> <p> Specifies the root index of the constant. </p> </dd> <dt><strong>DestOffsetIn32BitValues</strong></dt> <dd> <p> The offset, in 32-bit values, to set the first constant of the group. Supports multi-value constants at a given root index. Root constant entries must be sorted from smallest to largest DestOffsetIn32BitValues. </p> </dd> <dt><strong>Num32BitValuesToSet</strong></dt> <dd> <p> The number of 32-bit constants that are set at the given root index. Supports multi-value constants at a given root index. </p> </dd> </dl> </dd>
        /// </summary>
        /// <doc-id>dn986733</doc-id>
        /// <unmanaged>Constant</unmanaged>
        /// <unmanaged-short>Constant</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(4)]
        public SharpDX.Direct3D12.IndirectArgumentDescription.ConstantArgument Constant;
        /// <summary>
        /// <dd> <dl> <dt><strong>RootParameterIndex</strong></dt> <dd> <p> Specifies the root index of the CBV. </p> </dd> </dl> </dd>
        /// </summary>
        /// <doc-id>dn986733</doc-id>
        /// <unmanaged>ConstantBufferView</unmanaged>
        /// <unmanaged-short>ConstantBufferView</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(4)]
        public SharpDX.Direct3D12.IndirectArgumentDescription.ConstantBufferArgument ConstantBufferView;
        /// <summary>
        /// <dd> <dl> <dt><strong>RootParameterIndex</strong></dt> <dd> <p> Specifies the root index of the SRV. </p> </dd> </dl> </dd>
        /// </summary>
        /// <doc-id>dn986733</doc-id>
        /// <unmanaged>ShaderResourceView</unmanaged>
        /// <unmanaged-short>ShaderResourceView</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(4)]
        public SharpDX.Direct3D12.IndirectArgumentDescription.ShaderResourceViewArgument ShaderResourceView;
        /// <summary>
        /// <dd> <dl> <dt><strong>RootParameterIndex</strong></dt> <dd> <p> Specifies the root index of the UAV. </p> </dd> </dl> </dd>
        /// </summary>
        /// <doc-id>dn986733</doc-id>
        /// <unmanaged>UnorderedAccessView</unmanaged>
        /// <unmanaged-short>UnorderedAccessView</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(4)]
        public SharpDX.Direct3D12.IndirectArgumentDescription.UnorderedAccessViewArgument UnorderedAccessView;
    }

    /// <summary>
    /// <p> Debug message filter; contains a lists of message types to allow or deny.</p>
    /// </summary>
    /// <remarks>
    /// <p> For use with an <strong><see cref = "SharpDX.Direct3D12.InfoQueue"/></strong> Interface.</p>
    /// </remarks>
    /// <doc-id>dn950142</doc-id>
    /// <unmanaged>D3D12_INFO_QUEUE_FILTER</unmanaged>
    /// <unmanaged-short>D3D12_INFO_QUEUE_FILTER</unmanaged-short>
    public partial class InfoQueueFilter
    {
        /// <summary>
        /// <dd> <p> Specifies types of messages that you want to allow. See <strong><see cref = "SharpDX.Direct3D12.InfoQueueFilterDescription"/></strong>. </p> </dd>
        /// </summary>
        /// <doc-id>dn950142</doc-id>
        /// <unmanaged>AllowList</unmanaged>
        /// <unmanaged-short>AllowList</unmanaged-short>
        public SharpDX.Direct3D12.InfoQueueFilterDescription AllowList;
        /// <summary>
        /// <dd> <p> Specifies types of messages that you want to deny. </p> </dd>
        /// </summary>
        /// <doc-id>dn950142</doc-id>
        /// <unmanaged>DenyList</unmanaged>
        /// <unmanaged-short>DenyList</unmanaged-short>
        public SharpDX.Direct3D12.InfoQueueFilterDescription DenyList;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.Direct3D12.InfoQueueFilterDescription.__Native AllowList;
            public SharpDX.Direct3D12.InfoQueueFilterDescription.__Native DenyList;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            AllowList.__MarshalFree(ref @ref.AllowList);
            DenyList.__MarshalFree(ref @ref.DenyList);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            {
                AllowList = new SharpDX.Direct3D12.InfoQueueFilterDescription();
                AllowList.__MarshalFrom(ref @ref.AllowList);
            }

            {
                DenyList = new SharpDX.Direct3D12.InfoQueueFilterDescription();
                DenyList.__MarshalFrom(ref @ref.DenyList);
            }
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            AllowList.__MarshalTo(ref @ref.AllowList);
            DenyList.__MarshalTo(ref @ref.DenyList);
        }
    }

    /// <summary>
    /// <p> Allow or deny certain types of messages to pass through a filter.</p>
    /// </summary>
    /// <remarks>
    /// <p> For use with an <strong><see cref = "SharpDX.Direct3D12.InfoQueue"/></strong> Interface.</p>
    /// </remarks>
    /// <doc-id>dn950143</doc-id>
    /// <unmanaged>D3D12_INFO_QUEUE_FILTER_DESC</unmanaged>
    /// <unmanaged-short>D3D12_INFO_QUEUE_FILTER_DESC</unmanaged-short>
    public partial class InfoQueueFilterDescription
    {
        /// <summary>
        /// <dd> <p>Number of message categories to allow or deny. </p> </dd>
        /// </summary>
        /// <doc-id>dn950143</doc-id>
        /// <unmanaged>NumCategories</unmanaged>
        /// <unmanaged-short>NumCategories</unmanaged-short>
        internal System.Int32 CategorieCount;
        /// <summary>
        /// <dd> <p> Array of message categories to allow or deny. Array must have at least <em>NumCategories</em> members (see <strong><see cref = "SharpDX.Direct3D12.MessageCategory"/></strong>). </p> </dd>
        /// </summary>
        /// <doc-id>dn950143</doc-id>
        /// <unmanaged>pCategoryList</unmanaged>
        /// <unmanaged-short>pCategoryList</unmanaged-short>
        public System.IntPtr CategoryListPointer;
        /// <summary>
        /// <dd> <p> Number of message severity levels to allow or deny. </p> </dd>
        /// </summary>
        /// <doc-id>dn950143</doc-id>
        /// <unmanaged>NumSeverities</unmanaged>
        /// <unmanaged-short>NumSeverities</unmanaged-short>
        internal System.Int32 SeveritieCount;
        /// <summary>
        /// <dd> <p> Array of message severity levels to allow or deny. Array must have at least <em>NumSeverities</em> members (see <strong><see cref = "SharpDX.Direct3D12.MessageSeverity"/></strong>). </p> </dd>
        /// </summary>
        /// <doc-id>dn950143</doc-id>
        /// <unmanaged>pSeverityList</unmanaged>
        /// <unmanaged-short>pSeverityList</unmanaged-short>
        public System.IntPtr SeverityListPointer;
        /// <summary>
        /// <dd> <p> Number of message IDs to allow or deny. </p> </dd>
        /// </summary>
        /// <doc-id>dn950143</doc-id>
        /// <unmanaged>NumIDs</unmanaged>
        /// <unmanaged-short>NumIDs</unmanaged-short>
        internal System.Int32 IDCount;
        /// <summary>
        /// <dd> <p> Array of message IDs to allow or deny. Array must have at least <em>NumIDs</em> members (see <strong><see cref = "SharpDX.Direct3D12.MessageId"/></strong>). </p> </dd>
        /// </summary>
        /// <doc-id>dn950143</doc-id>
        /// <unmanaged>pIDList</unmanaged>
        /// <unmanaged-short>pIDList</unmanaged-short>
        public System.IntPtr IDListPointer;
    }

    /// <summary>
    /// <p>Describes a single element for the input-assembler stage of the graphics pipeline.</p>
    /// </summary>
    /// <remarks>
    /// <p>This structure is a member of the <strong><see cref = "SharpDX.Direct3D12.InputLayoutDescription"/></strong> structure. A pipeline state object contains a input-layout structure that defines one element being read from an input slot.</p>
    /// </remarks>
    /// <doc-id>dn770377</doc-id>
    /// <unmanaged>D3D12_INPUT_ELEMENT_DESC</unmanaged>
    /// <unmanaged-short>D3D12_INPUT_ELEMENT_DESC</unmanaged-short>
    public partial struct InputElement
    {
        /// <summary>
        /// <dd> <p>The HLSL semantic associated with this element in a shader input-signature.</p> </dd>
        /// </summary>
        /// <doc-id>dn770377</doc-id>
        /// <unmanaged>SemanticName</unmanaged>
        /// <unmanaged-short>SemanticName</unmanaged-short>
        public System.String SemanticName;
        /// <summary>
        /// <dd> <p>The semantic index for the element. A semantic index modifies a semantic, with an integer index number. A semantic index is only needed in a  case where there is more than one element with the same semantic. For example, a 4x4 matrix would have four components each with the semantic  name <strong>matrix</strong>, however each of the four component would have different semantic indices (0, 1, 2, and 3).</p> </dd>
        /// </summary>
        /// <doc-id>dn770377</doc-id>
        /// <unmanaged>SemanticIndex</unmanaged>
        /// <unmanaged-short>SemanticIndex</unmanaged-short>
        public System.Int32 SemanticIndex;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.DXGI.Format"/></strong>-typed value that specifies the format of the element data.</p> </dd>
        /// </summary>
        /// <doc-id>dn770377</doc-id>
        /// <unmanaged>Format</unmanaged>
        /// <unmanaged-short>Format</unmanaged-short>
        public SharpDX.DXGI.Format Format;
        /// <summary>
        /// <dd> <p>An integer value that identifies the input-assembler. For more info, see Input Slots. Valid values are between 0 and 15. </p> </dd>
        /// </summary>
        /// <doc-id>dn770377</doc-id>
        /// <unmanaged>InputSlot</unmanaged>
        /// <unmanaged-short>InputSlot</unmanaged-short>
        public System.Int32 Slot;
        /// <summary>
        /// <dd> <p>Optional. Offset, in bytes, between each element. Use D3D12_APPEND_ALIGNED_ELEMENT (0xffffffff) for convenience to define the current element directly  after the previous one, including any packing if necessary.</p> </dd>
        /// </summary>
        /// <doc-id>dn770377</doc-id>
        /// <unmanaged>AlignedByteOffset</unmanaged>
        /// <unmanaged-short>AlignedByteOffset</unmanaged-short>
        public System.Int32 AlignedByteOffset;
        /// <summary>
        /// <dd> <p>A value that identifies the input data class for a single input slot.</p> </dd>
        /// </summary>
        /// <doc-id>dn770377</doc-id>
        /// <unmanaged>InputSlotClass</unmanaged>
        /// <unmanaged-short>InputSlotClass</unmanaged-short>
        public SharpDX.Direct3D12.InputClassification Classification;
        /// <summary>
        /// <dd> <p>The number of instances to draw using the same per-instance data before advancing in the buffer by one element. This value must be 0 for an  element that contains per-vertex data (the slot class is set to the D3D12_INPUT_PER_VERTEX_DATA member of <strong><see cref = "SharpDX.Direct3D12.InputClassification"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>dn770377</doc-id>
        /// <unmanaged>InstanceDataStepRate</unmanaged>
        /// <unmanaged-short>InstanceDataStepRate</unmanaged-short>
        public System.Int32 InstanceDataStepRate;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.IntPtr SemanticName;
            public System.Int32 SemanticIndex;
            public SharpDX.DXGI.Format Format;
            public System.Int32 Slot;
            public System.Int32 AlignedByteOffset;
            public SharpDX.Direct3D12.InputClassification Classification;
            public System.Int32 InstanceDataStepRate;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.SemanticName);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            SemanticName = System.Runtime.InteropServices.Marshal.PtrToStringAnsi(@ref.SemanticName);
            SemanticIndex = @ref.SemanticIndex;
            Format = @ref.Format;
            Slot = @ref.Slot;
            AlignedByteOffset = @ref.AlignedByteOffset;
            Classification = @ref.Classification;
            InstanceDataStepRate = @ref.InstanceDataStepRate;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.SemanticName = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(SemanticName);
            @ref.SemanticIndex = SemanticIndex;
            @ref.Format = Format;
            @ref.Slot = Slot;
            @ref.AlignedByteOffset = AlignedByteOffset;
            @ref.Classification = Classification;
            @ref.InstanceDataStepRate = InstanceDataStepRate;
        }
    }

    /// <summary>
    /// <p>Describes the input-buffer data for the input-assembler stage.</p>
    /// </summary>
    /// <remarks>
    /// <p> This structure is a member of the <strong><see cref = "SharpDX.Direct3D12.GraphicsPipelineStateDescription"/></strong> structure.</p>
    /// </remarks>
    /// <doc-id>dn770378</doc-id>
    /// <unmanaged>D3D12_INPUT_LAYOUT_DESC</unmanaged>
    /// <unmanaged-short>D3D12_INPUT_LAYOUT_DESC</unmanaged-short>
    public partial class InputLayoutDescription
    {
        /// <summary>
        /// <dd> <p> An array of <strong><see cref = "SharpDX.Direct3D12.InputElement"/></strong> structures that describe the data types of the input-assembler stage. </p> </dd>
        /// </summary>
        /// <doc-id>dn770378</doc-id>
        /// <unmanaged>pInputElementDescs</unmanaged>
        /// <unmanaged-short>pInputElementDescs</unmanaged-short>
        private System.IntPtr InputElementsPointer;
        /// <summary>
        /// <dd> <p> The number of input-data types in the array of input elements that the <strong>pInputElementDescs</strong> member points to. </p> </dd>
        /// </summary>
        /// <doc-id>dn770378</doc-id>
        /// <unmanaged>NumElements</unmanaged>
        /// <unmanaged-short>NumElements</unmanaged-short>
        private System.Int32 ElementCount;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.IntPtr InputElementsPointer;
            public System.Int32 ElementCount;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            InputElementsPointer = @ref.InputElementsPointer;
            ElementCount = @ref.ElementCount;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.InputElementsPointer = InputElementsPointer;
            @ref.ElementCount = ElementCount;
        }
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_LOCAL_ROOT_SIGNATURE</unmanaged>
    /// <unmanaged-short>D3D12_LOCAL_ROOT_SIGNATURE</unmanaged-short>
    public partial struct LocalRootSignature
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>pLocalRootSignature</unmanaged>
        /// <unmanaged-short>pLocalRootSignature</unmanaged-short>
        public SharpDX.Direct3D12.RootSignature LocalRootSignaturePointer;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.IntPtr LocalRootSignaturePointer;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            if (@ref.LocalRootSignaturePointer != System.IntPtr.Zero)
                LocalRootSignaturePointer = new SharpDX.Direct3D12.RootSignature(@ref.LocalRootSignaturePointer);
            else
                LocalRootSignaturePointer = null;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.LocalRootSignaturePointer = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.RootSignature>(LocalRootSignaturePointer);
        }
    }

    /// <summary>
    /// <p> A debug message in the Information Queue.</p>
    /// </summary>
    /// <remarks>
    /// <p> This structure is returned from <strong>ID3D12InfoQueue::GetMessage</strong> as part of the Information Queue feature (see <strong><see cref = "SharpDX.Direct3D12.InfoQueue"/></strong>). </p>
    /// </remarks>
    /// <doc-id>dn950144</doc-id>
    /// <unmanaged>D3D12_MESSAGE</unmanaged>
    /// <unmanaged-short>D3D12_MESSAGE</unmanaged-short>
    public partial struct Message
    {
        /// <summary>
        /// <dd> <p> The category of the message. See <strong><see cref = "SharpDX.Direct3D12.MessageCategory"/></strong>. </p> </dd>
        /// </summary>
        /// <doc-id>dn950144</doc-id>
        /// <unmanaged>Category</unmanaged>
        /// <unmanaged-short>Category</unmanaged-short>
        public SharpDX.Direct3D12.MessageCategory Category;
        /// <summary>
        /// <dd> <p> The severity of the message. See  <strong><see cref = "SharpDX.Direct3D12.MessageSeverity"/></strong>. </p> </dd>
        /// </summary>
        /// <doc-id>dn950144</doc-id>
        /// <unmanaged>Severity</unmanaged>
        /// <unmanaged-short>Severity</unmanaged-short>
        public SharpDX.Direct3D12.MessageSeverity Severity;
        /// <summary>
        /// <dd> <p> The ID of the message. See <strong><see cref = "SharpDX.Direct3D12.MessageId"/></strong>. </p> </dd>
        /// </summary>
        /// <doc-id>dn950144</doc-id>
        /// <unmanaged>ID</unmanaged>
        /// <unmanaged-short>ID</unmanaged-short>
        public SharpDX.Direct3D12.MessageId Id;
        /// <summary>
        /// <dd> <p> The message string. </p> </dd>
        /// </summary>
        /// <doc-id>dn950144</doc-id>
        /// <unmanaged>pDescription</unmanaged>
        /// <unmanaged-short>pDescription</unmanaged-short>
        public System.String Description;
        /// <summary>
        /// <dd> <p> The length of <em>pDescription</em>, in bytes. </p> </dd>
        /// </summary>
        /// <doc-id>dn950144</doc-id>
        /// <unmanaged>DescriptionByteLength</unmanaged>
        /// <unmanaged-short>DescriptionByteLength</unmanaged-short>
        internal SharpDX.PointerSize DescriptionByteLength;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_META_COMMAND_DESC</unmanaged>
    /// <unmanaged-short>D3D12_META_COMMAND_DESC</unmanaged-short>
    public partial struct MetaCommandDescription
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Id</unmanaged>
        /// <unmanaged-short>Id</unmanaged-short>
        public System.Guid Id;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Name</unmanaged>
        /// <unmanaged-short>Name</unmanaged-short>
        public System.String Name;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>InitializationDirtyState</unmanaged>
        /// <unmanaged-short>InitializationDirtyState</unmanaged-short>
        public SharpDX.Direct3D12.GraphicsStates InitializationDirtyState;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>ExecutionDirtyState</unmanaged>
        /// <unmanaged-short>ExecutionDirtyState</unmanaged-short>
        public SharpDX.Direct3D12.GraphicsStates ExecutionDirtyState;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.Guid Id;
            public System.IntPtr Name;
            public SharpDX.Direct3D12.GraphicsStates InitializationDirtyState;
            public SharpDX.Direct3D12.GraphicsStates ExecutionDirtyState;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.Name);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Id = @ref.Id;
            Name = System.Runtime.InteropServices.Marshal.PtrToStringUni(@ref.Name);
            InitializationDirtyState = @ref.InitializationDirtyState;
            ExecutionDirtyState = @ref.ExecutionDirtyState;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Id = Id;
            @ref.Name = System.Runtime.InteropServices.Marshal.StringToHGlobalUni(Name);
            @ref.InitializationDirtyState = InitializationDirtyState;
            @ref.ExecutionDirtyState = ExecutionDirtyState;
        }
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_META_COMMAND_PARAMETER_DESC</unmanaged>
    /// <unmanaged-short>D3D12_META_COMMAND_PARAMETER_DESC</unmanaged-short>
    public partial struct MetaCommandParameterDescription
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Name</unmanaged>
        /// <unmanaged-short>Name</unmanaged-short>
        public System.String Name;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Type</unmanaged>
        /// <unmanaged-short>Type</unmanaged-short>
        public SharpDX.Direct3D12.MetaCommandParameterType Type;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Flags</unmanaged>
        /// <unmanaged-short>Flags</unmanaged-short>
        public SharpDX.Direct3D12.MetaCommandParameterFlags Flags;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>RequiredResourceState</unmanaged>
        /// <unmanaged-short>RequiredResourceState</unmanaged-short>
        public SharpDX.Direct3D12.ResourceStates RequiredResourceState;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>StructureOffset</unmanaged>
        /// <unmanaged-short>StructureOffset</unmanaged-short>
        public System.Int32 StructureOffset;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.IntPtr Name;
            public SharpDX.Direct3D12.MetaCommandParameterType Type;
            public SharpDX.Direct3D12.MetaCommandParameterFlags Flags;
            public SharpDX.Direct3D12.ResourceStates RequiredResourceState;
            public System.Int32 StructureOffset;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.Name);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Name = System.Runtime.InteropServices.Marshal.PtrToStringUni(@ref.Name);
            Type = @ref.Type;
            Flags = @ref.Flags;
            RequiredResourceState = @ref.RequiredResourceState;
            StructureOffset = @ref.StructureOffset;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Name = System.Runtime.InteropServices.Marshal.StringToHGlobalUni(Name);
            @ref.Type = Type;
            @ref.Flags = Flags;
            @ref.RequiredResourceState = RequiredResourceState;
            @ref.StructureOffset = StructureOffset;
        }
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_NODE_MASK</unmanaged>
    /// <unmanaged-short>D3D12_NODE_MASK</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct NodeMask
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>NodeMask</unmanaged>
        /// <unmanaged-short>NodeMask</unmanaged-short>
        public System.Int32 Mask;
    }

    /// <summary>
    /// <p> Describes the tile structure of a tiled resource with mipmaps. </p>
    /// </summary>
    /// <remarks>
    /// <p> This structure is used by the <strong>GetResourceTiling</strong> method. </p>
    /// </remarks>
    /// <doc-id>dn986736</doc-id>
    /// <unmanaged>D3D12_PACKED_MIP_INFO</unmanaged>
    /// <unmanaged-short>D3D12_PACKED_MIP_INFO</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct PackedMipInformation
    {
        /// <summary>
        /// <dd> <p> The number of standard mipmaps in the tiled resource. </p> </dd>
        /// </summary>
        /// <doc-id>dn986736</doc-id>
        /// <unmanaged>NumStandardMips</unmanaged>
        /// <unmanaged-short>NumStandardMips</unmanaged-short>
        public System.Byte StandardMipCount;
        /// <summary>
        /// <dd> <p> The number of packed mipmaps in the tiled resource. </p> <p> This number starts from the least detailed mipmap (either sharing tiles or using non standard tile layout). This number is 0 if no such packing is in the resource. For array surfaces, this value is the number of mipmaps that are packed for a given array slice where each array slice repeats the same packing. </p> <p> On Tier_2 tiled resources hardware, mipmaps that fill at least one standard shaped tile in all dimensions are not allowed to be included in the set of packed mipmaps. On Tier_1 hardware, mipmaps that are an integer multiple of one standard shaped tile in all dimensions are not allowed to be included in the set of packed mipmaps. Mipmaps with at least one dimension less than the standard tile shape may or may not be packed. When a given mipmap needs to be packed, all coarser mipmaps for a given array slice are considered packed as well. </p> </dd>
        /// </summary>
        /// <doc-id>dn986736</doc-id>
        /// <unmanaged>NumPackedMips</unmanaged>
        /// <unmanaged-short>NumPackedMips</unmanaged-short>
        public System.Byte PackedMipCount;
        /// <summary>
        /// <dd> <p> The number of tiles for the packed mipmaps in the tiled resource. </p> <p> If there is no packing, this value is meaningless and is set to 0. Otherwise, it is set to the number of tiles that are needed to represent the set of packed mipmaps. The pixel layout within the packed mipmaps is hardware specific. If apps define only partial mappings for the set of tiles in packed mipmaps, read and write behavior is vendor specific and undefined. For arrays, this value is only the count of packed mipmaps within the subresources for each array slice. </p> </dd>
        /// </summary>
        /// <doc-id>dn986736</doc-id>
        /// <unmanaged>NumTilesForPackedMips</unmanaged>
        /// <unmanaged-short>NumTilesForPackedMips</unmanaged-short>
        public System.Int32 TilesForPackedMipCount;
        /// <summary>
        /// <dd> <p> The offset of the first packed tile for the resource in the overall range of tiles. If <strong>NumPackedMips</strong> is 0, this value is meaningless and is 0. Otherwise, it is the offset of the first packed tile for the resource in the overall range of tiles for the resource. A value of 0 for <strong>StartTileIndexInOverallResource</strong> means the entire resource is packed. For array surfaces, this is the offset for the tiles that contain the packed mipmaps for the first array slice. Packed mipmaps for each array slice in arrayed surfaces are at this offset past the beginning of the tiles for each array slice. </p> <strong>Note</strong>?? The number of overall tiles, packed or not, for a given array slice is simply the total number of tiles for the resource divided by the resource's array size,  so it is easy to locate the range of tiles for any given array slice, out of which <strong>StartTileIndexInOverallResource</strong> identifies which of those are packed.  ? </dd>
        /// </summary>
        /// <doc-id>dn986736</doc-id>
        /// <unmanaged>StartTileIndexInOverallResource</unmanaged>
        /// <unmanaged-short>StartTileIndexInOverallResource</unmanaged-short>
        public System.Int32 StartTileIndexInOverallResource;
    }

    /// <summary>
    /// <p> Describes the layout of a root signature version 1.0. </p>
    /// </summary>
    /// <remarks>
    /// <p> This structure is used by the <strong>D3D12SerializeRootSignature</strong> function and is returned by the <strong>ID3D12RootSignatureDeserializer::GetRootSignatureDesc</strong> method. </p><p> There is one graphics root signature, and one compute root signature. </p>
    /// </remarks>
    /// <doc-id>dn986747</doc-id>
    /// <unmanaged>D3D12_PIPELINE_STATE_STREAM_DESC</unmanaged>
    /// <unmanaged-short>D3D12_PIPELINE_STATE_STREAM_DESC</unmanaged-short>
    public partial struct PipelineStateStreamDescription
    {
        /// <summary>
        /// <dd> <p> The number of slots in the root signature. This number is also the number of elements in the <em>pParameters</em> array. </p> </dd>
        /// </summary>
        /// <doc-id>dn986747</doc-id>
        /// <unmanaged>SizeInBytes</unmanaged>
        /// <unmanaged-short>SizeInBytes</unmanaged-short>
        public SharpDX.PointerSize SizeInBytes;
        /// <summary>
        /// <dd> <p> An array of <strong><see cref = "SharpDX.Direct3D12.RootParameter"/></strong> structures for the slots in the root signature. </p> </dd>
        /// </summary>
        /// <doc-id>dn986747</doc-id>
        /// <unmanaged>pPipelineStateSubobjectStream</unmanaged>
        /// <unmanaged-short>pPipelineStateSubobjectStream</unmanaged-short>
        public System.IntPtr PipelineStateSubobjectStreamPointer;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.IntPtr SizeInBytes;
            public System.IntPtr PipelineStateSubobjectStreamPointer;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            SizeInBytes = (SharpDX.PointerSize)@ref.SizeInBytes;
            PipelineStateSubobjectStreamPointer = @ref.PipelineStateSubobjectStreamPointer;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.SizeInBytes = (System.IntPtr)SizeInBytes;
            @ref.PipelineStateSubobjectStreamPointer = PipelineStateSubobjectStreamPointer;
        }
    }

    /// <summary>
    /// <p> Describes the footprint of a placed subresource, including the offset and the <see cref = "SharpDX.Direct3D12.SubResourceFootprint"/>. </p>
    /// </summary>
    /// <remarks>
    /// <p> This structure is used in the <strong><see cref = "SharpDX.Direct3D12.TextureCopyLocation"/></strong> structure, and by <strong>ID3D12Device::GetCopyableFootprints</strong>. </p><p> All the data referenced by the footprint structure must fit within the bounds of the parent resource. If you use <strong>GetCopyableFootprints</strong> to fill out the structure, the <em>pTotalBytes</em> output field indicates the required size of the resource.</p><p> This structure is also used a number of helper functions (refer to Helper Structures and Functions for D3D12).</p><p> When copying textures, use this structure along with <strong><see cref = "SharpDX.Direct3D12.TextureCopyLocation"/></strong>. </p>
    /// </remarks>
    /// <doc-id>dn986738</doc-id>
    /// <unmanaged>D3D12_PLACED_SUBRESOURCE_FOOTPRINT</unmanaged>
    /// <unmanaged-short>D3D12_PLACED_SUBRESOURCE_FOOTPRINT</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct PlacedSubResourceFootprint
    {
        /// <summary>
        /// <dd> <p> The offset of the subresource within the parent resource, in bytes. The offset between the start of the parent resource and this subresource. </p> </dd>
        /// </summary>
        /// <doc-id>dn986738</doc-id>
        /// <unmanaged>Offset</unmanaged>
        /// <unmanaged-short>Offset</unmanaged-short>
        public System.Int64 Offset;
        /// <summary>
        /// <dd> <p> The format, width, height, depth, and row-pitch of the subresource, as a <strong><see cref = "SharpDX.Direct3D12.SubResourceFootprint"/></strong> structure. </p> </dd>
        /// </summary>
        /// <doc-id>dn986738</doc-id>
        /// <unmanaged>Footprint</unmanaged>
        /// <unmanaged-short>Footprint</unmanaged-short>
        public SharpDX.Direct3D12.SubResourceFootprint Footprint;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_PROTECTED_RESOURCE_SESSION_DESC</unmanaged>
    /// <unmanaged-short>D3D12_PROTECTED_RESOURCE_SESSION_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct ProtectedResourceSessionDescription
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>NodeMask</unmanaged>
        /// <unmanaged-short>NodeMask</unmanaged-short>
        public System.Int32 NodeMask;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Flags</unmanaged>
        /// <unmanaged-short>Flags</unmanaged-short>
        public SharpDX.Direct3D12.ProtectedResourceSessionFlags Flags;
    }

    /// <summary>
    /// <p>Query information about graphics-pipeline activity in between calls to <strong>BeginQuery</strong> and <strong>EndQuery</strong>.</p>
    /// </summary>
    /// <remarks>
    /// <p>Use this structure with <strong><see cref = "SharpDX.Direct3D12.QueryHeapType"/></strong> and <strong>CreateQueryHeap</strong>.</p>
    /// </remarks>
    /// <doc-id>dn903808</doc-id>
    /// <unmanaged>D3D12_QUERY_DATA_PIPELINE_STATISTICS</unmanaged>
    /// <unmanaged-short>D3D12_QUERY_DATA_PIPELINE_STATISTICS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct QueryDataPipelineStatistics
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn903808</doc-id>
        /// <unmanaged>IAVertices</unmanaged>
        /// <unmanaged-short>IAVertices</unmanaged-short>
        public System.Int64 IAVerticeCount;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn903808</doc-id>
        /// <unmanaged>IAPrimitives</unmanaged>
        /// <unmanaged-short>IAPrimitives</unmanaged-short>
        public System.Int64 IAPrimitiveCount;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn903808</doc-id>
        /// <unmanaged>VSInvocations</unmanaged>
        /// <unmanaged-short>VSInvocations</unmanaged-short>
        public System.Int64 VSInvocationCount;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn903808</doc-id>
        /// <unmanaged>GSInvocations</unmanaged>
        /// <unmanaged-short>GSInvocations</unmanaged-short>
        public System.Int64 GSInvocationCount;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn903808</doc-id>
        /// <unmanaged>GSPrimitives</unmanaged>
        /// <unmanaged-short>GSPrimitives</unmanaged-short>
        public System.Int64 GSPrimitiveCount;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn903808</doc-id>
        /// <unmanaged>CInvocations</unmanaged>
        /// <unmanaged-short>CInvocations</unmanaged-short>
        public System.Int64 CInvocationCount;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn903808</doc-id>
        /// <unmanaged>CPrimitives</unmanaged>
        /// <unmanaged-short>CPrimitives</unmanaged-short>
        public System.Int64 CPrimitiveCount;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn903808</doc-id>
        /// <unmanaged>PSInvocations</unmanaged>
        /// <unmanaged-short>PSInvocations</unmanaged-short>
        public System.Int64 PSInvocationCount;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn903808</doc-id>
        /// <unmanaged>HSInvocations</unmanaged>
        /// <unmanaged-short>HSInvocations</unmanaged-short>
        public System.Int64 HSInvocationCount;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn903808</doc-id>
        /// <unmanaged>DSInvocations</unmanaged>
        /// <unmanaged-short>DSInvocations</unmanaged-short>
        public System.Int64 DSInvocationCount;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn903808</doc-id>
        /// <unmanaged>CSInvocations</unmanaged>
        /// <unmanaged-short>CSInvocations</unmanaged-short>
        public System.Int64 CSInvocationCount;
    }

    /// <summary>
    /// <p> Describes the purpose of a query heap.  A query heap contains an array of individual queries. </p>
    /// </summary>
    /// <remarks>
    /// <p> Use this structure with <strong>CreateQueryHeap</strong>. </p>
    /// </remarks>
    /// <doc-id>dn903810</doc-id>
    /// <unmanaged>D3D12_QUERY_HEAP_DESC</unmanaged>
    /// <unmanaged-short>D3D12_QUERY_HEAP_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct QueryHeapDescription
    {
        /// <summary>
        /// <dd> <p> Specifies one member of <strong><see cref = "SharpDX.Direct3D12.QueryHeapType"/></strong>. </p> </dd>
        /// </summary>
        /// <doc-id>dn903810</doc-id>
        /// <unmanaged>Type</unmanaged>
        /// <unmanaged-short>Type</unmanaged-short>
        public SharpDX.Direct3D12.QueryHeapType Type;
        /// <summary>
        /// <dd> <p> Specifies the number of queries the heap should contain. </p> </dd>
        /// </summary>
        /// <doc-id>dn903810</doc-id>
        /// <unmanaged>Count</unmanaged>
        /// <unmanaged-short>Count</unmanaged-short>
        public System.Int32 Count;
        /// <summary>
        /// <dd> <p> For single GPU operation, set this to zero. If there are multiple GPU nodes, set a bit to identify the node (the  device's physical adapter) to which the query heap applies. Each bit in the mask corresponds to a single node. Only 1 bit must be set. Refer to Multi-Adapter.</p> </dd>
        /// </summary>
        /// <doc-id>dn903810</doc-id>
        /// <unmanaged>NodeMask</unmanaged>
        /// <unmanaged-short>NodeMask</unmanaged-short>
        public System.Int32 NodeMask;
    }

    /// <summary>
    /// <p>Describes a memory range.</p>
    /// </summary>
    /// <remarks>
    /// <p><strong>End</strong> is one-past-the-end. When <strong>Begin</strong> equals <strong>End</strong>, the range is empty. The size of the range is (<strong>End</strong> - <strong>Begin</strong>). </p><p> This structure is used by the <strong>Map</strong> and <strong>Unmap</strong> methods. </p>
    /// </remarks>
    /// <doc-id>dn770386</doc-id>
    /// <unmanaged>D3D12_RANGE</unmanaged>
    /// <unmanaged-short>D3D12_RANGE</unmanaged-short>
    public partial struct Range
    {
        /// <summary>
        /// <dd> <p> The offset, in bytes, denoting the beginning of a memory range. </p> </dd>
        /// </summary>
        /// <doc-id>dn770386</doc-id>
        /// <unmanaged>Begin</unmanaged>
        /// <unmanaged-short>Begin</unmanaged-short>
        public SharpDX.PointerSize Begin;
        /// <summary>
        /// <dd> <p> The offset, in bytes, denoting the end of a memory range. <strong>End</strong> is one-past-the-end. </p> </dd>
        /// </summary>
        /// <doc-id>dn770386</doc-id>
        /// <unmanaged>End</unmanaged>
        /// <unmanaged-short>End</unmanaged-short>
        public SharpDX.PointerSize End;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.IntPtr Begin;
            public System.IntPtr End;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Begin = (SharpDX.PointerSize)@ref.Begin;
            End = (SharpDX.PointerSize)@ref.End;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Begin = (System.IntPtr)Begin;
            @ref.End = (System.IntPtr)End;
        }
    }

    /// <summary>
    /// <p> Describes the layout of a root signature version 1.0. </p>
    /// </summary>
    /// <remarks>
    /// <p> This structure is used by the <strong>D3D12SerializeRootSignature</strong> function and is returned by the <strong>ID3D12RootSignatureDeserializer::GetRootSignatureDesc</strong> method. </p><p> There is one graphics root signature, and one compute root signature. </p>
    /// </remarks>
    /// <doc-id>dn986747</doc-id>
    /// <unmanaged>D3D12_RANGE_UINT64</unmanaged>
    /// <unmanaged-short>D3D12_RANGE_UINT64</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct RangeUInt64
    {
        /// <summary>
        /// <dd> <p> The number of slots in the root signature. This number is also the number of elements in the <em>pParameters</em> array. </p> </dd>
        /// </summary>
        /// <doc-id>dn986747</doc-id>
        /// <unmanaged>Begin</unmanaged>
        /// <unmanaged-short>Begin</unmanaged-short>
        public System.Int64 Begin;
        /// <summary>
        /// <dd> <p> An array of <strong><see cref = "SharpDX.Direct3D12.RootParameter"/></strong> structures for the slots in the root signature. </p> </dd>
        /// </summary>
        /// <doc-id>dn986747</doc-id>
        /// <unmanaged>End</unmanaged>
        /// <unmanaged-short>End</unmanaged-short>
        public System.Int64 End;
    }

    /// <summary>
    /// <p>Describes rasterizer state.</p>
    /// </summary>
    /// <remarks>
    /// <p> A <strong><see cref = "SharpDX.Direct3D12.GraphicsPipelineStateDescription"/></strong> contains a rasterizer-state structure. </p><p> Rasterizer state defines the behavior of the rasterizer stage. </p><p> If you do not specify some rasterizer state,  the Direct3D runtime uses the following default values for rasterizer state. </p><table> <tr><th>State</th><th>Default Value</th></tr> <tr><td><strong>FillMode</strong></td><td>D3D12_FILL_MODE_SOLID</td></tr> <tr><td><strong>CullMode</strong></td><td>D3D12_CULL_MODE_BACK</td></tr> <tr><td><strong>FrontCounterClockwise</strong></td><td><strong><see cref = "SharpDX.Result.False"/></strong></td></tr> <tr><td><strong>DepthBias</strong></td><td>0</td></tr> <tr><td><strong>DepthBiasClamp</strong></td><td>0.0f</td></tr> <tr><td><strong>SlopeScaledDepthBias</strong></td><td>0.0f</td></tr> <tr><td><strong>DepthClipEnable</strong></td><td><strong>TRUE</strong></td></tr> <tr><td><strong>MultisampleEnable</strong></td><td><strong><see cref = "SharpDX.Result.False"/></strong></td></tr> <tr><td><strong>AntialiasedLineEnable</strong></td><td><strong><see cref = "SharpDX.Result.False"/></strong></td></tr> <tr><td><strong>ForcedSampleCount</strong></td><td>0</td></tr> <tr><td><strong>ConservativeRaster</strong></td><td><strong>D3D12_CONSERVATIVE_RASTERIZATION_MODE_OFF</strong></td></tr> </table><p>?</p>
    /// </remarks>
    /// <doc-id>dn770387</doc-id>
    /// <unmanaged>D3D12_RASTERIZER_DESC</unmanaged>
    /// <unmanaged-short>D3D12_RASTERIZER_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct RasterizerStateDescription
    {
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.FillMode"/></strong>-typed value that specifies the fill mode to use when rendering. </p> </dd>
        /// </summary>
        /// <doc-id>dn770387</doc-id>
        /// <unmanaged>FillMode</unmanaged>
        /// <unmanaged-short>FillMode</unmanaged-short>
        public SharpDX.Direct3D12.FillMode FillMode;
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.CullMode"/></strong>-typed value that specifies that triangles facing the specified direction are not drawn. </p> </dd>
        /// </summary>
        /// <doc-id>dn770387</doc-id>
        /// <unmanaged>CullMode</unmanaged>
        /// <unmanaged-short>CullMode</unmanaged-short>
        public SharpDX.Direct3D12.CullMode CullMode;
        /// <summary>
        /// <dd> <p> Determines if a triangle is front- or back-facing. If this member is <strong>TRUE</strong>, a triangle will be considered front-facing if its vertices are counter-clockwise on the render target and considered back-facing if they are clockwise. If this parameter is <strong><see cref = "SharpDX.Result.False"/></strong>, the opposite is true. </p> </dd>
        /// </summary>
        /// <doc-id>dn770387</doc-id>
        /// <unmanaged>FrontCounterClockwise</unmanaged>
        /// <unmanaged-short>FrontCounterClockwise</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsFrontCounterClockwise;
        /// <summary>
        /// <dd> <p> Depth value added to a given pixel. For info about depth bias, see Depth Bias. </p> </dd>
        /// </summary>
        /// <doc-id>dn770387</doc-id>
        /// <unmanaged>DepthBias</unmanaged>
        /// <unmanaged-short>DepthBias</unmanaged-short>
        public System.Int32 DepthBias;
        /// <summary>
        /// <dd> <p> Maximum depth bias of a pixel. For info about depth bias, see Depth Bias. </p> </dd>
        /// </summary>
        /// <doc-id>dn770387</doc-id>
        /// <unmanaged>DepthBiasClamp</unmanaged>
        /// <unmanaged-short>DepthBiasClamp</unmanaged-short>
        public System.Single DepthBiasClamp;
        /// <summary>
        /// <dd> <p> Scalar on a given pixel's slope. For info about depth bias, see Depth Bias. </p> </dd>
        /// </summary>
        /// <doc-id>dn770387</doc-id>
        /// <unmanaged>SlopeScaledDepthBias</unmanaged>
        /// <unmanaged-short>SlopeScaledDepthBias</unmanaged-short>
        public System.Single SlopeScaledDepthBias;
        /// <summary>
        /// <dd> <p> Specifies whether to enable clipping based on distance. </p> <p> The hardware always performs x and y clipping of rasterized coordinates. When <strong>DepthClipEnable</strong> is set to the default?<strong>TRUE</strong>, the hardware also clips the z value (that is, the hardware performs the last step of the following algorithm). </p> <code> 0 &lt; w
        /// -w &lt;= x &lt;= w (or arbitrarily wider range if implementation uses a guard band to reduce clipping burden)
        /// -w &lt;= y &lt;= w (or arbitrarily wider range if implementation uses a guard band to reduce clipping burden)
        /// 0 &lt;= z &lt;= w
        /// </code> <p> When you set <strong>DepthClipEnable</strong> to <strong><see cref = "SharpDX.Result.False"/></strong>, the hardware skips the z clipping (that is, the last step in the preceding algorithm). However, the hardware still performs the "0 &lt; w" clipping. When z clipping is disabled, improper depth ordering at the pixel level might result. However, when z clipping is disabled, stencil shadow implementations are simplified. In other words, you can avoid complex special-case handling for geometry that goes beyond the back clipping plane. </p> </dd>
        /// </summary>
        /// <doc-id>dn770387</doc-id>
        /// <unmanaged>DepthClipEnable</unmanaged>
        /// <unmanaged-short>DepthClipEnable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsDepthClipEnabled;
        /// <summary>
        /// <dd> <p> Specifies whether to use the quadrilateral or alpha line anti-aliasing algorithm on multisample antialiasing (MSAA) render targets. Set to <strong>TRUE</strong> to use the quadrilateral line anti-aliasing algorithm and to <strong><see cref = "SharpDX.Result.False"/></strong> to use the alpha line anti-aliasing algorithm. For more info about this member, see Remarks. </p> </dd>
        /// </summary>
        /// <doc-id>dn770387</doc-id>
        /// <unmanaged>MultisampleEnable</unmanaged>
        /// <unmanaged-short>MultisampleEnable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsMultisampleEnabled;
        /// <summary>
        /// <dd> <p> Specifies whether to enable line antialiasing; only applies if doing line drawing and <strong>MultisampleEnable</strong> is <strong><see cref = "SharpDX.Result.False"/></strong>. For more info about this member, see Remarks. </p> </dd>
        /// </summary>
        /// <doc-id>dn770387</doc-id>
        /// <unmanaged>AntialiasedLineEnable</unmanaged>
        /// <unmanaged-short>AntialiasedLineEnable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsAntialiasedLineEnabled;
        /// <summary>
        /// <dd> <p> The sample count that is forced while UAV rendering or rasterizing. Valid values are 0, 1, 2, 4, 8, and optionally 16. 0 indicates that the sample count is not forced. </p> </dd>
        /// </summary>
        /// <doc-id>dn770387</doc-id>
        /// <unmanaged>ForcedSampleCount</unmanaged>
        /// <unmanaged-short>ForcedSampleCount</unmanaged-short>
        public System.Int32 ForcedSampleCount;
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.ConservativeRasterizationMode"/></strong>-typed value that identifies whether conservative rasterization is on or off. </p> </dd>
        /// </summary>
        /// <doc-id>dn770387</doc-id>
        /// <unmanaged>ConservativeRaster</unmanaged>
        /// <unmanaged-short>ConservativeRaster</unmanaged-short>
        public SharpDX.Direct3D12.ConservativeRasterizationMode ConservativeRaster;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_RAYTRACING_AABB</unmanaged>
    /// <unmanaged-short>D3D12_RAYTRACING_AABB</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct RaytracingAabb
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MinX</unmanaged>
        /// <unmanaged-short>MinX</unmanaged-short>
        public System.Single MinX;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MinY</unmanaged>
        /// <unmanaged-short>MinY</unmanaged-short>
        public System.Single MinY;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MinZ</unmanaged>
        /// <unmanaged-short>MinZ</unmanaged-short>
        public System.Single MinZ;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MaxX</unmanaged>
        /// <unmanaged-short>MaxX</unmanaged-short>
        public System.Single MaxX;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MaxY</unmanaged>
        /// <unmanaged-short>MaxY</unmanaged-short>
        public System.Single MaxY;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MaxZ</unmanaged>
        /// <unmanaged-short>MaxZ</unmanaged-short>
        public System.Single MaxZ;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_COMPACTED_SIZE_DESC</unmanaged>
    /// <unmanaged-short>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_COMPACTED_SIZE_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct RaytracingAccelerationStructurePostbuildInformationCompactedSizeDescription
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>CompactedSizeInBytes</unmanaged>
        /// <unmanaged-short>CompactedSizeInBytes</unmanaged-short>
        public System.Int64 CompactedSizeInBytes;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_CURRENT_SIZE_DESC</unmanaged>
    /// <unmanaged-short>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_CURRENT_SIZE_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct RaytracingAccelerationStructurePostbuildInformationCurrentSizeDescription
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>CurrentSizeInBytes</unmanaged>
        /// <unmanaged-short>CurrentSizeInBytes</unmanaged-short>
        public System.Int64 CurrentSizeInBytes;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC</unmanaged>
    /// <unmanaged-short>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct RaytracingAccelerationStructurePostbuildInformationDescription
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>DestBuffer</unmanaged>
        /// <unmanaged-short>DestBuffer</unmanaged-short>
        public System.Int64 DestBuffer;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>InfoType</unmanaged>
        /// <unmanaged-short>InfoType</unmanaged-short>
        public SharpDX.Direct3D12.RaytracingAccelerationStructurePostbuildInformationType InfoType;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_SERIALIZATION_DESC</unmanaged>
    /// <unmanaged-short>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_SERIALIZATION_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct RaytracingAccelerationStructurePostbuildInformationSerializationDescription
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>SerializedSizeInBytes</unmanaged>
        /// <unmanaged-short>SerializedSizeInBytes</unmanaged-short>
        public System.Int64 SerializedSizeInBytes;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>NumBottomLevelAccelerationStructurePointers</unmanaged>
        /// <unmanaged-short>NumBottomLevelAccelerationStructurePointers</unmanaged-short>
        public System.Int64 BottomLevelAccelerationStructurePointerCount;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_TOOLS_VISUALIZATION_DESC</unmanaged>
    /// <unmanaged-short>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_TOOLS_VISUALIZATION_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct RaytracingAccelerationStructurePostbuildInformationToolSVisualizationDescription
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>DecodedSizeInBytes</unmanaged>
        /// <unmanaged-short>DecodedSizeInBytes</unmanaged-short>
        public System.Int64 DecodedSizeInBytes;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO</unmanaged>
    /// <unmanaged-short>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct RaytracingAccelerationStructurePrebuildInformation
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>ResultDataMaxSizeInBytes</unmanaged>
        /// <unmanaged-short>ResultDataMaxSizeInBytes</unmanaged-short>
        public System.Int64 ResultDataMaxSizeInBytes;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>ScratchDataSizeInBytes</unmanaged>
        /// <unmanaged-short>ScratchDataSizeInBytes</unmanaged-short>
        public System.Int64 ScratchDataSizeInBytes;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>UpdateScratchDataSizeInBytes</unmanaged>
        /// <unmanaged-short>UpdateScratchDataSizeInBytes</unmanaged-short>
        public System.Int64 UpdateScratchDataSizeInBytes;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_RAYTRACING_GEOMETRY_AABBS_DESC</unmanaged>
    /// <unmanaged-short>D3D12_RAYTRACING_GEOMETRY_AABBS_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct RaytracingGeometryAabbsDescription
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>AABBCount</unmanaged>
        /// <unmanaged-short>AABBCount</unmanaged-short>
        public System.Int64 AABBCount;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>AABBs</unmanaged>
        /// <unmanaged-short>AABBs</unmanaged-short>
        public SharpDX.Direct3D12.GpuVirtualAddressAndStride AABBs;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_RAYTRACING_GEOMETRY_DESC</unmanaged>
    /// <unmanaged-short>D3D12_RAYTRACING_GEOMETRY_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Explicit, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct RaytracingGeometryDescription
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Type</unmanaged>
        /// <unmanaged-short>Type</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(0)]
        public SharpDX.Direct3D12.RaytracingGeometryType Type;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Flags</unmanaged>
        /// <unmanaged-short>Flags</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(4)]
        public SharpDX.Direct3D12.RaytracingGeometryFlags Flags;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Triangles</unmanaged>
        /// <unmanaged-short>Triangles</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D12.RaytracingGeometryTriangleSDescription Triangles;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>AABBs</unmanaged>
        /// <unmanaged-short>AABBs</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D12.RaytracingGeometryAabbsDescription AABBs;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_RAYTRACING_GEOMETRY_TRIANGLES_DESC</unmanaged>
    /// <unmanaged-short>D3D12_RAYTRACING_GEOMETRY_TRIANGLES_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct RaytracingGeometryTriangleSDescription
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Transform3x4</unmanaged>
        /// <unmanaged-short>Transform3x4</unmanaged-short>
        public System.Int64 Transform3x4;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>IndexFormat</unmanaged>
        /// <unmanaged-short>IndexFormat</unmanaged-short>
        public SharpDX.DXGI.Format IndexFormat;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>VertexFormat</unmanaged>
        /// <unmanaged-short>VertexFormat</unmanaged-short>
        public SharpDX.DXGI.Format VertexFormat;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>IndexCount</unmanaged>
        /// <unmanaged-short>IndexCount</unmanaged-short>
        public System.Int32 IndexCount;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>VertexCount</unmanaged>
        /// <unmanaged-short>VertexCount</unmanaged-short>
        public System.Int32 VertexCount;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>IndexBuffer</unmanaged>
        /// <unmanaged-short>IndexBuffer</unmanaged-short>
        public System.Int64 IndexBuffer;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>VertexBuffer</unmanaged>
        /// <unmanaged-short>VertexBuffer</unmanaged-short>
        public SharpDX.Direct3D12.GpuVirtualAddressAndStride VertexBuffer;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_RAYTRACING_INSTANCE_DESC</unmanaged>
    /// <unmanaged-short>D3D12_RAYTRACING_INSTANCE_DESC</unmanaged-short>
    public partial struct RaytracingInstanceDescription
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Transform</unmanaged>
        /// <unmanaged-short>Transform</unmanaged-short>
        public System.Single[] Transform
        {
            get => _Transform ?? (_Transform = new System.Single[1]);
            private set => _Transform = value;
        }

        internal System.Single[] _Transform;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>InstanceID</unmanaged>
        /// <unmanaged-short>InstanceID</unmanaged-short>
        public System.Int32 InstanceID
        {
            get => (System.Int32)((_InstanceID >> 0) & 16777215);
            set => this._InstanceID = (System.Int32)((this._InstanceID & ~(16777215 << 0)) | ((value & 16777215) << 0));
        }

        internal System.Int32 _InstanceID;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>InstanceMask</unmanaged>
        /// <unmanaged-short>InstanceMask</unmanaged-short>
        public System.Int32 InstanceMask
        {
            get => (System.Int32)((_InstanceMask >> 24) & 255);
            set => this._InstanceMask = (System.Int32)((this._InstanceMask & ~(255 << 24)) | ((value & 255) << 24));
        }

        internal System.Int32 _InstanceMask;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>InstanceContributionToHitGroupIndex</unmanaged>
        /// <unmanaged-short>InstanceContributionToHitGroupIndex</unmanaged-short>
        public System.Int32 InstanceContributionToHitGroupIndex
        {
            get => (System.Int32)((_InstanceContributionToHitGroupIndex >> 32) & 16777215);
            set => this._InstanceContributionToHitGroupIndex = (System.Int32)((this._InstanceContributionToHitGroupIndex & ~(16777215 << 32)) | ((value & 16777215) << 32));
        }

        internal System.Int32 _InstanceContributionToHitGroupIndex;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Flags</unmanaged>
        /// <unmanaged-short>Flags</unmanaged-short>
        public System.Int32 Flags
        {
            get => (System.Int32)((_Flags >> 56) & 255);
            set => this._Flags = (System.Int32)((this._Flags & ~(255 << 56)) | ((value & 255) << 56));
        }

        internal System.Int32 _Flags;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>AccelerationStructure</unmanaged>
        /// <unmanaged-short>AccelerationStructure</unmanaged-short>
        public System.Int64 AccelerationStructure;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Explicit, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            [System.Runtime.InteropServices.FieldOffset(0)]
            public System.Single Transform;
            [System.Runtime.InteropServices.FieldOffset(4)]
            public System.Int32 InstanceID;
            [System.Runtime.InteropServices.FieldOffset(4)]
            public System.Int32 InstanceMask;
            [System.Runtime.InteropServices.FieldOffset(4)]
            public System.Int32 InstanceContributionToHitGroupIndex;
            [System.Runtime.InteropServices.FieldOffset(4)]
            public System.Int32 Flags;
            [System.Runtime.InteropServices.FieldOffset(8)]
            public System.Int64 AccelerationStructure;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            fixed (void *__to = &Transform[0], __from = &@ref.Transform)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 1 * sizeof (System.Single));
            _InstanceID = @ref.InstanceID;
            _InstanceMask = @ref.InstanceMask;
            _InstanceContributionToHitGroupIndex = @ref.InstanceContributionToHitGroupIndex;
            _Flags = @ref.Flags;
            AccelerationStructure = @ref.AccelerationStructure;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            fixed (void *__from = &Transform[0], __to = &@ref.Transform)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 1 * sizeof (System.Single));
            @ref.InstanceID |= (System.Int32)(_InstanceID & 16777215);
            @ref.InstanceMask |= (System.Int32)(_InstanceMask & -16777216);
            @ref.InstanceContributionToHitGroupIndex |= (System.Int32)(_InstanceContributionToHitGroupIndex & 16777215);
            @ref.Flags |= (System.Int32)(_Flags & -16777216);
            @ref.AccelerationStructure = AccelerationStructure;
        }
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_RAYTRACING_PIPELINE_CONFIG</unmanaged>
    /// <unmanaged-short>D3D12_RAYTRACING_PIPELINE_CONFIG</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct RaytracingPipelineConfig
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MaxTraceRecursionDepth</unmanaged>
        /// <unmanaged-short>MaxTraceRecursionDepth</unmanaged-short>
        public System.Int32 MaxTraceRecursionDepth;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_RAYTRACING_SHADER_CONFIG</unmanaged>
    /// <unmanaged-short>D3D12_RAYTRACING_SHADER_CONFIG</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct RaytracingShaderConfig
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MaxPayloadSizeInBytes</unmanaged>
        /// <unmanaged-short>MaxPayloadSizeInBytes</unmanaged-short>
        public System.Int32 MaxPayloadSizeInBytes;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MaxAttributeSizeInBytes</unmanaged>
        /// <unmanaged-short>MaxAttributeSizeInBytes</unmanaged-short>
        public System.Int32 MaxAttributeSizeInBytes;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_RENDER_PASS_BEGINNING_ACCESS</unmanaged>
    /// <unmanaged-short>D3D12_RENDER_PASS_BEGINNING_ACCESS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct RenderPassBeginningAccess
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Type</unmanaged>
        /// <unmanaged-short>Type</unmanaged-short>
        public SharpDX.Direct3D12.RenderPassBeginningAccessType Type;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Clear</unmanaged>
        /// <unmanaged-short>Clear</unmanaged-short>
        public SharpDX.Direct3D12.RenderPassBeginningAccessClearParameters Clear;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_RENDER_PASS_BEGINNING_ACCESS_CLEAR_PARAMETERS</unmanaged>
    /// <unmanaged-short>D3D12_RENDER_PASS_BEGINNING_ACCESS_CLEAR_PARAMETERS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct RenderPassBeginningAccessClearParameters
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>ClearValue</unmanaged>
        /// <unmanaged-short>ClearValue</unmanaged-short>
        public SharpDX.Direct3D12.ClearValue ClearValue;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_RENDER_PASS_DEPTH_STENCIL_DESC</unmanaged>
    /// <unmanaged-short>D3D12_RENDER_PASS_DEPTH_STENCIL_DESC</unmanaged-short>
    public partial struct RenderPassDepthStencilDescription
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>cpuDescriptor</unmanaged>
        /// <unmanaged-short>cpuDescriptor</unmanaged-short>
        public SharpDX.Direct3D12.CpuDescriptorHandle CpuDescriptor;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>DepthBeginningAccess</unmanaged>
        /// <unmanaged-short>DepthBeginningAccess</unmanaged-short>
        public SharpDX.Direct3D12.RenderPassBeginningAccess DepthBeginningAccess;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>StencilBeginningAccess</unmanaged>
        /// <unmanaged-short>StencilBeginningAccess</unmanaged-short>
        public SharpDX.Direct3D12.RenderPassBeginningAccess StencilBeginningAccess;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>DepthEndingAccess</unmanaged>
        /// <unmanaged-short>DepthEndingAccess</unmanaged-short>
        public SharpDX.Direct3D12.RenderPassEndingAccess DepthEndingAccess;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>StencilEndingAccess</unmanaged>
        /// <unmanaged-short>StencilEndingAccess</unmanaged-short>
        public SharpDX.Direct3D12.RenderPassEndingAccess StencilEndingAccess;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.Direct3D12.CpuDescriptorHandle.__Native CpuDescriptor;
            public SharpDX.Direct3D12.RenderPassBeginningAccess DepthBeginningAccess;
            public SharpDX.Direct3D12.RenderPassBeginningAccess StencilBeginningAccess;
            public SharpDX.Direct3D12.RenderPassEndingAccess.__Native DepthEndingAccess;
            public SharpDX.Direct3D12.RenderPassEndingAccess.__Native StencilEndingAccess;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            CpuDescriptor.__MarshalFree(ref @ref.CpuDescriptor);
            DepthEndingAccess.__MarshalFree(ref @ref.DepthEndingAccess);
            StencilEndingAccess.__MarshalFree(ref @ref.StencilEndingAccess);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            CpuDescriptor.__MarshalFrom(ref @ref.CpuDescriptor);
            DepthBeginningAccess = @ref.DepthBeginningAccess;
            StencilBeginningAccess = @ref.StencilBeginningAccess;
            DepthEndingAccess.__MarshalFrom(ref @ref.DepthEndingAccess);
            StencilEndingAccess.__MarshalFrom(ref @ref.StencilEndingAccess);
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            CpuDescriptor.__MarshalTo(ref @ref.CpuDescriptor);
            @ref.DepthBeginningAccess = DepthBeginningAccess;
            @ref.StencilBeginningAccess = StencilBeginningAccess;
            DepthEndingAccess.__MarshalTo(ref @ref.DepthEndingAccess);
            StencilEndingAccess.__MarshalTo(ref @ref.StencilEndingAccess);
        }
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_RENDER_PASS_ENDING_ACCESS</unmanaged>
    /// <unmanaged-short>D3D12_RENDER_PASS_ENDING_ACCESS</unmanaged-short>
    public partial struct RenderPassEndingAccess
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Type</unmanaged>
        /// <unmanaged-short>Type</unmanaged-short>
        public SharpDX.Direct3D12.RenderPassEndingAccessType Type;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Resolve</unmanaged>
        /// <unmanaged-short>Resolve</unmanaged-short>
        public SharpDX.Direct3D12.RenderPassEndingAccessResolveParameters Resolve;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.Direct3D12.RenderPassEndingAccessType Type;
            public SharpDX.Direct3D12.RenderPassEndingAccessResolveParameters.__Native Resolve;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            Resolve.__MarshalFree(ref @ref.Resolve);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Type = @ref.Type;
            Resolve.__MarshalFrom(ref @ref.Resolve);
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Type = Type;
            Resolve.__MarshalTo(ref @ref.Resolve);
        }
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_RENDER_PASS_ENDING_ACCESS_RESOLVE_PARAMETERS</unmanaged>
    /// <unmanaged-short>D3D12_RENDER_PASS_ENDING_ACCESS_RESOLVE_PARAMETERS</unmanaged-short>
    public partial struct RenderPassEndingAccessResolveParameters
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>pSrcResource</unmanaged>
        /// <unmanaged-short>pSrcResource</unmanaged-short>
        public SharpDX.Direct3D12.Resource SrcResourcePointer;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>pDstResource</unmanaged>
        /// <unmanaged-short>pDstResource</unmanaged-short>
        public SharpDX.Direct3D12.Resource DstResourcePointer;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>SubresourceCount</unmanaged>
        /// <unmanaged-short>SubresourceCount</unmanaged-short>
        public System.Int32 SubresourceCount;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>pSubresourceParameters</unmanaged>
        /// <unmanaged-short>pSubresourceParameters</unmanaged-short>
        public System.IntPtr SubresourceParametersPointer;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Format</unmanaged>
        /// <unmanaged-short>Format</unmanaged-short>
        public SharpDX.DXGI.Format Format;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>ResolveMode</unmanaged>
        /// <unmanaged-short>ResolveMode</unmanaged-short>
        public SharpDX.Direct3D12.ResolveMode ResolveMode;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>PreserveResolveSource</unmanaged>
        /// <unmanaged-short>PreserveResolveSource</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool PreserveResolveSource;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.IntPtr SrcResourcePointer;
            public System.IntPtr DstResourcePointer;
            public System.Int32 SubresourceCount;
            public System.IntPtr SubresourceParametersPointer;
            public SharpDX.DXGI.Format Format;
            public SharpDX.Direct3D12.ResolveMode ResolveMode;
            public SharpDX.Mathematics.Interop.RawBool PreserveResolveSource;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            if (@ref.SrcResourcePointer != System.IntPtr.Zero)
                SrcResourcePointer = new SharpDX.Direct3D12.Resource(@ref.SrcResourcePointer);
            else
                SrcResourcePointer = null;
            if (@ref.DstResourcePointer != System.IntPtr.Zero)
                DstResourcePointer = new SharpDX.Direct3D12.Resource(@ref.DstResourcePointer);
            else
                DstResourcePointer = null;
            SubresourceCount = @ref.SubresourceCount;
            SubresourceParametersPointer = @ref.SubresourceParametersPointer;
            Format = @ref.Format;
            ResolveMode = @ref.ResolveMode;
            PreserveResolveSource = @ref.PreserveResolveSource;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.SrcResourcePointer = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(SrcResourcePointer);
            @ref.DstResourcePointer = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D12.Resource>(DstResourcePointer);
            @ref.SubresourceCount = SubresourceCount;
            @ref.SubresourceParametersPointer = SubresourceParametersPointer;
            @ref.Format = Format;
            @ref.ResolveMode = ResolveMode;
            @ref.PreserveResolveSource = PreserveResolveSource;
        }
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_RENDER_PASS_ENDING_ACCESS_RESOLVE_SUBRESOURCE_PARAMETERS</unmanaged>
    /// <unmanaged-short>D3D12_RENDER_PASS_ENDING_ACCESS_RESOLVE_SUBRESOURCE_PARAMETERS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct RenderPassEndingAccessResolveSubResourceParameters
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>SrcSubresource</unmanaged>
        /// <unmanaged-short>SrcSubresource</unmanaged-short>
        public System.Int32 SrcSubresource;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>DstSubresource</unmanaged>
        /// <unmanaged-short>DstSubresource</unmanaged-short>
        public System.Int32 DstSubresource;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>DstX</unmanaged>
        /// <unmanaged-short>DstX</unmanaged-short>
        public System.Int32 DstX;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>DstY</unmanaged>
        /// <unmanaged-short>DstY</unmanaged-short>
        public System.Int32 DstY;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>SrcRect</unmanaged>
        /// <unmanaged-short>SrcRect</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawRectangle SrcRect;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_RENDER_PASS_RENDER_TARGET_DESC</unmanaged>
    /// <unmanaged-short>D3D12_RENDER_PASS_RENDER_TARGET_DESC</unmanaged-short>
    public partial struct RenderPassRenderTargetDescription
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>cpuDescriptor</unmanaged>
        /// <unmanaged-short>cpuDescriptor</unmanaged-short>
        public SharpDX.Direct3D12.CpuDescriptorHandle CpuDescriptor;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>BeginningAccess</unmanaged>
        /// <unmanaged-short>BeginningAccess</unmanaged-short>
        public SharpDX.Direct3D12.RenderPassBeginningAccess BeginningAccess;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>EndingAccess</unmanaged>
        /// <unmanaged-short>EndingAccess</unmanaged-short>
        public SharpDX.Direct3D12.RenderPassEndingAccess EndingAccess;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.Direct3D12.CpuDescriptorHandle.__Native CpuDescriptor;
            public SharpDX.Direct3D12.RenderPassBeginningAccess BeginningAccess;
            public SharpDX.Direct3D12.RenderPassEndingAccess.__Native EndingAccess;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            CpuDescriptor.__MarshalFree(ref @ref.CpuDescriptor);
            EndingAccess.__MarshalFree(ref @ref.EndingAccess);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            CpuDescriptor.__MarshalFrom(ref @ref.CpuDescriptor);
            BeginningAccess = @ref.BeginningAccess;
            EndingAccess.__MarshalFrom(ref @ref.EndingAccess);
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            CpuDescriptor.__MarshalTo(ref @ref.CpuDescriptor);
            @ref.BeginningAccess = BeginningAccess;
            EndingAccess.__MarshalTo(ref @ref.EndingAccess);
        }
    }

    /// <summary>
    /// <p>Describes the blend state for a render target.</p>
    /// </summary>
    /// <remarks>
    /// <p>You specify an array of <strong><see cref = "SharpDX.Direct3D12.RenderTargetBlendDescription"/></strong> structures in the <strong>RenderTarget</strong> member of the <strong><see cref = "SharpDX.Direct3D12.BlendStateDescription"/></strong> structure to describe the blend states for render targets; you can bind up to eight render targets to the output-merger stage at one time.</p><p>For info about how blending is done, see the output-merger stage.</p><p>Here are the default values for blend state.</p><table> <tr><th>State</th><th>Default Value</th></tr> <tr><td>BlendEnable</td><td><see cref = "SharpDX.Result.False"/></td></tr> <tr><td>LogicOpEnable</td><td><see cref = "SharpDX.Result.False"/></td></tr> <tr><td>SrcBlend</td><td>D3D12_BLEND_ONE</td></tr> <tr><td>DestBlend</td><td>D3D12_BLEND_ZERO</td></tr> <tr><td>BlendOp</td><td>D3D12_BLEND_OP_ADD</td></tr> <tr><td>SrcBlendAlpha</td><td>D3D12_BLEND_ONE</td></tr> <tr><td>DestBlendAlpha</td><td>D3D12_BLEND_ZERO</td></tr> <tr><td>BlendOpAlpha</td><td>D3D12_BLEND_OP_ADD</td></tr> <tr><td>LogicOp</td><td>D3D12_LOGIC_OP_NOOP</td></tr> <tr><td>RenderTargetWriteMask</td><td>D3D12_COLOR_WRITE_ENABLE_ALL</td></tr> </table><p>?</p>
    /// </remarks>
    /// <doc-id>dn770388</doc-id>
    /// <unmanaged>D3D12_RENDER_TARGET_BLEND_DESC</unmanaged>
    /// <unmanaged-short>D3D12_RENDER_TARGET_BLEND_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct RenderTargetBlendDescription
    {
        /// <summary>
        /// <dd> <p>Specifies whether to enable (or disable) blending. Set to <strong>TRUE</strong> to enable blending.</p> </dd>
        /// </summary>
        /// <doc-id>dn770388</doc-id>
        /// <unmanaged>BlendEnable</unmanaged>
        /// <unmanaged-short>BlendEnable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsBlendEnabled;
        /// <summary>
        /// <dd> <p>Specifies whether to enable (or disable) a logical operation. Set to <strong>TRUE</strong> to enable a logical operation.</p> </dd>
        /// </summary>
        /// <doc-id>dn770388</doc-id>
        /// <unmanaged>LogicOpEnable</unmanaged>
        /// <unmanaged-short>LogicOpEnable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool LogicOpEnable;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D12.BlendOption"/></strong>-typed value that specifies the operation to perform on the RGB value that the pixel shader outputs. The <strong>BlendOp</strong> member defines how to combine the <strong>SrcBlend</strong> and <strong>DestBlend</strong> operations.</p> </dd>
        /// </summary>
        /// <doc-id>dn770388</doc-id>
        /// <unmanaged>SrcBlend</unmanaged>
        /// <unmanaged-short>SrcBlend</unmanaged-short>
        public SharpDX.Direct3D12.BlendOption SourceBlend;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D12.BlendOption"/></strong>-typed value that specifies the operation to perform on the current RGB value in the render target. The <strong>BlendOp</strong> member defines how to combine the <strong>SrcBlend</strong> and <strong>DestBlend</strong> operations.</p> </dd>
        /// </summary>
        /// <doc-id>dn770388</doc-id>
        /// <unmanaged>DestBlend</unmanaged>
        /// <unmanaged-short>DestBlend</unmanaged-short>
        public SharpDX.Direct3D12.BlendOption DestinationBlend;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D12.BlendOperation"/></strong>-typed value that defines how to combine the <strong>SrcBlend</strong> and <strong>DestBlend</strong> operations.</p> </dd>
        /// </summary>
        /// <doc-id>dn770388</doc-id>
        /// <unmanaged>BlendOp</unmanaged>
        /// <unmanaged-short>BlendOp</unmanaged-short>
        public SharpDX.Direct3D12.BlendOperation BlendOperation;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D12.BlendOption"/></strong>-typed value that specifies the operation to perform on the alpha value that the pixel shader outputs. Blend options that end in _COLOR are not allowed. The <strong>BlendOpAlpha</strong> member defines how to combine the <strong>SrcBlendAlpha</strong> and <strong>DestBlendAlpha</strong> operations.</p> </dd>
        /// </summary>
        /// <doc-id>dn770388</doc-id>
        /// <unmanaged>SrcBlendAlpha</unmanaged>
        /// <unmanaged-short>SrcBlendAlpha</unmanaged-short>
        public SharpDX.Direct3D12.BlendOption SourceAlphaBlend;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D12.BlendOption"/></strong>-typed value that specifies the operation to perform on the current alpha value in the render target. Blend options that end in _COLOR are not allowed. The <strong>BlendOpAlpha</strong> member defines how to combine the <strong>SrcBlendAlpha</strong> and <strong>DestBlendAlpha</strong> operations.</p> </dd>
        /// </summary>
        /// <doc-id>dn770388</doc-id>
        /// <unmanaged>DestBlendAlpha</unmanaged>
        /// <unmanaged-short>DestBlendAlpha</unmanaged-short>
        public SharpDX.Direct3D12.BlendOption DestinationAlphaBlend;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D12.BlendOperation"/></strong>-typed value that defines how to combine the <strong>SrcBlendAlpha</strong> and <strong>DestBlendAlpha</strong> operations.</p> </dd>
        /// </summary>
        /// <doc-id>dn770388</doc-id>
        /// <unmanaged>BlendOpAlpha</unmanaged>
        /// <unmanaged-short>BlendOpAlpha</unmanaged-short>
        public SharpDX.Direct3D12.BlendOperation AlphaBlendOperation;
        /// <summary>
        /// <dd> <p>A  <strong><see cref = "SharpDX.Direct3D12.LogicOperation"/></strong>-typed value that specifies the logical operation to configure for the render target.</p> </dd>
        /// </summary>
        /// <doc-id>dn770388</doc-id>
        /// <unmanaged>LogicOp</unmanaged>
        /// <unmanaged-short>LogicOp</unmanaged-short>
        public SharpDX.Direct3D12.LogicOperation LogicOp;
        /// <summary>
        /// <dd> <p>A combination of <strong><see cref = "SharpDX.Direct3D12.ColorWriteMaskFlags"/></strong>-typed values that are combined by using a bitwise OR operation. The resulting value specifies a write mask.</p> </dd>
        /// </summary>
        /// <doc-id>dn770388</doc-id>
        /// <unmanaged>RenderTargetWriteMask</unmanaged>
        /// <unmanaged-short>RenderTargetWriteMask</unmanaged-short>
        public SharpDX.Direct3D12.ColorWriteMaskFlags RenderTargetWriteMask;
    }

    /// <summary>
    /// <p>Describes the subresources from a resource that are accessible by using a render-target view.</p>
    /// </summary>
    /// <remarks>
    /// <p>Pass a render-target-view description into <strong>ID3D12Device::CreateRenderTargetView</strong> to create a render-target view.</p><p>A render-target view can't use the following formats:</p><ul> <li>Any typeless format.</li> <li>DXGI_FORMAT_R32G32B32 if the view will be used to bind a buffer (vertex, index, constant, or stream-output).</li> </ul><p>If the format is set to DXGI_FORMAT_UNKNOWN, then the format of the resource that the view binds to the pipeline will be used.</p>
    /// </remarks>
    /// <doc-id>dn770389</doc-id>
    /// <unmanaged>D3D12_RENDER_TARGET_VIEW_DESC</unmanaged>
    /// <unmanaged-short>D3D12_RENDER_TARGET_VIEW_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Explicit, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct RenderTargetViewDescription
    {
        /// <summary>
        /// <p>Describes the elements in a buffer resource to use in a render-target view.</p>
        /// </summary>
        /// <remarks>
        /// <p>Use this structure with a <strong><see cref = "SharpDX.Direct3D12.RenderTargetViewDescription"/></strong> structure to view the resource as a buffer.</p>
        /// </remarks>
        /// <doc-id>dn770342</doc-id>
        /// <unmanaged>D3D12_BUFFER_RTV</unmanaged>
        /// <unmanaged-short>D3D12_BUFFER_RTV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct BufferResource
        {
            /// <summary>
            /// <dd> <p>Number of bytes between the beginning of the buffer and the first element to access.</p> </dd>
            /// </summary>
            /// <doc-id>dn770342</doc-id>
            /// <unmanaged>FirstElement</unmanaged>
            /// <unmanaged-short>FirstElement</unmanaged-short>
            public System.Int64 FirstElement;
            /// <summary>
            /// <dd> <p>The total number of elements in the view.</p> </dd>
            /// </summary>
            /// <doc-id>dn770342</doc-id>
            /// <unmanaged>NumElements</unmanaged>
            /// <unmanaged-short>NumElements</unmanaged-short>
            public System.Int32 ElementCount;
        }

        /// <summary>
        /// <p>Describes the subresource from a 1D texture to use in a render-target view.</p>
        /// </summary>
        /// <remarks>
        /// <p>Use this structure with a <strong><see cref = "SharpDX.Direct3D12.RenderTargetViewDescription"/></strong> structure to view the resource as a 1D texture.</p>
        /// </remarks>
        /// <doc-id>dn770419</doc-id>
        /// <unmanaged>D3D12_TEX1D_RTV</unmanaged>
        /// <unmanaged-short>D3D12_TEX1D_RTV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture1DResource
        {
            /// <summary>
            /// <dd> <p>The index of the mipmap level to use mip slice.</p> </dd>
            /// </summary>
            /// <doc-id>dn770419</doc-id>
            /// <unmanaged>MipSlice</unmanaged>
            /// <unmanaged-short>MipSlice</unmanaged-short>
            public System.Int32 MipSlice;
        }

        /// <summary>
        /// <p>Describes the subresources from an array of 1D textures to use in a render-target view.</p>
        /// </summary>
        /// <remarks>
        /// <p>Use this structure with a <strong><see cref = "SharpDX.Direct3D12.RenderTargetViewDescription"/></strong> structure to view the resource as an array of 1D textures.</p>
        /// </remarks>
        /// <doc-id>dn770415</doc-id>
        /// <unmanaged>D3D12_TEX1D_ARRAY_RTV</unmanaged>
        /// <unmanaged-short>D3D12_TEX1D_ARRAY_RTV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture1DArrayResource
        {
            /// <summary>
            /// <dd> <p>The index of the mipmap level to use mip slice.</p> </dd>
            /// </summary>
            /// <doc-id>dn770415</doc-id>
            /// <unmanaged>MipSlice</unmanaged>
            /// <unmanaged-short>MipSlice</unmanaged-short>
            public System.Int32 MipSlice;
            /// <summary>
            /// <dd> <p>The index of the first texture to use in an array of textures.</p> </dd>
            /// </summary>
            /// <doc-id>dn770415</doc-id>
            /// <unmanaged>FirstArraySlice</unmanaged>
            /// <unmanaged-short>FirstArraySlice</unmanaged-short>
            public System.Int32 FirstArraySlice;
            /// <summary>
            /// <dd> <p>Number of textures to use.</p> </dd>
            /// </summary>
            /// <doc-id>dn770415</doc-id>
            /// <unmanaged>ArraySize</unmanaged>
            /// <unmanaged-short>ArraySize</unmanaged-short>
            public System.Int32 ArraySize;
        }

        /// <summary>
        /// <p>Describes the subresource from a 2D texture to use in a render-target view.</p>
        /// </summary>
        /// <remarks>
        /// <p> Use this structure with a <strong><see cref = "SharpDX.Direct3D12.RenderTargetViewDescription"/></strong> structure to view the resource as a 2D texture. </p>
        /// </remarks>
        /// <doc-id>dn770433</doc-id>
        /// <unmanaged>D3D12_TEX2D_RTV</unmanaged>
        /// <unmanaged-short>D3D12_TEX2D_RTV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture2DResource
        {
            /// <summary>
            /// <dd> <p>The index of the mipmap level to use.</p> </dd>
            /// </summary>
            /// <doc-id>dn770433</doc-id>
            /// <unmanaged>MipSlice</unmanaged>
            /// <unmanaged-short>MipSlice</unmanaged-short>
            public System.Int32 MipSlice;
            /// <summary>
            /// <dd> <p> The index (plane slice number) of the plane to use in the texture. </p> </dd>
            /// </summary>
            /// <doc-id>dn770433</doc-id>
            /// <unmanaged>PlaneSlice</unmanaged>
            /// <unmanaged-short>PlaneSlice</unmanaged-short>
            public System.Int32 PlaneSlice;
        }

        /// <summary>
        /// <p>Describes the subresource from a multi sampled 2D texture to use in a render-target view.</p>
        /// </summary>
        /// <remarks>
        /// <p>This structure is a member of the <strong><see cref = "SharpDX.Direct3D12.RenderTargetViewDescription"/></strong> structure.</p><p>Because a multi sampled 2D texture contains a single subresource, there is actually nothing to specify in <strong><see cref = "SharpDX.Direct3D12.Texture2DMultisampledResource"/></strong>. Consequently, <strong>UnusedField_NothingToDefine</strong> is included so that this structure will compile in C. </p>
        /// </remarks>
        /// <doc-id>dn770426</doc-id>
        /// <unmanaged>D3D12_TEX2DMS_RTV</unmanaged>
        /// <unmanaged-short>D3D12_TEX2DMS_RTV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture2DMultisampledResource
        {
            /// <summary>
            /// <dd> <p>Integer of any value. See remarks.</p> </dd>
            /// </summary>
            /// <doc-id>dn770426</doc-id>
            /// <unmanaged>UnusedField_NothingToDefine</unmanaged>
            /// <unmanaged-short>UnusedField_NothingToDefine</unmanaged-short>
            public System.Int32 UnusedFieldNothingToDefine;
        }

        /// <summary>
        /// <p>Describes the subresources from an array of 2D textures to use in a render-target view.</p>
        /// </summary>
        /// <remarks>
        /// <p> Use this structure with a <strong><see cref = "SharpDX.Direct3D12.RenderTargetViewDescription"/></strong> structure to view the resource as an array of 2D textures. </p>
        /// </remarks>
        /// <doc-id>dn770429</doc-id>
        /// <unmanaged>D3D12_TEX2D_ARRAY_RTV</unmanaged>
        /// <unmanaged-short>D3D12_TEX2D_ARRAY_RTV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture2DArrayResource
        {
            /// <summary>
            /// <dd> <p>The index of the mipmap level to use mip slice.</p> </dd>
            /// </summary>
            /// <doc-id>dn770429</doc-id>
            /// <unmanaged>MipSlice</unmanaged>
            /// <unmanaged-short>MipSlice</unmanaged-short>
            public System.Int32 MipSlice;
            /// <summary>
            /// <dd> <p>The index of the first texture to use in an array of textures.</p> </dd>
            /// </summary>
            /// <doc-id>dn770429</doc-id>
            /// <unmanaged>FirstArraySlice</unmanaged>
            /// <unmanaged-short>FirstArraySlice</unmanaged-short>
            public System.Int32 FirstArraySlice;
            /// <summary>
            /// <dd> <p> Number of textures in the array to use in the render target view, starting from <strong>FirstArraySlice</strong>. </p> </dd>
            /// </summary>
            /// <doc-id>dn770429</doc-id>
            /// <unmanaged>ArraySize</unmanaged>
            /// <unmanaged-short>ArraySize</unmanaged-short>
            public System.Int32 ArraySize;
            /// <summary>
            /// <dd> <p> The index (plane slice number) of the plane to use in an array of textures. </p> </dd>
            /// </summary>
            /// <doc-id>dn770429</doc-id>
            /// <unmanaged>PlaneSlice</unmanaged>
            /// <unmanaged-short>PlaneSlice</unmanaged-short>
            public System.Int32 PlaneSlice;
        }

        /// <summary>
        /// <p> Describes the subresources from an array of multi sampled 2D textures to use in a render-target view. </p>
        /// </summary>
        /// <remarks>
        /// <p> Use this structure with a <strong><see cref = "SharpDX.Direct3D12.RenderTargetViewDescription"/></strong> structure to view the resource as an array of multi sampled 2D textures. </p>
        /// </remarks>
        /// <doc-id>dn770423</doc-id>
        /// <unmanaged>D3D12_TEX2DMS_ARRAY_RTV</unmanaged>
        /// <unmanaged-short>D3D12_TEX2DMS_ARRAY_RTV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture2DMultisampledArrayResource
        {
            /// <summary>
            /// <dd> <p> The index of the first texture to use in an array of textures. </p> </dd>
            /// </summary>
            /// <doc-id>dn770423</doc-id>
            /// <unmanaged>FirstArraySlice</unmanaged>
            /// <unmanaged-short>FirstArraySlice</unmanaged-short>
            public System.Int32 FirstArraySlice;
            /// <summary>
            /// <dd> <p> The number of textures to use. </p> </dd>
            /// </summary>
            /// <doc-id>dn770423</doc-id>
            /// <unmanaged>ArraySize</unmanaged>
            /// <unmanaged-short>ArraySize</unmanaged-short>
            public System.Int32 ArraySize;
        }

        /// <summary>
        /// <p>Describes the subresources from a 3D texture to use in a render-target view.</p>
        /// </summary>
        /// <remarks>
        /// <p>Use this structure with a <strong><see cref = "SharpDX.Direct3D12.RenderTargetViewDescription"/></strong> structure to view the resource as a 3D texture.</p>
        /// </remarks>
        /// <doc-id>dn770436</doc-id>
        /// <unmanaged>D3D12_TEX3D_RTV</unmanaged>
        /// <unmanaged-short>D3D12_TEX3D_RTV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture3DResource
        {
            /// <summary>
            /// <dd> <p>The index of the mipmap level to use mip slice.</p> </dd>
            /// </summary>
            /// <doc-id>dn770436</doc-id>
            /// <unmanaged>MipSlice</unmanaged>
            /// <unmanaged-short>MipSlice</unmanaged-short>
            public System.Int32 MipSlice;
            /// <summary>
            /// <dd> <p>First depth level to use.</p> </dd>
            /// </summary>
            /// <doc-id>dn770436</doc-id>
            /// <unmanaged>FirstWSlice</unmanaged>
            /// <unmanaged-short>FirstWSlice</unmanaged-short>
            public System.Int32 FirstDepthSlice;
            /// <summary>
            /// <dd> <p>Number of depth levels to use in the render-target view, starting from <strong>FirstWSlice</strong>. A value of -1 indicates all of the slices along the w axis, starting from <strong>FirstWSlice</strong>.</p> </dd>
            /// </summary>
            /// <doc-id>dn770436</doc-id>
            /// <unmanaged>WSize</unmanaged>
            /// <unmanaged-short>WSize</unmanaged-short>
            public System.Int32 DepthSliceCount;
        }

        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.DXGI.Format"/></strong>-typed value that specifies the viewing format.</p> </dd>
        /// </summary>
        /// <doc-id>dn770389</doc-id>
        /// <unmanaged>Format</unmanaged>
        /// <unmanaged-short>Format</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(0)]
        public SharpDX.DXGI.Format Format;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D12.RenderTargetViewDimension"/></strong>-typed value that specifies how the render-target resource will be accessed. This type specifies how the resource will be accessed. This member also determines which _RTV to use in the following union.</p> </dd>
        /// </summary>
        /// <doc-id>dn770389</doc-id>
        /// <unmanaged>ViewDimension</unmanaged>
        /// <unmanaged-short>ViewDimension</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(4)]
        public SharpDX.Direct3D12.RenderTargetViewDimension Dimension;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D12.BufferResource"/></strong> structure that specifies which buffer elements can be accessed.</p> </dd>
        /// </summary>
        /// <doc-id>dn770389</doc-id>
        /// <unmanaged>Buffer</unmanaged>
        /// <unmanaged-short>Buffer</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D12.RenderTargetViewDescription.BufferResource Buffer;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D12.Texture1DResource"/></strong> structure that specifies the subresources in a 1D texture that can be accessed.</p> </dd>
        /// </summary>
        /// <doc-id>dn770389</doc-id>
        /// <unmanaged>Texture1D</unmanaged>
        /// <unmanaged-short>Texture1D</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D12.RenderTargetViewDescription.Texture1DResource Texture1D;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D12.Texture1DArrayResource"/></strong> structure that specifies the subresources in a 1D texture array that can be accessed.</p> </dd>
        /// </summary>
        /// <doc-id>dn770389</doc-id>
        /// <unmanaged>Texture1DArray</unmanaged>
        /// <unmanaged-short>Texture1DArray</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D12.RenderTargetViewDescription.Texture1DArrayResource Texture1DArray;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D12.Texture2DResource"/></strong> structure that specifies the subresources in a 2D texture that can be accessed.</p> </dd>
        /// </summary>
        /// <doc-id>dn770389</doc-id>
        /// <unmanaged>Texture2D</unmanaged>
        /// <unmanaged-short>Texture2D</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D12.RenderTargetViewDescription.Texture2DResource Texture2D;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D12.Texture2DArrayResource"/></strong> structure that specifies the subresources in a 2D texture array that can be accessed.</p> </dd>
        /// </summary>
        /// <doc-id>dn770389</doc-id>
        /// <unmanaged>Texture2DArray</unmanaged>
        /// <unmanaged-short>Texture2DArray</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D12.RenderTargetViewDescription.Texture2DArrayResource Texture2DArray;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D12.Texture2DMultisampledResource"/></strong> structure that specifies a single subresource because a multisampled 2D texture only contains one subresource.</p> </dd>
        /// </summary>
        /// <doc-id>dn770389</doc-id>
        /// <unmanaged>Texture2DMS</unmanaged>
        /// <unmanaged-short>Texture2DMS</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D12.RenderTargetViewDescription.Texture2DMultisampledResource Texture2DMS;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D12.Texture2DMultisampledArrayResource"/></strong> structure that specifies the subresources in a multisampled 2D texture array that can be accessed.</p> </dd>
        /// </summary>
        /// <doc-id>dn770389</doc-id>
        /// <unmanaged>Texture2DMSArray</unmanaged>
        /// <unmanaged-short>Texture2DMSArray</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D12.RenderTargetViewDescription.Texture2DMultisampledArrayResource Texture2DMSArray;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D12.Texture3DResource"/></strong> structure that specifies subresources in a 3D texture that can be accessed.</p> </dd>
        /// </summary>
        /// <doc-id>dn770389</doc-id>
        /// <unmanaged>Texture3D</unmanaged>
        /// <unmanaged-short>Texture3D</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D12.RenderTargetViewDescription.Texture3DResource Texture3D;
    }

    /// <summary>
    /// <p> Describes the transition between usages of two different resources that have mappings into the same heap. </p>
    /// </summary>
    /// <remarks>
    /// <p> This structure is a member of the <strong><see cref = "SharpDX.Direct3D12.ResourceBarrier"/></strong> structure. </p><p> Both the before and the after resources can be specified or one or both resources can be <strong><c>null</c></strong>, which indicates that any placed or reserved resource could cause aliasing. </p><p>Refer to the usage models described in <strong>CreatePlacedResource</strong>.</p>
    /// </remarks>
    /// <doc-id>dn986739</doc-id>
    /// <unmanaged>D3D12_RESOURCE_ALIASING_BARRIER</unmanaged>
    /// <unmanaged-short>D3D12_RESOURCE_ALIASING_BARRIER</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct ResourceAliasingBarrier
    {
        /// <summary>
        /// <dd> <p> A reference to the <strong><see cref = "SharpDX.Direct3D12.Resource"/></strong> object that represents the before resource used in the transition. </p> </dd>
        /// </summary>
        /// <doc-id>dn986739</doc-id>
        /// <unmanaged>pResourceBefore</unmanaged>
        /// <unmanaged-short>pResourceBefore</unmanaged-short>
        private System.IntPtr ResourceBeforePointer;
        /// <summary>
        /// <dd> <p> A reference to the <strong><see cref = "SharpDX.Direct3D12.Resource"/></strong> object that represents the after resource used in the transition. </p> </dd>
        /// </summary>
        /// <doc-id>dn986739</doc-id>
        /// <unmanaged>pResourceAfter</unmanaged>
        /// <unmanaged-short>pResourceAfter</unmanaged-short>
        private System.IntPtr ResourceAfterPointer;
    }

    /// <summary>
    /// <p>Describes parameters needed to allocate resources.</p>
    /// </summary>
    /// <remarks>
    /// <p> This structure is used by the <strong>GetResourceAllocationInfo</strong> method. </p>
    /// </remarks>
    /// <doc-id>dn770391</doc-id>
    /// <unmanaged>D3D12_RESOURCE_ALLOCATION_INFO</unmanaged>
    /// <unmanaged-short>D3D12_RESOURCE_ALLOCATION_INFO</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct ResourceAllocationInformation
    {
        /// <summary>
        /// <dd> <p>The size, in bytes, of the resource.</p> </dd>
        /// </summary>
        /// <doc-id>dn770391</doc-id>
        /// <unmanaged>SizeInBytes</unmanaged>
        /// <unmanaged-short>SizeInBytes</unmanaged-short>
        public System.Int64 SizeInBytes;
        /// <summary>
        /// <dd> <p>The alignment value for the resource; one of 4KB (4096), 64KB (65536) and 4MB (4194304) alignment.</p> </dd>
        /// </summary>
        /// <doc-id>dn770391</doc-id>
        /// <unmanaged>Alignment</unmanaged>
        /// <unmanaged-short>Alignment</unmanaged-short>
        public System.Int64 Alignment;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_RESOURCE_ALLOCATION_INFO1</unmanaged>
    /// <unmanaged-short>D3D12_RESOURCE_ALLOCATION_INFO1</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct ResourceAllocationInformation1
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Offset</unmanaged>
        /// <unmanaged-short>Offset</unmanaged-short>
        public System.Int64 Offset;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Alignment</unmanaged>
        /// <unmanaged-short>Alignment</unmanaged-short>
        public System.Int64 Alignment;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>SizeInBytes</unmanaged>
        /// <unmanaged-short>SizeInBytes</unmanaged-short>
        public System.Int64 SizeInBytes;
    }

    /// <summary>
    /// <p> Describes a resource barrier (transition in resource use). </p>
    /// </summary>
    /// <remarks>
    /// <p> This structure is used by the <strong>ID3D12GraphicsCommandList::ResourceBarrier</strong> method. </p>
    /// </remarks>
    /// <doc-id>dn986740</doc-id>
    /// <unmanaged>D3D12_RESOURCE_BARRIER</unmanaged>
    /// <unmanaged-short>D3D12_RESOURCE_BARRIER</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct ResourceBarrier
    {
    }

    /// <summary>
    /// <p> Describes a resource, such as a texture. This structure is used extensively. </p>
    /// </summary>
    /// <remarks>
    /// <p> Use this structure with:</p><ul> <li> <strong>ID3D12Resource::GetDesc</strong> </li> <li> <strong>ID3D12Device::GetResourceAllocationInfo</strong> </li> <li> <strong>ID3D12Device::CreateCommittedResource</strong> </li> <li> <strong>ID3D12Device::CreatePlacedResource</strong> </li> <li> <strong>ID3D12Device::CreateReservedResource</strong> </li> <li> <strong>ID3D12Device::GetCopyableFootprints</strong> </li> <li> A number of the helper functions, refer to Helper Structures and Functions for D3D12.</li> </ul><p>Two common resources are buffers and textures, which both use this structure, but with quite different uses of the fields.</p>
    /// </remarks>
    /// <doc-id>dn903813</doc-id>
    /// <unmanaged>D3D12_RESOURCE_DESC</unmanaged>
    /// <unmanaged-short>D3D12_RESOURCE_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct ResourceDescription
    {
        /// <summary>
        /// <dd> <p> One member of <strong><see cref = "SharpDX.Direct3D12.ResourceDimension"/></strong>, specifying the dimensions of the resource (for example, D3D12_RESOURCE_DIMENSION_TEXTURE1D), or whether it is a buffer ((D3D12_RESOURCE_DIMENSION_BUFFER). </p> </dd>
        /// </summary>
        /// <doc-id>dn903813</doc-id>
        /// <unmanaged>Dimension</unmanaged>
        /// <unmanaged-short>Dimension</unmanaged-short>
        public SharpDX.Direct3D12.ResourceDimension Dimension;
        /// <summary>
        /// <dd> <p> Specifies the alignment. </p> </dd>
        /// </summary>
        /// <doc-id>dn903813</doc-id>
        /// <unmanaged>Alignment</unmanaged>
        /// <unmanaged-short>Alignment</unmanaged-short>
        public System.Int64 Alignment;
        /// <summary>
        /// <dd> <p> Specifies the width of the resource. </p> </dd>
        /// </summary>
        /// <doc-id>dn903813</doc-id>
        /// <unmanaged>Width</unmanaged>
        /// <unmanaged-short>Width</unmanaged-short>
        public System.Int64 Width;
        /// <summary>
        /// <dd> <p> Specifies the height of the resource. </p> </dd>
        /// </summary>
        /// <doc-id>dn903813</doc-id>
        /// <unmanaged>Height</unmanaged>
        /// <unmanaged-short>Height</unmanaged-short>
        public System.Int32 Height;
        /// <summary>
        /// <dd> <p> Specifies the depth of the resource, if it is 3D, or the array size if it is an array of 1D or 2D resources. </p> </dd>
        /// </summary>
        /// <doc-id>dn903813</doc-id>
        /// <unmanaged>DepthOrArraySize</unmanaged>
        /// <unmanaged-short>DepthOrArraySize</unmanaged-short>
        public System.Int16 DepthOrArraySize;
        /// <summary>
        /// <dd> <p> Specifies the number of MIP levels. </p> </dd>
        /// </summary>
        /// <doc-id>dn903813</doc-id>
        /// <unmanaged>MipLevels</unmanaged>
        /// <unmanaged-short>MipLevels</unmanaged-short>
        public System.Int16 MipLevels;
        /// <summary>
        /// <dd> <p> Specifies one member of  <strong><see cref = "SharpDX.DXGI.Format"/></strong>. </p> </dd>
        /// </summary>
        /// <doc-id>dn903813</doc-id>
        /// <unmanaged>Format</unmanaged>
        /// <unmanaged-short>Format</unmanaged-short>
        public SharpDX.DXGI.Format Format;
        /// <summary>
        /// <dd> <p> Specifies a <strong><see cref = "SharpDX.DXGI.SampleDescription"/></strong> structure. </p> </dd>
        /// </summary>
        /// <doc-id>dn903813</doc-id>
        /// <unmanaged>SampleDesc</unmanaged>
        /// <unmanaged-short>SampleDesc</unmanaged-short>
        public SharpDX.DXGI.SampleDescription SampleDescription;
        /// <summary>
        /// <dd> <p> Specifies one member of <strong><see cref = "SharpDX.Direct3D12.TextureLayout"/></strong>. </p> </dd>
        /// </summary>
        /// <doc-id>dn903813</doc-id>
        /// <unmanaged>Layout</unmanaged>
        /// <unmanaged-short>Layout</unmanaged-short>
        public SharpDX.Direct3D12.TextureLayout Layout;
        /// <summary>
        /// <dd> <p> Bitwise-OR'd flags, as <strong><see cref = "SharpDX.Direct3D12.ResourceFlags"/></strong> enumeration constants. </p> </dd>
        /// </summary>
        /// <doc-id>dn903813</doc-id>
        /// <unmanaged>Flags</unmanaged>
        /// <unmanaged-short>Flags</unmanaged-short>
        public SharpDX.Direct3D12.ResourceFlags Flags;
    }

    /// <summary>
    /// <p>Describes a 3D box.</p>
    /// </summary>
    /// <remarks>
    /// <p> This structure is used by the methods <strong>WriteToSubresource</strong>, <strong>ReadFromSubresource</strong> and <strong>CopyTextureRegion</strong>. </p>
    /// </remarks>
    /// <doc-id>dn770341</doc-id>
    /// <unmanaged>D3D12_BOX</unmanaged>
    /// <unmanaged-short>D3D12_BOX</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct ResourceRegion
    {
        /// <summary>
        /// <dd> <p>The x position of the left hand side of the box.</p> </dd>
        /// </summary>
        /// <doc-id>dn770341</doc-id>
        /// <unmanaged>left</unmanaged>
        /// <unmanaged-short>left</unmanaged-short>
        public System.Int32 Left;
        /// <summary>
        /// <dd> <p>The y position of the top of the box.</p> </dd>
        /// </summary>
        /// <doc-id>dn770341</doc-id>
        /// <unmanaged>top</unmanaged>
        /// <unmanaged-short>top</unmanaged-short>
        public System.Int32 Top;
        /// <summary>
        /// <dd> <p>The z position of the front of the box.</p> </dd>
        /// </summary>
        /// <doc-id>dn770341</doc-id>
        /// <unmanaged>front</unmanaged>
        /// <unmanaged-short>front</unmanaged-short>
        public System.Int32 Front;
        /// <summary>
        /// <dd> <p>The x position of the right hand side of the box, plus 1. This means that <code>right - left</code> equals the width of the box.</p> </dd>
        /// </summary>
        /// <doc-id>dn770341</doc-id>
        /// <unmanaged>right</unmanaged>
        /// <unmanaged-short>right</unmanaged-short>
        public System.Int32 Right;
        /// <summary>
        /// <dd> <p>The y position of the bottom of the box, plus 1. This means that <code>top - bottom</code> equals the height of the box.</p> </dd>
        /// </summary>
        /// <doc-id>dn770341</doc-id>
        /// <unmanaged>bottom</unmanaged>
        /// <unmanaged-short>bottom</unmanaged-short>
        public System.Int32 Bottom;
        /// <summary>
        /// <dd> <p>The z position of the back of the box, plus 1. This means that <code>front - back</code> equals the depth of the box.</p> </dd>
        /// </summary>
        /// <doc-id>dn770341</doc-id>
        /// <unmanaged>back</unmanaged>
        /// <unmanaged-short>back</unmanaged-short>
        public System.Int32 Back;
    }

    /// <summary>
    /// <p> Describes the transition of subresources between different usages. </p>
    /// </summary>
    /// <remarks>
    /// <p> This struct is used by the <strong>Transition</strong> member of the <strong><see cref = "SharpDX.Direct3D12.ResourceBarrier"/></strong> struct. </p>
    /// </remarks>
    /// <doc-id>dn986745</doc-id>
    /// <unmanaged>D3D12_RESOURCE_TRANSITION_BARRIER</unmanaged>
    /// <unmanaged-short>D3D12_RESOURCE_TRANSITION_BARRIER</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct ResourceTransitionBarrier
    {
        /// <summary>
        /// <dd> <p> A reference to the <strong><see cref = "SharpDX.Direct3D12.Resource"/></strong> object that represents the resource used in the transition. </p> </dd>
        /// </summary>
        /// <doc-id>dn986745</doc-id>
        /// <unmanaged>pResource</unmanaged>
        /// <unmanaged-short>pResource</unmanaged-short>
        private System.IntPtr ResourcePointer;
        /// <summary>
        /// <dd> <p> The index of the subresource for the transition. Use the <strong>D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES</strong> flag ( 0xffffffff ) to transition all subresources in a resource at the same time. </p> </dd>
        /// </summary>
        /// <doc-id>dn986745</doc-id>
        /// <unmanaged>Subresource</unmanaged>
        /// <unmanaged-short>Subresource</unmanaged-short>
        public System.Int32 Subresource;
        /// <summary>
        /// <dd> <p> The "before" usages of the subresources, as a bitwise-OR'd combination of <strong><see cref = "SharpDX.Direct3D12.ResourceStates"/></strong> enumeration constants. </p> </dd>
        /// </summary>
        /// <doc-id>dn986745</doc-id>
        /// <unmanaged>StateBefore</unmanaged>
        /// <unmanaged-short>StateBefore</unmanaged-short>
        public SharpDX.Direct3D12.ResourceStates StateBefore;
        /// <summary>
        /// <dd> <p> The "after" usages of the subresources, as a bitwise-OR'd combination of <strong><see cref = "SharpDX.Direct3D12.ResourceStates"/></strong> enumeration constants. </p> </dd>
        /// </summary>
        /// <doc-id>dn986745</doc-id>
        /// <unmanaged>StateAfter</unmanaged>
        /// <unmanaged-short>StateAfter</unmanaged-short>
        public SharpDX.Direct3D12.ResourceStates StateAfter;
    }

    /// <summary>
    /// <p> Represents a resource in which all UAV accesses must complete before any future UAV accesses can begin. </p>
    /// </summary>
    /// <remarks>
    /// <p> This struct represents a resource in which all unordered access view (UAV) accesses (reads or writes) must complete before any future UAV accesses (read or write) can begin. </p><p> This structure is a member of the <strong><see cref = "SharpDX.Direct3D12.ResourceBarrier"/></strong> structure. </p><p> You don't need to insert a UAV barrier between 2 draw or dispatch calls that only read a UAV. Additionally, you don't need to insert a UAV barrier between 2 draw or dispatch calls that write to the same UAV if you know that it's safe to execute the UAV accesses in any order. The resource can be <strong><c>null</c></strong>, which indicates that any UAV access could require the barrier. </p>
    /// </remarks>
    /// <doc-id>dn986746</doc-id>
    /// <unmanaged>D3D12_RESOURCE_UAV_BARRIER</unmanaged>
    /// <unmanaged-short>D3D12_RESOURCE_UAV_BARRIER</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct ResourceUnorderedAccessViewBarrier
    {
        /// <summary>
        /// <dd> <p> The resource used in the transition, as a reference to <strong><see cref = "SharpDX.Direct3D12.Resource"/></strong>. </p> </dd>
        /// </summary>
        /// <doc-id>dn986746</doc-id>
        /// <unmanaged>pResource</unmanaged>
        /// <unmanaged-short>pResource</unmanaged-short>
        public System.IntPtr ResourcePointer;
    }

    /// <summary>
    /// <p> Describes constants inline in the root signature that appear in shaders as one constant buffer. </p>
    /// </summary>
    /// <remarks>
    /// <p>Refer to Resource Binding in HLSL for more information on shader registers and spaces. </p><p><strong><see cref = "SharpDX.Direct3D12.RootConstants"/></strong> is the data type of the <strong>Constants</strong> member of <strong><see cref = "SharpDX.Direct3D12.RootParameter"/></strong>.  Use a <strong><see cref = "SharpDX.Direct3D12.RootConstants"/></strong> when you set <strong><see cref = "SharpDX.Direct3D12.RootParameter"/></strong>'s <strong>SlotType</strong> field to the D3D12_ROOT_PARAMETER_TYPE_32BIT_CONSTANTS member of <strong><see cref = "SharpDX.Direct3D12.RootParameterType"/></strong>. </p>
    /// </remarks>
    /// <doc-id>dn879475</doc-id>
    /// <unmanaged>D3D12_ROOT_CONSTANTS</unmanaged>
    /// <unmanaged-short>D3D12_ROOT_CONSTANTS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct RootConstants
    {
        /// <summary>
        /// <dd> <p> The shader register. </p> </dd>
        /// </summary>
        /// <doc-id>dn879475</doc-id>
        /// <unmanaged>ShaderRegister</unmanaged>
        /// <unmanaged-short>ShaderRegister</unmanaged-short>
        public System.Int32 ShaderRegister;
        /// <summary>
        /// <dd> <p> The register space. </p> </dd>
        /// </summary>
        /// <doc-id>dn879475</doc-id>
        /// <unmanaged>RegisterSpace</unmanaged>
        /// <unmanaged-short>RegisterSpace</unmanaged-short>
        public System.Int32 RegisterSpace;
        /// <summary>
        /// <dd> <p> The number of constants that occupy a single shader slot (these constants appear like a single constant buffer).  All constants occupy a single root signature bind slot. </p> </dd>
        /// </summary>
        /// <doc-id>dn879475</doc-id>
        /// <unmanaged>Num32BitValues</unmanaged>
        /// <unmanaged-short>Num32BitValues</unmanaged-short>
        public System.Int32 Value32BitCount;
    }

    /// <summary>
    /// <p> Describes descriptors inline in the root signature version 1.0 that appear in shaders. </p>
    /// </summary>
    /// <remarks>
    /// <p><strong><see cref = "SharpDX.Direct3D12.RootDescriptor"/></strong> is the data type of the <strong>Descriptor</strong> member of <strong><see cref = "SharpDX.Direct3D12.RootParameter"/></strong>. Use a <strong><see cref = "SharpDX.Direct3D12.RootDescriptor"/></strong> when you set <strong><see cref = "SharpDX.Direct3D12.RootParameter"/></strong>'s <strong>SlotType</strong> field to the D3D12_ROOT_PARAMETER_TYPE_CBV, D3D12_ROOT_PARAMETER_TYPE_SRV, or D3D12_ROOT_PARAMETER_TYPE_UAV members of <strong><see cref = "SharpDX.Direct3D12.RootParameterType"/></strong>. </p>
    /// </remarks>
    /// <doc-id>dn879476</doc-id>
    /// <unmanaged>D3D12_ROOT_DESCRIPTOR</unmanaged>
    /// <unmanaged-short>D3D12_ROOT_DESCRIPTOR</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct RootDescriptor
    {
        /// <summary>
        /// <dd> <p>The shader register.</p> </dd>
        /// </summary>
        /// <doc-id>dn879476</doc-id>
        /// <unmanaged>ShaderRegister</unmanaged>
        /// <unmanaged-short>ShaderRegister</unmanaged-short>
        public System.Int32 ShaderRegister;
        /// <summary>
        /// <dd> <p>The register space.</p> </dd>
        /// </summary>
        /// <doc-id>dn879476</doc-id>
        /// <unmanaged>RegisterSpace</unmanaged>
        /// <unmanaged-short>RegisterSpace</unmanaged-short>
        public System.Int32 RegisterSpace;
    }

    /// <summary>
    /// <p> Describes descriptors inline in the root signature version 1.1 that appear in shaders. </p>
    /// </summary>
    /// <remarks>
    /// <p><strong><see cref = "SharpDX.Direct3D12.RootDescriptor1"/></strong> is the data type of the <strong>Descriptor</strong> member of <strong><see cref = "SharpDX.Direct3D12.RootParameter1"/></strong>. Use a <strong><see cref = "SharpDX.Direct3D12.RootDescriptor1"/></strong> when you set <strong><see cref = "SharpDX.Direct3D12.RootParameter1"/></strong>'s <strong>SlotType</strong> field to the D3D12_ROOT_PARAMETER_TYPE_CBV, D3D12_ROOT_PARAMETER_TYPE_SRV, or D3D12_ROOT_PARAMETER_TYPE_UAV members of <strong><see cref = "SharpDX.Direct3D12.RootParameterType"/></strong>. </p><p>Refer to the helper structure <strong>CD3DX12_ROOT_DESCRIPTOR1</strong>.</p>
    /// </remarks>
    /// <doc-id>mt709120</doc-id>
    /// <unmanaged>D3D12_ROOT_DESCRIPTOR1</unmanaged>
    /// <unmanaged-short>D3D12_ROOT_DESCRIPTOR1</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct RootDescriptor1
    {
        /// <summary>
        /// <dd> <p>The shader register.</p> </dd>
        /// </summary>
        /// <doc-id>mt709120</doc-id>
        /// <unmanaged>ShaderRegister</unmanaged>
        /// <unmanaged-short>ShaderRegister</unmanaged-short>
        public System.Int32 ShaderRegister;
        /// <summary>
        /// <dd> <p>The register space.</p> </dd>
        /// </summary>
        /// <doc-id>mt709120</doc-id>
        /// <unmanaged>RegisterSpace</unmanaged>
        /// <unmanaged-short>RegisterSpace</unmanaged-short>
        public System.Int32 RegisterSpace;
        /// <summary>
        /// <dd> <p>Specifies the <strong><see cref = "SharpDX.Direct3D12.RootDescriptorFlags"/></strong> that determine the volatility of descriptors and the data they reference.</p> </dd>
        /// </summary>
        /// <doc-id>mt709120</doc-id>
        /// <unmanaged>Flags</unmanaged>
        /// <unmanaged-short>Flags</unmanaged-short>
        public SharpDX.Direct3D12.RootDescriptorFlags Flags;
    }

    /// <summary>
    /// <p> Describes the root signature 1.0 layout of a descriptor table as a collection of descriptor ranges that appear one after the other in a descriptor heap. </p>
    /// </summary>
    /// <remarks>
    /// <p> Samplers are not allowed in the same descriptor table as constant-buffer views (CBVs), unordered-access views (UAVs), and shader-resource views (SRVs). </p><p><strong><see cref = "SharpDX.Direct3D12.RootDescriptorTable"/></strong> is the data type of the <strong>DescriptorTable</strong> member of <strong><see cref = "SharpDX.Direct3D12.RootParameter"/></strong>. Use a <strong><see cref = "SharpDX.Direct3D12.RootDescriptorTable"/></strong> when you set <strong><see cref = "SharpDX.Direct3D12.RootParameter"/></strong>'s <strong>SlotType</strong> member to <strong>D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE</strong>. </p>
    /// </remarks>
    /// <doc-id>dn859382</doc-id>
    /// <unmanaged>D3D12_ROOT_DESCRIPTOR_TABLE</unmanaged>
    /// <unmanaged-short>D3D12_ROOT_DESCRIPTOR_TABLE</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct RootDescriptorTable
    {
        /// <summary>
        /// <dd> <p> The number of descriptor ranges in the table layout. </p> </dd>
        /// </summary>
        /// <doc-id>dn859382</doc-id>
        /// <unmanaged>NumDescriptorRanges</unmanaged>
        /// <unmanaged-short>NumDescriptorRanges</unmanaged-short>
        public System.Int32 DescriptorRangeCount;
        /// <summary>
        /// <dd> <p> An array of <strong><see cref = "SharpDX.Direct3D12.DescriptorRange"/></strong> structures that describe the descriptor ranges. </p> </dd>
        /// </summary>
        /// <doc-id>dn859382</doc-id>
        /// <unmanaged>pDescriptorRanges</unmanaged>
        /// <unmanaged-short>pDescriptorRanges</unmanaged-short>
        public System.IntPtr DescriptorRangesPointer;
    }

    /// <summary>
    /// <p> Describes the root signature 1.1 layout of a descriptor table as a collection of descriptor ranges that appear one after the other in a descriptor heap. </p>
    /// </summary>
    /// <remarks>
    /// <p> Samplers are not allowed in the same descriptor table as constant-buffer views (CBVs), unordered-access views (UAVs), and shader-resource views (SRVs). </p><p><strong><see cref = "SharpDX.Direct3D12.RootDescriptorTable1"/></strong> is the data type of the <strong>DescriptorTable</strong> member of <strong><see cref = "SharpDX.Direct3D12.RootParameter1"/></strong>. Use a <strong><see cref = "SharpDX.Direct3D12.RootDescriptorTable1"/></strong> when you set <strong><see cref = "SharpDX.Direct3D12.RootParameter1"/></strong>'s <strong>SlotType</strong> member to <strong>D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE</strong>. </p><p>Refer to the helper structure <strong>CD3DX12_ROOT_DESCRIPTOR_TABLE1</strong>.</p>
    /// </remarks>
    /// <doc-id>mt709122</doc-id>
    /// <unmanaged>D3D12_ROOT_DESCRIPTOR_TABLE1</unmanaged>
    /// <unmanaged-short>D3D12_ROOT_DESCRIPTOR_TABLE1</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct RootDescriptorTable1
    {
        /// <summary>
        /// <dd> <p> The number of descriptor ranges in the table layout. </p> </dd>
        /// </summary>
        /// <doc-id>mt709122</doc-id>
        /// <unmanaged>NumDescriptorRanges</unmanaged>
        /// <unmanaged-short>NumDescriptorRanges</unmanaged-short>
        public System.Int32 DescriptorRangeCount;
        /// <summary>
        /// <dd> <p> An array of <strong><see cref = "SharpDX.Direct3D12.DescriptorRange1"/></strong> structures that describe the descriptor ranges. </p> </dd>
        /// </summary>
        /// <doc-id>mt709122</doc-id>
        /// <unmanaged>pDescriptorRanges</unmanaged>
        /// <unmanaged-short>pDescriptorRanges</unmanaged-short>
        public System.IntPtr DescriptorRangesPointer;
    }

    /// <summary>
    /// <p>Describes the slot of a root signature version 1.0.</p>
    /// </summary>
    /// <remarks>
    /// <p> A <strong><see cref = "SharpDX.Direct3D12.RootSignatureDescription"/></strong> can contain descriptor tables and inline constants. More capable hardware could support inline descriptors in the root signature as well. The number of bind slots in the root signature are most efficient if kept below a certain size, and can have an upper bound as well. </p>
    /// </remarks>
    /// <doc-id>dn879477</doc-id>
    /// <unmanaged>D3D12_ROOT_PARAMETER</unmanaged>
    /// <unmanaged-short>D3D12_ROOT_PARAMETER</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct RootParameter
    {
    }

    /// <summary>
    /// <p>Describes the slot of a root signature version 1.1.</p>
    /// </summary>
    /// <remarks>
    /// <p>Use this structure with the <strong><see cref = "SharpDX.Direct3D12.RootSignatureDescription1"/></strong> structure.</p><p>Refer to the helper structure <strong>CD3DX12_ROOT_PARAMETER1</strong>.</p>
    /// </remarks>
    /// <doc-id>mt709123</doc-id>
    /// <unmanaged>D3D12_ROOT_PARAMETER1</unmanaged>
    /// <unmanaged-short>D3D12_ROOT_PARAMETER1</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct RootParameter1
    {
    }

    /// <summary>
    /// <p> Describes the layout of a root signature version 1.0. </p>
    /// </summary>
    /// <remarks>
    /// <p> This structure is used by the <strong>D3D12SerializeRootSignature</strong> function and is returned by the <strong>ID3D12RootSignatureDeserializer::GetRootSignatureDesc</strong> method. </p><p> There is one graphics root signature, and one compute root signature. </p>
    /// </remarks>
    /// <doc-id>dn986747</doc-id>
    /// <unmanaged>D3D12_ROOT_SIGNATURE_DESC</unmanaged>
    /// <unmanaged-short>D3D12_ROOT_SIGNATURE_DESC</unmanaged-short>
    public partial class RootSignatureDescription
    {
    }

    /// <summary>
    /// <p>Describes the layout of a root signature version 1.1.</p>
    /// </summary>
    /// <remarks>
    /// <p>Use this structure with the <strong><see cref = "SharpDX.Direct3D12.VersionedRootSignatureDescription"/></strong> structure.</p>
    /// </remarks>
    /// <doc-id>mt709124</doc-id>
    /// <unmanaged>D3D12_ROOT_SIGNATURE_DESC1</unmanaged>
    /// <unmanaged-short>D3D12_ROOT_SIGNATURE_DESC1</unmanaged-short>
    public partial class RootSignatureDescription1
    {
    }

    /// <summary>
    /// <p>Describes the slot of a root signature version 1.0.</p>
    /// </summary>
    /// <remarks>
    /// <p> A <strong><see cref = "SharpDX.Direct3D12.RootSignatureDescription"/></strong> can contain descriptor tables and inline constants. More capable hardware could support inline descriptors in the root signature as well. The number of bind slots in the root signature are most efficient if kept below a certain size, and can have an upper bound as well. </p>
    /// </remarks>
    /// <doc-id>dn879477</doc-id>
    /// <unmanaged>D3D12_RT_FORMAT_ARRAY</unmanaged>
    /// <unmanaged-short>D3D12_RT_FORMAT_ARRAY</unmanaged-short>
    public partial struct RtFormatArray
    {
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.RootParameterType"/></strong>-typed value that  specifies the type of root signature slot. This member determines which type to use in the union below. </p> </dd>
        /// </summary>
        /// <doc-id>dn879477</doc-id>
        /// <unmanaged>RTFormats</unmanaged>
        /// <unmanaged-short>RTFormats</unmanaged-short>
        public SharpDX.DXGI.Format[] RTFormats
        {
            get => _RTFormats ?? (_RTFormats = new SharpDX.DXGI.Format[8]);
            private set => _RTFormats = value;
        }

        internal SharpDX.DXGI.Format[] _RTFormats;
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.RootDescriptorTable"/></strong> structure that describes the layout of a descriptor table as a collection of descriptor ranges that appear one after the other in a descriptor heap. </p> </dd>
        /// </summary>
        /// <doc-id>dn879477</doc-id>
        /// <unmanaged>NumRenderTargets</unmanaged>
        /// <unmanaged-short>NumRenderTargets</unmanaged-short>
        public System.Int32 RenderTargetCount;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.DXGI.Format RTFormats;
            public SharpDX.DXGI.Format __RTFormats1;
            public SharpDX.DXGI.Format __RTFormats2;
            public SharpDX.DXGI.Format __RTFormats3;
            public SharpDX.DXGI.Format __RTFormats4;
            public SharpDX.DXGI.Format __RTFormats5;
            public SharpDX.DXGI.Format __RTFormats6;
            public SharpDX.DXGI.Format __RTFormats7;
            public System.Int32 RenderTargetCount;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            fixed (void *__to = &RTFormats[0], __from = &@ref.RTFormats)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 8 * sizeof (SharpDX.DXGI.Format));
            RenderTargetCount = @ref.RenderTargetCount;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            fixed (void *__from = &RTFormats[0], __to = &@ref.RTFormats)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 8 * sizeof (SharpDX.DXGI.Format));
            @ref.RenderTargetCount = RenderTargetCount;
        }
    }

    /// <summary>
    /// <p>This section provides code for sample scenarios. Many of the walk-throughs provide details on what coding is required to be added to a basic sample, to avoid repeating the basic component code for each scenario.</p><p>For the most basic component, refer to the Creating a Basic Direct3D 12 Component section. The following walk-throughs describe more advanced scenarios.</p><p> </p>
    /// </summary>
    /// <doc-id>mt186595</doc-id>
    /// <unmanaged>D3D12_SAMPLE_POSITION</unmanaged>
    /// <unmanaged-short>D3D12_SAMPLE_POSITION</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct SamplePosition
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>mt186595</doc-id>
        /// <unmanaged>X</unmanaged>
        /// <unmanaged-short>X</unmanaged-short>
        public System.Byte X;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>mt186595</doc-id>
        /// <unmanaged>Y</unmanaged>
        /// <unmanaged-short>Y</unmanaged-short>
        public System.Byte Y;
    }

    /// <summary>
    /// <p>Describes a sampler state.</p>
    /// </summary>
    /// <remarks>
    /// <p>This structure is used by <strong>CreateSampler</strong>.</p>
    /// </remarks>
    /// <doc-id>dn770403</doc-id>
    /// <unmanaged>D3D12_SAMPLER_DESC</unmanaged>
    /// <unmanaged-short>D3D12_SAMPLER_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct SamplerStateDescription
    {
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.Filter"/></strong>-typed value that specifies the filtering method to use when sampling a texture. </p> </dd>
        /// </summary>
        /// <doc-id>dn770403</doc-id>
        /// <unmanaged>Filter</unmanaged>
        /// <unmanaged-short>Filter</unmanaged-short>
        public SharpDX.Direct3D12.Filter Filter;
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.TextureAddressMode"/></strong>-typed value that specifies the method to use for resolving a u texture coordinate that is outside the 0 to 1 range. </p> </dd>
        /// </summary>
        /// <doc-id>dn770403</doc-id>
        /// <unmanaged>AddressU</unmanaged>
        /// <unmanaged-short>AddressU</unmanaged-short>
        public SharpDX.Direct3D12.TextureAddressMode AddressU;
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.TextureAddressMode"/></strong>-typed value that specifies the method to use for resolving a v texture coordinate that is outside the 0 to 1 range. </p> </dd>
        /// </summary>
        /// <doc-id>dn770403</doc-id>
        /// <unmanaged>AddressV</unmanaged>
        /// <unmanaged-short>AddressV</unmanaged-short>
        public SharpDX.Direct3D12.TextureAddressMode AddressV;
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.TextureAddressMode"/></strong>-typed value that specifies the method to use for resolving a w texture coordinate that is outside the 0 to 1 range. </p> </dd>
        /// </summary>
        /// <doc-id>dn770403</doc-id>
        /// <unmanaged>AddressW</unmanaged>
        /// <unmanaged-short>AddressW</unmanaged-short>
        public SharpDX.Direct3D12.TextureAddressMode AddressW;
        /// <summary>
        /// <dd> <p> Offset from the calculated mipmap level. For example, if the runtime calculates that a texture should be sampled at mipmap level 3 and <strong>MipLODBias</strong> is 2, the texture will be sampled at mipmap level 5. </p> </dd>
        /// </summary>
        /// <doc-id>dn770403</doc-id>
        /// <unmanaged>MipLODBias</unmanaged>
        /// <unmanaged-short>MipLODBias</unmanaged-short>
        public System.Single MipLodBias;
        /// <summary>
        /// <dd> <p> Clamping value used if <strong>D3D12_FILTER_ANISOTROPIC</strong> or <strong>D3D12_FILTER_COMPARISON_ANISOTROPIC</strong> is specified in <strong>Filter</strong>. Valid values are between 1 and 16. </p> </dd>
        /// </summary>
        /// <doc-id>dn770403</doc-id>
        /// <unmanaged>MaxAnisotropy</unmanaged>
        /// <unmanaged-short>MaxAnisotropy</unmanaged-short>
        public System.Int32 MaximumAnisotropy;
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.Comparison"/></strong>-typed value that specifies a function that compares sampled data against existing sampled data. </p> </dd>
        /// </summary>
        /// <doc-id>dn770403</doc-id>
        /// <unmanaged>ComparisonFunc</unmanaged>
        /// <unmanaged-short>ComparisonFunc</unmanaged-short>
        public SharpDX.Direct3D12.Comparison ComparisonFunction;
        /// <summary>
        /// <dd> <p> Border color to use if <strong>D3D12_TEXTURE_ADDRESS_MODE_BORDER</strong> is specified for <strong>AddressU</strong>, <strong>AddressV</strong>, or <strong>AddressW</strong>. Range must be between 0.0 and 1.0 inclusive. </p> </dd>
        /// </summary>
        /// <doc-id>dn770403</doc-id>
        /// <unmanaged>BorderColor</unmanaged>
        /// <unmanaged-short>BorderColor</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawColor4 BorderColor;
        /// <summary>
        /// <dd> <p>Lower end of the mipmap range to clamp access to, where 0 is the largest and most detailed mipmap level and any level higher than that is less detailed.</p> </dd>
        /// </summary>
        /// <doc-id>dn770403</doc-id>
        /// <unmanaged>MinLOD</unmanaged>
        /// <unmanaged-short>MinLOD</unmanaged-short>
        public System.Single MinimumLod;
        /// <summary>
        /// <dd> <p> Upper end of the mipmap range to clamp access to, where 0 is the largest and most detailed mipmap level and any level higher than that is less detailed. This value must be greater than or equal to <strong>MinLOD</strong>. To have no upper limit on LOD, set this member to a large value. </p> </dd>
        /// </summary>
        /// <doc-id>dn770403</doc-id>
        /// <unmanaged>MaxLOD</unmanaged>
        /// <unmanaged-short>MaxLOD</unmanaged-short>
        public System.Single MaximumLod;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER</unmanaged>
    /// <unmanaged-short>D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER</unmanaged-short>
    public partial struct SerializedDataDriverMatchingIdentifier
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>DriverOpaqueGUID</unmanaged>
        /// <unmanaged-short>DriverOpaqueGUID</unmanaged-short>
        public System.Guid DriverOpaqueGUID;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>DriverOpaqueVersioningData</unmanaged>
        /// <unmanaged-short>DriverOpaqueVersioningData</unmanaged-short>
        public System.Byte[] DriverOpaqueVersioningData
        {
            get => _DriverOpaqueVersioningData ?? (_DriverOpaqueVersioningData = new System.Byte[16]);
            private set => _DriverOpaqueVersioningData = value;
        }

        internal System.Byte[] _DriverOpaqueVersioningData;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.Guid DriverOpaqueGUID;
            public System.Byte DriverOpaqueVersioningData;
            public System.Byte __DriverOpaqueVersioningData1;
            public System.Byte __DriverOpaqueVersioningData2;
            public System.Byte __DriverOpaqueVersioningData3;
            public System.Byte __DriverOpaqueVersioningData4;
            public System.Byte __DriverOpaqueVersioningData5;
            public System.Byte __DriverOpaqueVersioningData6;
            public System.Byte __DriverOpaqueVersioningData7;
            public System.Byte __DriverOpaqueVersioningData8;
            public System.Byte __DriverOpaqueVersioningData9;
            public System.Byte __DriverOpaqueVersioningData10;
            public System.Byte __DriverOpaqueVersioningData11;
            public System.Byte __DriverOpaqueVersioningData12;
            public System.Byte __DriverOpaqueVersioningData13;
            public System.Byte __DriverOpaqueVersioningData14;
            public System.Byte __DriverOpaqueVersioningData15;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            DriverOpaqueGUID = @ref.DriverOpaqueGUID;
            fixed (void *__to = &DriverOpaqueVersioningData[0], __from = &@ref.DriverOpaqueVersioningData)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 16 * sizeof (System.Byte));
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.DriverOpaqueGUID = DriverOpaqueGUID;
            fixed (void *__from = &DriverOpaqueVersioningData[0], __to = &@ref.DriverOpaqueVersioningData)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 16 * sizeof (System.Byte));
        }
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_SERIALIZED_RAYTRACING_ACCELERATION_STRUCTURE_HEADER</unmanaged>
    /// <unmanaged-short>D3D12_SERIALIZED_RAYTRACING_ACCELERATION_STRUCTURE_HEADER</unmanaged-short>
    public partial struct SerializedRaytracingAccelerationStructureHeader
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>DriverMatchingIdentifier</unmanaged>
        /// <unmanaged-short>DriverMatchingIdentifier</unmanaged-short>
        public SharpDX.Direct3D12.SerializedDataDriverMatchingIdentifier DriverMatchingIdentifier;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>SerializedSizeInBytesIncludingHeader</unmanaged>
        /// <unmanaged-short>SerializedSizeInBytesIncludingHeader</unmanaged-short>
        public System.Int64 SerializedSizeInBytesIncludingHeader;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>DeserializedSizeInBytes</unmanaged>
        /// <unmanaged-short>DeserializedSizeInBytes</unmanaged-short>
        public System.Int64 DeserializedSizeInBytes;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>NumBottomLevelAccelerationStructurePointersAfterHeader</unmanaged>
        /// <unmanaged-short>NumBottomLevelAccelerationStructurePointersAfterHeader</unmanaged-short>
        public System.Int64 NumBottomLevelAccelerationStructurePointersAfterHeader;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.Direct3D12.SerializedDataDriverMatchingIdentifier.__Native DriverMatchingIdentifier;
            public System.Int64 SerializedSizeInBytesIncludingHeader;
            public System.Int64 DeserializedSizeInBytes;
            public System.Int64 NumBottomLevelAccelerationStructurePointersAfterHeader;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            DriverMatchingIdentifier.__MarshalFree(ref @ref.DriverMatchingIdentifier);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            DriverMatchingIdentifier.__MarshalFrom(ref @ref.DriverMatchingIdentifier);
            SerializedSizeInBytesIncludingHeader = @ref.SerializedSizeInBytesIncludingHeader;
            DeserializedSizeInBytes = @ref.DeserializedSizeInBytes;
            NumBottomLevelAccelerationStructurePointersAfterHeader = @ref.NumBottomLevelAccelerationStructurePointersAfterHeader;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            DriverMatchingIdentifier.__MarshalTo(ref @ref.DriverMatchingIdentifier);
            @ref.SerializedSizeInBytesIncludingHeader = SerializedSizeInBytesIncludingHeader;
            @ref.DeserializedSizeInBytes = DeserializedSizeInBytes;
            @ref.NumBottomLevelAccelerationStructurePointersAfterHeader = NumBottomLevelAccelerationStructurePointersAfterHeader;
        }
    }

    /// <summary>
    /// <p>Describes shader data.</p>
    /// </summary>
    /// <remarks>
    /// <p> The <strong><see cref = "SharpDX.Direct3D12.GraphicsPipelineStateDescription"/></strong> and <strong><see cref = "SharpDX.Direct3D12.ComputePipelineStateDescription"/></strong> objects contain <strong><see cref = "SharpDX.Direct3D12.ShaderBytecode"/></strong> structures that describe various shader types. </p>
    /// </remarks>
    /// <doc-id>dn770405</doc-id>
    /// <unmanaged>D3D12_SHADER_BYTECODE</unmanaged>
    /// <unmanaged-short>D3D12_SHADER_BYTECODE</unmanaged-short>
    public partial struct ShaderBytecode
    {
        /// <summary>
        /// <dd> <p> A reference to a memory block that contains the shader data. </p> </dd>
        /// </summary>
        /// <doc-id>dn770405</doc-id>
        /// <unmanaged>pShaderBytecode</unmanaged>
        /// <unmanaged-short>pShaderBytecode</unmanaged-short>
        private System.IntPtr Pointer;
        /// <summary>
        /// <dd> <p> The size, in bytes, of the shader data that the <strong>pShaderBytecode</strong> member points to. </p> </dd>
        /// </summary>
        /// <doc-id>dn770405</doc-id>
        /// <unmanaged>BytecodeLength</unmanaged>
        /// <unmanaged-short>BytecodeLength</unmanaged-short>
        private SharpDX.PointerSize Size;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.IntPtr Pointer;
            public System.IntPtr Size;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Pointer = @ref.Pointer;
            Size = (SharpDX.PointerSize)@ref.Size;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Pointer = Pointer;
            @ref.Size = (System.IntPtr)Size;
        }
    }

    /// <summary>
    /// <p>Describes a shader-resource view.</p>
    /// </summary>
    /// <remarks>
    /// <p> A view is a format-specific way to look at the data in a resource. The view determines what data to look at, and how it is cast when read. </p><p> When viewing a resource, the resource-view description must specify a typed format, that is compatible with the resource format. So that means that you can't create a resource-view description using any format with _TYPELESS in the name. You can however view a typeless resource by specifying a typed format for the view. For example, a DXGI_FORMAT_R32G32B32_TYPELESS resource can be viewed with one of these typed formats: DXGI_FORMAT_R32G32B32_FLOAT, DXGI_FORMAT_R32G32B32_UINT, and DXGI_FORMAT_R32G32B32_SINT, since these typed formats are compatible with the typeless resource. </p><p> Create a shader-resource-view description by calling <strong>ID3D12Device::CreateShaderResourceView</strong>.</p>
    /// </remarks>
    /// <doc-id>dn770406</doc-id>
    /// <unmanaged>D3D12_SHADER_RESOURCE_VIEW_DESC</unmanaged>
    /// <unmanaged-short>D3D12_SHADER_RESOURCE_VIEW_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Explicit, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct ShaderResourceViewDescription
    {
        /// <summary>
        /// <p>Describes the elements in a buffer resource to use in a shader-resource view.</p>
        /// </summary>
        /// <remarks>
        /// <p> This structure is used by <strong><see cref = "SharpDX.Direct3D12.ShaderResourceViewDescription"/></strong> to create a view of a buffer. </p>
        /// </remarks>
        /// <doc-id>dn770343</doc-id>
        /// <unmanaged>D3D12_BUFFER_SRV</unmanaged>
        /// <unmanaged-short>D3D12_BUFFER_SRV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct BufferResource
        {
            /// <summary>
            /// <dd> <p>The index of the first element to be accessed by the view.</p> </dd>
            /// </summary>
            /// <doc-id>dn770343</doc-id>
            /// <unmanaged>FirstElement</unmanaged>
            /// <unmanaged-short>FirstElement</unmanaged-short>
            public System.Int64 FirstElement;
            /// <summary>
            /// <dd> <p>The number of elements in the resource.</p> </dd>
            /// </summary>
            /// <doc-id>dn770343</doc-id>
            /// <unmanaged>NumElements</unmanaged>
            /// <unmanaged-short>NumElements</unmanaged-short>
            public System.Int32 ElementCount;
            /// <summary>
            /// <dd> <p>The size of each element in the buffer structure (in bytes) when the buffer represents a structured buffer.</p> </dd>
            /// </summary>
            /// <doc-id>dn770343</doc-id>
            /// <unmanaged>StructureByteStride</unmanaged>
            /// <unmanaged-short>StructureByteStride</unmanaged-short>
            public System.Int32 StructureByteStride;
            /// <summary>
            /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.BufferShaderResourceViewFlags"/></strong>-typed value that identifies view options for the buffer. Currently, the only option is to identify a raw view of the buffer. For more info about raw viewing of buffers, see Raw Views of Buffers. </p> </dd>
            /// </summary>
            /// <doc-id>dn770343</doc-id>
            /// <unmanaged>Flags</unmanaged>
            /// <unmanaged-short>Flags</unmanaged-short>
            public SharpDX.Direct3D12.BufferShaderResourceViewFlags Flags;
        }

        /// <summary>
        /// <p>Specifies the subresource from a 1D texture to use in a shader-resource view.</p>
        /// </summary>
        /// <remarks>
        /// <p>This structure is one member of a shader-resource-view description, <strong><see cref = "SharpDX.Direct3D12.ShaderResourceViewDescription"/></strong>.</p><p>As an example, assuming <strong>MostDetailedMip</strong> = 6 and <strong>MipLevels</strong> = 2, the view will have access to 2 mipmap levels, 6 and 7, of the original texture for which <strong>ID3D12Device::CreateShaderResourceView</strong> creates the view. In this situation, <strong>MostDetailedMip</strong> is greater than the <strong>MipLevels</strong> in the view. However, <strong>MostDetailedMip</strong> is not greater than the <strong>MipLevels</strong> in the original resource.</p>
        /// </remarks>
        /// <doc-id>dn770420</doc-id>
        /// <unmanaged>D3D12_TEX1D_SRV</unmanaged>
        /// <unmanaged-short>D3D12_TEX1D_SRV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture1DResource
        {
            /// <summary>
            /// <dd> <p>Index of the most detailed mipmap level to use; this number is between 0 and <strong>MipLevels</strong> (from the original Texture1D for which <strong>ID3D12Device::CreateShaderResourceView</strong> creates a view) -1.</p> </dd>
            /// </summary>
            /// <doc-id>dn770420</doc-id>
            /// <unmanaged>MostDetailedMip</unmanaged>
            /// <unmanaged-short>MostDetailedMip</unmanaged-short>
            public System.Int32 MostDetailedMip;
            /// <summary>
            /// <dd> <p>The maximum number of mipmap levels for the view  of the texture. See the remarks.</p> <p>Set to -1 to indicate all the mipmap levels from <strong>MostDetailedMip</strong> on down to least detailed.</p> </dd>
            /// </summary>
            /// <doc-id>dn770420</doc-id>
            /// <unmanaged>MipLevels</unmanaged>
            /// <unmanaged-short>MipLevels</unmanaged-short>
            public System.Int32 MipLevels;
            /// <summary>
            /// <dd> <p>A value to clamp sample LOD values to. For example, if you specify 2.0f for the clamp value, you ensure that no individual sample accesses a mip level less than 2.0f.</p> </dd>
            /// </summary>
            /// <doc-id>dn770420</doc-id>
            /// <unmanaged>ResourceMinLODClamp</unmanaged>
            /// <unmanaged-short>ResourceMinLODClamp</unmanaged-short>
            public System.Single ResourceMinLODClamp;
        }

        /// <summary>
        /// <p>Describes the subresources from an array of 1D textures to use in a shader-resource view.</p>
        /// </summary>
        /// <remarks>
        /// <p>This structure is one member of a shader-resource-view description, <strong><see cref = "SharpDX.Direct3D12.ShaderResourceViewDescription"/></strong>.</p>
        /// </remarks>
        /// <doc-id>dn770416</doc-id>
        /// <unmanaged>D3D12_TEX1D_ARRAY_SRV</unmanaged>
        /// <unmanaged-short>D3D12_TEX1D_ARRAY_SRV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture1DArrayResource
        {
            /// <summary>
            /// <dd> <p>Index of the most detailed mipmap level to use; this number is between 0 and <strong>MipLevels</strong> (from the original Texture1D for which <strong>ID3D12Device::CreateShaderResourceView</strong> creates a view) -1.</p> </dd>
            /// </summary>
            /// <doc-id>dn770416</doc-id>
            /// <unmanaged>MostDetailedMip</unmanaged>
            /// <unmanaged-short>MostDetailedMip</unmanaged-short>
            public System.Int32 MostDetailedMip;
            /// <summary>
            /// <dd> <p>The maximum number of mipmap levels for the view of the texture. See the remarks in <strong><see cref = "SharpDX.Direct3D12.Texture1DResource"/></strong>.</p> <p>Set to -1 to indicate all the mipmap levels from <strong>MostDetailedMip</strong> on down to least detailed.</p> </dd>
            /// </summary>
            /// <doc-id>dn770416</doc-id>
            /// <unmanaged>MipLevels</unmanaged>
            /// <unmanaged-short>MipLevels</unmanaged-short>
            public System.Int32 MipLevels;
            /// <summary>
            /// <dd> <p>The index of the first texture to use in an array of textures.</p> </dd>
            /// </summary>
            /// <doc-id>dn770416</doc-id>
            /// <unmanaged>FirstArraySlice</unmanaged>
            /// <unmanaged-short>FirstArraySlice</unmanaged-short>
            public System.Int32 FirstArraySlice;
            /// <summary>
            /// <dd> <p>Number of textures in the array.</p> </dd>
            /// </summary>
            /// <doc-id>dn770416</doc-id>
            /// <unmanaged>ArraySize</unmanaged>
            /// <unmanaged-short>ArraySize</unmanaged-short>
            public System.Int32 ArraySize;
            /// <summary>
            /// <dd> <p>A value to clamp sample LOD values to. For example, if you specify 2.0f for the clamp value, you ensure that no individual sample accesses a mip level less than 2.0f.</p> </dd>
            /// </summary>
            /// <doc-id>dn770416</doc-id>
            /// <unmanaged>ResourceMinLODClamp</unmanaged>
            /// <unmanaged-short>ResourceMinLODClamp</unmanaged-short>
            public System.Single ResourceMinLODClamp;
        }

        /// <summary>
        /// <p>Describes the subresource from a 2D texture to use in a shader-resource view.</p>
        /// </summary>
        /// <remarks>
        /// <p> This structure is one member of a shader-resource-view description, <strong><see cref = "SharpDX.Direct3D12.ShaderResourceViewDescription"/></strong>. </p>
        /// </remarks>
        /// <doc-id>dn770434</doc-id>
        /// <unmanaged>D3D12_TEX2D_SRV</unmanaged>
        /// <unmanaged-short>D3D12_TEX2D_SRV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture2DResource
        {
            /// <summary>
            /// <dd> <p> Index of the most detailed mipmap level to use; this number is between 0 and <strong>MipLevels</strong> (from the original Texture2D for which <strong>ID3D12Device::CreateShaderResourceView</strong> creates a view) -1. </p> </dd>
            /// </summary>
            /// <doc-id>dn770434</doc-id>
            /// <unmanaged>MostDetailedMip</unmanaged>
            /// <unmanaged-short>MostDetailedMip</unmanaged-short>
            public System.Int32 MostDetailedMip;
            /// <summary>
            /// <dd> <p> The maximum number of mipmap levels for the view of the texture. See the remarks in <strong><see cref = "SharpDX.Direct3D12.Texture1DResource"/></strong>. </p> <p> Set to -1 to indicate all the mipmap levels from <strong>MostDetailedMip</strong> on down to least detailed. </p> </dd>
            /// </summary>
            /// <doc-id>dn770434</doc-id>
            /// <unmanaged>MipLevels</unmanaged>
            /// <unmanaged-short>MipLevels</unmanaged-short>
            public System.Int32 MipLevels;
            /// <summary>
            /// <dd> <p> The index (plane slice number) of the plane to use in the texture. </p> </dd>
            /// </summary>
            /// <doc-id>dn770434</doc-id>
            /// <unmanaged>PlaneSlice</unmanaged>
            /// <unmanaged-short>PlaneSlice</unmanaged-short>
            public System.Int32 PlaneSlice;
            /// <summary>
            /// <dd> <p>A value to clamp sample LOD values to. For example, if you specify 2.0f for the clamp value, you ensure that no individual sample accesses a mip level less than 2.0f.</p> </dd>
            /// </summary>
            /// <doc-id>dn770434</doc-id>
            /// <unmanaged>ResourceMinLODClamp</unmanaged>
            /// <unmanaged-short>ResourceMinLODClamp</unmanaged-short>
            public System.Single ResourceMinLODClamp;
        }

        /// <summary>
        /// <p>Describes the subresources from an array of 2D textures to use in a shader-resource view.</p>
        /// </summary>
        /// <remarks>
        /// <p> This structure is one member of a shader-resource-view description, <strong><see cref = "SharpDX.Direct3D12.ShaderResourceViewDescription"/></strong>. </p>
        /// </remarks>
        /// <doc-id>dn770430</doc-id>
        /// <unmanaged>D3D12_TEX2D_ARRAY_SRV</unmanaged>
        /// <unmanaged-short>D3D12_TEX2D_ARRAY_SRV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture2DArrayResource
        {
            /// <summary>
            /// <dd> <p> Index of the most detailed mipmap level to use; this number is between 0 and <strong>MipLevels</strong> -1 (where <strong>MipLevels</strong> is from the original Texture2D for which <strong>ID3D12Device::CreateShaderResourceView</strong> creates a view). </p> </dd>
            /// </summary>
            /// <doc-id>dn770430</doc-id>
            /// <unmanaged>MostDetailedMip</unmanaged>
            /// <unmanaged-short>MostDetailedMip</unmanaged-short>
            public System.Int32 MostDetailedMip;
            /// <summary>
            /// <dd> <p> The maximum number of mipmap levels for the view of the texture. See the remarks in <strong><see cref = "SharpDX.Direct3D12.Texture1DResource"/></strong>. </p> <p> Set to -1 to indicate all the mipmap levels from <strong>MostDetailedMip</strong> on down to least detailed. </p> </dd>
            /// </summary>
            /// <doc-id>dn770430</doc-id>
            /// <unmanaged>MipLevels</unmanaged>
            /// <unmanaged-short>MipLevels</unmanaged-short>
            public System.Int32 MipLevels;
            /// <summary>
            /// <dd> <p>The index of the first texture to use in an array of textures.</p> </dd>
            /// </summary>
            /// <doc-id>dn770430</doc-id>
            /// <unmanaged>FirstArraySlice</unmanaged>
            /// <unmanaged-short>FirstArraySlice</unmanaged-short>
            public System.Int32 FirstArraySlice;
            /// <summary>
            /// <dd> <p>Number of textures in the array.</p> </dd>
            /// </summary>
            /// <doc-id>dn770430</doc-id>
            /// <unmanaged>ArraySize</unmanaged>
            /// <unmanaged-short>ArraySize</unmanaged-short>
            public System.Int32 ArraySize;
            /// <summary>
            /// <dd> <p> The index (plane slice number) of the plane to use in an array of textures. </p> </dd>
            /// </summary>
            /// <doc-id>dn770430</doc-id>
            /// <unmanaged>PlaneSlice</unmanaged>
            /// <unmanaged-short>PlaneSlice</unmanaged-short>
            public System.Int32 PlaneSlice;
            /// <summary>
            /// <dd> <p>A value to clamp sample LOD values to. For example, if you specify 2.0f for the clamp value, you ensure that no individual sample accesses a mip level less than 2.0f.</p> </dd>
            /// </summary>
            /// <doc-id>dn770430</doc-id>
            /// <unmanaged>ResourceMinLODClamp</unmanaged>
            /// <unmanaged-short>ResourceMinLODClamp</unmanaged-short>
            public System.Single ResourceMinLODClamp;
        }

        /// <summary>
        /// <p>Describes the subresources from a 3D texture to use in a shader-resource view.</p>
        /// </summary>
        /// <remarks>
        /// <p>This structure is one member of a shader-resource-view description, <strong><see cref = "SharpDX.Direct3D12.ShaderResourceViewDescription"/></strong>.</p>
        /// </remarks>
        /// <doc-id>dn770437</doc-id>
        /// <unmanaged>D3D12_TEX3D_SRV</unmanaged>
        /// <unmanaged-short>D3D12_TEX3D_SRV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture3DResource
        {
            /// <summary>
            /// <dd> <p>Index of the most detailed mipmap level to use; this number is between 0 and <strong>MipLevels</strong> (from the original Texture3D for which <strong>ID3D12Device::CreateShaderResourceView</strong> creates a view) -1.</p> </dd>
            /// </summary>
            /// <doc-id>dn770437</doc-id>
            /// <unmanaged>MostDetailedMip</unmanaged>
            /// <unmanaged-short>MostDetailedMip</unmanaged-short>
            public System.Int32 MostDetailedMip;
            /// <summary>
            /// <dd> <p>The maximum number of mipmap levels for the view of the texture. See the remarks in <strong><see cref = "SharpDX.Direct3D12.Texture1DResource"/></strong>.</p> <p>Set to -1 to indicate all the mipmap levels from <strong>MostDetailedMip</strong> on down to least detailed.</p> </dd>
            /// </summary>
            /// <doc-id>dn770437</doc-id>
            /// <unmanaged>MipLevels</unmanaged>
            /// <unmanaged-short>MipLevels</unmanaged-short>
            public System.Int32 MipLevels;
            /// <summary>
            /// <dd> <p>A value to clamp sample LOD values to. For example, if you specify 2.0f for the clamp value, you ensure that no individual sample accesses a mip level less than 2.0f.</p> </dd>
            /// </summary>
            /// <doc-id>dn770437</doc-id>
            /// <unmanaged>ResourceMinLODClamp</unmanaged>
            /// <unmanaged-short>ResourceMinLODClamp</unmanaged-short>
            public System.Single ResourceMinLODClamp;
        }

        /// <summary>
        /// <p>Describes the subresource from a cube texture to use in a shader-resource view.</p>
        /// </summary>
        /// <remarks>
        /// <p>This structure is one member of a shader-resource-view description, <strong><see cref = "SharpDX.Direct3D12.ShaderResourceViewDescription"/></strong>.</p>
        /// </remarks>
        /// <doc-id>dn770440</doc-id>
        /// <unmanaged>D3D12_TEXCUBE_SRV</unmanaged>
        /// <unmanaged-short>D3D12_TEXCUBE_SRV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct TextureCubeResource
        {
            /// <summary>
            /// <dd> <p>Index of the most detailed mipmap level to use; this number is between 0 and <strong>MipLevels</strong> (from the original TextureCube for which <strong>ID3D12Device::CreateShaderResourceView</strong> creates a view) -1.</p> </dd>
            /// </summary>
            /// <doc-id>dn770440</doc-id>
            /// <unmanaged>MostDetailedMip</unmanaged>
            /// <unmanaged-short>MostDetailedMip</unmanaged-short>
            public System.Int32 MostDetailedMip;
            /// <summary>
            /// <dd> <p>The maximum number of mipmap levels for the view of the texture. See the remarks in <strong><see cref = "SharpDX.Direct3D12.Texture1DResource"/></strong>.</p> <p>Set to -1 to indicate all the mipmap levels from <strong>MostDetailedMip</strong> on down to least detailed.</p> </dd>
            /// </summary>
            /// <doc-id>dn770440</doc-id>
            /// <unmanaged>MipLevels</unmanaged>
            /// <unmanaged-short>MipLevels</unmanaged-short>
            public System.Int32 MipLevels;
            /// <summary>
            /// <dd> <p>A value to clamp sample LOD values to. For example, if you specify 2.0f for the clamp value, you ensure that no individual sample accesses a mip level less than 2.0f.</p> </dd>
            /// </summary>
            /// <doc-id>dn770440</doc-id>
            /// <unmanaged>ResourceMinLODClamp</unmanaged>
            /// <unmanaged-short>ResourceMinLODClamp</unmanaged-short>
            public System.Single ResourceMinLODClamp;
        }

        /// <summary>
        /// <p>Describes the subresources from an array of cube textures to use in a shader-resource view.</p>
        /// </summary>
        /// <remarks>
        /// <p>This structure is one member of a shader-resource-view description, <strong><see cref = "SharpDX.Direct3D12.ShaderResourceViewDescription"/></strong>.</p>
        /// </remarks>
        /// <doc-id>dn770439</doc-id>
        /// <unmanaged>D3D12_TEXCUBE_ARRAY_SRV</unmanaged>
        /// <unmanaged-short>D3D12_TEXCUBE_ARRAY_SRV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct TextureCubeArrayResource
        {
            /// <summary>
            /// <dd> <p>Index of the most detailed mipmap level to use; this number is between 0 and <strong>MipLevels</strong> (from the original TextureCube for which <strong>ID3D12Device::CreateShaderResourceView</strong> creates a view) -1.</p> </dd>
            /// </summary>
            /// <doc-id>dn770439</doc-id>
            /// <unmanaged>MostDetailedMip</unmanaged>
            /// <unmanaged-short>MostDetailedMip</unmanaged-short>
            public System.Int32 MostDetailedMip;
            /// <summary>
            /// <dd> <p>The maximum number of mipmap levels for the view of the texture. See the remarks in <strong><see cref = "SharpDX.Direct3D12.Texture1DResource"/></strong>.</p> <p>Set to -1 to indicate all the mipmap levels from <strong>MostDetailedMip</strong> on down to least detailed.</p> </dd>
            /// </summary>
            /// <doc-id>dn770439</doc-id>
            /// <unmanaged>MipLevels</unmanaged>
            /// <unmanaged-short>MipLevels</unmanaged-short>
            public System.Int32 MipLevels;
            /// <summary>
            /// <dd> <p>Index of the first 2D texture to use.</p> </dd>
            /// </summary>
            /// <doc-id>dn770439</doc-id>
            /// <unmanaged>First2DArrayFace</unmanaged>
            /// <unmanaged-short>First2DArrayFace</unmanaged-short>
            public System.Int32 First2DArrayFace;
            /// <summary>
            /// <dd> <p>Number of cube textures in the array.</p> </dd>
            /// </summary>
            /// <doc-id>dn770439</doc-id>
            /// <unmanaged>NumCubes</unmanaged>
            /// <unmanaged-short>NumCubes</unmanaged-short>
            public System.Int32 CubeCount;
            /// <summary>
            /// <dd> <p>A value to clamp sample LOD values to. For example, if you specify 2.0f for the clamp value, you ensure that no individual sample accesses a mip level less than 2.0f.</p> </dd>
            /// </summary>
            /// <doc-id>dn770439</doc-id>
            /// <unmanaged>ResourceMinLODClamp</unmanaged>
            /// <unmanaged-short>ResourceMinLODClamp</unmanaged-short>
            public System.Single ResourceMinLODClamp;
        }

        /// <summary>
        /// <p>Describes the subresources from a multi sampled 2D texture to use in a shader-resource view.</p>
        /// </summary>
        /// <remarks>
        /// <p>This structure is a member of the <strong><see cref = "SharpDX.Direct3D12.ShaderResourceViewDescription"/></strong> structure.</p><p>Since a multi sampled 2D texture contains a single subresource, there is actually nothing to specify in <strong><see cref = "SharpDX.Direct3D12.Texture2DMultisampledResource"/></strong>. Consequently, <strong>UnusedField_NothingToDefine</strong> is included so that this structure will compile in C.</p>
        /// </remarks>
        /// <doc-id>dn770427</doc-id>
        /// <unmanaged>D3D12_TEX2DMS_SRV</unmanaged>
        /// <unmanaged-short>D3D12_TEX2DMS_SRV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture2DMultisampledResource
        {
            /// <summary>
            /// <dd> <p>Integer of any value. See remarks.</p> </dd>
            /// </summary>
            /// <doc-id>dn770427</doc-id>
            /// <unmanaged>UnusedField_NothingToDefine</unmanaged>
            /// <unmanaged-short>UnusedField_NothingToDefine</unmanaged-short>
            public System.Int32 UnusedFieldNothingToDefine;
        }

        /// <summary>
        /// <p>Describes the subresources from an array of multi sampled 2D textures to use in a shader-resource view.</p>
        /// </summary>
        /// <remarks>
        /// <p>This structure is one member of a shader-resource-view description, <strong><see cref = "SharpDX.Direct3D12.ShaderResourceViewDescription"/></strong>.</p>
        /// </remarks>
        /// <doc-id>dn770424</doc-id>
        /// <unmanaged>D3D12_TEX2DMS_ARRAY_SRV</unmanaged>
        /// <unmanaged-short>D3D12_TEX2DMS_ARRAY_SRV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture2DMultisampledArrayResource
        {
            /// <summary>
            /// <dd> <p>The index of the first texture to use in an array of textures.</p> </dd>
            /// </summary>
            /// <doc-id>dn770424</doc-id>
            /// <unmanaged>FirstArraySlice</unmanaged>
            /// <unmanaged-short>FirstArraySlice</unmanaged-short>
            public System.Int32 FirstArraySlice;
            /// <summary>
            /// <dd> <p>Number of textures to use.</p> </dd>
            /// </summary>
            /// <doc-id>dn770424</doc-id>
            /// <unmanaged>ArraySize</unmanaged>
            /// <unmanaged-short>ArraySize</unmanaged-short>
            public System.Int32 ArraySize;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_SRV</unmanaged>
        /// <unmanaged-short>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_SRV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct RaytracingAccelerationStructureResource
        {
            /// <summary>
            /// No documentation.
            /// </summary>
            /// <unmanaged>Location</unmanaged>
            /// <unmanaged-short>Location</unmanaged-short>
            public System.Int64 Location;
        }

        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.DXGI.Format"/></strong>-typed value that  specifies the viewing format. See remarks. </p> </dd>
        /// </summary>
        /// <doc-id>dn770406</doc-id>
        /// <unmanaged>Format</unmanaged>
        /// <unmanaged-short>Format</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(0)]
        public SharpDX.DXGI.Format Format;
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.ShaderResourceViewDimension"/></strong>-typed value that  specifies the resource type of the view.  This type is the same as the resource type of the underlying resource.  This member also determines which _SRV to use in the union below. </p> </dd>
        /// </summary>
        /// <doc-id>dn770406</doc-id>
        /// <unmanaged>ViewDimension</unmanaged>
        /// <unmanaged-short>ViewDimension</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(4)]
        public SharpDX.Direct3D12.ShaderResourceViewDimension Dimension;
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.ShaderComponentMapping"/></strong> enumeration constant, such as return component 0 (red) from memory, or force the resulting value to 0. This mapping enables the shader resource view (SRV) to choose how memory gets routed to the 4 return components in a shader after a memory fetch.   </p> </dd>
        /// </summary>
        /// <doc-id>dn770406</doc-id>
        /// <unmanaged>Shader4ComponentMapping</unmanaged>
        /// <unmanaged-short>Shader4ComponentMapping</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public System.Int32 Shader4ComponentMapping;
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.BufferResource"/></strong> structure that views the resource as a buffer. </p> </dd>
        /// </summary>
        /// <doc-id>dn770406</doc-id>
        /// <unmanaged>Buffer</unmanaged>
        /// <unmanaged-short>Buffer</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(16)]
        public SharpDX.Direct3D12.ShaderResourceViewDescription.BufferResource Buffer;
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.Texture1DResource"/></strong> structure that views the resource as a 1D texture. </p> </dd>
        /// </summary>
        /// <doc-id>dn770406</doc-id>
        /// <unmanaged>Texture1D</unmanaged>
        /// <unmanaged-short>Texture1D</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(16)]
        public SharpDX.Direct3D12.ShaderResourceViewDescription.Texture1DResource Texture1D;
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.Texture1DArrayResource"/></strong> structure that views the resource as a 1D-texture array. </p> </dd>
        /// </summary>
        /// <doc-id>dn770406</doc-id>
        /// <unmanaged>Texture1DArray</unmanaged>
        /// <unmanaged-short>Texture1DArray</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(16)]
        public SharpDX.Direct3D12.ShaderResourceViewDescription.Texture1DArrayResource Texture1DArray;
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.Texture2DResource"/></strong> structure that views the resource as a 2D-texture. </p> </dd>
        /// </summary>
        /// <doc-id>dn770406</doc-id>
        /// <unmanaged>Texture2D</unmanaged>
        /// <unmanaged-short>Texture2D</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(16)]
        public SharpDX.Direct3D12.ShaderResourceViewDescription.Texture2DResource Texture2D;
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.Texture2DArrayResource"/></strong> structure that views the resource as a 2D-texture array. </p> </dd>
        /// </summary>
        /// <doc-id>dn770406</doc-id>
        /// <unmanaged>Texture2DArray</unmanaged>
        /// <unmanaged-short>Texture2DArray</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(16)]
        public SharpDX.Direct3D12.ShaderResourceViewDescription.Texture2DArrayResource Texture2DArray;
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.Texture2DMultisampledResource"/></strong> structure that views the resource as a 2D-multisampled texture. </p> </dd>
        /// </summary>
        /// <doc-id>dn770406</doc-id>
        /// <unmanaged>Texture2DMS</unmanaged>
        /// <unmanaged-short>Texture2DMS</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(16)]
        public SharpDX.Direct3D12.ShaderResourceViewDescription.Texture2DMultisampledResource Texture2DMS;
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.Texture2DMultisampledArrayResource"/></strong> structure that views the resource as a 2D-multisampled-texture array. </p> </dd>
        /// </summary>
        /// <doc-id>dn770406</doc-id>
        /// <unmanaged>Texture2DMSArray</unmanaged>
        /// <unmanaged-short>Texture2DMSArray</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(16)]
        public SharpDX.Direct3D12.ShaderResourceViewDescription.Texture2DMultisampledArrayResource Texture2DMSArray;
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.Texture3DResource"/></strong> structure that views the resource as a 3D texture. </p> </dd>
        /// </summary>
        /// <doc-id>dn770406</doc-id>
        /// <unmanaged>Texture3D</unmanaged>
        /// <unmanaged-short>Texture3D</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(16)]
        public SharpDX.Direct3D12.ShaderResourceViewDescription.Texture3DResource Texture3D;
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.TextureCubeResource"/></strong> structure that views the resource as a 3D-cube texture. </p> </dd>
        /// </summary>
        /// <doc-id>dn770406</doc-id>
        /// <unmanaged>TextureCube</unmanaged>
        /// <unmanaged-short>TextureCube</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(16)]
        public SharpDX.Direct3D12.ShaderResourceViewDescription.TextureCubeResource TextureCube;
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.TextureCubeArrayResource"/></strong> structure that views the resource as a 3D-cube-texture array. </p> </dd>
        /// </summary>
        /// <doc-id>dn770406</doc-id>
        /// <unmanaged>TextureCubeArray</unmanaged>
        /// <unmanaged-short>TextureCubeArray</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(16)]
        public SharpDX.Direct3D12.ShaderResourceViewDescription.TextureCubeArrayResource TextureCubeArray;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn770406</doc-id>
        /// <unmanaged>RaytracingAccelerationStructure</unmanaged>
        /// <unmanaged-short>RaytracingAccelerationStructure</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(16)]
        public SharpDX.Direct3D12.ShaderResourceViewDescription.RaytracingAccelerationStructureResource RaytracingAccelerationStructure;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_STATE_OBJECT_CONFIG</unmanaged>
    /// <unmanaged-short>D3D12_STATE_OBJECT_CONFIG</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct StateObjectConfig
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Flags</unmanaged>
        /// <unmanaged-short>Flags</unmanaged-short>
        public SharpDX.Direct3D12.StateObjectFlags Flags;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_STATE_OBJECT_DESC</unmanaged>
    /// <unmanaged-short>D3D12_STATE_OBJECT_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct StateObjectDescription
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Type</unmanaged>
        /// <unmanaged-short>Type</unmanaged-short>
        public SharpDX.Direct3D12.StateObjectType Type;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>NumSubobjects</unmanaged>
        /// <unmanaged-short>NumSubobjects</unmanaged-short>
        public System.Int32 SubobjectCount;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>pSubobjects</unmanaged>
        /// <unmanaged-short>pSubobjects</unmanaged-short>
        public System.IntPtr SubobjectsPointer;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_STATE_SUBOBJECT</unmanaged>
    /// <unmanaged-short>D3D12_STATE_SUBOBJECT</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct StateSubObject
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Type</unmanaged>
        /// <unmanaged-short>Type</unmanaged-short>
        public SharpDX.Direct3D12.StateSubObjectType Type;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>pDesc</unmanaged>
        /// <unmanaged-short>pDesc</unmanaged-short>
        public System.IntPtr DescPointer;
    }

    /// <summary>
    /// <p> Describes a static sampler. </p>
    /// </summary>
    /// <remarks>
    /// <p> Use this structure with the <strong><see cref = "SharpDX.Direct3D12.RootSignatureDescription"/></strong> structure. </p>
    /// </remarks>
    /// <doc-id>dn986748</doc-id>
    /// <unmanaged>D3D12_STATIC_SAMPLER_DESC</unmanaged>
    /// <unmanaged-short>D3D12_STATIC_SAMPLER_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct StaticSamplerDescription
    {
        /// <summary>
        /// <dd> <p> The filtering method to use when sampling a texture, as a <strong><see cref = "SharpDX.Direct3D12.Filter"/></strong> enumeration constant. </p> </dd>
        /// </summary>
        /// <doc-id>dn986748</doc-id>
        /// <unmanaged>Filter</unmanaged>
        /// <unmanaged-short>Filter</unmanaged-short>
        public SharpDX.Direct3D12.Filter Filter;
        /// <summary>
        /// <dd> <p> Specifies the <strong><see cref = "SharpDX.Direct3D12.TextureAddressMode"/></strong> mode to use for resolving a <em>u</em> texture coordinate that is outside the 0 to 1 range. </p> </dd>
        /// </summary>
        /// <doc-id>dn986748</doc-id>
        /// <unmanaged>AddressU</unmanaged>
        /// <unmanaged-short>AddressU</unmanaged-short>
        public SharpDX.Direct3D12.TextureAddressMode AddressU;
        /// <summary>
        /// <dd> <p> Specifies the <strong><see cref = "SharpDX.Direct3D12.TextureAddressMode"/></strong> mode to use for resolving a <em>v</em> texture coordinate that is outside the 0 to 1 range. </p> </dd>
        /// </summary>
        /// <doc-id>dn986748</doc-id>
        /// <unmanaged>AddressV</unmanaged>
        /// <unmanaged-short>AddressV</unmanaged-short>
        public SharpDX.Direct3D12.TextureAddressMode AddressV;
        /// <summary>
        /// <dd> <p> Specifies the <strong><see cref = "SharpDX.Direct3D12.TextureAddressMode"/></strong> mode to use for resolving a <em>w</em> texture coordinate that is outside the 0 to 1 range. </p> </dd>
        /// </summary>
        /// <doc-id>dn986748</doc-id>
        /// <unmanaged>AddressW</unmanaged>
        /// <unmanaged-short>AddressW</unmanaged-short>
        public SharpDX.Direct3D12.TextureAddressMode AddressW;
        /// <summary>
        /// <dd> <p> Offset from the calculated mipmap level. For example, if Direct3D calculates that a texture should be sampled at mipmap level 3 and MipLODBias is 2, then the texture will be sampled at mipmap level 5. </p> </dd>
        /// </summary>
        /// <doc-id>dn986748</doc-id>
        /// <unmanaged>MipLODBias</unmanaged>
        /// <unmanaged-short>MipLODBias</unmanaged-short>
        public System.Single MipLODBias;
        /// <summary>
        /// <dd> <p> Clamping value used if D3D12_FILTER_ANISOTROPIC or D3D12_FILTER_COMPARISON_ANISOTROPIC is specified as the filter. Valid values are between 1 and 16. </p> </dd>
        /// </summary>
        /// <doc-id>dn986748</doc-id>
        /// <unmanaged>MaxAnisotropy</unmanaged>
        /// <unmanaged-short>MaxAnisotropy</unmanaged-short>
        public System.Int32 MaxAnisotropy;
        /// <summary>
        /// <dd> <p> A function that compares sampled data against existing sampled data.  The function options are listed in <strong><see cref = "SharpDX.Direct3D12.Comparison"/></strong>. </p> </dd>
        /// </summary>
        /// <doc-id>dn986748</doc-id>
        /// <unmanaged>ComparisonFunc</unmanaged>
        /// <unmanaged-short>ComparisonFunc</unmanaged-short>
        public SharpDX.Direct3D12.Comparison ComparisonFunc;
        /// <summary>
        /// <dd> <p> One member of <strong><see cref = "SharpDX.Direct3D12.StaticBorderColor"/></strong>, the border color to use if D3D12_TEXTURE_ADDRESS_MODE_BORDER is specified for AddressU, AddressV, or AddressW.  Range must be between 0.0 and 1.0 inclusive. </p> </dd>
        /// </summary>
        /// <doc-id>dn986748</doc-id>
        /// <unmanaged>BorderColor</unmanaged>
        /// <unmanaged-short>BorderColor</unmanaged-short>
        public SharpDX.Direct3D12.StaticBorderColor BorderColor;
        /// <summary>
        /// <dd> <p> Lower end of the mipmap range to clamp access to, where 0 is the largest and most detailed mipmap level and any level higher than that is less detailed. </p> </dd>
        /// </summary>
        /// <doc-id>dn986748</doc-id>
        /// <unmanaged>MinLOD</unmanaged>
        /// <unmanaged-short>MinLOD</unmanaged-short>
        public System.Single MinLOD;
        /// <summary>
        /// <dd> <p> Upper end of the mipmap range to clamp access to, where 0 is the largest and most detailed mipmap level and any level higher than that is less detailed. This value must be greater than or equal to MinLOD. To have no upper limit on LOD set this to a large value such as D3D12_FLOAT32_MAX. </p> </dd>
        /// </summary>
        /// <doc-id>dn986748</doc-id>
        /// <unmanaged>MaxLOD</unmanaged>
        /// <unmanaged-short>MaxLOD</unmanaged-short>
        public System.Single MaxLOD;
        /// <summary>
        /// <dd> <p> The <em>ShaderRegister</em> and <em>RegisterSpace</em> parameters correspond to the binding syntax of HLSL.  For example, in HLSL: </p> <code>Texture2D&lt;float4&gt; a : register(t2, space3);</code> <p> This corresponds to a  <em>ShaderRegister</em> of 2 (indicating the type is SRV), and <em>RegisterSpace</em> is 3. </p> <p> The  <em>ShaderRegister</em> and <em>RegisterSpace</em> pair is needed to establish correspondence between shader resources and runtime heap descriptors, using the root signature data structure. </p> </dd>
        /// </summary>
        /// <doc-id>dn986748</doc-id>
        /// <unmanaged>ShaderRegister</unmanaged>
        /// <unmanaged-short>ShaderRegister</unmanaged-short>
        public System.Int32 ShaderRegister;
        /// <summary>
        /// <dd> <p> See the description for <em>ShaderRegister</em>. Register space is optional; the default register space is 0. </p> </dd>
        /// </summary>
        /// <doc-id>dn986748</doc-id>
        /// <unmanaged>RegisterSpace</unmanaged>
        /// <unmanaged-short>RegisterSpace</unmanaged-short>
        public System.Int32 RegisterSpace;
        /// <summary>
        /// <dd> <p> Specifies the visibility of the sampler to the pipeline shaders, one member of <strong><see cref = "SharpDX.Direct3D12.ShaderVisibility"/></strong>. </p> </dd>
        /// </summary>
        /// <doc-id>dn986748</doc-id>
        /// <unmanaged>ShaderVisibility</unmanaged>
        /// <unmanaged-short>ShaderVisibility</unmanaged-short>
        public SharpDX.Direct3D12.ShaderVisibility ShaderVisibility;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_STREAM_OUTPUT_BUFFER_VIEW</unmanaged>
    /// <unmanaged-short>D3D12_STREAM_OUTPUT_BUFFER_VIEW</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct StreamOutputBufferView
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>BufferLocation</unmanaged>
        /// <unmanaged-short>BufferLocation</unmanaged-short>
        public System.Int64 BufferLocation;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>SizeInBytes</unmanaged>
        /// <unmanaged-short>SizeInBytes</unmanaged-short>
        public System.Int64 SizeInBytes;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>BufferFilledSizeLocation</unmanaged>
        /// <unmanaged-short>BufferFilledSizeLocation</unmanaged-short>
        public System.Int64 BufferFilledSizeLocation;
    }

    /// <summary>
    /// <p>Describes a streaming output buffer.</p>
    /// </summary>
    /// <remarks>
    /// <p> A <strong><see cref = "SharpDX.Direct3D12.GraphicsPipelineStateDescription"/></strong> object contains a <strong><see cref = "SharpDX.Direct3D12.StreamOutputDescription"/></strong> structure. </p>
    /// </remarks>
    /// <doc-id>dn770410</doc-id>
    /// <unmanaged>D3D12_STREAM_OUTPUT_DESC</unmanaged>
    /// <unmanaged-short>D3D12_STREAM_OUTPUT_DESC</unmanaged-short>
    public partial class StreamOutputDescription
    {
        /// <summary>
        /// <dd> <p> An array of <strong><see cref = "SharpDX.Direct3D12.StreamOutputElement"/></strong> structures. Can't be <strong><c>null</c></strong> if <strong>NumEntries</strong> &gt; 0. </p> </dd>
        /// </summary>
        /// <doc-id>dn770410</doc-id>
        /// <unmanaged>pSODeclaration</unmanaged>
        /// <unmanaged-short>pSODeclaration</unmanaged-short>
        private System.IntPtr StreamOutputEntriesPointer;
        /// <summary>
        /// <dd> <p> The number of entries in the stream output declaration array that the <strong>pSODeclaration</strong> member points to. </p> </dd>
        /// </summary>
        /// <doc-id>dn770410</doc-id>
        /// <unmanaged>NumEntries</unmanaged>
        /// <unmanaged-short>NumEntries</unmanaged-short>
        private System.Int32 EntrieCount;
        /// <summary>
        /// <dd> <p> An array of buffer strides; each stride is the size of an element for that buffer. </p> </dd>
        /// </summary>
        /// <doc-id>dn770410</doc-id>
        /// <unmanaged>pBufferStrides</unmanaged>
        /// <unmanaged-short>pBufferStrides</unmanaged-short>
        public System.IntPtr BufferStridesPointer;
        /// <summary>
        /// <dd> <p> The number of strides (or buffers) that the <strong>pBufferStrides</strong> member points to. </p> </dd>
        /// </summary>
        /// <doc-id>dn770410</doc-id>
        /// <unmanaged>NumStrides</unmanaged>
        /// <unmanaged-short>NumStrides</unmanaged-short>
        public System.Int32 StrideCount;
        /// <summary>
        /// <dd> <p> The index number of the stream to be sent to the rasterizer stage. </p> </dd>
        /// </summary>
        /// <doc-id>dn770410</doc-id>
        /// <unmanaged>RasterizedStream</unmanaged>
        /// <unmanaged-short>RasterizedStream</unmanaged-short>
        public System.Int32 RasterizedStream;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.IntPtr StreamOutputEntriesPointer;
            public System.Int32 EntrieCount;
            public System.IntPtr BufferStridesPointer;
            public System.Int32 StrideCount;
            public System.Int32 RasterizedStream;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            StreamOutputEntriesPointer = @ref.StreamOutputEntriesPointer;
            EntrieCount = @ref.EntrieCount;
            BufferStridesPointer = @ref.BufferStridesPointer;
            StrideCount = @ref.StrideCount;
            RasterizedStream = @ref.RasterizedStream;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.StreamOutputEntriesPointer = StreamOutputEntriesPointer;
            @ref.EntrieCount = EntrieCount;
            @ref.BufferStridesPointer = BufferStridesPointer;
            @ref.StrideCount = StrideCount;
            @ref.RasterizedStream = RasterizedStream;
        }
    }

    /// <summary>
    /// <p>Describes a vertex element in a vertex buffer in an output slot.</p>
    /// </summary>
    /// <remarks>
    /// <p>Specify an array of <strong><see cref = "SharpDX.Direct3D12.StreamOutputElement"/></strong> structures in the <strong>pSODeclaration</strong> member of a <strong><see cref = "SharpDX.Direct3D12.StreamOutputDescription"/></strong> structure. </p>
    /// </remarks>
    /// <doc-id>dn879483</doc-id>
    /// <unmanaged>D3D12_SO_DECLARATION_ENTRY</unmanaged>
    /// <unmanaged-short>D3D12_SO_DECLARATION_ENTRY</unmanaged-short>
    public partial struct StreamOutputElement
    {
        /// <summary>
        /// <dd> <p>Zero-based, stream number.</p> </dd>
        /// </summary>
        /// <doc-id>dn879483</doc-id>
        /// <unmanaged>Stream</unmanaged>
        /// <unmanaged-short>Stream</unmanaged-short>
        public System.Int32 Stream;
        /// <summary>
        /// <dd> <p>Type of output element; possible values include: <strong>"POSITION"</strong>, <strong>"NORMAL"</strong>, or <strong>"TEXCOORD0"</strong>. Note that if <strong>SemanticName</strong> is <strong><c>null</c></strong> then  <strong>ComponentCount</strong> can be greater than 4 and the described entry will be a gap in the stream out where no data will be written. </p> </dd>
        /// </summary>
        /// <doc-id>dn879483</doc-id>
        /// <unmanaged>SemanticName</unmanaged>
        /// <unmanaged-short>SemanticName</unmanaged-short>
        public System.String SemanticName;
        /// <summary>
        /// <dd> <p>Output element's zero-based index. Use, for example, if you have more than one texture coordinate stored in each vertex.</p> </dd>
        /// </summary>
        /// <doc-id>dn879483</doc-id>
        /// <unmanaged>SemanticIndex</unmanaged>
        /// <unmanaged-short>SemanticIndex</unmanaged-short>
        public System.Int32 SemanticIndex;
        /// <summary>
        /// <dd> <p>The component of the entry to begin writing out to. Valid values are 0 to 3. For example, if you only wish to output to the y and z components  of a position, <strong>StartComponent</strong> is 1 and <strong>ComponentCount</strong> is 2.</p> </dd>
        /// </summary>
        /// <doc-id>dn879483</doc-id>
        /// <unmanaged>StartComponent</unmanaged>
        /// <unmanaged-short>StartComponent</unmanaged-short>
        public System.Byte StartComponent;
        /// <summary>
        /// <dd> <p>The number of components of the entry to write out to. Valid values are 1 to 4. For example, if you only wish to output to the y and z components  of a position, <strong>StartComponent</strong> is 1 and <strong>ComponentCount</strong> is 2.  Note that if <strong>SemanticName</strong> is <strong><c>null</c></strong> then  <strong>ComponentCount</strong> can be greater than 4 and the described entry will be a gap in the stream out where no data will be written.</p> </dd>
        /// </summary>
        /// <doc-id>dn879483</doc-id>
        /// <unmanaged>ComponentCount</unmanaged>
        /// <unmanaged-short>ComponentCount</unmanaged-short>
        public System.Byte ComponentCount;
        /// <summary>
        /// <dd> <p>The associated stream output buffer that is bound to the pipeline.  The valid range for <strong>OutputSlot</strong> is 0 to 3.</p> </dd>
        /// </summary>
        /// <doc-id>dn879483</doc-id>
        /// <unmanaged>OutputSlot</unmanaged>
        /// <unmanaged-short>OutputSlot</unmanaged-short>
        public System.Byte OutputSlot;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.Int32 Stream;
            public System.IntPtr SemanticName;
            public System.Int32 SemanticIndex;
            public System.Byte StartComponent;
            public System.Byte ComponentCount;
            public System.Byte OutputSlot;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.SemanticName);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Stream = @ref.Stream;
            SemanticName = System.Runtime.InteropServices.Marshal.PtrToStringAnsi(@ref.SemanticName);
            SemanticIndex = @ref.SemanticIndex;
            StartComponent = @ref.StartComponent;
            ComponentCount = @ref.ComponentCount;
            OutputSlot = @ref.OutputSlot;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Stream = Stream;
            @ref.SemanticName = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(SemanticName);
            @ref.SemanticIndex = SemanticIndex;
            @ref.StartComponent = StartComponent;
            @ref.ComponentCount = ComponentCount;
            @ref.OutputSlot = OutputSlot;
        }
    }

    /// <summary>
    /// <p>Describes query data for stream output.</p>
    /// </summary>
    /// <remarks>
    /// <p>Use this structure with <strong><see cref = "SharpDX.Direct3D12.QueryHeapType"/></strong> and <strong>CreateQueryHeap</strong>.</p>
    /// </remarks>
    /// <doc-id>dn903809</doc-id>
    /// <unmanaged>D3D12_QUERY_DATA_SO_STATISTICS</unmanaged>
    /// <unmanaged-short>D3D12_QUERY_DATA_SO_STATISTICS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct StreamOutputStatistics
    {
        /// <summary>
        /// <dd> <p>Specifies the number of primitives written.</p> </dd>
        /// </summary>
        /// <doc-id>dn903809</doc-id>
        /// <unmanaged>NumPrimitivesWritten</unmanaged>
        /// <unmanaged-short>NumPrimitivesWritten</unmanaged-short>
        public System.Int64 NumPrimitivesWritten;
        /// <summary>
        /// <dd> <p>Specifies the total amount of storage needed by the primitives.</p> </dd>
        /// </summary>
        /// <doc-id>dn903809</doc-id>
        /// <unmanaged>PrimitivesStorageNeeded</unmanaged>
        /// <unmanaged-short>PrimitivesStorageNeeded</unmanaged-short>
        public System.Int64 PrimitivesStorageNeeded;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_SUBOBJECT_TO_EXPORTS_ASSOCIATION</unmanaged>
    /// <unmanaged-short>D3D12_SUBOBJECT_TO_EXPORTS_ASSOCIATION</unmanaged-short>
    public partial struct SubObjectToExportsAssociation
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>pSubobjectToAssociate</unmanaged>
        /// <unmanaged-short>pSubobjectToAssociate</unmanaged-short>
        public System.IntPtr SubobjectToAssociatePointer;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>NumExports</unmanaged>
        /// <unmanaged-short>NumExports</unmanaged-short>
        public System.Int32 ExportCount;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>pExports</unmanaged>
        /// <unmanaged-short>pExports</unmanaged-short>
        public System.String ExportsPointer;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.IntPtr SubobjectToAssociatePointer;
            public System.Int32 ExportCount;
            public System.IntPtr ExportsPointer;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.ExportsPointer);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            SubobjectToAssociatePointer = @ref.SubobjectToAssociatePointer;
            ExportCount = @ref.ExportCount;
            ExportsPointer = System.Runtime.InteropServices.Marshal.PtrToStringUni(@ref.ExportsPointer);
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.SubobjectToAssociatePointer = SubobjectToAssociatePointer;
            @ref.ExportCount = ExportCount;
            @ref.ExportsPointer = System.Runtime.InteropServices.Marshal.StringToHGlobalUni(ExportsPointer);
        }
    }

    /// <summary>
    /// <p> Describes subresource data. </p>
    /// </summary>
    /// <remarks>
    /// <p>This structure is used by a number of the helper functions, refer to Helper Structures and Functions for D3D12.</p>
    /// </remarks>
    /// <doc-id>dn879485</doc-id>
    /// <unmanaged>D3D12_SUBRESOURCE_DATA</unmanaged>
    /// <unmanaged-short>D3D12_SUBRESOURCE_DATA</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    internal partial struct SubResourceData
    {
        /// <summary>
        /// <dd> <p> A reference to a memory block that contains the subresource data. </p> </dd>
        /// </summary>
        /// <doc-id>dn879485</doc-id>
        /// <unmanaged>pData</unmanaged>
        /// <unmanaged-short>pData</unmanaged-short>
        public System.IntPtr DataPointer;
        /// <summary>
        /// <dd> <p> The row pitch, or width, or physical size, in bytes, of the subresource data. </p> </dd>
        /// </summary>
        /// <doc-id>dn879485</doc-id>
        /// <unmanaged>RowPitch</unmanaged>
        /// <unmanaged-short>RowPitch</unmanaged-short>
        public System.IntPtr RowPitch;
        /// <summary>
        /// <dd> <p> The depth pitch, or width, or physical size, in bytes, of the subresource data. </p> </dd>
        /// </summary>
        /// <doc-id>dn879485</doc-id>
        /// <unmanaged>SlicePitch</unmanaged>
        /// <unmanaged-short>SlicePitch</unmanaged-short>
        public System.IntPtr SlicePitch;
    }

    /// <summary>
    /// <p> Describes the format, width, height, depth, and row-pitch of the subresource into the parent resource. </p>
    /// </summary>
    /// <remarks>
    /// <p> Use this structure in the <strong><see cref = "SharpDX.Direct3D12.PlacedSubResourceFootprint"/></strong> structure. </p><p> The helper structure is <strong>CD3DX12_SUBRESOURCE_FOOTPRINT</strong>. </p>
    /// </remarks>
    /// <doc-id>dn986749</doc-id>
    /// <unmanaged>D3D12_SUBRESOURCE_FOOTPRINT</unmanaged>
    /// <unmanaged-short>D3D12_SUBRESOURCE_FOOTPRINT</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct SubResourceFootprint
    {
        /// <summary>
        /// <dd> <p> A <strong><see cref = "SharpDX.DXGI.Format"/></strong>-typed value that  specifies the viewing format. </p> </dd>
        /// </summary>
        /// <doc-id>dn986749</doc-id>
        /// <unmanaged>Format</unmanaged>
        /// <unmanaged-short>Format</unmanaged-short>
        public SharpDX.DXGI.Format Format;
        /// <summary>
        /// <dd> <p> The width of the subresource. </p> </dd>
        /// </summary>
        /// <doc-id>dn986749</doc-id>
        /// <unmanaged>Width</unmanaged>
        /// <unmanaged-short>Width</unmanaged-short>
        public System.Int32 Width;
        /// <summary>
        /// <dd> <p> The height of the subresource. </p> </dd>
        /// </summary>
        /// <doc-id>dn986749</doc-id>
        /// <unmanaged>Height</unmanaged>
        /// <unmanaged-short>Height</unmanaged-short>
        public System.Int32 Height;
        /// <summary>
        /// <dd> <p> The depth of the subresource. </p> </dd>
        /// </summary>
        /// <doc-id>dn986749</doc-id>
        /// <unmanaged>Depth</unmanaged>
        /// <unmanaged-short>Depth</unmanaged-short>
        public System.Int32 Depth;
        /// <summary>
        /// <dd> <p> The row pitch, or width, or physical size, in bytes, of the subresource data. This must be a multiple of D3D12_TEXTURE_DATA_PITCH_ALIGNMENT (256), and must be greater than or equal to the size of the data within a row. </p> </dd>
        /// </summary>
        /// <doc-id>dn986749</doc-id>
        /// <unmanaged>RowPitch</unmanaged>
        /// <unmanaged-short>RowPitch</unmanaged-short>
        public System.Int32 RowPitch;
    }

    /// <summary>
    /// <p>Describes subresource data.</p>
    /// </summary>
    /// <doc-id>dn770411</doc-id>
    /// <unmanaged>D3D12_SUBRESOURCE_INFO</unmanaged>
    /// <unmanaged-short>D3D12_SUBRESOURCE_INFO</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct SubResourceInformation
    {
        /// <summary>
        /// <dd> <p>Offset, in bytes, between the start of the parent resource and this subresource.</p> </dd>
        /// </summary>
        /// <doc-id>dn770411</doc-id>
        /// <unmanaged>Offset</unmanaged>
        /// <unmanaged-short>Offset</unmanaged-short>
        public System.Int64 Offset;
        /// <summary>
        /// <dd> <p>The row pitch, or width, or physical size, in bytes, of the subresource data.</p> </dd>
        /// </summary>
        /// <doc-id>dn770411</doc-id>
        /// <unmanaged>RowPitch</unmanaged>
        /// <unmanaged-short>RowPitch</unmanaged-short>
        public System.Int32 RowPitch;
        /// <summary>
        /// <dd> <p>The depth pitch, or width, or physical size, in bytes, of the subresource data.</p> </dd>
        /// </summary>
        /// <doc-id>dn770411</doc-id>
        /// <unmanaged>DepthPitch</unmanaged>
        /// <unmanaged-short>DepthPitch</unmanaged-short>
        public System.Int32 DepthPitch;
    }

    /// <summary>
    /// <p>Describes a subresource memory range.</p>
    /// </summary>
    /// <remarks>
    /// <p> This structure is used by the <strong>AtomicCopyBufferUINT</strong> and <strong>AtomicCopyBufferUINT64</strong> methods. </p>
    /// </remarks>
    /// <doc-id>mt492640</doc-id>
    /// <unmanaged>D3D12_SUBRESOURCE_RANGE_UINT64</unmanaged>
    /// <unmanaged-short>D3D12_SUBRESOURCE_RANGE_UINT64</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct SubResourceRangeUInt64
    {
        /// <summary>
        /// <dd> <p>The index of the subresource.</p> </dd>
        /// </summary>
        /// <doc-id>mt492640</doc-id>
        /// <unmanaged>Subresource</unmanaged>
        /// <unmanaged-short>Subresource</unmanaged-short>
        public System.Int32 Subresource;
        /// <summary>
        /// <dd> <p>A memory range within the subresource.</p> </dd>
        /// </summary>
        /// <doc-id>mt492640</doc-id>
        /// <unmanaged>Range</unmanaged>
        /// <unmanaged-short>Range</unmanaged-short>
        public SharpDX.Direct3D12.RangeUInt64 Range;
    }

    /// <summary>
    /// <p>Describes a tiled subresource volume.</p>
    /// </summary>
    /// <remarks>
    /// <p> This structure is used by the <strong>GetResourceTiling</strong> method. </p>
    /// </remarks>
    /// <doc-id>dn770412</doc-id>
    /// <unmanaged>D3D12_SUBRESOURCE_TILING</unmanaged>
    /// <unmanaged-short>D3D12_SUBRESOURCE_TILING</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct SubResourceTiling
    {
        /// <summary>
        /// <dd> <p>The width in tiles of the subresource.</p> </dd>
        /// </summary>
        /// <doc-id>dn770412</doc-id>
        /// <unmanaged>WidthInTiles</unmanaged>
        /// <unmanaged-short>WidthInTiles</unmanaged-short>
        public System.Int32 WidthInTiles;
        /// <summary>
        /// <dd> <p>The height in tiles of the subresource.</p> </dd>
        /// </summary>
        /// <doc-id>dn770412</doc-id>
        /// <unmanaged>HeightInTiles</unmanaged>
        /// <unmanaged-short>HeightInTiles</unmanaged-short>
        public System.Int16 HeightInTiles;
        /// <summary>
        /// <dd> <p>The depth in tiles of the subresource.</p> </dd>
        /// </summary>
        /// <doc-id>dn770412</doc-id>
        /// <unmanaged>DepthInTiles</unmanaged>
        /// <unmanaged-short>DepthInTiles</unmanaged-short>
        public System.Int16 DepthInTiles;
        /// <summary>
        /// <dd> <p>The index of the tile in the overall tiled subresource to start with. </p> </dd>
        /// </summary>
        /// <doc-id>dn770412</doc-id>
        /// <unmanaged>StartTileIndexInOverallResource</unmanaged>
        /// <unmanaged-short>StartTileIndexInOverallResource</unmanaged-short>
        public System.Int32 StartTileIndexInOverallResource;
    }

    /// <summary>
    /// <p>Describes a portion of a texture for the purpose of texture copies. </p>
    /// </summary>
    /// <remarks>
    /// <p> Use this structure with <strong>CopyTextureRegion</strong>. </p>
    /// </remarks>
    /// <doc-id>dn903818</doc-id>
    /// <unmanaged>D3D12_TEXTURE_COPY_LOCATION</unmanaged>
    /// <unmanaged-short>D3D12_TEXTURE_COPY_LOCATION</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct TextureCopyLocation
    {
    }

    /// <summary>
    /// <p>Describes the coordinates of a tiled resource.</p>
    /// </summary>
    /// <remarks>
    /// <p> This structure is used by the <strong>CopyTiles</strong>, <strong>CopyTileMappings</strong> and <strong>UpdateTileMappings</strong> methods. </p>
    /// </remarks>
    /// <doc-id>dn770443</doc-id>
    /// <unmanaged>D3D12_TILED_RESOURCE_COORDINATE</unmanaged>
    /// <unmanaged-short>D3D12_TILED_RESOURCE_COORDINATE</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct TiledResourceCoordinate
    {
        /// <summary>
        /// <dd> <p>The x-coordinate of the tiled resource.</p> </dd>
        /// </summary>
        /// <doc-id>dn770443</doc-id>
        /// <unmanaged>X</unmanaged>
        /// <unmanaged-short>X</unmanaged-short>
        public System.Int32 X;
        /// <summary>
        /// <dd> <p>The y-coordinate of the tiled resource.</p> </dd>
        /// </summary>
        /// <doc-id>dn770443</doc-id>
        /// <unmanaged>Y</unmanaged>
        /// <unmanaged-short>Y</unmanaged-short>
        public System.Int32 Y;
        /// <summary>
        /// <dd> <p>The z-coordinate of the tiled resource.</p> </dd>
        /// </summary>
        /// <doc-id>dn770443</doc-id>
        /// <unmanaged>Z</unmanaged>
        /// <unmanaged-short>Z</unmanaged-short>
        public System.Int32 Z;
        /// <summary>
        /// <dd> <p>The index of the subresource for the tiled resource.</p> </dd>
        /// </summary>
        /// <doc-id>dn770443</doc-id>
        /// <unmanaged>Subresource</unmanaged>
        /// <unmanaged-short>Subresource</unmanaged-short>
        public System.Int32 Subresource;
    }

    /// <summary>
    /// <p>Describes the size of a tiled region.</p>
    /// </summary>
    /// <remarks>
    /// <p> This structure is used by the <strong>CopyTiles</strong>, <strong>CopyTileMappings</strong> and <strong>UpdateTileMappings</strong> methods. </p>
    /// </remarks>
    /// <doc-id>dn770448</doc-id>
    /// <unmanaged>D3D12_TILE_REGION_SIZE</unmanaged>
    /// <unmanaged-short>D3D12_TILE_REGION_SIZE</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct TileRegionSize
    {
        /// <summary>
        /// <dd> <p>The number of tiles in the tiled region.</p> </dd>
        /// </summary>
        /// <doc-id>dn770448</doc-id>
        /// <unmanaged>NumTiles</unmanaged>
        /// <unmanaged-short>NumTiles</unmanaged-short>
        public System.Int32 TileCount;
        /// <summary>
        /// <dd> <p> Specifies whether the runtime uses the <strong>Width</strong>, <strong>Height</strong>, and <strong>Depth</strong> members to define the region. </p> <p> If <strong>TRUE</strong>, the runtime uses the <strong>Width</strong>, <strong>Height</strong>, and <strong>Depth</strong> members to define the region. In this case,  <strong>NumTiles</strong> should be equal to <strong>Width</strong> *  <strong>Height</strong> * <strong>Depth</strong>.</p> <p> If <strong><see cref = "SharpDX.Result.False"/></strong>, the runtime ignores the <strong>Width</strong>, <strong>Height</strong>, and <strong>Depth</strong> members and uses the <strong>NumTiles</strong> member to traverse tiles in the resource linearly across x, then y, then z (as applicable) and then spills over mipmaps/arrays in subresource order.  For example, use this technique to map an entire resource at once. </p> <p> Regardless of whether you specify <strong>TRUE</strong> or <strong><see cref = "SharpDX.Result.False"/></strong> for <strong>UseBox</strong>, you use a <strong><see cref = "SharpDX.Direct3D12.TiledResourceCoordinate"/></strong> structure to specify the starting location for the region within the resource as a separate parameter outside of this structure by using x, y, and z coordinates. </p> <p> When the region includes mipmaps that are packed with nonstandard tiling, <strong>UseBox</strong> must be <strong><see cref = "SharpDX.Result.False"/></strong> because tile dimensions are not standard and the app only knows a count of how many tiles are consumed by the packed area, which is per array slice.  The corresponding (separate) starting location parameter uses x to offset into the flat range of tiles in this case, and y and z coordinates must each be 0. </p> </dd>
        /// </summary>
        /// <doc-id>dn770448</doc-id>
        /// <unmanaged>UseBox</unmanaged>
        /// <unmanaged-short>UseBox</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool UseBox;
        /// <summary>
        /// <dd> <p> The width of the tiled region, in tiles. Used for buffer and 1D, 2D, and 3D textures. For more info, see Tile and toast image sizes. </p> </dd>
        /// </summary>
        /// <doc-id>dn770448</doc-id>
        /// <unmanaged>Width</unmanaged>
        /// <unmanaged-short>Width</unmanaged-short>
        public System.Int32 Width;
        /// <summary>
        /// <dd> <p> The height of the tiled region, in tiles. Used for 2D and 3D textures. For more info, see Tile and toast image sizes. </p> </dd>
        /// </summary>
        /// <doc-id>dn770448</doc-id>
        /// <unmanaged>Height</unmanaged>
        /// <unmanaged-short>Height</unmanaged-short>
        public System.Int16 Height;
        /// <summary>
        /// <dd> <p>The depth of the tiled region, in tiles. Used for 3D textures or arrays. For arrays, used for advancing in depth jumps to next slice of same mipmap size, which isn't contiguous in the subresource counting space if there are multiple mipmaps.</p> </dd>
        /// </summary>
        /// <doc-id>dn770448</doc-id>
        /// <unmanaged>Depth</unmanaged>
        /// <unmanaged-short>Depth</unmanaged-short>
        public System.Int16 Depth;
    }

    /// <summary>
    /// <p>Describes the shape of a tile by specifying its dimensions.</p>
    /// </summary>
    /// <remarks>
    /// <p> This structure is used by the <strong>GetResourceTiling</strong> method. </p>
    /// </remarks>
    /// <doc-id>dn770449</doc-id>
    /// <unmanaged>D3D12_TILE_SHAPE</unmanaged>
    /// <unmanaged-short>D3D12_TILE_SHAPE</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct TileShape
    {
        /// <summary>
        /// <dd> <p>The width in texels of the tile.</p> </dd>
        /// </summary>
        /// <doc-id>dn770449</doc-id>
        /// <unmanaged>WidthInTexels</unmanaged>
        /// <unmanaged-short>WidthInTexels</unmanaged-short>
        public System.Int32 WidthInTexels;
        /// <summary>
        /// <dd> <p>The height in texels of the tile.</p> </dd>
        /// </summary>
        /// <doc-id>dn770449</doc-id>
        /// <unmanaged>HeightInTexels</unmanaged>
        /// <unmanaged-short>HeightInTexels</unmanaged-short>
        public System.Int32 HeightInTexels;
        /// <summary>
        /// <dd> <p>The depth in texels of the tile.</p> </dd>
        /// </summary>
        /// <doc-id>dn770449</doc-id>
        /// <unmanaged>DepthInTexels</unmanaged>
        /// <unmanaged-short>DepthInTexels</unmanaged-short>
        public System.Int32 DepthInTexels;
    }

    /// <summary>
    /// <p>Describes the subresources from a resource that are accessible by using an unordered-access view.</p>
    /// </summary>
    /// <remarks>
    /// <p>Pass an unordered-access-view description into <strong>ID3D12Device::CreateUnorderedAccessView</strong> to create a view.</p>
    /// </remarks>
    /// <doc-id>dn770451</doc-id>
    /// <unmanaged>D3D12_UNORDERED_ACCESS_VIEW_DESC</unmanaged>
    /// <unmanaged-short>D3D12_UNORDERED_ACCESS_VIEW_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Explicit, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct UnorderedAccessViewDescription
    {
        /// <summary>
        /// <p>Describes the elements in a buffer to use in a unordered-access view.</p>
        /// </summary>
        /// <remarks>
        /// <p> Use this structure with a <strong><see cref = "SharpDX.Direct3D12.UnorderedAccessViewDescription"/></strong> structure to view the resource as a buffer. </p>
        /// </remarks>
        /// <doc-id>dn770345</doc-id>
        /// <unmanaged>D3D12_BUFFER_UAV</unmanaged>
        /// <unmanaged-short>D3D12_BUFFER_UAV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct BufferResource
        {
            /// <summary>
            /// <dd> <p>The zero-based index of the first element to be accessed.</p> </dd>
            /// </summary>
            /// <doc-id>dn770345</doc-id>
            /// <unmanaged>FirstElement</unmanaged>
            /// <unmanaged-short>FirstElement</unmanaged-short>
            public System.Int64 FirstElement;
            /// <summary>
            /// <dd> <p>The number of elements in the resource. For structured buffers, this is the number of structures in the buffer.</p> </dd>
            /// </summary>
            /// <doc-id>dn770345</doc-id>
            /// <unmanaged>NumElements</unmanaged>
            /// <unmanaged-short>NumElements</unmanaged-short>
            public System.Int32 ElementCount;
            /// <summary>
            /// <dd> <p>The size of each element in the buffer structure (in bytes) when the buffer represents a structured buffer.</p> </dd>
            /// </summary>
            /// <doc-id>dn770345</doc-id>
            /// <unmanaged>StructureByteStride</unmanaged>
            /// <unmanaged-short>StructureByteStride</unmanaged-short>
            public System.Int32 StructureByteStride;
            /// <summary>
            /// <dd> <p> The counter offset, in bytes. </p> </dd>
            /// </summary>
            /// <doc-id>dn770345</doc-id>
            /// <unmanaged>CounterOffsetInBytes</unmanaged>
            /// <unmanaged-short>CounterOffsetInBytes</unmanaged-short>
            public System.Int64 CounterOffsetInBytes;
            /// <summary>
            /// <dd> <p> A <strong><see cref = "SharpDX.Direct3D12.BufferUnorderedAccessViewFlags"/></strong>-typed value that specifies the view options for the resource. </p> </dd>
            /// </summary>
            /// <doc-id>dn770345</doc-id>
            /// <unmanaged>Flags</unmanaged>
            /// <unmanaged-short>Flags</unmanaged-short>
            public SharpDX.Direct3D12.BufferUnorderedAccessViewFlags Flags;
        }

        /// <summary>
        /// <p>Describes a unordered-access 1D texture resource.</p>
        /// </summary>
        /// <remarks>
        /// <p>Use this structure with a <strong><see cref = "SharpDX.Direct3D12.UnorderedAccessViewDescription"/></strong> structure to view the resource as a 1D texture.</p>
        /// </remarks>
        /// <doc-id>dn770421</doc-id>
        /// <unmanaged>D3D12_TEX1D_UAV</unmanaged>
        /// <unmanaged-short>D3D12_TEX1D_UAV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture1DResource
        {
            /// <summary>
            /// <dd> <p>The mipmap slice index.</p> </dd>
            /// </summary>
            /// <doc-id>dn770421</doc-id>
            /// <unmanaged>MipSlice</unmanaged>
            /// <unmanaged-short>MipSlice</unmanaged-short>
            public System.Int32 MipSlice;
        }

        /// <summary>
        /// <p>Describes an array of unordered-access 1D texture resources. </p>
        /// </summary>
        /// <remarks>
        /// <p>Use this structure with a <strong><see cref = "SharpDX.Direct3D12.UnorderedAccessViewDescription"/></strong> structure to view the resource as an array of 1D textures.</p>
        /// </remarks>
        /// <doc-id>dn770417</doc-id>
        /// <unmanaged>D3D12_TEX1D_ARRAY_UAV</unmanaged>
        /// <unmanaged-short>D3D12_TEX1D_ARRAY_UAV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture1DArrayResource
        {
            /// <summary>
            /// <dd> <p>The mipmap slice index.</p> </dd>
            /// </summary>
            /// <doc-id>dn770417</doc-id>
            /// <unmanaged>MipSlice</unmanaged>
            /// <unmanaged-short>MipSlice</unmanaged-short>
            public System.Int32 MipSlice;
            /// <summary>
            /// <dd> <p>The zero-based index of the first array slice to be accessed.</p> </dd>
            /// </summary>
            /// <doc-id>dn770417</doc-id>
            /// <unmanaged>FirstArraySlice</unmanaged>
            /// <unmanaged-short>FirstArraySlice</unmanaged-short>
            public System.Int32 FirstArraySlice;
            /// <summary>
            /// <dd> <p>The number of slices in the array.</p> </dd>
            /// </summary>
            /// <doc-id>dn770417</doc-id>
            /// <unmanaged>ArraySize</unmanaged>
            /// <unmanaged-short>ArraySize</unmanaged-short>
            public System.Int32 ArraySize;
        }

        /// <summary>
        /// <p>Describes a unordered-access 2D texture resource.</p>
        /// </summary>
        /// <remarks>
        /// <p> Use this structure with a <strong><see cref = "SharpDX.Direct3D12.UnorderedAccessViewDescription"/></strong> structure to view the resource as a 2D texture. </p>
        /// </remarks>
        /// <doc-id>dn770435</doc-id>
        /// <unmanaged>D3D12_TEX2D_UAV</unmanaged>
        /// <unmanaged-short>D3D12_TEX2D_UAV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture2DResource
        {
            /// <summary>
            /// <dd> <p>The mipmap slice index.</p> </dd>
            /// </summary>
            /// <doc-id>dn770435</doc-id>
            /// <unmanaged>MipSlice</unmanaged>
            /// <unmanaged-short>MipSlice</unmanaged-short>
            public System.Int32 MipSlice;
            /// <summary>
            /// <dd> <p> The index (plane slice number) of the plane to use in the texture. </p> </dd>
            /// </summary>
            /// <doc-id>dn770435</doc-id>
            /// <unmanaged>PlaneSlice</unmanaged>
            /// <unmanaged-short>PlaneSlice</unmanaged-short>
            public System.Int32 PlaneSlice;
        }

        /// <summary>
        /// <p> Describes an array of unordered-access 2D texture resources. </p>
        /// </summary>
        /// <remarks>
        /// <p> Use this structure with a <strong><see cref = "SharpDX.Direct3D12.UnorderedAccessViewDescription"/></strong> structure to view the resource as an array of 2D textures. </p>
        /// </remarks>
        /// <doc-id>dn770431</doc-id>
        /// <unmanaged>D3D12_TEX2D_ARRAY_UAV</unmanaged>
        /// <unmanaged-short>D3D12_TEX2D_ARRAY_UAV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture2DArrayResource
        {
            /// <summary>
            /// <dd> <p>The mipmap slice index.</p> </dd>
            /// </summary>
            /// <doc-id>dn770431</doc-id>
            /// <unmanaged>MipSlice</unmanaged>
            /// <unmanaged-short>MipSlice</unmanaged-short>
            public System.Int32 MipSlice;
            /// <summary>
            /// <dd> <p>The zero-based index of the first array slice to be accessed.</p> </dd>
            /// </summary>
            /// <doc-id>dn770431</doc-id>
            /// <unmanaged>FirstArraySlice</unmanaged>
            /// <unmanaged-short>FirstArraySlice</unmanaged-short>
            public System.Int32 FirstArraySlice;
            /// <summary>
            /// <dd> <p>The number of slices in the array.</p> </dd>
            /// </summary>
            /// <doc-id>dn770431</doc-id>
            /// <unmanaged>ArraySize</unmanaged>
            /// <unmanaged-short>ArraySize</unmanaged-short>
            public System.Int32 ArraySize;
            /// <summary>
            /// <dd> <p> The index (plane slice number) of the plane to use in an array of textures. </p> </dd>
            /// </summary>
            /// <doc-id>dn770431</doc-id>
            /// <unmanaged>PlaneSlice</unmanaged>
            /// <unmanaged-short>PlaneSlice</unmanaged-short>
            public System.Int32 PlaneSlice;
        }

        /// <summary>
        /// <p>Describes a unordered-access 3D texture resource.</p>
        /// </summary>
        /// <remarks>
        /// <p>Use this structure with a <strong><see cref = "SharpDX.Direct3D12.UnorderedAccessViewDescription"/></strong> structure to view the resource as a 3D texture.</p>
        /// </remarks>
        /// <doc-id>dn770438</doc-id>
        /// <unmanaged>D3D12_TEX3D_UAV</unmanaged>
        /// <unmanaged-short>D3D12_TEX3D_UAV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture3DResource
        {
            /// <summary>
            /// <dd> <p>The mipmap slice index.</p> </dd>
            /// </summary>
            /// <doc-id>dn770438</doc-id>
            /// <unmanaged>MipSlice</unmanaged>
            /// <unmanaged-short>MipSlice</unmanaged-short>
            public System.Int32 MipSlice;
            /// <summary>
            /// <dd> <p>The zero-based index of the first depth slice to be accessed.</p> </dd>
            /// </summary>
            /// <doc-id>dn770438</doc-id>
            /// <unmanaged>FirstWSlice</unmanaged>
            /// <unmanaged-short>FirstWSlice</unmanaged-short>
            public System.Int32 FirstWSlice;
            /// <summary>
            /// <dd> <p>The number of depth slices.</p> </dd>
            /// </summary>
            /// <doc-id>dn770438</doc-id>
            /// <unmanaged>WSize</unmanaged>
            /// <unmanaged-short>WSize</unmanaged-short>
            public System.Int32 WSize;
        }

        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.DXGI.Format"/></strong>-typed value that specifies the viewing format.</p> </dd>
        /// </summary>
        /// <doc-id>dn770451</doc-id>
        /// <unmanaged>Format</unmanaged>
        /// <unmanaged-short>Format</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(0)]
        public SharpDX.DXGI.Format Format;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D12.UnorderedAccessViewDimension"/></strong>-typed value that specifies the resource type of the view. This type specifies how the resource will be accessed. This member also determines which _UAV to use in the union below.</p> </dd>
        /// </summary>
        /// <doc-id>dn770451</doc-id>
        /// <unmanaged>ViewDimension</unmanaged>
        /// <unmanaged-short>ViewDimension</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(4)]
        public SharpDX.Direct3D12.UnorderedAccessViewDimension Dimension;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D12.BufferResource"/></strong> structure that specifies which buffer elements can be accessed.</p> </dd>
        /// </summary>
        /// <doc-id>dn770451</doc-id>
        /// <unmanaged>Buffer</unmanaged>
        /// <unmanaged-short>Buffer</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D12.UnorderedAccessViewDescription.BufferResource Buffer;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D12.Texture1DResource"/></strong> structure that specifies the subresources in a 1D texture that can be accessed.</p> </dd>
        /// </summary>
        /// <doc-id>dn770451</doc-id>
        /// <unmanaged>Texture1D</unmanaged>
        /// <unmanaged-short>Texture1D</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D12.UnorderedAccessViewDescription.Texture1DResource Texture1D;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D12.Texture1DArrayResource"/></strong> structure that specifies the subresources in a 1D texture array that can be accessed.</p> </dd>
        /// </summary>
        /// <doc-id>dn770451</doc-id>
        /// <unmanaged>Texture1DArray</unmanaged>
        /// <unmanaged-short>Texture1DArray</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D12.UnorderedAccessViewDescription.Texture1DArrayResource Texture1DArray;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D12.Texture2DResource"/></strong> structure that specifies the subresources in a 2D texture that can be accessed.</p> </dd>
        /// </summary>
        /// <doc-id>dn770451</doc-id>
        /// <unmanaged>Texture2D</unmanaged>
        /// <unmanaged-short>Texture2D</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D12.UnorderedAccessViewDescription.Texture2DResource Texture2D;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D12.Texture2DArrayResource"/></strong> structure that specifies the subresources in a 2D texture array that can be accessed.</p> </dd>
        /// </summary>
        /// <doc-id>dn770451</doc-id>
        /// <unmanaged>Texture2DArray</unmanaged>
        /// <unmanaged-short>Texture2DArray</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D12.UnorderedAccessViewDescription.Texture2DArrayResource Texture2DArray;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D12.Texture3DResource"/></strong> structure that specifies subresources in a 3D texture that can be accessed.</p> </dd>
        /// </summary>
        /// <doc-id>dn770451</doc-id>
        /// <unmanaged>Texture3D</unmanaged>
        /// <unmanaged-short>Texture3D</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D12.UnorderedAccessViewDescription.Texture3DResource Texture3D;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_VERSIONED_DEVICE_REMOVED_EXTENDED_DATA</unmanaged>
    /// <unmanaged-short>D3D12_VERSIONED_DEVICE_REMOVED_EXTENDED_DATA</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct VersionedDeviceRemovedExtendedData
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Version</unmanaged>
        /// <unmanaged-short>Version</unmanaged-short>
        public SharpDX.Direct3D12.DredVersion Version;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Dred_1_0</unmanaged>
        /// <unmanaged-short>Dred_1_0</unmanaged-short>
        public SharpDX.Direct3D12.DeviceRemovedExtendedData Dred10;
    }

    /// <summary>
    /// <p>Holds any version of a root signature description, and is designed to be used with serialization/deserialization functions.</p>
    /// </summary>
    /// <remarks>
    /// <p>Use this structure with the following methods.</p><ul> <li> <strong>GetRootSignatureDescAtVersion</strong> </li> <li> <strong>GetUnconvertedRootSignatureDesc</strong> </li> <li> <strong>D3D12SerializeVersionedRootSignature</strong> </li> </ul><p>Refer to the helper structure <strong>CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC</strong>. </p>
    /// </remarks>
    /// <doc-id>mt709125</doc-id>
    /// <unmanaged>D3D12_VERSIONED_ROOT_SIGNATURE_DESC</unmanaged>
    /// <unmanaged-short>D3D12_VERSIONED_ROOT_SIGNATURE_DESC</unmanaged-short>
    public partial class VersionedRootSignatureDescription
    {
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D12_VERTEX_BUFFER_VIEW</unmanaged>
    /// <unmanaged-short>D3D12_VERTEX_BUFFER_VIEW</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct VertexBufferView
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>BufferLocation</unmanaged>
        /// <unmanaged-short>BufferLocation</unmanaged-short>
        public System.Int64 BufferLocation;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>SizeInBytes</unmanaged>
        /// <unmanaged-short>SizeInBytes</unmanaged-short>
        public System.Int32 SizeInBytes;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>StrideInBytes</unmanaged>
        /// <unmanaged-short>StrideInBytes</unmanaged-short>
        public System.Int32 StrideInBytes;
    }

    /// <summary>
    /// <p>Specifies the viewport/stencil and render target associated with a view instance.</p>
    /// </summary>
    /// <remarks>
    /// <p>The values specified in a view instance location structure can be added to ViewportArrayIndex and RenderTargetArrayIndex values output by the shader prior to rasterization to compute the final effective index of the viewport and render target to send primitives to. If a computed index is out of range (that is, when the index is larger than the number of viewport or render target elements in their respective arrays) then the effective index becomes 0.</p><p>For shaders that dynamically select the viewport or render target indices, an application can set all the view instance locations declared in a PSO to the same value to act as a uniform base value for all views.</p>
    /// </remarks>
    /// <doc-id>mt844811</doc-id>
    /// <unmanaged>D3D12_VIEW_INSTANCE_LOCATION</unmanaged>
    /// <unmanaged-short>D3D12_VIEW_INSTANCE_LOCATION</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct ViewInstanceLocation
    {
        /// <summary>
        /// <dd> <p> The index of the viewport in the viewports array to be used by the view instance associated with this location. </p> </dd>
        /// </summary>
        /// <doc-id>mt844811</doc-id>
        /// <unmanaged>ViewportArrayIndex</unmanaged>
        /// <unmanaged-short>ViewportArrayIndex</unmanaged-short>
        public System.Int32 ViewportArrayIndex;
        /// <summary>
        /// <dd> <p> The index of the render target in the render targets array to be used by the view instance associated with this location. </p> </dd>
        /// </summary>
        /// <doc-id>mt844811</doc-id>
        /// <unmanaged>RenderTargetArrayIndex</unmanaged>
        /// <unmanaged-short>RenderTargetArrayIndex</unmanaged-short>
        public System.Int32 RenderTargetArrayIndex;
    }

    /// <summary>
    /// <p>Specifies parameters used during view instancing configuration.</p>
    /// </summary>
    /// <remarks>
    /// <p>View instancing is declared in a PSO using this structure. The view instance count is set in the PSO to allow whole-pipeline optimization based on the number of views.</p><p>View instancing is disabled when it's not declared in the PSO or when ViewInstanceCount is set to 0. When disabled, rendering behaves as if view instancing is enabled and ViewInstanceCount is set to 1; shaders only see a value of 0 in SV_ViewID and just one view instance is produced. This allows shaders that are aware of view instancing to still be used in PSOs that disable it. Some adapters might support shader model 6.1 (which exposes SV_ViewID) but not view instancing; these adapters must still support shaders that input SV_ViewID in PSOs that declare ViewInstanceCount as 0 or 1.</p><p>The shader prior to rasterization can output SV_RenderTargetArrayIndex and SV_ViewportArrayIndex values which don't have to depend on SV_ViewID. To compute the final effective index of the viewport and render target where primitives will be sent, these values, when present, are added to the ViewportArrayIndex and RenderTargetArrayIndex values of the view instance locations declared in the PSO. If a computed index is out of range (that is, when the index is larger than the number of viewport or render target elements in their respective arrays) then the effective index becomes 0.</p><p>For shaders that dynamically select the viewport or render target indices, an application can set all the view instance locations declared in the PSO to a single value (such as 0) to act as a uniform base index to which the dynamically-selected SV_RenderTargetArrayIndex and SV_ViewportArrayIndex values are added.</p>
    /// </remarks>
    /// <doc-id>mt844812</doc-id>
    /// <unmanaged>D3D12_VIEW_INSTANCING_DESC</unmanaged>
    /// <unmanaged-short>D3D12_VIEW_INSTANCING_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct ViewInstancingDescription
    {
        /// <summary>
        /// <dd> <p> Specifies the number of views to be used, up to D3D12_MAX_VIEW_INSTANCE_COUNT. </p> </dd>
        /// </summary>
        /// <doc-id>mt844812</doc-id>
        /// <unmanaged>ViewInstanceCount</unmanaged>
        /// <unmanaged-short>ViewInstanceCount</unmanaged-short>
        public System.Int32 ViewInstanceCount;
        /// <summary>
        /// <dd> <p> The address of a memory location that contains <strong>ViewInstanceCount</strong> view instance location structures that specify the location of viewport/scissor and render target details of each view instance.  </p> </dd>
        /// </summary>
        /// <doc-id>mt844812</doc-id>
        /// <unmanaged>pViewInstanceLocations</unmanaged>
        /// <unmanaged-short>pViewInstanceLocations</unmanaged-short>
        public System.IntPtr ViewInstanceLocationsPointer;
        /// <summary>
        /// <dd> <p> Configures view instancing with additional options. </p> </dd>
        /// </summary>
        /// <doc-id>mt844812</doc-id>
        /// <unmanaged>Flags</unmanaged>
        /// <unmanaged-short>Flags</unmanaged-short>
        public SharpDX.Direct3D12.ViewInstancingFlags Flags;
    }

    /// <summary>
    /// <p>Describes the dimensions of a viewport.</p>
    /// </summary>
    /// <remarks>
    /// <p>Pass an array of these structures to the <em>pViewports</em> parameter  in a call to  <strong>ID3D12GraphicsCommandList::RSSetViewports</strong> to set viewports for the display.</p>
    /// </remarks>
    /// <doc-id>dn770454</doc-id>
    /// <unmanaged>D3D12_VIEWPORT</unmanaged>
    /// <unmanaged-short>D3D12_VIEWPORT</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct Viewport
    {
        /// <summary>
        /// <dd> <p>X position of the left hand side of the viewport. </p> </dd>
        /// </summary>
        /// <doc-id>dn770454</doc-id>
        /// <unmanaged>TopLeftX</unmanaged>
        /// <unmanaged-short>TopLeftX</unmanaged-short>
        public System.Single TopLeftX;
        /// <summary>
        /// <dd> <p>Y position of the top of the viewport. </p> </dd>
        /// </summary>
        /// <doc-id>dn770454</doc-id>
        /// <unmanaged>TopLeftY</unmanaged>
        /// <unmanaged-short>TopLeftY</unmanaged-short>
        public System.Single TopLeftY;
        /// <summary>
        /// <dd> <p>Width of the viewport.</p> </dd>
        /// </summary>
        /// <doc-id>dn770454</doc-id>
        /// <unmanaged>Width</unmanaged>
        /// <unmanaged-short>Width</unmanaged-short>
        public System.Single Width;
        /// <summary>
        /// <dd> <p>Height of the viewport.</p> </dd>
        /// </summary>
        /// <doc-id>dn770454</doc-id>
        /// <unmanaged>Height</unmanaged>
        /// <unmanaged-short>Height</unmanaged-short>
        public System.Single Height;
        /// <summary>
        /// <dd> <p>Minimum depth of the viewport. Ranges between 0 and 1.</p> </dd>
        /// </summary>
        /// <doc-id>dn770454</doc-id>
        /// <unmanaged>MinDepth</unmanaged>
        /// <unmanaged-short>MinDepth</unmanaged-short>
        public System.Single MinDepth;
        /// <summary>
        /// <dd> <p>Maximum depth of the viewport. Ranges between 0 and 1.</p> </dd>
        /// </summary>
        /// <doc-id>dn770454</doc-id>
        /// <unmanaged>MaxDepth</unmanaged>
        /// <unmanaged-short>MaxDepth</unmanaged-short>
        public System.Single MaxDepth;
    }

    /// <summary>
    /// <p>Specifies the immediate value and destination address written using <strong>ID3D12CommandList2::WriteBufferImmediate</strong>.</p>
    /// </summary>
    /// <remarks>
    /// <p></p>
    /// </remarks>
    /// <doc-id>mt844815</doc-id>
    /// <unmanaged>D3D12_WRITEBUFFERIMMEDIATE_PARAMETER</unmanaged>
    /// <unmanaged-short>D3D12_WRITEBUFFERIMMEDIATE_PARAMETER</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct WriteBufferImmediateParameter
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>mt844815</doc-id>
        /// <unmanaged>Dest</unmanaged>
        /// <unmanaged-short>Dest</unmanaged-short>
        public System.Int64 Dest;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>mt844815</doc-id>
        /// <unmanaged>Value</unmanaged>
        /// <unmanaged-short>Value</unmanaged-short>
        public System.Int32 Value;
    }
}
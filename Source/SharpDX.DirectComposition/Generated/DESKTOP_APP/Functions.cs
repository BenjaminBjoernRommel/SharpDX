// <auto-generated/>

namespace SharpDX.DirectComposition
{
    /// <summary>
    /// Functions
    /// </summary>
    public partial class DComp
    {
        /// <summary>
        /// <p>Creates a new device object that can be used to create other Microsoft DirectComposition objects.</p>
        /// </summary>
        /// <param name = "dxgiDevice"><dd>  <p>The DXGI device to use to create DirectComposition surface objects.</p> </dd></param>
        /// <param name = "iid"><dd>  <p>The identifier of the interface to retrieve. </p> </dd></param>
        /// <param name = "dcompositionDevice"><dd>  <p>Receives an interface reference to the newly created device object. The reference is of the type specified by the <em>iid</em> parameter. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>A  device object serves as the factory for all other DirectComposition objects. It also controls transactional composition through the <strong>IDCompositionDevice::Commit</strong> method.</p><p>The DXGI device specified by <em>dxgiDevice</em> is used to create all DirectComposition surface objects. In particular, the <strong>IDCompositionSurface::BeginDraw</strong> method returns an interface reference to a DXGI surface that belongs to the device specified by the <em>dxgiDevice</em> parameter. </p><p>When creating the DXGI device, developers must specify the <strong>D3D11_CREATE_DEVICE BGRA_SUPPORT</strong> or <strong>D3D10_CREATE_DEVICE_BGRA_SUPPORT</strong> flag for Direct2D interoperability with Microsoft Direct3D resources.</p><p>The <em>iid</em> parameter must be <code>__uuidof(<see cref = "SharpDX.DirectComposition.Device"/>)</code>, and the <em>dcompositionDevice</em> parameter receives a reference to an <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface.
        /// </p>
        /// </remarks>
        /// <doc-id>hh437359</doc-id>
        /// <unmanaged>HRESULT DCompositionCreateDevice([In, Optional] IDXGIDevice* dxgiDevice,[In] const GUID&amp; iid,[Out] void** dcompositionDevice)</unmanaged>
        /// <unmanaged-short>DCompositionCreateDevice</unmanaged-short>
        internal static unsafe void CreateDevice(SharpDX.DXGI.Device dxgiDevice, System.Guid iid, out System.IntPtr dcompositionDevice)
        {
            System.IntPtr dxgiDevice_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            dxgiDevice_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DXGI.Device>(dxgiDevice);
            fixed (void *dcompositionDevice_ = &dcompositionDevice)
                __result__ = DCompositionCreateDevice_((void *)dxgiDevice_, &iid, dcompositionDevice_);
            __result__.CheckError();
        }

        [System.Runtime.InteropServices.DllImportAttribute("dcomp.dll", EntryPoint = "DCompositionCreateDevice", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern int DCompositionCreateDevice_(void *param0, void *param1, void *param2);
        /// <summary>
        /// <p>Creates a new device object that can be used to create other Microsoft DirectComposition objects.</p>
        /// </summary>
        /// <param name = "renderingDevice"><dd> <p>An optional reference to a DirectX device to be used to create DirectComposition surface objects. Must be a reference to an object implementing the <strong><see cref = "SharpDX.DXGI.Device"/></strong> or <strong><see cref = "SharpDX.Direct2D1.Device"/></strong> interfaces.</p> </dd></param>
        /// <param name = "iid"><dd> <p>The identifier of the interface to retrieve. This must be one of __uuidof(<see cref = "SharpDX.DirectComposition.Device"/>) or __uuidof(<see cref = "SharpDX.DirectComposition.DesktopDevice"/>).</p> </dd></param>
        /// <param name = "dcompositionDevice"><dd> <p>Receives an interface reference to the newly created device object. The reference is of the type specified by the <em>iid</em> parameter. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>A device object serves as the factory for all other DirectComposition objects. It also controls transactional composition through the IDCompositionDevice2::Commit method. </p><p>The <em>renderingDevice</em> parameter may point to a DXGI, Direct3D, Direct2D device object, or it may be <c>null</c>. This parameter affects the behavior of the IDCompositionDevice2::CreateSurface, IDCompositionDevice2::CreateVirtualSurface and IDCompositionSurface::BeginDraw methods. </p><p>If the <em>renderingDevice</em> parameter is <c>null</c> then the returned DirectComposition device cannot directly create DirectComposition surface objects. In particular, IDCompositionDevice2::CreateSurface and IDCompositionDevice2::CreateVirtualSurface methods return E_INVALIDARG, regardless of the supplied parameters. However, such a DirectComposition device object can still be used to indirectly create surfaces if the application creates a surface factory object via the IDCompositionDevice2::CreateSurfaceFactory method. </p><p>If the <em>renderingDevice</em> parameter points to a DXGI device, that device is used to allocate all video memory needed by the IDCompositionDevice2::CreateSurface and IDCompositionDevice2::CreateVirtualSurface methods. Moreover, the IDCompositionSurface::BeginDraw method returns an interface reference to a DXGI surface that belongs to that same DXGI device. </p><p>If the <em>renderingDevice</em> parameter points to a Direct2D device object, DirectComposition extracts from it the underlying DXGI device object and uses it as if that DXGI device object had been passed in as the <em>renderingDevice</em> parameter. However, passing in a Direct2D object further causes IDCompositionSurface::BeginDraw to accept __uuidof(<see cref = "SharpDX.Direct2D1.DeviceContext"/>) for its <em>iid</em> parameter for any objects created with the IDCompositionDevice2::CreateSurface or IDCompositionDevice2::CreateVirtualSurface methods. In that case, the Direct2D device context object returned by IDCompositionSurface::BeginDraw will belong to the same Direct2D device passed as the <em>renderingDevice</em> parameter. </p><p>If the <em>iid</em> parameter is __uuidof(<see cref = "SharpDX.DirectComposition.Device"/>), then the dcompositionDevice parameter receives a reference to a Version 1 <see cref = "SharpDX.DirectComposition.Device"/> interface, but the underlying object is a Version 2 desktop device object. The application can later obtain a reference to either the <see cref = "SharpDX.DirectComposition.Device2"/> or <see cref = "SharpDX.DirectComposition.DesktopDevice"/> interfaces by calling the <strong>QueryInterface</strong> method on that device. Similarly, all DirectComposition objects created from such a device are Version 2 objects under the covers. For example, the IDCompositionDevice::CreateVisual method will return an <see cref = "SharpDX.DirectComposition.Visual"/> interface to the created visual, but the application can obtain a reference to the <see cref = "SharpDX.DirectComposition.Visual2"/> interface via the QueryInterface method. This behavior allows an application written to the DirectComposition V1 API to incrementally adopt DirectComposition V2 features by changing the device creation method from DCompositionCreateDevice to DCompositionCreateDevice2, while still requesting the <see cref = "SharpDX.DirectComposition.Device2"/> interface. This allows the rest of the code to remain unchanged, while allowing the application to use QueryInterface in just the places where new functionality is needed.
        /// </p>
        /// </remarks>
        /// <doc-id>dn280347</doc-id>
        /// <unmanaged>HRESULT DCompositionCreateDevice2([In, Optional] IUnknown* renderingDevice,[In] const GUID&amp; iid,[Out] void** dcompositionDevice)</unmanaged>
        /// <unmanaged-short>DCompositionCreateDevice2</unmanaged-short>
        internal static unsafe void CreateDevice2(SharpDX.IUnknown renderingDevice, System.Guid iid, out System.IntPtr dcompositionDevice)
        {
            System.IntPtr renderingDevice_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            renderingDevice_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(renderingDevice);
            fixed (void *dcompositionDevice_ = &dcompositionDevice)
                __result__ = DCompositionCreateDevice2_((void *)renderingDevice_, &iid, dcompositionDevice_);
            __result__.CheckError();
        }

        [System.Runtime.InteropServices.DllImportAttribute("dcomp.dll", EntryPoint = "DCompositionCreateDevice2", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern int DCompositionCreateDevice2_(void *param0, void *param1, void *param2);
        /// <summary>
        /// <p>Creates a new DirectComposition device object, which can be used to create other DirectComposition objects.</p>
        /// </summary>
        /// <param name = "renderingDevice"><dd>  <p>An optional reference to a DirectX device to be used to create DirectComposition surface objects. Must be a reference to an object implementing the <strong><see cref = "SharpDX.DXGI.Device"/></strong> or <strong><see cref = "SharpDX.Direct2D1.Device"/></strong> interfaces.</p> </dd></param>
        /// <param name = "iid"><dd>  <p>The identifier of the interface to retrieve. This must be one of __uuidof(<see cref = "SharpDX.DirectComposition.Device"/>) or __uuidof(<see cref = "SharpDX.DirectComposition.DesktopDevice"/>).</p> </dd></param>
        /// <param name = "dcompositionDevice"><dd>  <p>Receives an interface reference to the newly created device object. The reference is of the type specified by the <em>iid</em> parameter. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If this function succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn958410</doc-id>
        /// <unmanaged>HRESULT DCompositionCreateDevice3([In, Optional] IUnknown* renderingDevice,[In] const GUID&amp; iid,[Out] void** dcompositionDevice)</unmanaged>
        /// <unmanaged-short>DCompositionCreateDevice3</unmanaged-short>
        internal static unsafe void CreateDevice3(SharpDX.IUnknown renderingDevice, System.Guid iid, out System.IntPtr dcompositionDevice)
        {
            System.IntPtr renderingDevice_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            renderingDevice_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(renderingDevice);
            fixed (void *dcompositionDevice_ = &dcompositionDevice)
                __result__ = DCompositionCreateDevice3_((void *)renderingDevice_, &iid, dcompositionDevice_);
            __result__.CheckError();
        }

        [System.Runtime.InteropServices.DllImportAttribute("dcomp.dll", EntryPoint = "DCompositionCreateDevice3", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern int DCompositionCreateDevice3_(void *param0, void *param1, void *param2);
        /// <summary>
        /// <p>Creates a new composition surface object that can be bound to a
        /// Microsoft DirectX swap chain or swap buffer and associated
        /// with a visual.</p>
        /// </summary>
        /// <param name = "desiredAccess"><dd>  <p>The requested access to the composition surface object. It can be one of the following values:</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong></strong></dt> <dt>0x0000L</dt> </dl> </td><td> <p>No access.</p> </td></tr> <tr><td><dl> <dt><strong>COMPOSITIONSURFACE_READ</strong></dt> <dt>0x0001L</dt> </dl> </td><td> <p>Read access. For internal use only.</p> </td></tr> <tr><td><dl> <dt><strong>COMPOSITIONSURFACE_WRITE</strong></dt> <dt>0x0002L</dt> </dl> </td><td> <p>Write access. For internal use only.</p> </td></tr> <tr><td><dl> <dt><strong>COMPOSITIONSURFACE_ALL_ACCESS</strong></dt> <dt>0x0003L</dt> </dl> </td><td> <p>Read/write access. Always specify this flag except when duplicating a surface in another process, in which case set <em>desiredAccess</em> to 0.</p> </td></tr> </table> <p>?</p> </dd></param>
        /// <param name = "securityAttributes"><dd>  <p>Contains the security descriptor for the composition surface object, and specifies whether the handle of the composition surface object is inheritable when a child process is created. If this parameter is <c>null</c>, the composition surface object is created with default security attributes  that grant read and write access to the current process,  but do not enable child processes to  inherit the handle.</p> </dd></param>
        /// <param name = "surfaceHandle"><dd>  <p>The handle of the new composition surface object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.  </p></returns>
        /// <doc-id>hh437360</doc-id>
        /// <unmanaged>HRESULT DCompositionCreateSurfaceHandle([In] DWORD desiredAccess,[In, Optional] SECURITY_ATTRIBUTES* securityAttributes,[Out] void** surfaceHandle)</unmanaged>
        /// <unmanaged-short>DCompositionCreateSurfaceHandle</unmanaged-short>
        public static unsafe void CreateSurfaceHandle(System.Int32 desiredAccess, SharpDX.Win32.SecurityAttributes? securityAttributes, out System.IntPtr surfaceHandle)
        {
            SharpDX.Win32.SecurityAttributes securityAttributes_;
            SharpDX.Result __result__;
            if (securityAttributes != null)
                securityAttributes_ = securityAttributes.Value;
            fixed (void *surfaceHandle_ = &surfaceHandle)
                __result__ = DCompositionCreateSurfaceHandle_(desiredAccess, securityAttributes == null ? (void *)0 : &securityAttributes_, surfaceHandle_);
            __result__.CheckError();
        }

        [System.Runtime.InteropServices.DllImportAttribute("dcomp.dll", EntryPoint = "DCompositionCreateSurfaceHandle", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern int DCompositionCreateSurfaceHandle_(int param0, void *param1, void *param2);
        /// <summary>
        /// <p>Creates an Interaction/InputSink to route mouse wheel messages to the given <see cref = "System.IntPtr"/>.  This will fail if there is already an interaction attached to this visual. After calling this API, the device that owns the visual must be committed. </p>
        /// </summary>
        /// <param name = "visual"><dd>  <p>The visual to route messages from.</p> </dd></param>
        /// <param name = "hwnd"><dd>  <p>The <see cref = "System.IntPtr"/> to route messages to.</p> </dd></param>
        /// <param name = "enable"><dd>  <p>Boolean value indicating whether to enable or disable routing.</p> </dd></param>
        /// <returns><p>If this function succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>mt590822</doc-id>
        /// <unmanaged>HRESULT DCompositionAttachMouseWheelToHwnd([In] IDCompositionVisual* visual,[In] HWND hwnd,[In] BOOL enable)</unmanaged>
        /// <unmanaged-short>DCompositionAttachMouseWheelToHwnd</unmanaged-short>
        internal static unsafe void AttachMouseWheelToHwnd(SharpDX.DirectComposition.Visual visual, System.IntPtr hwnd, SharpDX.Mathematics.Interop.RawBool enable)
        {
            System.IntPtr visual_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            visual_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Visual>(visual);
            __result__ = DCompositionAttachMouseWheelToHwnd_((void *)visual_, (void *)hwnd, enable);
            __result__.CheckError();
        }

        [System.Runtime.InteropServices.DllImportAttribute("dcomp.dll", EntryPoint = "DCompositionAttachMouseWheelToHwnd", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern int DCompositionAttachMouseWheelToHwnd_(void *param0, void *param1, SharpDX.Mathematics.Interop.RawBool param2);
        /// <summary>
        /// <p>Creates an Interaction/InputSink to route mouse button down and any  subsequent move and up events to the given <see cref = "System.IntPtr"/>. There is no move  thresholding; when enabled, all events including and following the down  are unconditionally redirected to the specified window. After calling this  API, the device owning the visual must be committed.</p>
        /// </summary>
        /// <param name = "visual"><dd>  <p>The visual to route messages from.</p> </dd></param>
        /// <param name = "hwnd"><dd>  <p>The <see cref = "System.IntPtr"/> to route messages to.</p> </dd></param>
        /// <param name = "enable"><dd>  <p>Boolean value indicating whether to enable or disable routing.</p> </dd></param>
        /// <returns><p>If this function succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>mt734228</doc-id>
        /// <unmanaged>HRESULT DCompositionAttachMouseDragToHwnd([In] IDCompositionVisual* visual,[In] HWND hwnd,[In] BOOL enable)</unmanaged>
        /// <unmanaged-short>DCompositionAttachMouseDragToHwnd</unmanaged-short>
        internal static unsafe void AttachMouseDragToHwnd(SharpDX.DirectComposition.Visual visual, System.IntPtr hwnd, SharpDX.Mathematics.Interop.RawBool enable)
        {
            System.IntPtr visual_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            visual_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Visual>(visual);
            __result__ = DCompositionAttachMouseDragToHwnd_((void *)visual_, (void *)hwnd, enable);
            __result__.CheckError();
        }

        [System.Runtime.InteropServices.DllImportAttribute("dcomp.dll", EntryPoint = "DCompositionAttachMouseDragToHwnd", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern int DCompositionAttachMouseDragToHwnd_(void *param0, void *param1, SharpDX.Mathematics.Interop.RawBool param2);
    }

    /// <summary>
    /// Functions
    /// </summary>
    public partial class ResultCode
    {
    }
}
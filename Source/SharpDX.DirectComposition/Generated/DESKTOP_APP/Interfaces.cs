// <auto-generated/>

namespace SharpDX.DirectComposition
{
    [System.Runtime.InteropServices.GuidAttribute("0B74B9E8-CDD6-492F-BBBC-5ED32157026D")]
    public partial class AffineTransform2DEffect : SharpDX.DirectComposition.FilterEffect
    {
        public AffineTransform2DEffect(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator AffineTransform2DEffect(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new AffineTransform2DEffect(nativePtr);
        /// <summary>
        /// <p>Sets the interpolation mode of the effect.</p>
        /// </summary>
        /// <doc-id>dn919692</doc-id>
        /// <unmanaged>SetInterpolationMode</unmanaged>
        /// <unmanaged-short>SetInterpolationMode</unmanaged-short>
        public SharpDX.Direct2D1.AffineTransform2DInterpolationMode InterpolationMode
        {
            set => SetInterpolationMode(value);
        }

        /// <summary>
        /// <p>Sets the border mode to use with the effect.</p>
        /// </summary>
        /// <doc-id>dn919691</doc-id>
        /// <unmanaged>SetBorderMode</unmanaged>
        /// <unmanaged-short>SetBorderMode</unmanaged-short>
        public SharpDX.Direct2D1.BorderMode BorderMode
        {
            set => SetBorderMode(value);
        }

        /// <summary>
        /// <p>Sets the transform matrix of the effect.</p>
        /// </summary>
        /// <doc-id>dn919695</doc-id>
        /// <unmanaged>SetTransformMatrix</unmanaged>
        /// <unmanaged-short>SetTransformMatrix</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawMatrix3x2 TransformMatrix
        {
            set => SetTransformMatrix(ref value);
        }

        /// <summary>
        /// <p>Sets the interpolation mode of the effect.</p>
        /// </summary>
        /// <param name = "interpolationMode"><dd>  <p>Specifies the interpolation mode of the effect.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919692</doc-id>
        /// <unmanaged>HRESULT IDCompositionAffineTransform2DEffect::SetInterpolationMode([In] D2D1_2DAFFINETRANSFORM_INTERPOLATION_MODE interpolationMode)</unmanaged>
        /// <unmanaged-short>IDCompositionAffineTransform2DEffect::SetInterpolationMode</unmanaged-short>
        internal unsafe void SetInterpolationMode(SharpDX.Direct2D1.AffineTransform2DInterpolationMode interpolationMode)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)interpolationMode), (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the border mode to use with the effect.</p>
        /// </summary>
        /// <param name = "borderMode"><dd>  <p>Specifies the border mode to use with the effect.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919691</doc-id>
        /// <unmanaged>HRESULT IDCompositionAffineTransform2DEffect::SetBorderMode([In] D2D1_BORDER_MODE borderMode)</unmanaged>
        /// <unmanaged-short>IDCompositionAffineTransform2DEffect::SetBorderMode</unmanaged-short>
        internal unsafe void SetBorderMode(SharpDX.Direct2D1.BorderMode borderMode)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)borderMode), (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the transform matrix of the effect.</p>
        /// </summary>
        /// <param name = "transformMatrix"><dd>  <p>Specifies the transform matrix for the effect to use.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919695</doc-id>
        /// <unmanaged>HRESULT IDCompositionAffineTransform2DEffect::SetTransformMatrix([In] const D2D_MATRIX_3X2_F&amp; transformMatrix)</unmanaged>
        /// <unmanaged-short>IDCompositionAffineTransform2DEffect::SetTransformMatrix</unmanaged-short>
        internal unsafe void SetTransformMatrix(ref SharpDX.Mathematics.Interop.RawMatrix3x2 transformMatrix)
        {
            SharpDX.Result __result__;
            fixed (void *transformMatrix_ = &transformMatrix)
                __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, transformMatrix_, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets an element of the transform matrix of the effect.</p>
        /// </summary>
        /// <param name = "row"><dd>  <p>The row of the element.</p> </dd></param>
        /// <param name = "column"><dd>  <p>The column of the element.</p> </dd></param>
        /// <param name = "animation"><dd>  <p>The new value of the element.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919696</doc-id>
        /// <unmanaged>HRESULT IDCompositionAffineTransform2DEffect::SetTransformMatrixElement([In] int row,[In] int column,[In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionAffineTransform2DEffect::SetTransformMatrixElement</unmanaged-short>
        public unsafe void SetTransformMatrixElement(System.Int32 row, System.Int32 column, SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, row, column, (void *)animation_, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets an element of the transform matrix of the effect.</p>
        /// </summary>
        /// <param name = "row"><dd>  <p>The row of the element.</p> </dd></param>
        /// <param name = "column"><dd>  <p>The column of the element.</p> </dd></param>
        /// <param name = "value"><dd>  <p>The new value of the element.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919696</doc-id>
        /// <unmanaged>HRESULT IDCompositionAffineTransform2DEffect::SetTransformMatrixElement([In] int row,[In] int column,[In] float value)</unmanaged>
        /// <unmanaged-short>IDCompositionAffineTransform2DEffect::SetTransformMatrixElement</unmanaged-short>
        public unsafe void SetTransformMatrixElement(System.Int32 row, System.Int32 column, System.Single value)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, row, column, value, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the sharpness of the effect.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>An animation that represents how the sharpness value changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919694</doc-id>
        /// <unmanaged>HRESULT IDCompositionAffineTransform2DEffect::SetSharpness([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionAffineTransform2DEffect::SetSharpness</unmanaged-short>
        public unsafe void SetSharpness(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the sharpness of the effect.</p>
        /// </summary>
        /// <param name = "sharpness"><dd>  <p>An animation that represents how the sharpness value changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919694</doc-id>
        /// <unmanaged>HRESULT IDCompositionAffineTransform2DEffect::SetSharpness([In] float sharpness)</unmanaged>
        /// <unmanaged-short>IDCompositionAffineTransform2DEffect::SetSharpness</unmanaged-short>
        public unsafe void SetSharpness(System.Single sharpness)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, sharpness, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("CBFD91D9-51B2-45e4-B3DE-D19CCFB863C5")]
    public partial class Animation : SharpDX.ComObject
    {
        public Animation(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Animation(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Animation(nativePtr);
        /// <summary>
        /// <p>Sets the absolute time at which the animation function starts.</p>
        /// </summary>
        /// <remarks>
        /// <p>By default, an animation function starts when the first frame of the animation takes effect. For example, if an application creates a simple animation function with a single primitive at offset zero, associates the animation with some property,  and then calls the <strong>IDCompositionDevice::Commit</strong> method, the first frame that includes the commit samples the animation at offset zero for the first primitive. This implies that the actual default start time of all animations varies depending on the time between when the application creates the animation and calls <strong>Commit</strong>, to the time it takes the composition engine to pick up the committed changes. The application can use the <strong>SetAbsoluteBeginTime</strong> method to exercise finer control over the starting time of an animation. </p><p>This method does not control when animations take effect; it only affects how animations are sampled after they start. If the application specifies the exact time of the next frame as the absolute begin time, the result is the same as not calling this method at all. If the specified begin time is different from the time of the next frame, the result is one of following: </p><ul> <li>If the specified time is later than the next frame time, the animation start is delayed until the specified begin time.</li> <li>If the specified time is earlier than the next frame time, the beginning of the animation is dropped and sampling starts into the animation function.
        /// </li> </ul>
        /// </remarks>
        /// <doc-id>hh437390</doc-id>
        /// <unmanaged>SetAbsoluteBeginTime</unmanaged>
        /// <unmanaged-short>SetAbsoluteBeginTime</unmanaged-short>
        public System.Int64 AbsoluteBeginTime
        {
            set => SetAbsoluteBeginTime(value);
        }

        /// <summary>
        /// <p>Resets the animation function so that it contains no segments.</p>
        /// </summary>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method returns the animation function to a clean state, as when the animation was first constructed. After this method is called, the next segment to be added becomes the first segment of the animation function. Because it is the first segment, it can have any non-negative beginning offset.</p>
        /// </remarks>
        /// <doc-id>hh437389</doc-id>
        /// <unmanaged>HRESULT IDCompositionAnimation::Reset()</unmanaged>
        /// <unmanaged-short>IDCompositionAnimation::Reset</unmanaged-short>
        public unsafe void Reset()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the absolute time at which the animation function starts.</p>
        /// </summary>
        /// <param name = "beginTime"><dd>  <p>The starting time for this animation.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>By default, an animation function starts when the first frame of the animation takes effect. For example, if an application creates a simple animation function with a single primitive at offset zero, associates the animation with some property,  and then calls the <strong>IDCompositionDevice::Commit</strong> method, the first frame that includes the commit samples the animation at offset zero for the first primitive. This implies that the actual default start time of all animations varies depending on the time between when the application creates the animation and calls <strong>Commit</strong>, to the time it takes the composition engine to pick up the committed changes. The application can use the <strong>SetAbsoluteBeginTime</strong> method to exercise finer control over the starting time of an animation. </p><p>This method does not control when animations take effect; it only affects how animations are sampled after they start. If the application specifies the exact time of the next frame as the absolute begin time, the result is the same as not calling this method at all. If the specified begin time is different from the time of the next frame, the result is one of following: </p><ul> <li>If the specified time is later than the next frame time, the animation start is delayed until the specified begin time.</li> <li>If the specified time is earlier than the next frame time, the beginning of the animation is dropped and sampling starts into the animation function.
        /// </li> </ul>
        /// </remarks>
        /// <doc-id>hh437390</doc-id>
        /// <unmanaged>HRESULT IDCompositionAnimation::SetAbsoluteBeginTime([In] LARGE_INTEGER beginTime)</unmanaged>
        /// <unmanaged-short>IDCompositionAnimation::SetAbsoluteBeginTime</unmanaged-short>
        internal unsafe void SetAbsoluteBeginTime(System.Int64 beginTime)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, beginTime, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Adds a cubic polynomial segment to the animation function.</p>
        /// </summary>
        /// <param name = "beginOffset"><dd>  <p>The offset, in seconds, from the beginning of the animation function to the point when this segment should take effect.</p> </dd></param>
        /// <param name = "constantCoefficient"><dd>  <p>The constant coefficient of the polynomial.</p> </dd></param>
        /// <param name = "linearCoefficient"><dd>  <p>The linear coefficient of the polynomial.</p> </dd></param>
        /// <param name = "quadraticCoefficient"><dd>  <p>The quadratic coefficient of the polynomial.</p> </dd></param>
        /// <param name = "cubicCoefficient"><dd>  <p>The cubic coefficient of the polynomial.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>A cubic segment transitions time along a cubic polynomial.  For a given time input (t), the output value is given by the following equation. </p><p><em>x</em>(<em>t</em>) = <em>at</em>? + <em>bt</em>? + <em>ct</em> + <em>d</em></p><p>This method fails if any of the parameters are NaN, positive infinity, or negative infinity.</p><p>Because animation segments must be added in increasing order, this method fails if the <em>beginOffset</em> parameter is less than or equal to the <em>beginOffset</em> parameter of the previous segment, if any.</p><p>This animation segment remains in effect until the begin time of the next segment in the animation function. If the animation function contains no more segments, this segment remains in effect indefinitely. </p><p>If all coefficients except <em>constantCoefficient</em> are zero, the value of this segment remains constant over time, and the animation does not cause a recomposition for the duration of the segment.</p>
        /// </remarks>
        /// <doc-id>hh437385</doc-id>
        /// <unmanaged>HRESULT IDCompositionAnimation::AddCubic([In] double beginOffset,[In] float constantCoefficient,[In] float linearCoefficient,[In] float quadraticCoefficient,[In] float cubicCoefficient)</unmanaged>
        /// <unmanaged-short>IDCompositionAnimation::AddCubic</unmanaged-short>
        public unsafe void AddCubic(System.Double beginOffset, System.Single constantCoefficient, System.Single linearCoefficient, System.Single quadraticCoefficient, System.Single cubicCoefficient)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, beginOffset, constantCoefficient, linearCoefficient, quadraticCoefficient, cubicCoefficient, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Adds a sinusoidal segment to the animation function.</p>
        /// </summary>
        /// <param name = "beginOffset"><dd>  <p>The offset, in seconds, from the beginning of the animation function to the point when this segment should take effect. </p> </dd></param>
        /// <param name = "bias"><dd>  <p>A constant that is added to the sinusoidal.</p> </dd></param>
        /// <param name = "amplitude"><dd>  <p>A scale factor that is applied to the sinusoidal.</p> </dd></param>
        /// <param name = "frequency"><dd>  <p>A scale factor that is applied to the time offset, in Hertz.</p> </dd></param>
        /// <param name = "phase"><dd>  <p>A constant that is added to the time offset, in degrees.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method fails if any of the parameters are NaN, positive infinity, or negative infinity, or if the <em>beginOffset</em> parameter is negative. </p><p>Because animation segments must be added in increasing order, this method fails if the <em>beginOffset</em> parameter is less than or equal to the <em>beginOffset</em> parameter of the previous segment, if any.</p><p>This animation segment remains in effect until the begin time of the next segment in the animation function. If the animation function contains no more segments, this segment remains in effect indefinitely. </p>
        /// </remarks>
        /// <doc-id>hh437387</doc-id>
        /// <unmanaged>HRESULT IDCompositionAnimation::AddSinusoidal([In] double beginOffset,[In] float bias,[In] float amplitude,[In] float frequency,[In] float phase)</unmanaged>
        /// <unmanaged-short>IDCompositionAnimation::AddSinusoidal</unmanaged-short>
        public unsafe void AddSinusoidal(System.Double beginOffset, System.Single bias, System.Single amplitude, System.Single frequency, System.Single phase)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, beginOffset, bias, amplitude, frequency, phase, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Adds a repeat segment that causes the specified portion of an animation function to be repeated.</p>
        /// </summary>
        /// <param name = "beginOffset"><dd>  <p>The offset, in seconds, from the beginning of the animation to the point at which the repeat should begin.</p> </dd></param>
        /// <param name = "durationToRepeat"><dd>  <p>The duration, in seconds, of a portion of the animation immediately preceding the begin time that is specified by <em>beginOffset</em>.  This is the portion that will be repeated.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method fails if any of the parameters are NaN, positive infinity, or negative infinity.</p><p>Because animation segments must be added in increasing order, this method fails if the <em>beginOffset</em> parameter is less than or equal to the <em>beginOffset</em> parameter of the previous segment. This method also fails if this is the first segment to be added to the animation function.</p><p>This animation segment remains in effect until the begin time of the next segment. If the animation function contains no more segments, this segment remains in effect indefinitely.</p>
        /// </remarks>
        /// <doc-id>hh437386</doc-id>
        /// <unmanaged>HRESULT IDCompositionAnimation::AddRepeat([In] double beginOffset,[In] double durationToRepeat)</unmanaged>
        /// <unmanaged-short>IDCompositionAnimation::AddRepeat</unmanaged-short>
        public unsafe void AddRepeat(System.Double beginOffset, System.Double durationToRepeat)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, beginOffset, durationToRepeat, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Adds an end segment that marks the end of an animation function.  </p>
        /// </summary>
        /// <param name = "endOffset"><dd>  <p>The offset, in seconds, from the beginning of the animation function to the point when the function ends.</p> </dd></param>
        /// <param name = "endValue"><dd>  <p>The final value of the animation.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>When the specified offset is reached, the property or properties affected by this animation are set to the specified final value, and then the animation stops. If no end segment is added, the final segment of the animation function runs indefinitely. Calling this method is semantically identical to making the last segment of the animation function a cubic polynomial where the cubic, quadratic, and linear coefficients are all zeros, and the constant coefficient is the desired final value.</p><p>Because animation segments must be added in increasing order, this method fails if the <em>endOffset</em> parameter is less than or equal to the <em>beginOffset</em> parameter of the previous segment. This method also fails if this is the first segment to be added to the animation function.</p><p>After this method is called, all methods on this animation object fail except the <strong>IDCompositionAnimation::Reset</strong> method.</p>
        /// </remarks>
        /// <doc-id>hh437388</doc-id>
        /// <unmanaged>HRESULT IDCompositionAnimation::End([In] double endOffset,[In] float endValue)</unmanaged>
        /// <unmanaged-short>IDCompositionAnimation::End</unmanaged-short>
        public unsafe void End(System.Double endOffset, System.Single endValue)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, endOffset, endValue, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("3B67DFA8-E3DD-4E61-B640-46C2F3D739DC")]
    public partial class ArithmeticCompositeEffect : SharpDX.DirectComposition.FilterEffect
    {
        public ArithmeticCompositeEffect(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ArithmeticCompositeEffect(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ArithmeticCompositeEffect(nativePtr);
        /// <summary>
        /// <p>Sets the coefficients for the equation used to composite the two input images.</p>
        /// </summary>
        /// <doc-id>dn919708</doc-id>
        /// <unmanaged>SetCoefficients</unmanaged>
        /// <unmanaged-short>SetCoefficients</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector4 Coefficients
        {
            set => SetCoefficients(value);
        }

        /// <summary>
        /// <p>Specifies whether to clamp color values before the effect passes the values to the next effect in the graph.</p>
        /// </summary>
        /// <doc-id>dn919699</doc-id>
        /// <unmanaged>SetClampOutput</unmanaged>
        /// <unmanaged-short>SetClampOutput</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool ClampOutput
        {
            set => SetClampOutput(value);
        }

        /// <summary>
        /// <p>Sets the coefficients for the equation used to composite the two input images.</p>
        /// </summary>
        /// <param name = "coefficients"><dd>  <p>The coefficients for the equation used to composite the two input images.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919708</doc-id>
        /// <unmanaged>HRESULT IDCompositionArithmeticCompositeEffect::SetCoefficients([In] const D2D_VECTOR_4F&amp; coefficients)</unmanaged>
        /// <unmanaged-short>IDCompositionArithmeticCompositeEffect::SetCoefficients</unmanaged-short>
        internal unsafe void SetCoefficients(SharpDX.Mathematics.Interop.RawVector4 coefficients)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &coefficients, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Specifies whether to clamp color values before the effect passes the values to the next effect in the graph.</p>
        /// </summary>
        /// <param name = "clampoutput"><dd>  <p>A boolean value indicating whether to clamp the color values.  A value of TRUE causes color values to be clamped between 0 and 1.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919699</doc-id>
        /// <unmanaged>HRESULT IDCompositionArithmeticCompositeEffect::SetClampOutput([In] BOOL clampoutput)</unmanaged>
        /// <unmanaged-short>IDCompositionArithmeticCompositeEffect::SetClampOutput</unmanaged-short>
        internal unsafe void SetClampOutput(SharpDX.Mathematics.Interop.RawBool clampoutput)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint0(this._nativePointer, clampoutput, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the first coefficient for the equation used to composite the two input images.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>An animation that represents how the value changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919701</doc-id>
        /// <unmanaged>HRESULT IDCompositionArithmeticCompositeEffect::SetCoefficient1([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionArithmeticCompositeEffect::SetCoefficient1</unmanaged-short>
        public unsafe void SetCoefficient1(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the first coefficient for the equation used to composite the two input images.</p>
        /// </summary>
        /// <param name = "coeffcient1"><dd>  <p>An animation that represents how the value changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919701</doc-id>
        /// <unmanaged>HRESULT IDCompositionArithmeticCompositeEffect::SetCoefficient1([In] float Coeffcient1)</unmanaged>
        /// <unmanaged-short>IDCompositionArithmeticCompositeEffect::SetCoefficient1</unmanaged-short>
        public unsafe void SetCoefficient1(System.Single coeffcient1)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, coeffcient1, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the second coefficient for the equation used to composite the two input images.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>An animation that represents how the value of the second coefficient changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919703</doc-id>
        /// <unmanaged>HRESULT IDCompositionArithmeticCompositeEffect::SetCoefficient2([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionArithmeticCompositeEffect::SetCoefficient2</unmanaged-short>
        public unsafe void SetCoefficient2(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the second coefficient for the equation used to composite the two input images.</p>
        /// </summary>
        /// <param name = "coefficient2"><dd>  <p>An animation that represents how the value of the second coefficient changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919703</doc-id>
        /// <unmanaged>HRESULT IDCompositionArithmeticCompositeEffect::SetCoefficient2([In] float Coefficient2)</unmanaged>
        /// <unmanaged-short>IDCompositionArithmeticCompositeEffect::SetCoefficient2</unmanaged-short>
        public unsafe void SetCoefficient2(System.Single coefficient2)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, coefficient2, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the third coefficient for the equation used to composite the two input images.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>An animation that represents how the value of the third coefficient changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919705</doc-id>
        /// <unmanaged>HRESULT IDCompositionArithmeticCompositeEffect::SetCoefficient3([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionArithmeticCompositeEffect::SetCoefficient3</unmanaged-short>
        public unsafe void SetCoefficient3(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the third coefficient for the equation used to composite the two input images.</p>
        /// </summary>
        /// <param name = "coefficient3"><dd>  <p>An animation that represents how the value of the third coefficient changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919705</doc-id>
        /// <unmanaged>HRESULT IDCompositionArithmeticCompositeEffect::SetCoefficient3([In] float Coefficient3)</unmanaged>
        /// <unmanaged-short>IDCompositionArithmeticCompositeEffect::SetCoefficient3</unmanaged-short>
        public unsafe void SetCoefficient3(System.Single coefficient3)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, coefficient3, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the fourth coefficient for the equation used to composite the two input images.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>An animation that represents how the value of the fourth coefficient changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919707</doc-id>
        /// <unmanaged>HRESULT IDCompositionArithmeticCompositeEffect::SetCoefficient4([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionArithmeticCompositeEffect::SetCoefficient4</unmanaged-short>
        public unsafe void SetCoefficient4(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the fourth coefficient for the equation used to composite the two input images.</p>
        /// </summary>
        /// <param name = "coefficient4"><dd>  <p>An animation that represents how the value of the fourth coefficient changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919707</doc-id>
        /// <unmanaged>HRESULT IDCompositionArithmeticCompositeEffect::SetCoefficient4([In] float Coefficient4)</unmanaged>
        /// <unmanaged-short>IDCompositionArithmeticCompositeEffect::SetCoefficient4</unmanaged-short>
        public unsafe void SetCoefficient4(System.Single coefficient4)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, coefficient4, (*(void ***)this._nativePointer)[13]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("33ECDC0A-578A-4A11-9C14-0CB90517F9C5")]
    public partial class BlendEffect : SharpDX.DirectComposition.FilterEffect
    {
        public BlendEffect(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator BlendEffect(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new BlendEffect(nativePtr);
        /// <summary>
        /// <p>Sets the blend mode to use when the blend effect combines the two images.</p>
        /// </summary>
        /// <doc-id>dn919710</doc-id>
        /// <unmanaged>SetMode</unmanaged>
        /// <unmanaged-short>SetMode</unmanaged-short>
        public SharpDX.Direct2D1.BlendMode Mode
        {
            set => SetMode(value);
        }

        /// <summary>
        /// <p>Sets the blend mode to use when the blend effect combines the two images.</p>
        /// </summary>
        /// <param name = "mode"><dd>  <p>The blend mode to use when the blend effect combines the two images.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919710</doc-id>
        /// <unmanaged>HRESULT IDCompositionBlendEffect::SetMode([In] D2D1_BLEND_MODE mode)</unmanaged>
        /// <unmanaged-short>IDCompositionBlendEffect::SetMode</unmanaged-short>
        internal unsafe void SetMode(SharpDX.Direct2D1.BlendMode mode)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)mode), (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("6027496E-CB3A-49AB-934F-D798DA4F7DA6")]
    public partial class BrightnessEffect : SharpDX.DirectComposition.FilterEffect
    {
        public BrightnessEffect(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator BrightnessEffect(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new BrightnessEffect(nativePtr);
        /// <summary>
        /// <p>Sets the upper portion of the brightness transfer curve. </p>
        /// </summary>
        /// <doc-id>dn919717</doc-id>
        /// <unmanaged>SetWhitePoint</unmanaged>
        /// <unmanaged-short>SetWhitePoint</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 WhitePoint
        {
            set => SetWhitePoint(value);
        }

        /// <summary>
        /// <p>Specifies the lower portion of the brightness transfer curve for the brightness effect.</p>
        /// </summary>
        /// <doc-id>dn919712</doc-id>
        /// <unmanaged>SetBlackPoint</unmanaged>
        /// <unmanaged-short>SetBlackPoint</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 BlackPoint
        {
            set => SetBlackPoint(value);
        }

        /// <summary>
        /// <p>Sets the upper portion of the brightness transfer curve. </p>
        /// </summary>
        /// <param name = "whitePoint"><dd>  <p>The upper portion of the brightness transfer curve. The white point adjusts the appearance of the brighter portions of the image. This vector is for both the x value and the y value, in that order. Each of the values must be between 0 and 1, inclusive.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919717</doc-id>
        /// <unmanaged>HRESULT IDCompositionBrightnessEffect::SetWhitePoint([In] const D2D_VECTOR_2F&amp; whitePoint)</unmanaged>
        /// <unmanaged-short>IDCompositionBrightnessEffect::SetWhitePoint</unmanaged-short>
        internal unsafe void SetWhitePoint(SharpDX.Mathematics.Interop.RawVector2 whitePoint)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &whitePoint, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Specifies the lower portion of the brightness transfer curve for the brightness effect.</p>
        /// </summary>
        /// <param name = "blackPoint"><dd>  <p>The lower portion of the brightness transfer curve. The black point adjusts the appearance of the darker portions of the image. The vector is for both the x value and the y value, in that order. Each of the values must be between 0 and 1, inclusive.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919712</doc-id>
        /// <unmanaged>HRESULT IDCompositionBrightnessEffect::SetBlackPoint([In] const D2D_VECTOR_2F&amp; blackPoint)</unmanaged>
        /// <unmanaged-short>IDCompositionBrightnessEffect::SetBlackPoint</unmanaged-short>
        internal unsafe void SetBlackPoint(SharpDX.Mathematics.Interop.RawVector2 blackPoint)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &blackPoint, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the x value of the white point.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>The x value of the white point. This value must be between 0 and 1.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919718</doc-id>
        /// <unmanaged>HRESULT IDCompositionBrightnessEffect::SetWhitePointX([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionBrightnessEffect::SetWhitePointX</unmanaged-short>
        public unsafe void SetWhitePointX(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the x value of the white point.</p>
        /// </summary>
        /// <param name = "whitePointX"><dd>  <p>The x value of the white point. This value must be between 0 and 1.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919718</doc-id>
        /// <unmanaged>HRESULT IDCompositionBrightnessEffect::SetWhitePointX([In] float whitePointX)</unmanaged>
        /// <unmanaged-short>IDCompositionBrightnessEffect::SetWhitePointX</unmanaged-short>
        public unsafe void SetWhitePointX(System.Single whitePointX)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, whitePointX, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the y value of the white point.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>An animation that represents how the y value of the white point changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919721</doc-id>
        /// <unmanaged>HRESULT IDCompositionBrightnessEffect::SetWhitePointY([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionBrightnessEffect::SetWhitePointY</unmanaged-short>
        public unsafe void SetWhitePointY(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the y value of the white point.</p>
        /// </summary>
        /// <param name = "whitePointY"><dd>  <p>An animation that represents how the y value of the white point changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919721</doc-id>
        /// <unmanaged>HRESULT IDCompositionBrightnessEffect::SetWhitePointY([In] float whitePointY)</unmanaged>
        /// <unmanaged-short>IDCompositionBrightnessEffect::SetWhitePointY</unmanaged-short>
        public unsafe void SetWhitePointY(System.Single whitePointY)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, whitePointY, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the x value of the black point.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>The x value of the black point.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919713</doc-id>
        /// <unmanaged>HRESULT IDCompositionBrightnessEffect::SetBlackPointX([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionBrightnessEffect::SetBlackPointX</unmanaged-short>
        public unsafe void SetBlackPointX(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the x value of the black point.</p>
        /// </summary>
        /// <param name = "blackPointX"><dd>  <p>The x value of the black point.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919713</doc-id>
        /// <unmanaged>HRESULT IDCompositionBrightnessEffect::SetBlackPointX([In] float blackPointX)</unmanaged>
        /// <unmanaged-short>IDCompositionBrightnessEffect::SetBlackPointX</unmanaged-short>
        public unsafe void SetBlackPointX(System.Single blackPointX)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, blackPointX, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the y value of the black point.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>An animation that represents how the y value of the black point changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919716</doc-id>
        /// <unmanaged>HRESULT IDCompositionBrightnessEffect::SetBlackPointY([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionBrightnessEffect::SetBlackPointY</unmanaged-short>
        public unsafe void SetBlackPointY(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the y value of the black point.</p>
        /// </summary>
        /// <param name = "blackPointY"><dd>  <p>An animation that represents how the y value of the black point changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919716</doc-id>
        /// <unmanaged>HRESULT IDCompositionBrightnessEffect::SetBlackPointY([In] float blackPointY)</unmanaged>
        /// <unmanaged-short>IDCompositionBrightnessEffect::SetBlackPointY</unmanaged-short>
        public unsafe void SetBlackPointY(System.Single blackPointY)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, blackPointY, (*(void ***)this._nativePointer)[13]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("64AC3703-9D3F-45ec-A109-7CAC0E7A13A7")]
    public partial class Clip : SharpDX.ComObject
    {
        public Clip(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Clip(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Clip(nativePtr);
    }

    [System.Runtime.InteropServices.GuidAttribute("C1170A22-3CE2-4966-90D4-55408BFC84C4")]
    public partial class ColorMatrixEffect : SharpDX.DirectComposition.FilterEffect
    {
        public ColorMatrixEffect(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ColorMatrixEffect(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ColorMatrixEffect(nativePtr);
        /// <summary>
        /// <p>Sets the matrix used by the effect to multiply the RGBA values of the image.</p>
        /// </summary>
        /// <doc-id>dn919725</doc-id>
        /// <unmanaged>SetMatrix</unmanaged>
        /// <unmanaged-short>SetMatrix</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawMatrix5x4 Matrix
        {
            set => SetMatrix(ref value);
        }

        /// <summary>
        /// <p>Sets the alpha mode of the output for the color matrix effect.</p>
        /// </summary>
        /// <doc-id>dn919723</doc-id>
        /// <unmanaged>SetAlphaMode</unmanaged>
        /// <unmanaged-short>SetAlphaMode</unmanaged-short>
        public SharpDX.Direct2D1.ColorMatrixAlphaMode AlphaMode
        {
            set => SetAlphaMode(value);
        }

        /// <summary>
        /// <p>Specifies whether the effect clamps color values to between 0 and 1 before the effects passes the values to the next effect in the chain.</p>
        /// </summary>
        /// <doc-id>dn919724</doc-id>
        /// <unmanaged>SetClampOutput</unmanaged>
        /// <unmanaged-short>SetClampOutput</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool ClampOutput
        {
            set => SetClampOutput(value);
        }

        /// <summary>
        /// <p>Sets the matrix used by the effect to multiply the RGBA values of the image.</p>
        /// </summary>
        /// <param name = "matrix"><dd>  <p>The matrix used by the effect to multiply the RGBA values of the image. The matrix is column major and is applied as shown in the following equation: </p></dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919725</doc-id>
        /// <unmanaged>HRESULT IDCompositionColorMatrixEffect::SetMatrix([In] const D2D_MATRIX_5X4_F&amp; matrix)</unmanaged>
        /// <unmanaged-short>IDCompositionColorMatrixEffect::SetMatrix</unmanaged-short>
        internal unsafe void SetMatrix(ref SharpDX.Mathematics.Interop.RawMatrix5x4 matrix)
        {
            SharpDX.Result __result__;
            fixed (void *matrix_ = &matrix)
                __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, matrix_, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets an element of the color matrix.</p>
        /// </summary>
        /// <param name = "row"><dd>  <p>The row of the element.</p> </dd></param>
        /// <param name = "column"><dd>  <p>The column of the element.</p> </dd></param>
        /// <param name = "animation"><dd>  <p>An animation that represents how the element value changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919727</doc-id>
        /// <unmanaged>HRESULT IDCompositionColorMatrixEffect::SetMatrixElement([In] int row,[In] int column,[In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionColorMatrixEffect::SetMatrixElement</unmanaged-short>
        public unsafe void SetMatrixElement(System.Int32 row, System.Int32 column, SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, row, column, (void *)animation_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets an element of the color matrix.</p>
        /// </summary>
        /// <param name = "row"><dd>  <p>The row of the element.</p> </dd></param>
        /// <param name = "column"><dd>  <p>The column of the element.</p> </dd></param>
        /// <param name = "value"><dd>  <p>An animation that represents how the element value changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919727</doc-id>
        /// <unmanaged>HRESULT IDCompositionColorMatrixEffect::SetMatrixElement([In] int row,[In] int column,[In] float value)</unmanaged>
        /// <unmanaged-short>IDCompositionColorMatrixEffect::SetMatrixElement</unmanaged-short>
        public unsafe void SetMatrixElement(System.Int32 row, System.Int32 column, System.Single value)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, row, column, value, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the alpha mode of the output for the color matrix effect.</p>
        /// </summary>
        /// <param name = "mode"><dd>  <p>The alpha mode of the output for the color matrix effect.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919723</doc-id>
        /// <unmanaged>HRESULT IDCompositionColorMatrixEffect::SetAlphaMode([In] D2D1_COLORMATRIX_ALPHA_MODE mode)</unmanaged>
        /// <unmanaged-short>IDCompositionColorMatrixEffect::SetAlphaMode</unmanaged-short>
        internal unsafe void SetAlphaMode(SharpDX.Direct2D1.ColorMatrixAlphaMode mode)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)mode), (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Specifies whether the effect clamps color values to between 0 and 1 before the effects passes the values to the next effect in the chain.</p>
        /// </summary>
        /// <param name = "clamp"><dd>  <p>A boolean value indicating whether the effect clamps color values to between 0 and 1 before the effects passes the values to the next effect in the chain.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919724</doc-id>
        /// <unmanaged>HRESULT IDCompositionColorMatrixEffect::SetClampOutput([In] BOOL clamp)</unmanaged>
        /// <unmanaged-short>IDCompositionColorMatrixEffect::SetClampOutput</unmanaged-short>
        internal unsafe void SetClampOutput(SharpDX.Mathematics.Interop.RawBool clamp)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint0(this._nativePointer, clamp, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("576616C0-A231-494D-A38D-00FD5EC4DB46")]
    public partial class CompositeEffect : SharpDX.DirectComposition.FilterEffect
    {
        public CompositeEffect(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator CompositeEffect(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new CompositeEffect(nativePtr);
        /// <summary>
        /// <p>Sets the mode for the composite effect.</p>
        /// </summary>
        /// <doc-id>dn919729</doc-id>
        /// <unmanaged>SetMode</unmanaged>
        /// <unmanaged-short>SetMode</unmanaged-short>
        public SharpDX.Direct2D1.CompositeMode Mode
        {
            set => SetMode(value);
        }

        /// <summary>
        /// <p>Sets the mode for the composite effect.</p>
        /// </summary>
        /// <param name = "mode"><dd>  <p>The mode for the composite effect.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919729</doc-id>
        /// <unmanaged>HRESULT IDCompositionCompositeEffect::SetMode([In] D2D1_COMPOSITE_MODE mode)</unmanaged>
        /// <unmanaged-short>IDCompositionCompositeEffect::SetMode</unmanaged-short>
        internal unsafe void SetMode(SharpDX.Direct2D1.CompositeMode mode)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)mode), (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("5F4633FE-1E08-4CB8-8C75-CE24333F5602")]
    public partial class DesktopDevice : SharpDX.DirectComposition.Device2
    {
        public DesktopDevice(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DesktopDevice(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DesktopDevice(nativePtr);
        /// <summary>
        /// <p>Creates a composition target object that is bound to the window that is represented by the specified window handle.</p>
        /// </summary>
        /// <param name = "hwnd"><dd> <p>The window to which the composition target object should be bound. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <param name = "topmost"><dd> <p>TRUE if the visual tree should be displayed on top of the children of the window specified by the hwnd parameter; otherwise, the visual tree is displayed behind the children.</p> </dd></param>
        /// <returns><dd> <p>The new composition target object. This parameter must not be <c>null</c>.</p> </dd></returns>
        /// <remarks>
        /// <p>A DirectComposition visual tree must be bound to a window before anything can be displayed on screen. The window can be a top-level window or a child window. In either case, the window can be a layered window, but in all cases the window must belong to the calling process. If the window belongs to a different process, this method returns DCOMPOSITION_ERROR_ACCESS_DENIED.</p><p>When DirectComposition content is composed to the window, the content is always composed on top of whatever is drawn directly to that window through the device context returned by the <strong>GetDC</strong> function, or by calls to DirectX Present methods. However, because window clipping rules apply to DirectComposition content, if the window has child windows, those child windows may clip the visual tree. The topmost parameter determines whether child windows clip the visual tree.</p><p>Conceptually, each window consists of four layers:</p><ol> <li>The contents drawn directly to the window handle (this is the bottommost layer).</li> <li>An optional DirectComposition visual tree.</li> <li>The contents of all child windows, if any.</li> <li>Another optional DirectComposition visual tree (this is the topmost layer).</li> </ol><p>All four layers are clipped to the window?s visible region.</p><p>At most, only two composition targets can be created for each window in the system, one topmost and one not topmost. If a composition target is already bound to the specified window at the specified layer, this method fails. When a composition target object is destroyed, the layer it composed is available for use by a new composition target object.</p>
        /// </remarks>
        /// <doc-id>dn280353</doc-id>
        /// <unmanaged>HRESULT IDCompositionDesktopDevice::CreateTargetForHwnd([In] HWND hwnd,[In] BOOL topmost,[Out] IDCompositionTarget** target)</unmanaged>
        /// <unmanaged-short>IDCompositionDesktopDevice::CreateTargetForHwnd</unmanaged-short>
        internal unsafe SharpDX.DirectComposition.Target CreateTargetForHwnd(System.IntPtr hwnd, SharpDX.Mathematics.Interop.RawBool topmost)
        {
            SharpDX.DirectComposition.Target target;
            System.IntPtr target_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint0(this._nativePointer, (void *)hwnd, topmost, &target_, (*(void ***)this._nativePointer)[24]);
            if (target_ != System.IntPtr.Zero)
                target = new SharpDX.DirectComposition.Target(target_);
            else
                target = null;
            __result__.CheckError();
            return target;
        }

        /// <summary>
        /// <p>Creates a new composition surface object that wraps an existing composition surface.</p>
        /// </summary>
        /// <param name = "handle"><dd> <p>The handle of an existing composition surface that was created by a call to the <strong>DCompositionCreateSurfaceHandle</strong> function.</p> </dd></param>
        /// <returns><dd> <p>The new composition surface object. This parameter must not be <c>null</c>.</p> </dd></returns>
        /// <doc-id>dn280351</doc-id>
        /// <unmanaged>HRESULT IDCompositionDesktopDevice::CreateSurfaceFromHandle([In] void* handle,[Out] IUnknown** surface)</unmanaged>
        /// <unmanaged-short>IDCompositionDesktopDevice::CreateSurfaceFromHandle</unmanaged-short>
        public unsafe SharpDX.IUnknown CreateSurfaceFromHandle(System.IntPtr handle)
        {
            SharpDX.IUnknown surface;
            System.IntPtr surface_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)handle, &surface_, (*(void ***)this._nativePointer)[25]);
            if (surface_ != System.IntPtr.Zero)
                surface = new SharpDX.ComObject(surface_);
            else
                surface = null;
            __result__.CheckError();
            return surface;
        }

        /// <summary>
        /// <p>Creates a wrapper object that represents the rasterization of a layered window, and that can be associated with a visual for composition.</p>
        /// </summary>
        /// <param name = "hwnd"><dd> <p>The handle of the layered window for which to create a wrapper. A layered window is created by specifying WS_EX_LAYERED when creating the window with the <strong>CreateWindowEx</strong> function or by setting WS_EX_LAYERED via <strong>SetWindowLong</strong> after the window has been created.</p> </dd></param>
        /// <returns><dd> <p>The new composition surface object. This parameter must not be <c>null</c>.</p> </dd></returns>
        /// <remarks>
        /// <p>You can use the surface reference in calls to the IDCompositionVisual::SetContent method to set the content of one or more visuals. After setting the content, the visuals compose the contents of the specified layered window as long as the window is layered. If the window is unlayered, the window content disappears from the output of the composition tree. If the window is later re-layered, the window content reappears as long as it is still associated with a visual. If the window is resized, the affected visuals are re-composed. </p><p>The contents of the window are not cached beyond the life of the window. That is, if the window is destroyed, the affected visuals stop composing the window. </p><p>If the window is moved off-screen or resized to zero, the system stops composing the content of those visuals. You should use the <strong>DwmSetWindowAttribute</strong> function with the DWMWA_CLOAK flag to "cloak" the layered child window when you need to hide the original window while allowing the system to continue to compose the content of the visuals.
        /// </p>
        /// </remarks>
        /// <doc-id>dn280352</doc-id>
        /// <unmanaged>HRESULT IDCompositionDesktopDevice::CreateSurfaceFromHwnd([In] HWND hwnd,[Out] IUnknown** surface)</unmanaged>
        /// <unmanaged-short>IDCompositionDesktopDevice::CreateSurfaceFromHwnd</unmanaged-short>
        public unsafe SharpDX.IUnknown CreateSurfaceFromHwnd(System.IntPtr hwnd)
        {
            SharpDX.IUnknown surface;
            System.IntPtr surface_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)hwnd, &surface_, (*(void ***)this._nativePointer)[26]);
            if (surface_ != System.IntPtr.Zero)
                surface = new SharpDX.ComObject(surface_);
            else
                surface = null;
            __result__.CheckError();
            return surface;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("C37EA93A-E7AA-450D-B16F-9746CB0407F3")]
    public partial class Device : SharpDX.ComObject
    {
        public Device(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Device(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Device(nativePtr);
        /// <summary>
        /// <p>Retrieves information from the composition engine about composition times and the frame rate.</p>
        /// </summary>
        /// <remarks>
        /// <p>This method retrieves timing information about the composition engine that an application can use to synchronize the rasterization of bitmaps with independent animations.</p>
        /// </remarks>
        /// <doc-id>hh437415</doc-id>
        /// <unmanaged>GetFrameStatistics</unmanaged>
        /// <unmanaged-short>GetFrameStatistics</unmanaged-short>
        public SharpDX.DirectComposition.FrameStatistics FrameStatistics
        {
            get
            {
                GetFrameStatistics(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Commits all DirectComposition commands that are pending on this device.</p>
        /// </summary>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Calls to DirectComposition methods are always batched and executed atomically as a single transaction. Calls take effect only when <strong>IDCompositionDevice::Commit</strong> is called, at which time all pending method calls for a device are executed at once. </p><p>An application that uses multiple devices must call <strong>Commit</strong> for each device separately. However, because the composition engine processes the calls individually, the batch of commands might not take effect at the same time. </p>
        /// </remarks>
        /// <doc-id>hh437393</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice::Commit()</unmanaged>
        /// <unmanaged-short>IDCompositionDevice::Commit</unmanaged-short>
        public unsafe void Commit()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Waits for the composition engine to finish processing the previous call to the <strong>IDCompositionDevice::Commit</strong> method. </p>
        /// </summary>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <doc-id>hh920928</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice::WaitForCommitCompletion()</unmanaged>
        /// <unmanaged-short>IDCompositionDevice::WaitForCommitCompletion</unmanaged-short>
        public unsafe void WaitForCommitCompletion()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves information from the composition engine about composition times and the frame rate.</p>
        /// </summary>
        /// <param name = "statistics"><dd>  <p>A structure that receives composition times and frame rate information.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method retrieves timing information about the composition engine that an application can use to synchronize the rasterization of bitmaps with independent animations.</p>
        /// </remarks>
        /// <doc-id>hh437415</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice::GetFrameStatistics([Out] DCOMPOSITION_FRAME_STATISTICS* statistics)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice::GetFrameStatistics</unmanaged-short>
        internal unsafe void GetFrameStatistics(out SharpDX.DirectComposition.FrameStatistics statistics)
        {
            statistics = default (SharpDX.DirectComposition.FrameStatistics);
            SharpDX.Result __result__;
            fixed (void *statistics_ = &statistics)
                __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, statistics_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a composition target object that is bound to the window that is represented by the specified window handle (<strong><see cref = "System.IntPtr"/></strong>).</p>
        /// </summary>
        /// <param name = "hwnd">No documentation.</param>
        /// <param name = "topmost">No documentation.</param>
        /// <param name = "target">No documentation.</param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>A Microsoft DirectComposition visual tree must be bound to a window before anything can be displayed on screen. The window can be a top-level window or a child window. In either case, the window can be a layered window, but in all cases the window must belong to the calling process. If the window belongs to a different process, this method returns <strong>DCOMPOSITION_ERROR_ACCESS_DENIED</strong>. </p><p>When DirectComposition content is composed to the window, the content is always composed on top of whatever is drawn directly to that window through the device context (<strong><see cref = "System.IntPtr"/></strong>) returned by the <strong>GetDC</strong> function, or by calls to Microsoft DirectX <strong>Present</strong> methods. However, because window clipping rules apply to DirectComposition content, if the window has child windows, those child windows may clip the visual tree. The <em>topmost</em> parameter determines whether child windows clip the visual tree. </p><p> Conceptually, each window consists of four layers:</p><ol> <li>The contents drawn directly to the window handle (this is the bottommost layer).</li> <li>An optional DirectComposition visual tree.</li> <li>The contents of all child windows, if any.</li> <li>Another optional DirectComposition visual tree (this is the topmost layer).</li> </ol><p>All four layers are clipped to the window's visible region.</p><p>At most, only two composition targets can be created for each window in the system, one topmost and one not topmost. If a composition target is already bound to the specified window at the specified layer, this method fails. When a composition target object is destroyed, the layer it composed is available for use by a new composition target object.</p>
        /// </remarks>
        /// <doc-id>hh437396</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice::CreateTargetForHwnd([In] HWND hwnd,[In] BOOL topmost,[Out] IDCompositionTarget** target)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice::CreateTargetForHwnd</unmanaged-short>
        internal unsafe void CreateTargetForHwnd(System.IntPtr hwnd, SharpDX.Mathematics.Interop.RawBool topmost, out SharpDX.DirectComposition.Target target)
        {
            System.IntPtr target_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint0(this._nativePointer, (void *)hwnd, topmost, &target_, (*(void ***)this._nativePointer)[6]);
            if (target_ != System.IntPtr.Zero)
                target = new SharpDX.DirectComposition.Target(target_);
            else
                target = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a new visual object.</p>
        /// </summary>
        /// <param name = "visual"><dd>  <p>The new visual object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>A new visual object has a static value of zero for the OffsetX and OffsetY properties, and <c>null</c> for the Transform, Clip, and Content properties. Initially, the visual  does not cause the contents of a window to change. The visual must be added as a child of another visual, or as the root of a composition target, before it can affect the appearance of a window.</p>
        /// </remarks>
        /// <doc-id>hh437414</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice::CreateVisual([Out, Fast] IDCompositionVisual** visual)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice::CreateVisual</unmanaged-short>
        internal unsafe void CreateVisual(SharpDX.DirectComposition.Visual visual)
        {
            System.IntPtr visual_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &visual_, (*(void ***)this._nativePointer)[7]);
            (visual).NativePointer = visual_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates an updateable surface object that can be associated with one or more visuals for composition.</p>
        /// </summary>
        /// <param name = "width"><dd>  <p>The width of the surface, in pixels.</p> </dd></param>
        /// <param name = "height"><dd>  <p>The height of the surface, in pixels.</p> </dd></param>
        /// <param name = "pixelFormat"><dd>  <p>The pixel format of the surface.</p> </dd></param>
        /// <param name = "alphaMode"><dd>  <p>The format of the alpha channel, if an alpha channel is included in the pixel format. It can be one of the following values:</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>DXGI_ALPHA_MODE_UNSPECIFIED</strong></dt> </dl> </td><td> <p>The alpha channel is not specified. This value has the same effect as <strong>DXGI_ALPHA_MODE_IGNORE</strong>.</p> </td></tr> <tr><td><dl> <dt><strong>DXGI_ALPHA_MODE_PREMULTIPLIED</strong></dt> </dl> </td><td> <p>The color channels contain values that are premultiplied with the alpha channel.</p> </td></tr> <tr><td><dl> <dt><strong>DXGI_ALPHA_MODE_IGNORE</strong></dt> </dl> </td><td> <p>The alpha channel should be ignored and the bitmap should be rendered opaquely.</p> </td></tr> </table> <p>?</p> </dd></param>
        /// <param name = "surface"><dd>  <p>The newly created surface object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>A Microsoft DirectComposition surface is a rectangular array of pixels that can be associated with a visual for composition. </p><p>A newly created surface object is in an uninitialized state. While it is uninitialized, the surface has no effect on the composition of the visual tree. It behaves exactly like a surface that has  100% transparent pixels. </p><p>To initialize the surface with pixel data, use the <strong>IDCompositionSurface::BeginDraw</strong> method. The first call to this method must cover the entire surface area to provide an initial value for every pixel. Subsequent calls may specify smaller sub-rectangles of the surface to update. </p><p>DirectComposition surfaces support the following pixel formats: </p><ul> <li><strong>DXGI_FORMAT_B8G8R8A8_UNORM</strong></li> <li><strong>DXGI_FORMAT_R8G8B8A8_UNORM</strong></li> <li><strong>DXGI_FORMAT_R16G16B16A16_FLOAT</strong></li> </ul>
        /// </remarks>
        /// <doc-id>hh437405</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice::CreateSurface([In] unsigned int width,[In] unsigned int height,[In] DXGI_FORMAT pixelFormat,[In] DXGI_ALPHA_MODE alphaMode,[Out, Fast] IDCompositionSurface** surface)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice::CreateSurface</unmanaged-short>
        internal unsafe void CreateSurface(System.Int32 width, System.Int32 height, SharpDX.DXGI.Format pixelFormat, SharpDX.DXGI.AlphaMode alphaMode, SharpDX.DirectComposition.Surface surface)
        {
            System.IntPtr surface_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, width, height, unchecked ((System.Int32)pixelFormat), unchecked ((System.Int32)alphaMode), &surface_, (*(void ***)this._nativePointer)[8]);
            (surface).NativePointer = surface_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a sparsely populated surface that can be associated with one or more visuals for composition.</p>
        /// </summary>
        /// <param name = "initialWidth"><dd>  <p>The width of the surface, in pixels. The maximum width is 16,777,216 pixels.</p> </dd></param>
        /// <param name = "initialHeight"><dd>  <p>The height of the surface, in pixels. The maximum height is 16,777,216 pixels.</p> </dd></param>
        /// <param name = "pixelFormat"><dd>  <p>The pixel format of the surface.</p> </dd></param>
        /// <param name = "alphaMode"><dd>  <p>The meaning of the alpha channel, if the pixel format contains an alpha channel. It can be one of the following values:</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>DXGI_ALPHA_MODE_UNSPECIFIED</strong></dt> </dl> </td><td> <p>The alpha channel is not specified. This value has the same effect as <strong>DXGI_ALPHA_MODE_IGNORE</strong>.</p> </td></tr> <tr><td><dl> <dt><strong>DXGI_ALPHA_MODE_PREMULTIPLIED</strong></dt> </dl> </td><td> <p>The color channels contain values that are premultiplied with the alpha channel.</p> </td></tr> <tr><td><dl> <dt><strong>DXGI_ALPHA_MODE_IGNORE</strong></dt> </dl> </td><td> <p>The alpha channel should be ignored and the bitmap should be rendered opaquely.</p> </td></tr> </table> <p>?</p> </dd></param>
        /// <param name = "virtualSurface"><dd>  <p>The newly created surface object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>A Microsoft DirectComposition sparse surface is a logical object that behaves like a rectangular array of pixels that can be associated with a visual for composition. The surface is not necessarily backed by any physical video or system memory for every one of its pixels. The application can realize or virtualize parts of the logical surface at different times. </p><p>A newly created surface object is in an uninitialized state. While it is uninitialized, the surface has no effect on the composition of the visual tree. It behaves exactly like a surface that is initialized with 100% transparent pixels. </p><p>To initialize the surface with pixel data, use the <strong>IDCompositionSurface::BeginDraw</strong> method. This method not only provides pixels for the surface, but it also allocates actual storage space for those pixels. The memory allocation persists until the application returns some of the memory to the system. The application can free part or all of the allocated memory by calling the <strong>IDComposition::VirtualSurfaceTrim</strong> method. </p><p>DirectComposition surfaces support the following pixel formats:</p><ul> <li><strong>DXGI_FORMAT_B8G8R8A8_UNORM</strong></li> <li><strong>DXGI_FORMAT_R8G8B8A8_UNORM</strong></li> <li><strong>DXGI_FORMAT_R16G16B16A16_FLOAT</strong></li> </ul><p>This method fails if <em>initialWidth</em> or <em>initialHeight</em> exceeds 16,777,216 pixels. </p>
        /// </remarks>
        /// <doc-id>hh437413</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice::CreateVirtualSurface([In] unsigned int initialWidth,[In] unsigned int initialHeight,[In] DXGI_FORMAT pixelFormat,[In] DXGI_ALPHA_MODE alphaMode,[Out, Fast] IDCompositionVirtualSurface** virtualSurface)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice::CreateVirtualSurface</unmanaged-short>
        internal unsafe void CreateVirtualSurface(System.Int32 initialWidth, System.Int32 initialHeight, SharpDX.DXGI.Format pixelFormat, SharpDX.DXGI.AlphaMode alphaMode, SharpDX.DirectComposition.VirtualSurface virtualSurface)
        {
            System.IntPtr virtualSurface_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, initialWidth, initialHeight, unchecked ((System.Int32)pixelFormat), unchecked ((System.Int32)alphaMode), &virtualSurface_, (*(void ***)this._nativePointer)[9]);
            (virtualSurface).NativePointer = virtualSurface_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a new composition surface object that wraps an existing composition surface.</p>
        /// </summary>
        /// <param name = "handle"><dd>  <p>The handle of an existing composition surface that was created by a call to the <strong>DCompositionCreateSurfaceHandle</strong> function.</p> </dd></param>
        /// <param name = "surface"><dd>  <p>The new composition surface object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method enables an application to use a shared composition surface in a composition tree. </p>
        /// </remarks>
        /// <doc-id>hh437406</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice::CreateSurfaceFromHandle([In] void* handle,[Out] IUnknown** surface)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice::CreateSurfaceFromHandle</unmanaged-short>
        internal unsafe void CreateSurfaceFromHandle(System.IntPtr handle, out SharpDX.IUnknown surface)
        {
            System.IntPtr surface_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)handle, &surface_, (*(void ***)this._nativePointer)[10]);
            if (surface_ != System.IntPtr.Zero)
                surface = new SharpDX.ComObject(surface_);
            else
                surface = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a wrapper object that represents the rasterization of a layered window, and that can be associated with a visual for composition.</p>
        /// </summary>
        /// <param name = "hwnd"><dd>  <p>The handle of the layered window for which to create a  wrapper. A layered window is created by specifying <strong>WS_EX_LAYERED</strong> when creating the window with the <strong>CreateWindowEx</strong> function or by setting <strong>WS_EX_LAYERED</strong> via <strong>SetWindowLong</strong> after the window has been created.</p> </dd></param>
        /// <param name = "surface"><dd>  <p>The new composition surface object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>You can use the <em>surface</em> reference in calls to the <strong>IDCompositionVisual::SetContent</strong> method to set the content of one or more visuals. After setting the content, the visuals compose the contents of the specified layered window as long as the window is layered. If the window is unlayered, the window content disappears from the output of the composition tree. If the window is later re-layered, the window content reappears as long as it is still associated with a visual. If the window is resized, the affected visuals are re-composed. </p><p>The contents of the window are not cached beyond the life of the window. That is, if the window is destroyed, the affected visuals stop composing the window.
        /// </p><p>If the window is moved off-screen or resized to zero, the system stops composing the content of visuals. You should use the <strong>DwmSetWindowAttribute</strong> function with the <strong>DWMWA_CLOAK</strong> flag to "cloak" the layered child window when you need to hide the original window while allowing the system to continue to compose the content of the visuals. For more information, see How to animate the bitmap of a layered child window and DirectComposition layered child window sample.</p>
        /// </remarks>
        /// <doc-id>hh437407</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice::CreateSurfaceFromHwnd([In] HWND hwnd,[Out] IUnknown** surface)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice::CreateSurfaceFromHwnd</unmanaged-short>
        internal unsafe void CreateSurfaceFromHwnd(System.IntPtr hwnd, out SharpDX.IUnknown surface)
        {
            System.IntPtr surface_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)hwnd, &surface_, (*(void ***)this._nativePointer)[11]);
            if (surface_ != System.IntPtr.Zero)
                surface = new SharpDX.ComObject(surface_);
            else
                surface = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a 2D translation transform object.</p>
        /// </summary>
        /// <param name = "translateTransform"><dd>  <p>The new 2D translation transform object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>A new 2D translation transform object has a static value of zero for the OffsetX and OffsetY properties.</p>
        /// </remarks>
        /// <doc-id>hh437411</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice::CreateTranslateTransform([Out, Fast] IDCompositionTranslateTransform** translateTransform)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice::CreateTranslateTransform</unmanaged-short>
        internal unsafe void CreateTranslateTransform(SharpDX.DirectComposition.TranslateTransform translateTransform)
        {
            System.IntPtr translateTransform_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &translateTransform_, (*(void ***)this._nativePointer)[12]);
            (translateTransform).NativePointer = translateTransform_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a 2D scale transform object.</p>
        /// </summary>
        /// <param name = "scaleTransform"><dd>  <p>The new 2D scale transform object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>A new 2D scale transform object has a static value of zero for the ScaleX, ScaleY, CenterX, and CenterY properties.</p>
        /// </remarks>
        /// <doc-id>hh437402</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice::CreateScaleTransform([Out, Fast] IDCompositionScaleTransform** scaleTransform)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice::CreateScaleTransform</unmanaged-short>
        internal unsafe void CreateScaleTransform(SharpDX.DirectComposition.ScaleTransform scaleTransform)
        {
            System.IntPtr scaleTransform_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &scaleTransform_, (*(void ***)this._nativePointer)[13]);
            (scaleTransform).NativePointer = scaleTransform_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a 2D rotation transform object.</p>
        /// </summary>
        /// <param name = "rotateTransform"><dd>  <p>The new rotation transform object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>A new 2D rotation transform object has a static value of zero for the Angle, CenterX, and CenterY properties.</p>
        /// </remarks>
        /// <doc-id>hh437400</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice::CreateRotateTransform([Out, Fast] IDCompositionRotateTransform** rotateTransform)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice::CreateRotateTransform</unmanaged-short>
        internal unsafe void CreateRotateTransform(SharpDX.DirectComposition.RotateTransform rotateTransform)
        {
            System.IntPtr rotateTransform_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &rotateTransform_, (*(void ***)this._nativePointer)[14]);
            (rotateTransform).NativePointer = rotateTransform_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a 2D skew transform object.</p>
        /// </summary>
        /// <param name = "skewTransform"><dd>  <p>The new 2D skew transform object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>A new 2D skew transform object has a static value of zero for the AngleX, AngleY, CenterX, and CenterY properties.</p>
        /// </remarks>
        /// <doc-id>hh437404</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice::CreateSkewTransform([Out, Fast] IDCompositionSkewTransform** skewTransform)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice::CreateSkewTransform</unmanaged-short>
        internal unsafe void CreateSkewTransform(SharpDX.DirectComposition.SkewTransform skewTransform)
        {
            System.IntPtr skewTransform_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &skewTransform_, (*(void ***)this._nativePointer)[15]);
            (skewTransform).NativePointer = skewTransform_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a 2D 3-by-2 matrix transform object.</p>
        /// </summary>
        /// <param name = "matrixTransform"><dd>  <p>The new matrix transform object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>A new matrix transform object has the identity matrix as its initial value. The identity matrix is the 3x2 matrix with ones on the main diagonal and zeros elsewhere, as shown in the following illustration. </p><p></p><p>When an identity transform is applied to an object, it does not change the position, shape, or size of the object. It is similar to the way that multiplying a number by one does not change the number. Any transform other than the identity transform will modify the position, shape, and/or size of objects.</p>
        /// </remarks>
        /// <doc-id>hh437397</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice::CreateMatrixTransform([Out, Fast] IDCompositionMatrixTransform** matrixTransform)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice::CreateMatrixTransform</unmanaged-short>
        internal unsafe void CreateMatrixTransform(SharpDX.DirectComposition.MatrixTransform matrixTransform)
        {
            System.IntPtr matrixTransform_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &matrixTransform_, (*(void ***)this._nativePointer)[16]);
            (matrixTransform).NativePointer = matrixTransform_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a 2D transform group object that holds an array of 2D transform objects.</p>
        /// </summary>
        /// <param name = "transforms"><dd>  <p>An array of 2D transform objects that make up this transform group.</p> </dd></param>
        /// <param name = "elements"><dd>  <p>The number of elements in the <em>transforms</em> array.</p> </dd></param>
        /// <param name = "transformGroup"><dd>  <p>The new transform group object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>The array entries in a transform group cannot be changed. However, each transform in the array can be modified through its own property setting methods. If a transform in the array is modified, the change is reflected in the computed matrix of the transform group.</p>
        /// </remarks>
        /// <doc-id>hh437410</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice::CreateTransformGroup([In, Buffer] IDCompositionTransform** transforms,[In] unsigned int elements,[Out, Fast] IDCompositionTransform** transformGroup)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice::CreateTransformGroup</unmanaged-short>
        internal unsafe void CreateTransformGroup(SharpDX.DirectComposition.Transform[] transforms, System.Int32 elements, SharpDX.DirectComposition.Transform transformGroup)
        {
            System.IntPtr*transforms_;
            transforms_ = (System.IntPtr*)0;
            if (transforms != null)
            {
                System.IntPtr*_transforms = stackalloc System.IntPtr[transforms.Length];
                transforms_ = _transforms;
            }

            System.IntPtr transformGroup_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            if (transforms != null)
                for (int i = 0; i < transforms.Length; ++i)
                    (transforms_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Transform>(transforms[i]);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)transforms_, elements, &transformGroup_, (*(void ***)this._nativePointer)[17]);
            (transformGroup).NativePointer = transformGroup_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a 3D translation transform object.</p>
        /// </summary>
        /// <param name = "translateTransform3D"><dd>  <p>The new 3D translation transform object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>A newly created 3D translation transform has a static value of 0 for the OffsetX, OffsetY, and OffsetZ properties. </p>
        /// </remarks>
        /// <doc-id>hh437412</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice::CreateTranslateTransform3D([Out, Fast] IDCompositionTranslateTransform3D** translateTransform3D)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice::CreateTranslateTransform3D</unmanaged-short>
        internal unsafe void CreateTranslateTransform3D(SharpDX.DirectComposition.TranslateTransform3D translateTransform3D)
        {
            System.IntPtr translateTransform3D_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &translateTransform3D_, (*(void ***)this._nativePointer)[18]);
            (translateTransform3D).NativePointer = translateTransform3D_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a 3D scale transform object.</p>
        /// </summary>
        /// <param name = "scaleTransform3D"><dd>  <p>The new 3D scale transform object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>A new 3D scale transform object has a static value of 1.0 for the ScaleX, ScaleY, and ScaleZ properties.</p>
        /// </remarks>
        /// <doc-id>hh437403</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice::CreateScaleTransform3D([Out, Fast] IDCompositionScaleTransform3D** scaleTransform3D)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice::CreateScaleTransform3D</unmanaged-short>
        internal unsafe void CreateScaleTransform3D(SharpDX.DirectComposition.ScaleTransform3D scaleTransform3D)
        {
            System.IntPtr scaleTransform3D_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &scaleTransform3D_, (*(void ***)this._nativePointer)[19]);
            (scaleTransform3D).NativePointer = scaleTransform3D_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a 3D rotation transform object.</p>
        /// </summary>
        /// <param name = "rotateTransform3D"><dd>  <p>The new 3D rotation transform object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>A new 3D rotation transform object has a default static value of zero for the Angle, CenterX, CenterY, AxisX, and AxisY properties, and a default static value of 1.0 for the AxisZ property.</p>
        /// </remarks>
        /// <doc-id>hh437401</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice::CreateRotateTransform3D([Out, Fast] IDCompositionRotateTransform3D** rotateTransform3D)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice::CreateRotateTransform3D</unmanaged-short>
        internal unsafe void CreateRotateTransform3D(SharpDX.DirectComposition.RotateTransform3D rotateTransform3D)
        {
            System.IntPtr rotateTransform3D_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &rotateTransform3D_, (*(void ***)this._nativePointer)[20]);
            (rotateTransform3D).NativePointer = rotateTransform3D_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a 3D 4-by-4 matrix transform object.</p>
        /// </summary>
        /// <param name = "matrixTransform3D"><dd>  <p>The new 3D matrix transform object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>The new 3D matrix transform has the identity matrix as its value. The identity matrix is the 4-by-4 matrix with ones on the main diagonal and zeros elsewhere, as shown in the following illustration. </p><p></p><p>When an identity transform is applied to an object, it does not change the position, shape, or size of the object. It is similar to the way that multiplying a number by one does not change the number. Any transform other than the identity transform will modify the position, shape, and/or size of objects.</p>
        /// </remarks>
        /// <doc-id>hh437398</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice::CreateMatrixTransform3D([Out, Fast] IDCompositionMatrixTransform3D** matrixTransform3D)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice::CreateMatrixTransform3D</unmanaged-short>
        internal unsafe void CreateMatrixTransform3D(SharpDX.DirectComposition.MatrixTransform3D matrixTransform3D)
        {
            System.IntPtr matrixTransform3D_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &matrixTransform3D_, (*(void ***)this._nativePointer)[21]);
            (matrixTransform3D).NativePointer = matrixTransform3D_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a 3D transform group object that holds an array of 3D transform objects.</p>
        /// </summary>
        /// <param name = "transforms3D"><dd>  <p>An array of 3D transform objects that make up this transform group.</p> </dd></param>
        /// <param name = "elements"><dd>  <p>The number of elements in the <em>transforms</em> array.</p> </dd></param>
        /// <param name = "transform3DGroup"><dd>  <p>The new 3D transform group object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>The array entries in a 3D transform group cannot be changed. However, each transform in the array can be modified through its own property setting methods. If a transform in the array is modified, the change is reflected in the computed matrix of the transform group.</p>
        /// </remarks>
        /// <doc-id>hh437409</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice::CreateTransform3DGroup([In, Buffer] IDCompositionTransform3D** transforms3D,[In] unsigned int elements,[Out, Fast] IDCompositionTransform3D** transform3DGroup)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice::CreateTransform3DGroup</unmanaged-short>
        internal unsafe void CreateTransform3DGroup(SharpDX.DirectComposition.Transform3D[] transforms3D, System.Int32 elements, SharpDX.DirectComposition.Transform3D transform3DGroup)
        {
            System.IntPtr*transforms3D_;
            transforms3D_ = (System.IntPtr*)0;
            if (transforms3D != null)
            {
                System.IntPtr*_transforms3D = stackalloc System.IntPtr[transforms3D.Length];
                transforms3D_ = _transforms3D;
            }

            System.IntPtr transform3DGroup_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            if (transforms3D != null)
                for (int i = 0; i < transforms3D.Length; ++i)
                    (transforms3D_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Transform3D>(transforms3D[i]);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)transforms3D_, elements, &transform3DGroup_, (*(void ***)this._nativePointer)[22]);
            (transform3DGroup).NativePointer = transform3DGroup_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates an object that represents multiple effects to be applied to a visual subtree.</p>
        /// </summary>
        /// <param name = "effectGroup"><dd>  <p>The new effect group object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>An effect group enables an application to apply multiple effects to a single visual subtree. </p><p>A new effect group has a default opacity value of 1.0 and no 3D transformations.</p>
        /// </remarks>
        /// <doc-id>hh437395</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice::CreateEffectGroup([Out, Fast] IDCompositionEffectGroup** effectGroup)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice::CreateEffectGroup</unmanaged-short>
        internal unsafe void CreateEffectGroup(SharpDX.DirectComposition.EffectGroup effectGroup)
        {
            System.IntPtr effectGroup_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &effectGroup_, (*(void ***)this._nativePointer)[23]);
            (effectGroup).NativePointer = effectGroup_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a clip object that can be used to restrict the rendering of  a visual subtree to a rectangular area.</p>
        /// </summary>
        /// <param name = "clip"><dd>  <p>The new clip object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>A newly created clip object has a static value of ?FLT_MAX for the left and top properties, and a static value of ?FLT_MAX for the right and bottom properties, effectively making it a no-op clip object.</p>
        /// </remarks>
        /// <doc-id>hh437399</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice::CreateRectangleClip([Out, Fast] IDCompositionRectangleClip** clip)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice::CreateRectangleClip</unmanaged-short>
        internal unsafe void CreateRectangleClip(SharpDX.DirectComposition.RectangleClip clip)
        {
            System.IntPtr clip_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &clip_, (*(void ***)this._nativePointer)[24]);
            (clip).NativePointer = clip_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates an animation object that is used to animate one or more scalar properties of one or more Microsoft DirectComposition objects. </p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>The new animation object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>A number of DirectComposition object properties can have an animation object as the value of the property. When a property has an animation object as its value, DirectComposition redraws the visual at the refresh rate to reflect the changing value of the property that is being animated.</p><p>A newly created animation object does not have any animation segments associated with it. An application must use the methods of the <strong><see cref = "SharpDX.DirectComposition.Animation"/></strong> interface to build an animation function before setting the animation object as the property of another DirectComposition object.</p>
        /// </remarks>
        /// <doc-id>hh437394</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice::CreateAnimation([Out, Fast] IDCompositionAnimation** animation)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice::CreateAnimation</unmanaged-short>
        internal unsafe void CreateAnimation(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &animation_, (*(void ***)this._nativePointer)[25]);
            (animation).NativePointer = animation_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Determines whether the DirectComposition device object is still valid.</p>
        /// </summary>
        /// <param name = "fValidRef"><dd> <p>TRUE if the  DirectComposition device object is still valid; otherwise <see cref = "SharpDX.Result.False"/>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p> If the Microsoft DirectX Graphics Infrastructure (DXGI) device is lost, the DirectComposition device associated with the DXGI device is also lost. When it detects a lost device, DirectComposition sends the <strong>WM_PAINT</strong> message to all windows that are composing DirectComposition content using the lost device. An application should call <strong>CheckDeviceState</strong> in response to each  <strong>WM_PAINT</strong> message to ensure that the DirectComposition device object is still valid. The application must take steps to recover content if the device object becomes invalid. Steps include creating new DXGI and DirectComposition devices, and recreating all content. (It?s not possible to create just a new DXGI device and associate it with the existing DirectComposition device.)  The system ensures that the device object remains valid between <strong>WM_PAINT</strong> messages. </p>
        /// </remarks>
        /// <doc-id>hh707428</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice::CheckDeviceState([Out] BOOL* pfValid)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice::CheckDeviceState</unmanaged-short>
        public unsafe void CheckDeviceState(out SharpDX.Mathematics.Interop.RawBool fValidRef)
        {
            fValidRef = default (SharpDX.Mathematics.Interop.RawBool);
            SharpDX.Result __result__;
            fixed (void *fValidRef_ = &fValidRef)
                __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, fValidRef_, (*(void ***)this._nativePointer)[26]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a 2D transform group object that holds an array of 2D transform objects.</p>
        /// </summary>
        /// <param name = "transforms"><dd>  <p>An array of 2D transform objects that make up this transform group.</p> </dd></param>
        /// <param name = "elements"><dd>  <p>The number of elements in the <em>transforms</em> array.</p> </dd></param>
        /// <param name = "transformGroup"><dd>  <p>The new transform group object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>The array entries in a transform group cannot be changed. However, each transform in the array can be modified through its own property setting methods. If a transform in the array is modified, the change is reflected in the computed matrix of the transform group.</p>
        /// </remarks>
        /// <doc-id>hh437410</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice::CreateTransformGroup([In, Buffer] IDCompositionTransform** transforms,[In] unsigned int elements,[Out, Fast] IDCompositionTransform** transformGroup)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice::CreateTransformGroup</unmanaged-short>
        internal unsafe void CreateTransformGroup(SharpDX.ComArray<SharpDX.DirectComposition.Transform> transforms, System.Int32 elements, SharpDX.DirectComposition.Transform transformGroup)
        {
            System.IntPtr transformGroup_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)(transforms?.NativePointer ?? System.IntPtr.Zero), elements, &transformGroup_, (*(void ***)this._nativePointer)[17]);
            (transformGroup).NativePointer = transformGroup_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a 2D transform group object that holds an array of 2D transform objects.</p>
        /// </summary>
        /// <param name = "transforms"><dd>  <p>An array of 2D transform objects that make up this transform group.</p> </dd></param>
        /// <param name = "elements"><dd>  <p>The number of elements in the <em>transforms</em> array.</p> </dd></param>
        /// <param name = "transformGroup"><dd>  <p>The new transform group object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>The array entries in a transform group cannot be changed. However, each transform in the array can be modified through its own property setting methods. If a transform in the array is modified, the change is reflected in the computed matrix of the transform group.</p>
        /// </remarks>
        /// <doc-id>hh437410</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice::CreateTransformGroup([In, Buffer] IDCompositionTransform** transforms,[In] unsigned int elements,[Out, Fast] IDCompositionTransform** transformGroup)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice::CreateTransformGroup</unmanaged-short>
        private unsafe void CreateTransformGroup(System.IntPtr transforms, System.Int32 elements, System.IntPtr transformGroup)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)transforms, elements, (void *)transformGroup, (*(void ***)this._nativePointer)[17]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a 3D transform group object that holds an array of 3D transform objects.</p>
        /// </summary>
        /// <param name = "transforms3D"><dd>  <p>An array of 3D transform objects that make up this transform group.</p> </dd></param>
        /// <param name = "elements"><dd>  <p>The number of elements in the <em>transforms</em> array.</p> </dd></param>
        /// <param name = "transform3DGroup"><dd>  <p>The new 3D transform group object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>The array entries in a 3D transform group cannot be changed. However, each transform in the array can be modified through its own property setting methods. If a transform in the array is modified, the change is reflected in the computed matrix of the transform group.</p>
        /// </remarks>
        /// <doc-id>hh437409</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice::CreateTransform3DGroup([In, Buffer] IDCompositionTransform3D** transforms3D,[In] unsigned int elements,[Out, Fast] IDCompositionTransform3D** transform3DGroup)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice::CreateTransform3DGroup</unmanaged-short>
        internal unsafe void CreateTransform3DGroup(SharpDX.ComArray<SharpDX.DirectComposition.Transform3D> transforms3D, System.Int32 elements, SharpDX.DirectComposition.Transform3D transform3DGroup)
        {
            System.IntPtr transform3DGroup_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)(transforms3D?.NativePointer ?? System.IntPtr.Zero), elements, &transform3DGroup_, (*(void ***)this._nativePointer)[22]);
            (transform3DGroup).NativePointer = transform3DGroup_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a 3D transform group object that holds an array of 3D transform objects.</p>
        /// </summary>
        /// <param name = "transforms3D"><dd>  <p>An array of 3D transform objects that make up this transform group.</p> </dd></param>
        /// <param name = "elements"><dd>  <p>The number of elements in the <em>transforms</em> array.</p> </dd></param>
        /// <param name = "transform3DGroup"><dd>  <p>The new 3D transform group object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>The array entries in a 3D transform group cannot be changed. However, each transform in the array can be modified through its own property setting methods. If a transform in the array is modified, the change is reflected in the computed matrix of the transform group.</p>
        /// </remarks>
        /// <doc-id>hh437409</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice::CreateTransform3DGroup([In, Buffer] IDCompositionTransform3D** transforms3D,[In] unsigned int elements,[Out, Fast] IDCompositionTransform3D** transform3DGroup)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice::CreateTransform3DGroup</unmanaged-short>
        private unsafe void CreateTransform3DGroup(System.IntPtr transforms3D, System.Int32 elements, System.IntPtr transform3DGroup)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)transforms3D, elements, (void *)transform3DGroup, (*(void ***)this._nativePointer)[22]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("75F6468D-1B8E-447C-9BC6-75FEA80B5B25")]
    public partial class Device2 : SharpDX.ComObject
    {
        public Device2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Device2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Device2(nativePtr);
        /// <summary>
        /// <p>Retrieves information from the composition engine about composition times and the frame rate.</p>
        /// </summary>
        /// <remarks>
        /// <p>This method retrieves timing information about the composition engine that an application can use to synchronize the rasterization of bitmaps with independent animations.</p>
        /// </remarks>
        /// <doc-id>dn280375</doc-id>
        /// <unmanaged>GetFrameStatistics</unmanaged>
        /// <unmanaged-short>GetFrameStatistics</unmanaged-short>
        public SharpDX.DirectComposition.FrameStatistics FrameStatistics
        {
            get
            {
                GetFrameStatistics(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Commits all DirectComposition commands that are pending on this device.</p>
        /// </summary>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See  DirectComposition Error Codes for a  list of error codes.</p></returns>
        /// <remarks>
        /// <p>Calls to DirectComposition methods are always batched and executed atomically as  a single transaction. Calls take effect only when  <strong>IDCompositionDevice2::Commit</strong> is  called, at which time all pending method calls for a device are executed at once.</p><p>An application that uses multiple devices must call  <strong>Commit</strong> for each device separately.  However, because the composition engine processes the calls individually, the batch of commands might not take  effect at the same time.</p>
        /// </remarks>
        /// <doc-id>dn280355</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice2::Commit()</unmanaged>
        /// <unmanaged-short>IDCompositionDevice2::Commit</unmanaged-short>
        public unsafe void Commit()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Waits for the composition engine to finish processing the previous call to the <strong>IDCompositionDevice2::Commit</strong> method. </p>
        /// </summary>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <doc-id>dn280376</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice2::WaitForCommitCompletion()</unmanaged>
        /// <unmanaged-short>IDCompositionDevice2::WaitForCommitCompletion</unmanaged-short>
        public unsafe void WaitForCommitCompletion()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves information from the composition engine about composition times and the frame rate.</p>
        /// </summary>
        /// <param name = "statistics"><dd>  <p>A structure that receives composition times and frame rate information.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method retrieves timing information about the composition engine that an application can use to synchronize the rasterization of bitmaps with independent animations.</p>
        /// </remarks>
        /// <doc-id>dn280375</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice2::GetFrameStatistics([Out] DCOMPOSITION_FRAME_STATISTICS* statistics)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice2::GetFrameStatistics</unmanaged-short>
        internal unsafe void GetFrameStatistics(out SharpDX.DirectComposition.FrameStatistics statistics)
        {
            statistics = default (SharpDX.DirectComposition.FrameStatistics);
            SharpDX.Result __result__;
            fixed (void *statistics_ = &statistics)
                __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, statistics_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a new visual object.</p>
        /// </summary>
        /// <param name = "visual"><dd>  <p>The new visual object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>A new visual object has a static value of zero for the OffsetX and OffsetY properties, and <c>null</c> for the Transform, Clip, and Content properties. Initially, the visual  does not cause the contents of a window to change. The visual must be added as a child of another visual, or as the root of a composition target, before it can affect the appearance of a window.</p>
        /// </remarks>
        /// <doc-id>dn280373</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateVisual([Out, Fast] IDCompositionVisual2** visual)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice2::CreateVisual</unmanaged-short>
        internal unsafe void CreateVisual(SharpDX.DirectComposition.Visual2 visual)
        {
            System.IntPtr visual_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &visual_, (*(void ***)this._nativePointer)[6]);
            (visual).NativePointer = visual_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a Microsoft DirectComposition surface factory object, which can be used to create other DirectComposition surface or virtual surface objects</p>
        /// </summary>
        /// <param name = "renderingDevice"><dd> <p>A reference to a DirectX device to be used to create DirectComposition surface objects. Must be a reference to an object implementing the <strong><see cref = "SharpDX.DXGI.Device"/></strong> or <strong><see cref = "SharpDX.Direct2D1.Device"/></strong> interfaces. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <param name = "surfaceFactory"><dd> <p>The newly created surface factory object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>A surface factory allows an application to simultaneously use more than one single DXGI or Direct2D device with DirectComposition. Each surface factory has a permanent association with one DXGI or Direct2D device, but a DirectComposition device may have any number of surface factories. </p><p>Each surface factory manages resources independently from the others. In particular, DirectComposition pools surface allocations to mitigate surface allocation and deallocation costs. This pool is done on a per-surface factory basis. </p><p>If the <strong>DCompositionCreateDevice2</strong> function is called with a non-<c>null</c> <em>renderingDevice</em> parameter, the returned DirectComposition device object has an implicit surface factory under the covers associated with the given rendering device. This implicit surface factory is used to service the <strong>IDCompositionDevice::CreateSurface</strong>, <strong>IDCompositionDevice::CreateVirtualSurface</strong>, <strong>IDCompositionDevice2::CreateSurface</strong> and <strong>IDCompositionDevice2::CreateVirtualSurface</strong> methods. </p><p>A surface object remains alive as long as any of the surfaces or virtual surfaces that it created remain alive, either directly because the application holds a direct reference, or indirectly because one or more such surfaces are associated with one or more visual objects.
        /// </p>
        /// </remarks>
        /// <doc-id>dn280367</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateSurfaceFactory([In] IUnknown* renderingDevice,[Out, Fast] IDCompositionSurfaceFactory** surfaceFactory)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice2::CreateSurfaceFactory</unmanaged-short>
        internal unsafe void CreateSurfaceFactory(SharpDX.IUnknown renderingDevice, SharpDX.DirectComposition.SurfaceFactory surfaceFactory)
        {
            System.IntPtr renderingDevice_ = System.IntPtr.Zero;
            System.IntPtr surfaceFactory_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            renderingDevice_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(renderingDevice);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)renderingDevice_, &surfaceFactory_, (*(void ***)this._nativePointer)[7]);
            (surfaceFactory).NativePointer = surfaceFactory_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates an updateable surface object that can be associated with one or more visuals for composition.</p>
        /// </summary>
        /// <param name = "width"><dd>  <p>The width of the surface, in pixels. Constrained by the feature level of the rendering device that was passed in at the time the DirectComposition device was created. </p> </dd></param>
        /// <param name = "height"><dd>  <p>The height of the surface, in pixels. Constrained by the feature level of the rendering device that was passed in at the time the DirectComposition device was created.</p> </dd></param>
        /// <param name = "pixelFormat"><dd>  <p>The pixel format of the surface.</p> </dd></param>
        /// <param name = "alphaMode"><dd>  <p>The format of the alpha channel, if an alpha channel is included in the pixel format. It can be one of the following values:</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>DXGI_ALPHA_MODE_UNSPECIFIED</strong></dt> </dl> </td><td> <p>The alpha channel is not specified. This value has the same effect as <strong>DXGI_ALPHA_MODE_IGNORE</strong>.</p> </td></tr> <tr><td><dl> <dt><strong>DXGI_ALPHA_MODE_PREMULTIPLIED</strong></dt> </dl> </td><td> <p>The color channels contain values that are premultiplied with the alpha channel.</p> </td></tr> <tr><td><dl> <dt><strong>DXGI_ALPHA_MODE_IGNORE</strong></dt> </dl> </td><td> <p>The alpha channel should be ignored and the bitmap should be rendered opaquely.</p> </td></tr> </table> <p>?</p> </dd></param>
        /// <param name = "surface"><dd>  <p>The newly created surface object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>A Microsoft DirectComposition surface is a rectangular array of pixels that can be associated with a visual for composition. </p><p>A newly created surface object is in an uninitialized state. While it is uninitialized, the surface has no effect on the composition of the visual tree. It behaves exactly like a surface that has  100% transparent pixels. </p><p>To initialize the surface with pixel data, use the <strong>IDCompositionSurface::BeginDraw</strong> and <strong>IDCompositionSurface::EndDraw</strong> methods. The first call to this method must cover the entire surface area to provide an initial value for every pixel. Subsequent calls may specify smaller sub-rectangles of the surface to update. </p><p>DirectComposition surfaces support the following pixel formats: </p><ul> <li><strong>DXGI_FORMAT_B8G8R8A8_UNORM</strong></li> <li><strong>DXGI_FORMAT_R8G8B8A8_UNORM</strong></li> <li><strong>DXGI_FORMAT_R16G16B16A16_FLOAT</strong></li> </ul>
        /// </remarks>
        /// <doc-id>dn280366</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateSurface([In] unsigned int width,[In] unsigned int height,[In] DXGI_FORMAT pixelFormat,[In] DXGI_ALPHA_MODE alphaMode,[Out, Fast] IDCompositionSurface** surface)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice2::CreateSurface</unmanaged-short>
        internal unsafe void CreateSurface(System.Int32 width, System.Int32 height, SharpDX.DXGI.Format pixelFormat, SharpDX.DXGI.AlphaMode alphaMode, SharpDX.DirectComposition.Surface surface)
        {
            System.IntPtr surface_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, width, height, unchecked ((System.Int32)pixelFormat), unchecked ((System.Int32)alphaMode), &surface_, (*(void ***)this._nativePointer)[8]);
            (surface).NativePointer = surface_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a sparsely populated surface that can be associated with one or more visuals for composition.</p>
        /// </summary>
        /// <param name = "initialWidth"><dd>  <p>The width of the surface, in pixels. The maximum width is 16,777,216 pixels.</p> </dd></param>
        /// <param name = "initialHeight"><dd>  <p>The height of the surface, in pixels. The maximum height is 16,777,216 pixels.</p> </dd></param>
        /// <param name = "pixelFormat"><dd>  <p>The pixel format of the surface.</p> </dd></param>
        /// <param name = "alphaMode"><dd>  <p>The meaning of the alpha channel, if the pixel format contains an alpha channel. It can be one of the following values:</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>DXGI_ALPHA_MODE_UNSPECIFIED</strong></dt> </dl> </td><td> <p>The alpha channel is not specified. This value has the same effect as <strong>DXGI_ALPHA_MODE_IGNORE</strong>.</p> </td></tr> <tr><td><dl> <dt><strong>DXGI_ALPHA_MODE_PREMULTIPLIED</strong></dt> </dl> </td><td> <p>The color channels contain values that are premultiplied with the alpha channel.</p> </td></tr> <tr><td><dl> <dt><strong>DXGI_ALPHA_MODE_IGNORE</strong></dt> </dl> </td><td> <p>The alpha channel should be ignored and the bitmap should be rendered opaquely.</p> </td></tr> </table> <p>?</p> </dd></param>
        /// <param name = "virtualSurface"><dd>  <p>The newly created surface object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>A Microsoft DirectComposition sparse surface is a logical object that behaves like a rectangular array of pixels that can be associated with a visual for composition. The surface is not necessarily backed by any physical video or system memory for every one of its pixels. The application can realize or virtualize parts of the logical surface at different times. </p><p>A newly created surface object is in an uninitialized state. While it is uninitialized, the surface has no effect on the composition of the visual tree. It behaves exactly like a surface that is initialized with 100% transparent pixels. </p><p>To initialize the surface with pixel data, use the <strong>IDCompositionSurface::BeginDraw</strong> and <strong>IDCompositionSurface::EndDraw</strong> methods. This method not only provides pixels for the surface, but it also allocates actual storage space for those pixels. The memory allocation persists until the application returns some of the memory to the system. The application can free part or all of the allocated memory by calling the <strong>IDCompositionVirtualSurface::Trim</strong> method.</p><p>DirectComposition surfaces support the following pixel formats:</p><ul> <li><strong>DXGI_FORMAT_B8G8R8A8_UNORM</strong></li> <li><strong>DXGI_FORMAT_R8G8B8A8_UNORM</strong></li> <li><strong>DXGI_FORMAT_R16G16B16A16_FLOAT</strong></li> </ul><p>This method fails if <em>initialWidth</em> or <em>initialHeight</em> exceeds 16,777,216 pixels. </p>
        /// </remarks>
        /// <doc-id>dn280372</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateVirtualSurface([In] unsigned int initialWidth,[In] unsigned int initialHeight,[In] DXGI_FORMAT pixelFormat,[In] DXGI_ALPHA_MODE alphaMode,[Out, Fast] IDCompositionVirtualSurface** virtualSurface)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice2::CreateVirtualSurface</unmanaged-short>
        internal unsafe void CreateVirtualSurface(System.Int32 initialWidth, System.Int32 initialHeight, SharpDX.DXGI.Format pixelFormat, SharpDX.DXGI.AlphaMode alphaMode, SharpDX.DirectComposition.VirtualSurface virtualSurface)
        {
            System.IntPtr virtualSurface_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, initialWidth, initialHeight, unchecked ((System.Int32)pixelFormat), unchecked ((System.Int32)alphaMode), &virtualSurface_, (*(void ***)this._nativePointer)[9]);
            (virtualSurface).NativePointer = virtualSurface_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a 2D translation transform object.</p>
        /// </summary>
        /// <param name = "translateTransform"><dd>  <p>The new 2D translation transform object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>A new 2D translation transform object has a static value of zero for the OffsetX and OffsetY properties.</p>
        /// </remarks>
        /// <doc-id>dn280370</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateTranslateTransform([Out, Fast] IDCompositionTranslateTransform** translateTransform)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice2::CreateTranslateTransform</unmanaged-short>
        internal unsafe void CreateTranslateTransform(SharpDX.DirectComposition.TranslateTransform translateTransform)
        {
            System.IntPtr translateTransform_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &translateTransform_, (*(void ***)this._nativePointer)[10]);
            (translateTransform).NativePointer = translateTransform_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a 2D scale transform object.</p>
        /// </summary>
        /// <param name = "scaleTransform"><dd>  <p>The new 2D scale transform object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>A new 2D scale transform object has a static value of zero for the ScaleX, ScaleY, CenterX, and CenterY properties.</p>
        /// </remarks>
        /// <doc-id>dn280363</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateScaleTransform([Out, Fast] IDCompositionScaleTransform** scaleTransform)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice2::CreateScaleTransform</unmanaged-short>
        internal unsafe void CreateScaleTransform(SharpDX.DirectComposition.ScaleTransform scaleTransform)
        {
            System.IntPtr scaleTransform_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &scaleTransform_, (*(void ***)this._nativePointer)[11]);
            (scaleTransform).NativePointer = scaleTransform_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a 2D rotation transform object.</p>
        /// </summary>
        /// <param name = "rotateTransform"><dd>  <p>The new rotation transform object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>A new 2D rotation transform object has a static value of zero for the Angle, CenterX, and CenterY properties.</p>
        /// </remarks>
        /// <doc-id>dn280361</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateRotateTransform([Out, Fast] IDCompositionRotateTransform** rotateTransform)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice2::CreateRotateTransform</unmanaged-short>
        internal unsafe void CreateRotateTransform(SharpDX.DirectComposition.RotateTransform rotateTransform)
        {
            System.IntPtr rotateTransform_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &rotateTransform_, (*(void ***)this._nativePointer)[12]);
            (rotateTransform).NativePointer = rotateTransform_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a 2D skew transform object.</p>
        /// </summary>
        /// <param name = "skewTransform"><dd>  <p>The new 2D skew transform object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>A new 2D skew transform object has a static value of zero for the AngleX, AngleY, CenterX, and CenterY properties.</p>
        /// </remarks>
        /// <doc-id>dn280365</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateSkewTransform([Out, Fast] IDCompositionSkewTransform** skewTransform)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice2::CreateSkewTransform</unmanaged-short>
        internal unsafe void CreateSkewTransform(SharpDX.DirectComposition.SkewTransform skewTransform)
        {
            System.IntPtr skewTransform_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &skewTransform_, (*(void ***)this._nativePointer)[13]);
            (skewTransform).NativePointer = skewTransform_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a 2D 3-by-2 matrix transform object.</p>
        /// </summary>
        /// <param name = "matrixTransform"><dd>  <p>The new matrix transform object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>A new matrix transform object has the identity matrix as its initial value. The identity matrix is the 3x2 matrix with ones on the main diagonal and zeros elsewhere, as shown in the following illustration. </p><p></p><p>When an identity transform is applied to an object, it does not change the position, shape, or size of the object. It is similar to the way that multiplying a number by one does not change the number. Any transform other than the identity transform will modify the position, shape, and/or size of objects.</p>
        /// </remarks>
        /// <doc-id>dn280358</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateMatrixTransform([Out, Fast] IDCompositionMatrixTransform** matrixTransform)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice2::CreateMatrixTransform</unmanaged-short>
        internal unsafe void CreateMatrixTransform(SharpDX.DirectComposition.MatrixTransform matrixTransform)
        {
            System.IntPtr matrixTransform_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &matrixTransform_, (*(void ***)this._nativePointer)[14]);
            (matrixTransform).NativePointer = matrixTransform_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a 2D transform group object that holds an array of 2D transform objects.</p>
        /// </summary>
        /// <param name = "transforms"><dd>  <p>An array of 2D transform objects that make up this transform group.</p> </dd></param>
        /// <param name = "elements"><dd>  <p>The number of elements in the <em>transforms</em> array.</p> </dd></param>
        /// <param name = "transformGroup"><dd>  <p>The new transform group object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>The array entries in a transform group cannot be changed. However, each transform in the array can be modified through its own property setting methods. If a transform in the array is modified, the change is reflected in the computed matrix of the transform group.</p>
        /// </remarks>
        /// <doc-id>dn280369</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateTransformGroup([In, Buffer] IDCompositionTransform** transforms,[In] unsigned int elements,[Out, Fast] IDCompositionTransform** transformGroup)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice2::CreateTransformGroup</unmanaged-short>
        internal unsafe void CreateTransformGroup(SharpDX.DirectComposition.Transform[] transforms, System.Int32 elements, SharpDX.DirectComposition.Transform transformGroup)
        {
            System.IntPtr*transforms_;
            transforms_ = (System.IntPtr*)0;
            if (transforms != null)
            {
                System.IntPtr*_transforms = stackalloc System.IntPtr[transforms.Length];
                transforms_ = _transforms;
            }

            System.IntPtr transformGroup_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            if (transforms != null)
                for (int i = 0; i < transforms.Length; ++i)
                    (transforms_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Transform>(transforms[i]);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)transforms_, elements, &transformGroup_, (*(void ***)this._nativePointer)[15]);
            (transformGroup).NativePointer = transformGroup_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a 3D translation transform object.</p>
        /// </summary>
        /// <param name = "translateTransform3D"><dd>  <p>The new 3D translation transform object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>A newly created 3D translation transform has a static value of 0 for the OffsetX, OffsetY, and OffsetZ properties. </p>
        /// </remarks>
        /// <doc-id>dn280371</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateTranslateTransform3D([Out, Fast] IDCompositionTranslateTransform3D** translateTransform3D)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice2::CreateTranslateTransform3D</unmanaged-short>
        internal unsafe void CreateTranslateTransform3D(SharpDX.DirectComposition.TranslateTransform3D translateTransform3D)
        {
            System.IntPtr translateTransform3D_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &translateTransform3D_, (*(void ***)this._nativePointer)[16]);
            (translateTransform3D).NativePointer = translateTransform3D_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a 3D scale transform object.</p>
        /// </summary>
        /// <param name = "scaleTransform3D"><dd>  <p>The new 3D scale transform object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>A new 3D scale transform object has a static value of 1.0 for the ScaleX, ScaleY, and ScaleZ properties.</p>
        /// </remarks>
        /// <doc-id>dn280364</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateScaleTransform3D([Out, Fast] IDCompositionScaleTransform3D** scaleTransform3D)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice2::CreateScaleTransform3D</unmanaged-short>
        internal unsafe void CreateScaleTransform3D(SharpDX.DirectComposition.ScaleTransform3D scaleTransform3D)
        {
            System.IntPtr scaleTransform3D_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &scaleTransform3D_, (*(void ***)this._nativePointer)[17]);
            (scaleTransform3D).NativePointer = scaleTransform3D_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a 3D rotation transform object.</p>
        /// </summary>
        /// <param name = "rotateTransform3D"><dd>  <p>The new 3D rotation transform object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>A new 3D rotation transform object has a default static value of zero for the Angle, CenterX, CenterY, CenterZ, AxisX, and AxisY properties, and a default static value of 1.0 for the AxisZ property.</p>
        /// </remarks>
        /// <doc-id>dn280362</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateRotateTransform3D([Out, Fast] IDCompositionRotateTransform3D** rotateTransform3D)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice2::CreateRotateTransform3D</unmanaged-short>
        internal unsafe void CreateRotateTransform3D(SharpDX.DirectComposition.RotateTransform3D rotateTransform3D)
        {
            System.IntPtr rotateTransform3D_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &rotateTransform3D_, (*(void ***)this._nativePointer)[18]);
            (rotateTransform3D).NativePointer = rotateTransform3D_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a 3D 4-by-4 matrix transform object.</p>
        /// </summary>
        /// <param name = "matrixTransform3D"><dd>  <p>The new 3D matrix transform object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>The new 3D matrix transform has the identity matrix as its value. The identity matrix is the 4-by-4 matrix with ones on the main diagonal and zeros elsewhere, as shown in the following illustration. </p><p></p><p>When an identity transform is applied to an object, it does not change the position, shape, or size of the object. It is similar to the way that multiplying a number by one does not change the number. Any transform other than the identity transform will modify the position, shape, and/or size of objects.</p>
        /// </remarks>
        /// <doc-id>dn280359</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateMatrixTransform3D([Out, Fast] IDCompositionMatrixTransform3D** matrixTransform3D)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice2::CreateMatrixTransform3D</unmanaged-short>
        internal unsafe void CreateMatrixTransform3D(SharpDX.DirectComposition.MatrixTransform3D matrixTransform3D)
        {
            System.IntPtr matrixTransform3D_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &matrixTransform3D_, (*(void ***)this._nativePointer)[19]);
            (matrixTransform3D).NativePointer = matrixTransform3D_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a 3D transform group object that holds an array of 3D transform objects.</p>
        /// </summary>
        /// <param name = "transforms3D"><dd>  <p>An array of 3D transform objects that make up this transform group.</p> </dd></param>
        /// <param name = "elements"><dd>  <p>The number of elements in the <em>transforms</em> array.</p> </dd></param>
        /// <param name = "transform3DGroup"><dd>  <p>The new 3D transform group object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>The array entries in a 3D transform group cannot be changed. However, each transform in the array can be modified through its own property setting methods. If a transform in the array is modified, the change is reflected in the computed matrix of the transform group.</p>
        /// </remarks>
        /// <doc-id>dn280368</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateTransform3DGroup([In, Buffer] IDCompositionTransform3D** transforms3D,[In] unsigned int elements,[Out, Fast] IDCompositionTransform3D** transform3DGroup)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice2::CreateTransform3DGroup</unmanaged-short>
        internal unsafe void CreateTransform3DGroup(SharpDX.DirectComposition.Transform3D[] transforms3D, System.Int32 elements, SharpDX.DirectComposition.Transform3D transform3DGroup)
        {
            System.IntPtr*transforms3D_;
            transforms3D_ = (System.IntPtr*)0;
            if (transforms3D != null)
            {
                System.IntPtr*_transforms3D = stackalloc System.IntPtr[transforms3D.Length];
                transforms3D_ = _transforms3D;
            }

            System.IntPtr transform3DGroup_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            if (transforms3D != null)
                for (int i = 0; i < transforms3D.Length; ++i)
                    (transforms3D_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Transform3D>(transforms3D[i]);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)transforms3D_, elements, &transform3DGroup_, (*(void ***)this._nativePointer)[20]);
            (transform3DGroup).NativePointer = transform3DGroup_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates an object that represents multiple effects to be applied to a visual subtree.</p>
        /// </summary>
        /// <param name = "effectGroup"><dd>  <p>The new effect group object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>An effect group enables an application to apply multiple effects to a single visual subtree. </p><p>A new effect group has a default opacity value of 1.0 and no 3D transformations.</p><p>To set the opacity and transform values, use the corresponding methods on the <strong><see cref = "SharpDX.DirectComposition.EffectGroup"/></strong> that was created.</p>
        /// </remarks>
        /// <doc-id>dn280357</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateEffectGroup([Out, Fast] IDCompositionEffectGroup** effectGroup)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice2::CreateEffectGroup</unmanaged-short>
        internal unsafe void CreateEffectGroup(SharpDX.DirectComposition.EffectGroup effectGroup)
        {
            System.IntPtr effectGroup_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &effectGroup_, (*(void ***)this._nativePointer)[21]);
            (effectGroup).NativePointer = effectGroup_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a clip object that can be used to restrict the rendering of  a visual subtree to a rectangular area.</p>
        /// </summary>
        /// <param name = "clip"><dd>  <p>The new clip object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>A newly created clip object has a static value of FLT_MAX for the left and top properties, and a static value of ?FLT_MAX for the right and bottom properties, effectively making it a no-op clip object.</p>
        /// </remarks>
        /// <doc-id>dn280360</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateRectangleClip([Out, Fast] IDCompositionRectangleClip** clip)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice2::CreateRectangleClip</unmanaged-short>
        internal unsafe void CreateRectangleClip(SharpDX.DirectComposition.RectangleClip clip)
        {
            System.IntPtr clip_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &clip_, (*(void ***)this._nativePointer)[22]);
            (clip).NativePointer = clip_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates an animation object that is used to animate one or more scalar properties of one or more Microsoft DirectComposition objects. </p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>The new animation object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>A number of DirectComposition object properties can have an animation object as the value of the property. When a property has an animation object as its value, DirectComposition redraws the visual at the refresh rate to reflect the changing value of the property that is being animated.</p><p>A newly created animation object does not have any animation segments associated with it. An application must use the methods of the <strong><see cref = "SharpDX.DirectComposition.Animation"/></strong> interface to build an animation function before setting the animation object as the property of another DirectComposition object.</p>
        /// </remarks>
        /// <doc-id>dn280356</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateAnimation([Out, Fast] IDCompositionAnimation** animation)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice2::CreateAnimation</unmanaged-short>
        internal unsafe void CreateAnimation(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &animation_, (*(void ***)this._nativePointer)[23]);
            (animation).NativePointer = animation_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a 2D transform group object that holds an array of 2D transform objects.</p>
        /// </summary>
        /// <param name = "transforms"><dd>  <p>An array of 2D transform objects that make up this transform group.</p> </dd></param>
        /// <param name = "elements"><dd>  <p>The number of elements in the <em>transforms</em> array.</p> </dd></param>
        /// <param name = "transformGroup"><dd>  <p>The new transform group object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>The array entries in a transform group cannot be changed. However, each transform in the array can be modified through its own property setting methods. If a transform in the array is modified, the change is reflected in the computed matrix of the transform group.</p>
        /// </remarks>
        /// <doc-id>dn280369</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateTransformGroup([In, Buffer] IDCompositionTransform** transforms,[In] unsigned int elements,[Out, Fast] IDCompositionTransform** transformGroup)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice2::CreateTransformGroup</unmanaged-short>
        internal unsafe void CreateTransformGroup(SharpDX.ComArray<SharpDX.DirectComposition.Transform> transforms, System.Int32 elements, SharpDX.DirectComposition.Transform transformGroup)
        {
            System.IntPtr transformGroup_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)(transforms?.NativePointer ?? System.IntPtr.Zero), elements, &transformGroup_, (*(void ***)this._nativePointer)[15]);
            (transformGroup).NativePointer = transformGroup_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a 2D transform group object that holds an array of 2D transform objects.</p>
        /// </summary>
        /// <param name = "transforms"><dd>  <p>An array of 2D transform objects that make up this transform group.</p> </dd></param>
        /// <param name = "elements"><dd>  <p>The number of elements in the <em>transforms</em> array.</p> </dd></param>
        /// <param name = "transformGroup"><dd>  <p>The new transform group object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>The array entries in a transform group cannot be changed. However, each transform in the array can be modified through its own property setting methods. If a transform in the array is modified, the change is reflected in the computed matrix of the transform group.</p>
        /// </remarks>
        /// <doc-id>dn280369</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateTransformGroup([In, Buffer] IDCompositionTransform** transforms,[In] unsigned int elements,[Out, Fast] IDCompositionTransform** transformGroup)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice2::CreateTransformGroup</unmanaged-short>
        private unsafe void CreateTransformGroup(System.IntPtr transforms, System.Int32 elements, System.IntPtr transformGroup)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)transforms, elements, (void *)transformGroup, (*(void ***)this._nativePointer)[15]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a 3D transform group object that holds an array of 3D transform objects.</p>
        /// </summary>
        /// <param name = "transforms3D"><dd>  <p>An array of 3D transform objects that make up this transform group.</p> </dd></param>
        /// <param name = "elements"><dd>  <p>The number of elements in the <em>transforms</em> array.</p> </dd></param>
        /// <param name = "transform3DGroup"><dd>  <p>The new 3D transform group object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>The array entries in a 3D transform group cannot be changed. However, each transform in the array can be modified through its own property setting methods. If a transform in the array is modified, the change is reflected in the computed matrix of the transform group.</p>
        /// </remarks>
        /// <doc-id>dn280368</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateTransform3DGroup([In, Buffer] IDCompositionTransform3D** transforms3D,[In] unsigned int elements,[Out, Fast] IDCompositionTransform3D** transform3DGroup)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice2::CreateTransform3DGroup</unmanaged-short>
        internal unsafe void CreateTransform3DGroup(SharpDX.ComArray<SharpDX.DirectComposition.Transform3D> transforms3D, System.Int32 elements, SharpDX.DirectComposition.Transform3D transform3DGroup)
        {
            System.IntPtr transform3DGroup_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)(transforms3D?.NativePointer ?? System.IntPtr.Zero), elements, &transform3DGroup_, (*(void ***)this._nativePointer)[20]);
            (transform3DGroup).NativePointer = transform3DGroup_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a 3D transform group object that holds an array of 3D transform objects.</p>
        /// </summary>
        /// <param name = "transforms3D"><dd>  <p>An array of 3D transform objects that make up this transform group.</p> </dd></param>
        /// <param name = "elements"><dd>  <p>The number of elements in the <em>transforms</em> array.</p> </dd></param>
        /// <param name = "transform3DGroup"><dd>  <p>The new 3D transform group object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>The array entries in a 3D transform group cannot be changed. However, each transform in the array can be modified through its own property setting methods. If a transform in the array is modified, the change is reflected in the computed matrix of the transform group.</p>
        /// </remarks>
        /// <doc-id>dn280368</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateTransform3DGroup([In, Buffer] IDCompositionTransform3D** transforms3D,[In] unsigned int elements,[Out, Fast] IDCompositionTransform3D** transform3DGroup)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice2::CreateTransform3DGroup</unmanaged-short>
        private unsafe void CreateTransform3DGroup(System.IntPtr transforms3D, System.Int32 elements, System.IntPtr transform3DGroup)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)transforms3D, elements, (void *)transform3DGroup, (*(void ***)this._nativePointer)[20]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("0987CB06-F916-48BF-8D35-CE7641781BD9")]
    public partial class Device3 : SharpDX.DirectComposition.Device2
    {
        public Device3(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Device3(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Device3(nativePtr);
        /// <summary>
        /// <p>Creates an instance of <strong><see cref = "SharpDX.DirectComposition.GaussianBlurEffect"/></strong>.</p>
        /// </summary>
        /// <param name = "gaussianBlurEffect">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn950134</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice3::CreateGaussianBlurEffect([Out, Fast] IDCompositionGaussianBlurEffect** gaussianBlurEffect)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice3::CreateGaussianBlurEffect</unmanaged-short>
        internal unsafe void CreateGaussianBlurEffect(SharpDX.DirectComposition.GaussianBlurEffect gaussianBlurEffect)
        {
            System.IntPtr gaussianBlurEffect_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &gaussianBlurEffect_, (*(void ***)this._nativePointer)[24]);
            (gaussianBlurEffect).NativePointer = gaussianBlurEffect_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates an instance of <strong><see cref = "SharpDX.DirectComposition.BrightnessEffect"/></strong>. </p>
        /// </summary>
        /// <param name = "brightnessEffect">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn950130</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice3::CreateBrightnessEffect([Out, Fast] IDCompositionBrightnessEffect** brightnessEffect)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice3::CreateBrightnessEffect</unmanaged-short>
        internal unsafe void CreateBrightnessEffect(SharpDX.DirectComposition.BrightnessEffect brightnessEffect)
        {
            System.IntPtr brightnessEffect_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &brightnessEffect_, (*(void ***)this._nativePointer)[25]);
            (brightnessEffect).NativePointer = brightnessEffect_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates an instance of <strong><see cref = "SharpDX.DirectComposition.ColorMatrixEffect"/></strong>.</p>
        /// </summary>
        /// <param name = "colorMatrixEffect">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn950131</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice3::CreateColorMatrixEffect([Out, Fast] IDCompositionColorMatrixEffect** colorMatrixEffect)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice3::CreateColorMatrixEffect</unmanaged-short>
        internal unsafe void CreateColorMatrixEffect(SharpDX.DirectComposition.ColorMatrixEffect colorMatrixEffect)
        {
            System.IntPtr colorMatrixEffect_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &colorMatrixEffect_, (*(void ***)this._nativePointer)[26]);
            (colorMatrixEffect).NativePointer = colorMatrixEffect_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates an instance of <strong><see cref = "SharpDX.DirectComposition.ShadowEffect"/></strong>. </p>
        /// </summary>
        /// <param name = "shadowEffect">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn950138</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice3::CreateShadowEffect([Out, Fast] IDCompositionShadowEffect** shadowEffect)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice3::CreateShadowEffect</unmanaged-short>
        internal unsafe void CreateShadowEffect(SharpDX.DirectComposition.ShadowEffect shadowEffect)
        {
            System.IntPtr shadowEffect_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &shadowEffect_, (*(void ***)this._nativePointer)[27]);
            (shadowEffect).NativePointer = shadowEffect_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates an instance of <strong><see cref = "SharpDX.DirectComposition.HueRotationEffect"/></strong>. </p>
        /// </summary>
        /// <param name = "hueRotationEffect">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn950135</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice3::CreateHueRotationEffect([Out, Fast] IDCompositionHueRotationEffect** hueRotationEffect)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice3::CreateHueRotationEffect</unmanaged-short>
        internal unsafe void CreateHueRotationEffect(SharpDX.DirectComposition.HueRotationEffect hueRotationEffect)
        {
            System.IntPtr hueRotationEffect_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &hueRotationEffect_, (*(void ***)this._nativePointer)[28]);
            (hueRotationEffect).NativePointer = hueRotationEffect_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates an instance of <strong><see cref = "SharpDX.DirectComposition.SaturationEffect"/></strong>. </p>
        /// </summary>
        /// <param name = "saturationEffect">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn950137</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice3::CreateSaturationEffect([Out, Fast] IDCompositionSaturationEffect** saturationEffect)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice3::CreateSaturationEffect</unmanaged-short>
        internal unsafe void CreateSaturationEffect(SharpDX.DirectComposition.SaturationEffect saturationEffect)
        {
            System.IntPtr saturationEffect_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &saturationEffect_, (*(void ***)this._nativePointer)[29]);
            (saturationEffect).NativePointer = saturationEffect_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates an instance of <strong><see cref = "SharpDX.DirectComposition.TurbulenceEffect"/></strong>. </p>
        /// </summary>
        /// <param name = "turbulenceEffect">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn950140</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice3::CreateTurbulenceEffect([Out, Fast] IDCompositionTurbulenceEffect** turbulenceEffect)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice3::CreateTurbulenceEffect</unmanaged-short>
        internal unsafe void CreateTurbulenceEffect(SharpDX.DirectComposition.TurbulenceEffect turbulenceEffect)
        {
            System.IntPtr turbulenceEffect_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &turbulenceEffect_, (*(void ***)this._nativePointer)[30]);
            (turbulenceEffect).NativePointer = turbulenceEffect_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates an instance of <strong><see cref = "SharpDX.DirectComposition.LinearTransferEffect"/></strong>. </p>
        /// </summary>
        /// <param name = "linearTransferEffect">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn950136</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice3::CreateLinearTransferEffect([Out, Fast] IDCompositionLinearTransferEffect** linearTransferEffect)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice3::CreateLinearTransferEffect</unmanaged-short>
        internal unsafe void CreateLinearTransferEffect(SharpDX.DirectComposition.LinearTransferEffect linearTransferEffect)
        {
            System.IntPtr linearTransferEffect_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &linearTransferEffect_, (*(void ***)this._nativePointer)[31]);
            (linearTransferEffect).NativePointer = linearTransferEffect_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates an instance of <strong><see cref = "SharpDX.DirectComposition.TableTransferEffect"/></strong>. </p>
        /// </summary>
        /// <param name = "tableTransferEffect">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn950139</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice3::CreateTableTransferEffect([Out, Fast] IDCompositionTableTransferEffect** tableTransferEffect)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice3::CreateTableTransferEffect</unmanaged-short>
        internal unsafe void CreateTableTransferEffect(SharpDX.DirectComposition.TableTransferEffect tableTransferEffect)
        {
            System.IntPtr tableTransferEffect_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &tableTransferEffect_, (*(void ***)this._nativePointer)[32]);
            (tableTransferEffect).NativePointer = tableTransferEffect_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates an instance of <strong><see cref = "SharpDX.DirectComposition.CompositeEffect"/></strong>. </p>
        /// </summary>
        /// <param name = "compositeEffect">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn950132</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice3::CreateCompositeEffect([Out, Fast] IDCompositionCompositeEffect** compositeEffect)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice3::CreateCompositeEffect</unmanaged-short>
        internal unsafe void CreateCompositeEffect(SharpDX.DirectComposition.CompositeEffect compositeEffect)
        {
            System.IntPtr compositeEffect_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &compositeEffect_, (*(void ***)this._nativePointer)[33]);
            (compositeEffect).NativePointer = compositeEffect_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates an instance of <strong><see cref = "SharpDX.DirectComposition.BlendEffect"/></strong>.</p>
        /// </summary>
        /// <param name = "blendEffect">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn950129</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice3::CreateBlendEffect([Out, Fast] IDCompositionBlendEffect** blendEffect)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice3::CreateBlendEffect</unmanaged-short>
        internal unsafe void CreateBlendEffect(SharpDX.DirectComposition.BlendEffect blendEffect)
        {
            System.IntPtr blendEffect_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &blendEffect_, (*(void ***)this._nativePointer)[34]);
            (blendEffect).NativePointer = blendEffect_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates an instance of <strong><see cref = "SharpDX.DirectComposition.ArithmeticCompositeEffect"/></strong>.</p>
        /// </summary>
        /// <param name = "arithmeticCompositeEffect">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn950128</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice3::CreateArithmeticCompositeEffect([Out, Fast] IDCompositionArithmeticCompositeEffect** arithmeticCompositeEffect)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice3::CreateArithmeticCompositeEffect</unmanaged-short>
        internal unsafe void CreateArithmeticCompositeEffect(SharpDX.DirectComposition.ArithmeticCompositeEffect arithmeticCompositeEffect)
        {
            System.IntPtr arithmeticCompositeEffect_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &arithmeticCompositeEffect_, (*(void ***)this._nativePointer)[35]);
            (arithmeticCompositeEffect).NativePointer = arithmeticCompositeEffect_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates an instance of <strong><see cref = "SharpDX.DirectComposition.AffineTransform2DEffect"/></strong>.</p>
        /// </summary>
        /// <param name = "affineTransform2dEffect">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn950127</doc-id>
        /// <unmanaged>HRESULT IDCompositionDevice3::CreateAffineTransform2DEffect([Out, Fast] IDCompositionAffineTransform2DEffect** affineTransform2dEffect)</unmanaged>
        /// <unmanaged-short>IDCompositionDevice3::CreateAffineTransform2DEffect</unmanaged-short>
        internal unsafe void CreateAffineTransform2DEffect(SharpDX.DirectComposition.AffineTransform2DEffect affineTransform2dEffect)
        {
            System.IntPtr affineTransform2dEffect_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &affineTransform2dEffect_, (*(void ***)this._nativePointer)[36]);
            (affineTransform2dEffect).NativePointer = affineTransform2dEffect_;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("A1A3C64A-224F-4A81-9773-4F03A89D3C6C")]
    public partial class DeviceDebug : SharpDX.ComObject
    {
        public DeviceDebug(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DeviceDebug(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DeviceDebug(nativePtr);
        /// <summary>
        /// <p>Enables display of performance debugging counters.</p>
        /// </summary>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Performance counters are displayed on the top-right corner of the screen. From left to right, Microsoft DirectComposition displays the following information: </p><ul> <li>The composition engine frame rate, in frames per second, averaged over the last 60 composition frames</li> <li>The overall CPU usage of the composition thread, in milliseconds
        /// </li> </ul><p>The DirectComposition composition engine operates on the entire desktop all at once, so the performance counters measure the total cost of desktop composition, not just the cost of any one particular application. If the application occupies the entire screen, however, it is reasonable to assume that all of the composition cost is due to that one application.
        /// </p>
        /// </remarks>
        /// <doc-id>dn280380</doc-id>
        /// <unmanaged>HRESULT IDCompositionDeviceDebug::EnableDebugCounters()</unmanaged>
        /// <unmanaged-short>IDCompositionDeviceDebug::EnableDebugCounters</unmanaged-short>
        public unsafe void EnableDebugCounters()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Disables display of performance debugging counters.</p>
        /// </summary>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Microsoft DirectComposition keeps a count of how many DirectComposition devices have performance counters enabled, for the entire desktop session. If the count is non-zero, the performance counters are displayed. Therefore, disabling the counters may not make them go away if another device is also requesting display of the counters.</p>
        /// </remarks>
        /// <doc-id>dn280379</doc-id>
        /// <unmanaged>HRESULT IDCompositionDeviceDebug::DisableDebugCounters()</unmanaged>
        /// <unmanaged-short>IDCompositionDeviceDebug::DisableDebugCounters</unmanaged-short>
        public unsafe void DisableDebugCounters()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("EC81B08F-BFCB-4e8d-B193-A915587999E8")]
    public partial class Effect : SharpDX.ComObject
    {
        public Effect(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Effect(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Effect(nativePtr);
    }

    [System.Runtime.InteropServices.GuidAttribute("A7929A74-E6B2-4bd6-8B95-4040119CA34D")]
    public partial class EffectGroup : SharpDX.DirectComposition.Effect
    {
        public EffectGroup(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator EffectGroup(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new EffectGroup(nativePtr);
        /// <summary>
        /// <p>Sets the 3D transformation effect object that modifies the rasterization of the visuals that this effect group is applied to.</p>
        /// </summary>
        /// <remarks>
        /// <p>This method fails if <em>transform3D</em> is an invalid reference, or if the reference was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface as this effect group. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method. </p><p>If the <em>transform3D</em> parameter is <c>null</c>, the effect group does not apply any perspective transformations to the visuals. Setting the transform to <c>null</c> is equivalent to setting the transform to an <strong><see cref = "SharpDX.DirectComposition.MatrixTransform3D"/></strong> object where the specified matrix is the identity matrix. However, an application should use a <c>null</c> transform whenever possible because it is slightly faster.  </p>
        /// </remarks>
        /// <doc-id>hh437423</doc-id>
        /// <unmanaged>SetTransform3D</unmanaged>
        /// <unmanaged-short>SetTransform3D</unmanaged-short>
        public SharpDX.DirectComposition.Transform3D Transform3D
        {
            set => SetTransform3D(value);
        }

        /// <summary>
        /// <p>Changes the value of the Opacity property.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>The new value of the Opacity property.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>The opacity is interpreted as completely transparent for all values less than or equal to 0, and as completely opaque for all values greater than or equal to 1. All values between 0 and 1 represent partial opacity. </p><p>This method fails if the <em>opacity</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the Opacity property was previously animated, this method removes the animation and sets the Opacity property to the specified static value.
        /// </p>
        /// </remarks>
        /// <doc-id>hh437420</doc-id>
        /// <unmanaged>HRESULT IDCompositionEffectGroup::SetOpacity([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionEffectGroup::SetOpacity</unmanaged-short>
        public unsafe void SetOpacity(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of the Opacity property.</p>
        /// </summary>
        /// <param name = "opacity"><dd>  <p>The new value of the Opacity property.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>The opacity is interpreted as completely transparent for all values less than or equal to 0, and as completely opaque for all values greater than or equal to 1. All values between 0 and 1 represent partial opacity. </p><p>This method fails if the <em>opacity</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the Opacity property was previously animated, this method removes the animation and sets the Opacity property to the specified static value.
        /// </p>
        /// </remarks>
        /// <doc-id>hh437420</doc-id>
        /// <unmanaged>HRESULT IDCompositionEffectGroup::SetOpacity([In] float opacity)</unmanaged>
        /// <unmanaged-short>IDCompositionEffectGroup::SetOpacity</unmanaged-short>
        public unsafe void SetOpacity(System.Single opacity)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, opacity, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the 3D transformation effect object that modifies the rasterization of the visuals that this effect group is applied to.</p>
        /// </summary>
        /// <param name = "transform3D"><dd>  <p>Pointer to an <strong><see cref = "SharpDX.DirectComposition.Transform3D"/></strong> interface or one of its derived interfaces. This parameter can be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method fails if <em>transform3D</em> is an invalid reference, or if the reference was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface as this effect group. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method. </p><p>If the <em>transform3D</em> parameter is <c>null</c>, the effect group does not apply any perspective transformations to the visuals. Setting the transform to <c>null</c> is equivalent to setting the transform to an <strong><see cref = "SharpDX.DirectComposition.MatrixTransform3D"/></strong> object where the specified matrix is the identity matrix. However, an application should use a <c>null</c> transform whenever possible because it is slightly faster.  </p>
        /// </remarks>
        /// <doc-id>hh437423</doc-id>
        /// <unmanaged>HRESULT IDCompositionEffectGroup::SetTransform3D([In, Optional] IDCompositionTransform3D* transform3D)</unmanaged>
        /// <unmanaged-short>IDCompositionEffectGroup::SetTransform3D</unmanaged-short>
        internal unsafe void SetTransform3D(SharpDX.DirectComposition.Transform3D transform3D)
        {
            System.IntPtr transform3D_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            transform3D_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Transform3D>(transform3D);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)transform3D_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("30C421D5-8CB2-4E9F-B133-37BE270D4AC2")]
    public partial class FilterEffect : SharpDX.DirectComposition.Effect
    {
        public FilterEffect(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator FilterEffect(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new FilterEffect(nativePtr);
        /// <summary>
        /// <p>Sets the the input at an index to the specified filter effect.</p>
        /// </summary>
        /// <param name = "index"><dd>  <p>Specifies the index the to apply the filter effect at.</p> </dd></param>
        /// <param name = "input"><dd>  <p>The filter effect to apply. The following effects are available: </p> <ul> <li> <strong><see cref = "SharpDX.DirectComposition.AffineTransform2DEffect"/></strong> </li> <li> <strong><see cref = "SharpDX.DirectComposition.ArithmeticCompositeEffect"/></strong> </li> <li> <strong><see cref = "SharpDX.DirectComposition.BlendEffect"/></strong> </li> <li> <strong><see cref = "SharpDX.DirectComposition.BrightnessEffect"/></strong> </li> <li> <strong>IDCompositionColorNatrixEffect</strong> </li> <li> <strong><see cref = "SharpDX.DirectComposition.CompositeEffect"/></strong> </li> <li> <strong>IDCompositionFloodEffect</strong> </li> <li> <strong><see cref = "SharpDX.DirectComposition.GaussianBlurEffect"/></strong> </li> <li> <strong><see cref = "SharpDX.DirectComposition.HueRotationEffect"/></strong> </li> <li> <strong>IDCompositionLinearTransferRffect</strong> </li> <li> <strong>IDCompositionSaturationRffect</strong> </li> <li> <strong><see cref = "SharpDX.DirectComposition.ShadowEffect"/></strong> </li> <li> <strong><see cref = "SharpDX.DirectComposition.TableTransferEffect"/></strong> </li> <li> <strong><see cref = "SharpDX.DirectComposition.TurbulenceEffect"/></strong> </li> </ul> </dd></param>
        /// <param name = "flags"><dd>  <p>Flags to apply to the filter effect.  </p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919731</doc-id>
        /// <unmanaged>HRESULT IDCompositionFilterEffect::SetInput([In] unsigned int index,[In, Optional] IUnknown* input,[In] unsigned int flags)</unmanaged>
        /// <unmanaged-short>IDCompositionFilterEffect::SetInput</unmanaged-short>
        public unsafe void SetInput(System.Int32 index, SharpDX.IUnknown input, System.Int32 flags)
        {
            System.IntPtr input_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            input_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(input);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, index, (void *)input_, flags, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("45D4D0B7-1BD4-454E-8894-2BFA68443033")]
    public partial class GaussianBlurEffect : SharpDX.DirectComposition.FilterEffect
    {
        public GaussianBlurEffect(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator GaussianBlurEffect(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new GaussianBlurEffect(nativePtr);
        /// <summary>
        /// <p>Sets the mode used to calculate the border of the image.</p>
        /// </summary>
        /// <doc-id>dn919735</doc-id>
        /// <unmanaged>SetBorderMode</unmanaged>
        /// <unmanaged-short>SetBorderMode</unmanaged-short>
        public SharpDX.Direct2D1.BorderMode BorderMode
        {
            set => SetBorderMode(value);
        }

        /// <summary>
        /// <p>Sets the amount of blur to be applied to the image.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p> The amount of blur to be applied to the image. You can compute the blur radius of the kernel by multiplying the standard deviation by 3. The units of both the standard deviation and blur radius are DIPs. A value of zero DIPs disables this effect entirely. </p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919736</doc-id>
        /// <unmanaged>HRESULT IDCompositionGaussianBlurEffect::SetStandardDeviation([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionGaussianBlurEffect::SetStandardDeviation</unmanaged-short>
        public unsafe void SetStandardDeviation(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the amount of blur to be applied to the image.</p>
        /// </summary>
        /// <param name = "amount"><dd>  <p> The amount of blur to be applied to the image. You can compute the blur radius of the kernel by multiplying the standard deviation by 3. The units of both the standard deviation and blur radius are DIPs. A value of zero DIPs disables this effect entirely. </p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919736</doc-id>
        /// <unmanaged>HRESULT IDCompositionGaussianBlurEffect::SetStandardDeviation([In] float amount)</unmanaged>
        /// <unmanaged-short>IDCompositionGaussianBlurEffect::SetStandardDeviation</unmanaged-short>
        public unsafe void SetStandardDeviation(System.Single amount)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, amount, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the mode used to calculate the border of the image.</p>
        /// </summary>
        /// <param name = "mode"><dd>  <p>The mode used to calculate the border of the image.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919735</doc-id>
        /// <unmanaged>HRESULT IDCompositionGaussianBlurEffect::SetBorderMode([In] D2D1_BORDER_MODE mode)</unmanaged>
        /// <unmanaged-short>IDCompositionGaussianBlurEffect::SetBorderMode</unmanaged-short>
        internal unsafe void SetBorderMode(SharpDX.Direct2D1.BorderMode mode)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)mode), (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("6DB9F920-0770-4781-B0C6-381912F9D167")]
    public partial class HueRotationEffect : SharpDX.DirectComposition.FilterEffect
    {
        public HueRotationEffect(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator HueRotationEffect(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new HueRotationEffect(nativePtr);
        /// <summary>
        /// <p>Sets the angle to rotate the hue.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>An animation that represents how the angle value changes over time.  The effect calculates a color matrix based on the rotation angle (?) according to the following matrix equations: </p><p> This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919740</doc-id>
        /// <unmanaged>HRESULT IDCompositionHueRotationEffect::SetAngle([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionHueRotationEffect::SetAngle</unmanaged-short>
        public unsafe void SetAngle(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the angle to rotate the hue.</p>
        /// </summary>
        /// <param name = "amountDegrees"><dd>  <p>An animation that represents how the angle value changes over time.  The effect calculates a color matrix based on the rotation angle (?) according to the following matrix equations: </p><p> This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919740</doc-id>
        /// <unmanaged>HRESULT IDCompositionHueRotationEffect::SetAngle([In] float amountDegrees)</unmanaged>
        /// <unmanaged-short>IDCompositionHueRotationEffect::SetAngle</unmanaged-short>
        public unsafe void SetAngle(System.Single amountDegrees)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, amountDegrees, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("4305EE5B-C4A0-4C88-9385-67124E017683")]
    public partial class LinearTransferEffect : SharpDX.DirectComposition.FilterEffect
    {
        public LinearTransferEffect(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator LinearTransferEffect(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new LinearTransferEffect(nativePtr);
        /// <summary>
        /// <p>Specifies whether to apply the transfer function to the red channel.</p>
        /// </summary>
        /// <doc-id>dn919758</doc-id>
        /// <unmanaged>SetRedDisable</unmanaged>
        /// <unmanaged-short>SetRedDisable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool RedDisable
        {
            set => SetRedDisable(value);
        }

        /// <summary>
        /// <p>Specifies whether to apply the transfer function to the green channel.</p>
        /// </summary>
        /// <doc-id>dn919753</doc-id>
        /// <unmanaged>SetGreenDisable</unmanaged>
        /// <unmanaged-short>SetGreenDisable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool GreenDisable
        {
            set => SetGreenDisable(value);
        }

        /// <summary>
        /// <p>Specifies whether to apply the transfer function to the blue channel.</p>
        /// </summary>
        /// <doc-id>dn919747</doc-id>
        /// <unmanaged>SetBlueDisable</unmanaged>
        /// <unmanaged-short>SetBlueDisable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool BlueDisable
        {
            set => SetBlueDisable(value);
        }

        /// <summary>
        /// <p>Specifies whether to apply the transfer function to the alpha channel.</p>
        /// </summary>
        /// <doc-id>dn919742</doc-id>
        /// <unmanaged>SetAlphaDisable</unmanaged>
        /// <unmanaged-short>SetAlphaDisable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool AlphaDisable
        {
            set => SetAlphaDisable(value);
        }

        /// <summary>
        /// <p>Specifies whether the effect clamps color values to between 0 and 1 before the effect passes the values to the next effect in the graph.</p>
        /// </summary>
        /// <doc-id>dn919752</doc-id>
        /// <unmanaged>SetClampOutput</unmanaged>
        /// <unmanaged-short>SetClampOutput</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool ClampOutput
        {
            set => SetClampOutput(value);
        }

        /// <summary>
        /// <p>Sets the Y-intercept of the linear function for the red channel.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>The Y-intercept of the linear function for the red channel.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919761</doc-id>
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetRedYIntercept([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetRedYIntercept</unmanaged-short>
        public unsafe void SetRedYIntercept(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the Y-intercept of the linear function for the red channel.</p>
        /// </summary>
        /// <param name = "redYIntercept"><dd>  <p>The Y-intercept of the linear function for the red channel.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919761</doc-id>
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetRedYIntercept([In] float redYIntercept)</unmanaged>
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetRedYIntercept</unmanaged-short>
        public unsafe void SetRedYIntercept(System.Single redYIntercept)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, redYIntercept, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the slope of the linear function for the red channel.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>An animation that represents how the slope of the linear function for the red channel changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919760</doc-id>
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetRedSlope([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetRedSlope</unmanaged-short>
        public unsafe void SetRedSlope(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the slope of the linear function for the red channel.</p>
        /// </summary>
        /// <param name = "redSlope"><dd>  <p>An animation that represents how the slope of the linear function for the red channel changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919760</doc-id>
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetRedSlope([In] float redSlope)</unmanaged>
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetRedSlope</unmanaged-short>
        public unsafe void SetRedSlope(System.Single redSlope)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, redSlope, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Specifies whether to apply the transfer function to the red channel.</p>
        /// </summary>
        /// <param name = "redDisable"><dd>  <p> A boolean value that specifies whether to apply the transfer function to the red channel. If you set this to TRUE the effect does not apply the transfer function to the red channel. If you set this to <see cref = "SharpDX.Result.False"/> the effect applies the RedLinearTransfer function to the red channel. </p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919758</doc-id>
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetRedDisable([In] BOOL redDisable)</unmanaged>
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetRedDisable</unmanaged-short>
        internal unsafe void SetRedDisable(SharpDX.Mathematics.Interop.RawBool redDisable)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint0(this._nativePointer, redDisable, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the Y-intercept of the linear function for the green channel.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>An animation that represents how the Y-intercept of the linear function for the green channel changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919757</doc-id>
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetGreenYIntercept([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetGreenYIntercept</unmanaged-short>
        public unsafe void SetGreenYIntercept(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the Y-intercept of the linear function for the green channel.</p>
        /// </summary>
        /// <param name = "greenYIntercept"><dd>  <p>An animation that represents how the Y-intercept of the linear function for the green channel changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919757</doc-id>
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetGreenYIntercept([In] float greenYIntercept)</unmanaged>
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetGreenYIntercept</unmanaged-short>
        public unsafe void SetGreenYIntercept(System.Single greenYIntercept)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, greenYIntercept, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the slope of the linear function for the green channel.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>The slope of the linear function for the green channel.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919754</doc-id>
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetGreenSlope([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetGreenSlope</unmanaged-short>
        public unsafe void SetGreenSlope(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the slope of the linear function for the green channel.</p>
        /// </summary>
        /// <param name = "greenSlope"><dd>  <p>The slope of the linear function for the green channel.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919754</doc-id>
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetGreenSlope([In] float greenSlope)</unmanaged>
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetGreenSlope</unmanaged-short>
        public unsafe void SetGreenSlope(System.Single greenSlope)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, greenSlope, (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Specifies whether to apply the transfer function to the green channel.</p>
        /// </summary>
        /// <param name = "greenDisable"><dd>  <p> A boolean value that specifies whether to apply the transfer function to the green channel. If you set this to TRUE the effect does not apply the transfer function to the green channel. If you set this to <see cref = "SharpDX.Result.False"/> it applies the GreenLinearTransfer function to the green channel. </p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919753</doc-id>
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetGreenDisable([In] BOOL greenDisable)</unmanaged>
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetGreenDisable</unmanaged-short>
        internal unsafe void SetGreenDisable(SharpDX.Mathematics.Interop.RawBool greenDisable)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint0(this._nativePointer, greenDisable, (*(void ***)this._nativePointer)[13]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the Y-intercept of the linear function for the blue channel. </p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>An animation that represents how the Y-intercept of the linear function for the blue channel changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919751</doc-id>
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetBlueYIntercept([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetBlueYIntercept</unmanaged-short>
        public unsafe void SetBlueYIntercept(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[14]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the Y-intercept of the linear function for the blue channel. </p>
        /// </summary>
        /// <param name = "blueYIntercept"><dd>  <p>An animation that represents how the Y-intercept of the linear function for the blue channel changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919751</doc-id>
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetBlueYIntercept([In] float blueYIntercept)</unmanaged>
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetBlueYIntercept</unmanaged-short>
        public unsafe void SetBlueYIntercept(System.Single blueYIntercept)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, blueYIntercept, (*(void ***)this._nativePointer)[15]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the slope of the linear function for the blue channel.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>An animation that represents how the slope of the linear function for the blue channel changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919749</doc-id>
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetBlueSlope([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetBlueSlope</unmanaged-short>
        public unsafe void SetBlueSlope(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[16]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the slope of the linear function for the blue channel.</p>
        /// </summary>
        /// <param name = "blueSlope"><dd>  <p>An animation that represents how the slope of the linear function for the blue channel changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919749</doc-id>
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetBlueSlope([In] float blueSlope)</unmanaged>
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetBlueSlope</unmanaged-short>
        public unsafe void SetBlueSlope(System.Single blueSlope)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, blueSlope, (*(void ***)this._nativePointer)[17]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Specifies whether to apply the transfer function to the blue channel.</p>
        /// </summary>
        /// <param name = "blueDisable"><dd>  <p> A boolean value that specifies whether to apply the transfer function to the blue channel. If you set this to TRUE the effect does not apply the transfer function to the blue channel. If you set this to <see cref = "SharpDX.Result.False"/> it applies the BlueLinearTransfer function to the blue channel. </p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919747</doc-id>
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetBlueDisable([In] BOOL blueDisable)</unmanaged>
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetBlueDisable</unmanaged-short>
        internal unsafe void SetBlueDisable(SharpDX.Mathematics.Interop.RawBool blueDisable)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint0(this._nativePointer, blueDisable, (*(void ***)this._nativePointer)[18]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the Y-intercept of the linear function for the Alpha channel.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>An animation that represents how the the Y-intercept of the linear function for the alpha channel. changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919746</doc-id>
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetAlphaYIntercept([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetAlphaYIntercept</unmanaged-short>
        public unsafe void SetAlphaYIntercept(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[19]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the Y-intercept of the linear function for the Alpha channel.</p>
        /// </summary>
        /// <param name = "alphaYIntercept"><dd>  <p>An animation that represents how the the Y-intercept of the linear function for the alpha channel. changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919746</doc-id>
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetAlphaYIntercept([In] float alphaYIntercept)</unmanaged>
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetAlphaYIntercept</unmanaged-short>
        public unsafe void SetAlphaYIntercept(System.Single alphaYIntercept)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, alphaYIntercept, (*(void ***)this._nativePointer)[20]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the slope of the linear function for the alpha channel.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>An animation that represents how the slope of the linear function for the alpha channel changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919744</doc-id>
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetAlphaSlope([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetAlphaSlope</unmanaged-short>
        public unsafe void SetAlphaSlope(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[21]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the slope of the linear function for the alpha channel.</p>
        /// </summary>
        /// <param name = "alphaSlope"><dd>  <p>An animation that represents how the slope of the linear function for the alpha channel changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919744</doc-id>
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetAlphaSlope([In] float alphaSlope)</unmanaged>
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetAlphaSlope</unmanaged-short>
        public unsafe void SetAlphaSlope(System.Single alphaSlope)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, alphaSlope, (*(void ***)this._nativePointer)[22]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Specifies whether to apply the transfer function to the alpha channel.</p>
        /// </summary>
        /// <param name = "alphaDisable"><dd>  <p> A boolean value that specifies whether to apply the transfer function to the alpha channel. If you set this to TRUE the effect does not apply the transfer function to the Alpha channel. If you set this to <see cref = "SharpDX.Result.False"/> it applies the AlphaLinearTransfer function to the Alpha channel. </p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919742</doc-id>
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetAlphaDisable([In] BOOL alphaDisable)</unmanaged>
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetAlphaDisable</unmanaged-short>
        internal unsafe void SetAlphaDisable(SharpDX.Mathematics.Interop.RawBool alphaDisable)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint0(this._nativePointer, alphaDisable, (*(void ***)this._nativePointer)[23]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Specifies whether the effect clamps color values to between 0 and 1 before the effect passes the values to the next effect in the graph.</p>
        /// </summary>
        /// <param name = "clampOutput"><dd>  <p> A boolean value that specifies whether the effect clamps color values to between 0 and 1 before the effect passes the values to the next effect in the graph. If you set this to TRUE the effect will clamp the values. If you set this to <see cref = "SharpDX.Result.False"/>, the effect will not clamp the color values, but other effects and the output surface may clamp the values if they are not of high enough precision. </p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919752</doc-id>
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetClampOutput([In] BOOL clampOutput)</unmanaged>
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetClampOutput</unmanaged-short>
        internal unsafe void SetClampOutput(SharpDX.Mathematics.Interop.RawBool clampOutput)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint0(this._nativePointer, clampOutput, (*(void ***)this._nativePointer)[24]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("16CDFF07-C503-419c-83F2-0965C7AF1FA6")]
    public partial class MatrixTransform : SharpDX.DirectComposition.Transform
    {
        public MatrixTransform(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator MatrixTransform(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new MatrixTransform(nativePtr);
        /// <summary>
        /// <p>Changes all values of the matrix of this 2D transform.</p>
        /// </summary>
        /// <param name = "matrix"><dd>  <p>The new matrix for this 2D transform.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method fails if any of the matrix values are NaN, positive infinity, or negative infinity.</p><p>If any of the matrix elements were previously animated, this method removes the animations and sets the elements to the specified static value.</p>
        /// </remarks>
        /// <doc-id>hh437430</doc-id>
        /// <unmanaged>HRESULT IDCompositionMatrixTransform::SetMatrix([In] const D2D_MATRIX_3X2_F&amp; matrix)</unmanaged>
        /// <unmanaged-short>IDCompositionMatrixTransform::SetMatrix</unmanaged-short>
        public unsafe void SetMatrix(ref SharpDX.Mathematics.Interop.RawMatrix3x2 matrix)
        {
            SharpDX.Result __result__;
            fixed (void *matrix_ = &matrix)
                __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, matrix_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Animates the value of one element of the matrix of this 2D transform.</p>
        /// </summary>
        /// <param name = "row"><dd> <p>The row index of the element to change. This value must be between 0 and 2, inclusive.</p> </dd></param>
        /// <param name = "column"><dd> <p>The column index of the element to change. This value must be between 0 and 1, inclusive.</p> </dd></param>
        /// <param name = "animation"><dd> <p>An animation that represents how the value of the specified element changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the element unless this method is called again. If the element was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface as the affected transform. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.
        /// </p>
        /// </remarks>
        /// <doc-id>hh437432</doc-id>
        /// <unmanaged>HRESULT IDCompositionMatrixTransform::SetMatrixElement([In] int row,[In] int column,[In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionMatrixTransform::SetMatrixElement</unmanaged-short>
        public unsafe void SetMatrixElement(System.Int32 row, System.Int32 column, SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, row, column, (void *)animation_, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Animates the value of one element of the matrix of this 2D transform.</p>
        /// </summary>
        /// <param name = "row"><dd> <p>The row index of the element to change. This value must be between 0 and 2, inclusive.</p> </dd></param>
        /// <param name = "column"><dd> <p>The column index of the element to change. This value must be between 0 and 1, inclusive.</p> </dd></param>
        /// <param name = "value"><dd> <p>An animation that represents how the value of the specified element changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the element unless this method is called again. If the element was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface as the affected transform. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.
        /// </p>
        /// </remarks>
        /// <doc-id>hh437432</doc-id>
        /// <unmanaged>HRESULT IDCompositionMatrixTransform::SetMatrixElement([In] int row,[In] int column,[In] float value)</unmanaged>
        /// <unmanaged-short>IDCompositionMatrixTransform::SetMatrixElement</unmanaged-short>
        public unsafe void SetMatrixElement(System.Int32 row, System.Int32 column, System.Single value)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, row, column, value, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("4B3363F0-643B-41b7-B6E0-CCF22D34467C")]
    public partial class MatrixTransform3D : SharpDX.DirectComposition.Transform3D
    {
        public MatrixTransform3D(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator MatrixTransform3D(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new MatrixTransform3D(nativePtr);
        /// <summary>
        /// <p>Changes all values of the matrix of this 3D transformation effect.</p>
        /// </summary>
        /// <param name = "matrix"><dd>  <p>The new matrix for this 3D transformation effect.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method fails if any of the matrix values are NaN, positive infinity, or negative infinity.</p><p>If any of the matrix elements were previously animated, this method removes the animations and sets the elements to the specified static value.</p>
        /// </remarks>
        /// <doc-id>hh437426</doc-id>
        /// <unmanaged>HRESULT IDCompositionMatrixTransform3D::SetMatrix([In] const D3DMATRIX&amp; matrix)</unmanaged>
        /// <unmanaged-short>IDCompositionMatrixTransform3D::SetMatrix</unmanaged-short>
        public unsafe void SetMatrix(ref SharpDX.Mathematics.Interop.RawMatrix matrix)
        {
            SharpDX.Result __result__;
            fixed (void *matrix_ = &matrix)
                __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, matrix_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of one element of the matrix of this 3D transform.</p>
        /// </summary>
        /// <param name = "row"><dd>  <p>The row index of the element to change. This value must be between 0 and 3, inclusive.</p> </dd></param>
        /// <param name = "column"><dd>  <p>The column index of the element to change. This value must be between 0 and 3, inclusive.</p> </dd></param>
        /// <param name = "animation"><dd>  <p>The new value of the specified element.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method fails if the <em>value</em> parameter is NaN, positive infinity, or negative infinity.</p><p>If the specified element was previously animated, this method removes the animation and sets the element to the specified static value.</p>
        /// </remarks>
        /// <doc-id>hh437427</doc-id>
        /// <unmanaged>HRESULT IDCompositionMatrixTransform3D::SetMatrixElement([In] int row,[In] int column,[In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionMatrixTransform3D::SetMatrixElement</unmanaged-short>
        public unsafe void SetMatrixElement(System.Int32 row, System.Int32 column, SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, row, column, (void *)animation_, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of one element of the matrix of this 3D transform.</p>
        /// </summary>
        /// <param name = "row"><dd>  <p>The row index of the element to change. This value must be between 0 and 3, inclusive.</p> </dd></param>
        /// <param name = "column"><dd>  <p>The column index of the element to change. This value must be between 0 and 3, inclusive.</p> </dd></param>
        /// <param name = "value"><dd>  <p>The new value of the specified element.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method fails if the <em>value</em> parameter is NaN, positive infinity, or negative infinity.</p><p>If the specified element was previously animated, this method removes the animation and sets the element to the specified static value.</p>
        /// </remarks>
        /// <doc-id>hh437427</doc-id>
        /// <unmanaged>HRESULT IDCompositionMatrixTransform3D::SetMatrixElement([In] int row,[In] int column,[In] float value)</unmanaged>
        /// <unmanaged-short>IDCompositionMatrixTransform3D::SetMatrixElement</unmanaged-short>
        public unsafe void SetMatrixElement(System.Int32 row, System.Int32 column, System.Single value)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, row, column, value, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("9842AD7D-D9CF-4908-AED7-48B51DA5E7C2")]
    public partial class RectangleClip : SharpDX.DirectComposition.Clip
    {
        public RectangleClip(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator RectangleClip(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new RectangleClip(nativePtr);
        /// <summary>
        /// <p>Animates the value of the Left property of a clip rectangle. The Left property specifies the x-coordinate of the upper-left corner of the clip rectangle.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>An animation object that determines how the value of the Left property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the Left property unless this method is called again. If the Left  property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.
        /// </p>
        /// </remarks>
        /// <doc-id>hh448901</doc-id>
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetLeft([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionRectangleClip::SetLeft</unmanaged-short>
        public unsafe void SetLeft(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Animates the value of the Left property of a clip rectangle. The Left property specifies the x-coordinate of the upper-left corner of the clip rectangle.</p>
        /// </summary>
        /// <param name = "left"><dd>  <p>An animation object that determines how the value of the Left property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the Left property unless this method is called again. If the Left  property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.
        /// </p>
        /// </remarks>
        /// <doc-id>hh448901</doc-id>
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetLeft([In] float left)</unmanaged>
        /// <unmanaged-short>IDCompositionRectangleClip::SetLeft</unmanaged-short>
        public unsafe void SetLeft(System.Single left)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, left, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Animates the value of the Top property of a clip rectangle. The Top property specifies the y-coordinate of the upper-left corner of the clip rectangle.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>An animation object that determines how the value of the Top property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the Top property unless this method is called again. If the Top  property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.
        /// </p>
        /// </remarks>
        /// <doc-id>hh448922</doc-id>
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetTop([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionRectangleClip::SetTop</unmanaged-short>
        public unsafe void SetTop(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Animates the value of the Top property of a clip rectangle. The Top property specifies the y-coordinate of the upper-left corner of the clip rectangle.</p>
        /// </summary>
        /// <param name = "top"><dd>  <p>An animation object that determines how the value of the Top property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the Top property unless this method is called again. If the Top  property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.
        /// </p>
        /// </remarks>
        /// <doc-id>hh448922</doc-id>
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetTop([In] float top)</unmanaged>
        /// <unmanaged-short>IDCompositionRectangleClip::SetTop</unmanaged-short>
        public unsafe void SetTop(System.Single top)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, top, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Animates the value of the Right property of a clip rectangle. The Right property specifies the x-coordinate of the lower-right corner of the clip rectangle.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>An animation object that determines how the value of the Right property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the Right property unless this method is called again. If the Right  property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.
        /// </p>
        /// </remarks>
        /// <doc-id>hh448907</doc-id>
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetRight([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionRectangleClip::SetRight</unmanaged-short>
        public unsafe void SetRight(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Animates the value of the Right property of a clip rectangle. The Right property specifies the x-coordinate of the lower-right corner of the clip rectangle.</p>
        /// </summary>
        /// <param name = "right"><dd>  <p>An animation object that determines how the value of the Right property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the Right property unless this method is called again. If the Right  property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.
        /// </p>
        /// </remarks>
        /// <doc-id>hh448907</doc-id>
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetRight([In] float right)</unmanaged>
        /// <unmanaged-short>IDCompositionRectangleClip::SetRight</unmanaged-short>
        public unsafe void SetRight(System.Single right)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, right, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of the Bottom property of a clip object. The Bottom property specifies the y-coordinate of the lower-right corner of the clip rectangle. </p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>The new value of the Bottom property, in pixels. This parameter has a numerical limit of -2^21 to 2^21.  The API accepts numbers outside of this range, but they are always clamped to this range.</p> </dd></param>
        /// <returns><p> If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.  See DirectComposition Error Codes for a list of error codes. </p></returns>
        /// <remarks>
        /// <p> This method fails if the <em>bottom</em> parameter is NaN, positive infinity, or negative infinity. </p><p> If the Bottom property was previously animated, this method removes the animation and sets the Bottom property to the specified static value. </p>
        /// </remarks>
        /// <doc-id>hh448860</doc-id>
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetBottom([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionRectangleClip::SetBottom</unmanaged-short>
        public unsafe void SetBottom(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of the Bottom property of a clip object. The Bottom property specifies the y-coordinate of the lower-right corner of the clip rectangle. </p>
        /// </summary>
        /// <param name = "bottom"><dd>  <p>The new value of the Bottom property, in pixels. This parameter has a numerical limit of -2^21 to 2^21.  The API accepts numbers outside of this range, but they are always clamped to this range.</p> </dd></param>
        /// <returns><p> If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.  See DirectComposition Error Codes for a list of error codes. </p></returns>
        /// <remarks>
        /// <p> This method fails if the <em>bottom</em> parameter is NaN, positive infinity, or negative infinity. </p><p> If the Bottom property was previously animated, this method removes the animation and sets the Bottom property to the specified static value. </p>
        /// </remarks>
        /// <doc-id>hh448860</doc-id>
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetBottom([In] float bottom)</unmanaged>
        /// <unmanaged-short>IDCompositionRectangleClip::SetBottom</unmanaged-short>
        public unsafe void SetBottom(System.Single bottom)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, bottom, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of the TopLeftRadiusX property of this clip. The TopLeftRadiusX property  specifies the x radius of the ellipse that rounds the top-left corner of the clip.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>The new value of the x radius. This parameter has a numerical limit of -2^21 to 2^21.  The API accepts numbers outside of this range, but they are always clamped to this range.</p> </dd></param>
        /// <returns><p> If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes. </p></returns>
        /// <remarks>
        /// <p> This method fails if the <em>radius</em> parameter is NaN, positive infinity, or negative infinity. </p><p> If the <em>radius</em> property was previously animated, this method removes the animation and sets the <em>radius</em> property to the specified static value. </p>
        /// </remarks>
        /// <doc-id>hh448910</doc-id>
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetTopLeftRadiusX([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionRectangleClip::SetTopLeftRadiusX</unmanaged-short>
        public unsafe void SetTopLeftRadiusX(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of the TopLeftRadiusX property of this clip. The TopLeftRadiusX property  specifies the x radius of the ellipse that rounds the top-left corner of the clip.</p>
        /// </summary>
        /// <param name = "radius"><dd>  <p>The new value of the x radius. This parameter has a numerical limit of -2^21 to 2^21.  The API accepts numbers outside of this range, but they are always clamped to this range.</p> </dd></param>
        /// <returns><p> If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes. </p></returns>
        /// <remarks>
        /// <p> This method fails if the <em>radius</em> parameter is NaN, positive infinity, or negative infinity. </p><p> If the <em>radius</em> property was previously animated, this method removes the animation and sets the <em>radius</em> property to the specified static value. </p>
        /// </remarks>
        /// <doc-id>hh448910</doc-id>
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetTopLeftRadiusX([In] float radius)</unmanaged>
        /// <unmanaged-short>IDCompositionRectangleClip::SetTopLeftRadiusX</unmanaged-short>
        public unsafe void SetTopLeftRadiusX(System.Single radius)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, radius, (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of the TopLeftRadiusY property of this clip. The TopLeftRadiusY property  specifies the y radius of the ellipse that rounds the top-left corner of the clip.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>The new value of the y radius. This parameter has a numerical limit of -2^21 to 2^21.  The API accepts numbers outside of this range, but they are always clamped to this range.</p> </dd></param>
        /// <returns><p> If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes. </p></returns>
        /// <remarks>
        /// <p> This method fails if the <em>radius</em> parameter is NaN, positive infinity, or negative infinity. </p><p> If the <em>radius</em> property was previously animated, this method removes the animation and sets the <em>radius</em> property to the specified static value. </p>
        /// </remarks>
        /// <doc-id>hh448913</doc-id>
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetTopLeftRadiusY([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionRectangleClip::SetTopLeftRadiusY</unmanaged-short>
        public unsafe void SetTopLeftRadiusY(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[13]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of the TopLeftRadiusY property of this clip. The TopLeftRadiusY property  specifies the y radius of the ellipse that rounds the top-left corner of the clip.</p>
        /// </summary>
        /// <param name = "radius"><dd>  <p>The new value of the y radius. This parameter has a numerical limit of -2^21 to 2^21.  The API accepts numbers outside of this range, but they are always clamped to this range.</p> </dd></param>
        /// <returns><p> If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes. </p></returns>
        /// <remarks>
        /// <p> This method fails if the <em>radius</em> parameter is NaN, positive infinity, or negative infinity. </p><p> If the <em>radius</em> property was previously animated, this method removes the animation and sets the <em>radius</em> property to the specified static value. </p>
        /// </remarks>
        /// <doc-id>hh448913</doc-id>
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetTopLeftRadiusY([In] float radius)</unmanaged>
        /// <unmanaged-short>IDCompositionRectangleClip::SetTopLeftRadiusY</unmanaged-short>
        public unsafe void SetTopLeftRadiusY(System.Single radius)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, radius, (*(void ***)this._nativePointer)[14]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Animates the value of the TopRightRadiusX property of this clip. The TopRightRadiusX property  specifies the x radius of the ellipse that rounds the top-right corner of the clip.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>An animation object that determines how the value of the x radius changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the x radius unless this method is called again. If the x radius was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.
        /// </p>
        /// </remarks>
        /// <doc-id>hh448917</doc-id>
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetTopRightRadiusX([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionRectangleClip::SetTopRightRadiusX</unmanaged-short>
        public unsafe void SetTopRightRadiusX(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[15]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Animates the value of the TopRightRadiusX property of this clip. The TopRightRadiusX property  specifies the x radius of the ellipse that rounds the top-right corner of the clip.</p>
        /// </summary>
        /// <param name = "radius"><dd>  <p>An animation object that determines how the value of the x radius changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the x radius unless this method is called again. If the x radius was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.
        /// </p>
        /// </remarks>
        /// <doc-id>hh448917</doc-id>
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetTopRightRadiusX([In] float radius)</unmanaged>
        /// <unmanaged-short>IDCompositionRectangleClip::SetTopRightRadiusX</unmanaged-short>
        public unsafe void SetTopRightRadiusX(System.Single radius)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, radius, (*(void ***)this._nativePointer)[16]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of the TopRightRadiusY property of this clip. The TopRightRadiusY property  specifies the y radius of the ellipse that rounds the top-right corner of the clip.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>The new value of the y radius. This parameter has a numerical limit of -2^21 to 2^21.  The API accepts numbers outside of this range, but they are always clamped to this range.</p> </dd></param>
        /// <returns><p> If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes. </p></returns>
        /// <remarks>
        /// <p> This method fails if the <em>radius</em> parameter is NaN, positive infinity, or negative infinity. </p><p> If the <em>radius</em> property was previously animated, this method removes the animation and sets the <em>radius</em> property to the specified static value. </p>
        /// </remarks>
        /// <doc-id>hh448919</doc-id>
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetTopRightRadiusY([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionRectangleClip::SetTopRightRadiusY</unmanaged-short>
        public unsafe void SetTopRightRadiusY(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[17]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of the TopRightRadiusY property of this clip. The TopRightRadiusY property  specifies the y radius of the ellipse that rounds the top-right corner of the clip.</p>
        /// </summary>
        /// <param name = "radius"><dd>  <p>The new value of the y radius. This parameter has a numerical limit of -2^21 to 2^21.  The API accepts numbers outside of this range, but they are always clamped to this range.</p> </dd></param>
        /// <returns><p> If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes. </p></returns>
        /// <remarks>
        /// <p> This method fails if the <em>radius</em> parameter is NaN, positive infinity, or negative infinity. </p><p> If the <em>radius</em> property was previously animated, this method removes the animation and sets the <em>radius</em> property to the specified static value. </p>
        /// </remarks>
        /// <doc-id>hh448919</doc-id>
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetTopRightRadiusY([In] float radius)</unmanaged>
        /// <unmanaged-short>IDCompositionRectangleClip::SetTopRightRadiusY</unmanaged-short>
        public unsafe void SetTopRightRadiusY(System.Single radius)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, radius, (*(void ***)this._nativePointer)[18]);
            __result__.CheckError();
        }

        /// <summary>
        /// Changes or animates the value of the BottomLeftRadiusX property of this clip. The BottomLeftRadiusX property  specifies the x radius of the ellipse that rounds the lower-left corner of the clip.
        /// </summary>
        /// <param name = "animation">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <doc-id>hh437435</doc-id>
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetBottomLeftRadiusX([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionRectangleClip::SetBottomLeftRadiusX</unmanaged-short>
        public unsafe void SetBottomLeftRadiusX(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[19]);
            __result__.CheckError();
        }

        /// <summary>
        /// Changes or animates the value of the BottomLeftRadiusX property of this clip. The BottomLeftRadiusX property  specifies the x radius of the ellipse that rounds the lower-left corner of the clip.
        /// </summary>
        /// <param name = "radius">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <doc-id>hh437435</doc-id>
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetBottomLeftRadiusX([In] float radius)</unmanaged>
        /// <unmanaged-short>IDCompositionRectangleClip::SetBottomLeftRadiusX</unmanaged-short>
        public unsafe void SetBottomLeftRadiusX(System.Single radius)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, radius, (*(void ***)this._nativePointer)[20]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of the BottomLeftRadiusY property of this clip. The BottomLeftRadiusY property  specifies the y radius of the ellipse that rounds the lower-left corner of the clip.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>The new value of the y radius. This parameter has a numerical limit of -2^21 to 2^21.  The API accepts numbers outside of this range, but they are always clamped to this range.</p> </dd></param>
        /// <returns><p> If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes. </p></returns>
        /// <remarks>
        /// <p> This method fails if the <em>radius</em> parameter is NaN, positive infinity, or negative infinity. </p><p> If the <em>radius</em> property was previously animated, this method removes the animation and sets the <em>radius</em> property to the specified static value. </p>
        /// </remarks>
        /// <doc-id>hh437443</doc-id>
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetBottomLeftRadiusY([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionRectangleClip::SetBottomLeftRadiusY</unmanaged-short>
        public unsafe void SetBottomLeftRadiusY(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[21]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of the BottomLeftRadiusY property of this clip. The BottomLeftRadiusY property  specifies the y radius of the ellipse that rounds the lower-left corner of the clip.</p>
        /// </summary>
        /// <param name = "radius"><dd>  <p>The new value of the y radius. This parameter has a numerical limit of -2^21 to 2^21.  The API accepts numbers outside of this range, but they are always clamped to this range.</p> </dd></param>
        /// <returns><p> If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes. </p></returns>
        /// <remarks>
        /// <p> This method fails if the <em>radius</em> parameter is NaN, positive infinity, or negative infinity. </p><p> If the <em>radius</em> property was previously animated, this method removes the animation and sets the <em>radius</em> property to the specified static value. </p>
        /// </remarks>
        /// <doc-id>hh437443</doc-id>
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetBottomLeftRadiusY([In] float radius)</unmanaged>
        /// <unmanaged-short>IDCompositionRectangleClip::SetBottomLeftRadiusY</unmanaged-short>
        public unsafe void SetBottomLeftRadiusY(System.Single radius)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, radius, (*(void ***)this._nativePointer)[22]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Animates the value of the BottomRightRadiusX property of this clip. The BottomRightRadiusX property  specifies the x radius of the ellipse that rounds the lower-right corner of the clip.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>An animation object that determines how the value of the x radius changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the x radius unless this method is called again. If the x radius was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.
        /// </p>
        /// </remarks>
        /// <doc-id>hh448853</doc-id>
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetBottomRightRadiusX([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionRectangleClip::SetBottomRightRadiusX</unmanaged-short>
        public unsafe void SetBottomRightRadiusX(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[23]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Animates the value of the BottomRightRadiusX property of this clip. The BottomRightRadiusX property  specifies the x radius of the ellipse that rounds the lower-right corner of the clip.</p>
        /// </summary>
        /// <param name = "radius"><dd>  <p>An animation object that determines how the value of the x radius changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the x radius unless this method is called again. If the x radius was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.
        /// </p>
        /// </remarks>
        /// <doc-id>hh448853</doc-id>
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetBottomRightRadiusX([In] float radius)</unmanaged>
        /// <unmanaged-short>IDCompositionRectangleClip::SetBottomRightRadiusX</unmanaged-short>
        public unsafe void SetBottomRightRadiusX(System.Single radius)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, radius, (*(void ***)this._nativePointer)[24]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of the BottomRightRadiusY property of this clip. The BottomRightRadiusY property  specifies the y radius of the ellipse that rounds the lower-right corner of the clip.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>The new value of the y radius. This parameter has a numerical limit of -2^21 to 2^21.  The API accepts numbers outside of this range, but they are always clamped to this range.</p> </dd></param>
        /// <returns><p> If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes. </p></returns>
        /// <remarks>
        /// <p> This method fails if the <em>radius</em> parameter is NaN, positive infinity, or negative infinity. </p><p> If the <em>radius</em> property was previously animated, this method removes the animation and sets the <em>radius</em> property to the specified static value. </p>
        /// </remarks>
        /// <doc-id>hh448857</doc-id>
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetBottomRightRadiusY([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionRectangleClip::SetBottomRightRadiusY</unmanaged-short>
        public unsafe void SetBottomRightRadiusY(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[25]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of the BottomRightRadiusY property of this clip. The BottomRightRadiusY property  specifies the y radius of the ellipse that rounds the lower-right corner of the clip.</p>
        /// </summary>
        /// <param name = "radius"><dd>  <p>The new value of the y radius. This parameter has a numerical limit of -2^21 to 2^21.  The API accepts numbers outside of this range, but they are always clamped to this range.</p> </dd></param>
        /// <returns><p> If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes. </p></returns>
        /// <remarks>
        /// <p> This method fails if the <em>radius</em> parameter is NaN, positive infinity, or negative infinity. </p><p> If the <em>radius</em> property was previously animated, this method removes the animation and sets the <em>radius</em> property to the specified static value. </p>
        /// </remarks>
        /// <doc-id>hh448857</doc-id>
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetBottomRightRadiusY([In] float radius)</unmanaged>
        /// <unmanaged-short>IDCompositionRectangleClip::SetBottomRightRadiusY</unmanaged-short>
        public unsafe void SetBottomRightRadiusY(System.Single radius)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, radius, (*(void ***)this._nativePointer)[26]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("641ED83C-AE96-46c5-90DC-32774CC5C6D5")]
    public partial class RotateTransform : SharpDX.DirectComposition.Transform
    {
        public RotateTransform(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator RotateTransform(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new RotateTransform(nativePtr);
        /// <summary>
        /// <p>Animates the value of the Angle property of a 2D rotation transform. The Angle property specifies the rotation angle.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>An animation object that determines how the value of the Angle property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the Angle property unless this method is called again. If the Angle property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.
        /// </p>
        /// </remarks>
        /// <doc-id>hh448974</doc-id>
        /// <unmanaged>HRESULT IDCompositionRotateTransform::SetAngle([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionRotateTransform::SetAngle</unmanaged-short>
        public unsafe void SetAngle(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Animates the value of the Angle property of a 2D rotation transform. The Angle property specifies the rotation angle.</p>
        /// </summary>
        /// <param name = "angle"><dd>  <p>An animation object that determines how the value of the Angle property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the Angle property unless this method is called again. If the Angle property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.
        /// </p>
        /// </remarks>
        /// <doc-id>hh448974</doc-id>
        /// <unmanaged>HRESULT IDCompositionRotateTransform::SetAngle([In] float angle)</unmanaged>
        /// <unmanaged-short>IDCompositionRotateTransform::SetAngle</unmanaged-short>
        public unsafe void SetAngle(System.Single angle)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, angle, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Animates the value of the CenterX property of a 2D rotation transform.  The CenterX property specifies the x-coordinate of the point about which the rotation is performed.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>An animation object that determines how the value of the CenterX property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the CenterX property unless this method is called again. If the CenterX property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.
        /// </p>
        /// </remarks>
        /// <doc-id>hh448980</doc-id>
        /// <unmanaged>HRESULT IDCompositionRotateTransform::SetCenterX([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionRotateTransform::SetCenterX</unmanaged-short>
        public unsafe void SetCenterX(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Animates the value of the CenterX property of a 2D rotation transform.  The CenterX property specifies the x-coordinate of the point about which the rotation is performed.</p>
        /// </summary>
        /// <param name = "centerX"><dd>  <p>An animation object that determines how the value of the CenterX property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the CenterX property unless this method is called again. If the CenterX property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.
        /// </p>
        /// </remarks>
        /// <doc-id>hh448980</doc-id>
        /// <unmanaged>HRESULT IDCompositionRotateTransform::SetCenterX([In] float centerX)</unmanaged>
        /// <unmanaged-short>IDCompositionRotateTransform::SetCenterX</unmanaged-short>
        public unsafe void SetCenterX(System.Single centerX)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, centerX, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Animates the value of the CenterY property of a 2D rotation transform. The CenterY property specifies the y-coordinate of the point about which the rotation is performed.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>An animation object that determines how the value of the CenterY property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the CenterY property unless this method is called again. If the CenterY property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.
        /// </p>
        /// </remarks>
        /// <doc-id>hh448986</doc-id>
        /// <unmanaged>HRESULT IDCompositionRotateTransform::SetCenterY([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionRotateTransform::SetCenterY</unmanaged-short>
        public unsafe void SetCenterY(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Animates the value of the CenterY property of a 2D rotation transform. The CenterY property specifies the y-coordinate of the point about which the rotation is performed.</p>
        /// </summary>
        /// <param name = "centerY"><dd>  <p>An animation object that determines how the value of the CenterY property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the CenterY property unless this method is called again. If the CenterY property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.
        /// </p>
        /// </remarks>
        /// <doc-id>hh448986</doc-id>
        /// <unmanaged>HRESULT IDCompositionRotateTransform::SetCenterY([In] float centerY)</unmanaged>
        /// <unmanaged-short>IDCompositionRotateTransform::SetCenterY</unmanaged-short>
        public unsafe void SetCenterY(System.Single centerY)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, centerY, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("D8F5B23F-D429-4a91-B55A-D2F45FD75B18")]
    public partial class RotateTransform3D : SharpDX.DirectComposition.Transform3D
    {
        public RotateTransform3D(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator RotateTransform3D(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new RotateTransform3D(nativePtr);
        /// <summary>
        /// <p>Animates the value of the Angle property of a 3D rotation transform. The Angle property specifies the rotation angle. The default value is zero.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>An animation object that determines how the value of the Angle property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the Angle property unless this method is called again. If the Angle property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface as the affected 3D transform. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.
        /// </p>
        /// </remarks>
        /// <doc-id>hh448931</doc-id>
        /// <unmanaged>HRESULT IDCompositionRotateTransform3D::SetAngle([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionRotateTransform3D::SetAngle</unmanaged-short>
        public unsafe void SetAngle(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Animates the value of the Angle property of a 3D rotation transform. The Angle property specifies the rotation angle. The default value is zero.</p>
        /// </summary>
        /// <param name = "angle"><dd>  <p>An animation object that determines how the value of the Angle property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the Angle property unless this method is called again. If the Angle property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface as the affected 3D transform. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.
        /// </p>
        /// </remarks>
        /// <doc-id>hh448931</doc-id>
        /// <unmanaged>HRESULT IDCompositionRotateTransform3D::SetAngle([In] float angle)</unmanaged>
        /// <unmanaged-short>IDCompositionRotateTransform3D::SetAngle</unmanaged-short>
        public unsafe void SetAngle(System.Single angle)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, angle, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// Changes or animates the value of the AxisX property of a 3D rotation transform. The AxisX property specifies the x-coordinate for the axis vector of rotation. The default value is zero.
        /// </summary>
        /// <param name = "animation">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <doc-id>hh448939</doc-id>
        /// <unmanaged>HRESULT IDCompositionRotateTransform3D::SetAxisX([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionRotateTransform3D::SetAxisX</unmanaged-short>
        public unsafe void SetAxisX(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// Changes or animates the value of the AxisX property of a 3D rotation transform. The AxisX property specifies the x-coordinate for the axis vector of rotation. The default value is zero.
        /// </summary>
        /// <param name = "axisX">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <doc-id>hh448939</doc-id>
        /// <unmanaged>HRESULT IDCompositionRotateTransform3D::SetAxisX([In] float axisX)</unmanaged>
        /// <unmanaged-short>IDCompositionRotateTransform3D::SetAxisX</unmanaged-short>
        public unsafe void SetAxisX(System.Single axisX)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, axisX, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of the AxisY property of a 3D rotation transform. The AxisY property specifies the y-coordinate for the axis vector of rotation.  The default value is zero.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>The new y-coordinate for the axis vector of rotation. </p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>When setting the axis to a non-default value, you should always set all three axis properties (AxisX, AxisY, and AxisZ).</p><p>This method fails if the <em>axisY</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the AxisY property was previously animated, this method removes the animation and sets the AxisY property to the specified static value.
        /// </p>
        /// </remarks>
        /// <doc-id>hh448941</doc-id>
        /// <unmanaged>HRESULT IDCompositionRotateTransform3D::SetAxisY([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionRotateTransform3D::SetAxisY</unmanaged-short>
        public unsafe void SetAxisY(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of the AxisY property of a 3D rotation transform. The AxisY property specifies the y-coordinate for the axis vector of rotation.  The default value is zero.</p>
        /// </summary>
        /// <param name = "axisY"><dd>  <p>The new y-coordinate for the axis vector of rotation. </p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>When setting the axis to a non-default value, you should always set all three axis properties (AxisX, AxisY, and AxisZ).</p><p>This method fails if the <em>axisY</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the AxisY property was previously animated, this method removes the animation and sets the AxisY property to the specified static value.
        /// </p>
        /// </remarks>
        /// <doc-id>hh448941</doc-id>
        /// <unmanaged>HRESULT IDCompositionRotateTransform3D::SetAxisY([In] float axisY)</unmanaged>
        /// <unmanaged-short>IDCompositionRotateTransform3D::SetAxisY</unmanaged-short>
        public unsafe void SetAxisY(System.Single axisY)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, axisY, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// Changes or animates the value of the AxisZ property of a 3D rotation transform. The AxisZ property specifies the z-coordinate for the axis vector of rotation. The default value is 1.0.
        /// </summary>
        /// <param name = "animation">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <doc-id>hh448951</doc-id>
        /// <unmanaged>HRESULT IDCompositionRotateTransform3D::SetAxisZ([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionRotateTransform3D::SetAxisZ</unmanaged-short>
        public unsafe void SetAxisZ(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// Changes or animates the value of the AxisZ property of a 3D rotation transform. The AxisZ property specifies the z-coordinate for the axis vector of rotation. The default value is 1.0.
        /// </summary>
        /// <param name = "axisZ">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <doc-id>hh448951</doc-id>
        /// <unmanaged>HRESULT IDCompositionRotateTransform3D::SetAxisZ([In] float axisZ)</unmanaged>
        /// <unmanaged-short>IDCompositionRotateTransform3D::SetAxisZ</unmanaged-short>
        public unsafe void SetAxisZ(System.Single axisZ)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, axisZ, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// Changes or animates the value of the CenterX property of a 3D rotation transform. The CenterX property specifies the x-coordinate of the point about which the rotation is performed. The default value is zero.
        /// </summary>
        /// <param name = "animation">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <doc-id>hh448957</doc-id>
        /// <unmanaged>HRESULT IDCompositionRotateTransform3D::SetCenterX([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionRotateTransform3D::SetCenterX</unmanaged-short>
        public unsafe void SetCenterX(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }

        /// <summary>
        /// Changes or animates the value of the CenterX property of a 3D rotation transform. The CenterX property specifies the x-coordinate of the point about which the rotation is performed. The default value is zero.
        /// </summary>
        /// <param name = "centerX">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <doc-id>hh448957</doc-id>
        /// <unmanaged>HRESULT IDCompositionRotateTransform3D::SetCenterX([In] float centerX)</unmanaged>
        /// <unmanaged-short>IDCompositionRotateTransform3D::SetCenterX</unmanaged-short>
        public unsafe void SetCenterX(System.Single centerX)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, centerX, (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Animates the value of the CenterY property of a 3D rotation transform.  The CenterY property specifies the y-coordinate of the point about which the rotation is performed. The default value is zero.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>An animation object that determines how the value of the CenterY property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the CenterY property unless this method is called again. If the CenterY property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.
        /// </p>
        /// </remarks>
        /// <doc-id>hh448961</doc-id>
        /// <unmanaged>HRESULT IDCompositionRotateTransform3D::SetCenterY([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionRotateTransform3D::SetCenterY</unmanaged-short>
        public unsafe void SetCenterY(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[13]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Animates the value of the CenterY property of a 3D rotation transform.  The CenterY property specifies the y-coordinate of the point about which the rotation is performed. The default value is zero.</p>
        /// </summary>
        /// <param name = "centerY"><dd>  <p>An animation object that determines how the value of the CenterY property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the CenterY property unless this method is called again. If the CenterY property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.
        /// </p>
        /// </remarks>
        /// <doc-id>hh448961</doc-id>
        /// <unmanaged>HRESULT IDCompositionRotateTransform3D::SetCenterY([In] float centerY)</unmanaged>
        /// <unmanaged-short>IDCompositionRotateTransform3D::SetCenterY</unmanaged-short>
        public unsafe void SetCenterY(System.Single centerY)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, centerY, (*(void ***)this._nativePointer)[14]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of the CenterZ property of a 3D rotation transform. The CenterZ property specifies the z-coordinate of the point about which the rotation is performed. The default value is zero.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>The new z-coordinate of the center point.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method fails if the <em>centerZ</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the CenterZ property was previously animated, this method removes the animation and sets the CenterZ property to the specified static value.
        /// </p>
        /// </remarks>
        /// <doc-id>hh448965</doc-id>
        /// <unmanaged>HRESULT IDCompositionRotateTransform3D::SetCenterZ([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionRotateTransform3D::SetCenterZ</unmanaged-short>
        public unsafe void SetCenterZ(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[15]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of the CenterZ property of a 3D rotation transform. The CenterZ property specifies the z-coordinate of the point about which the rotation is performed. The default value is zero.</p>
        /// </summary>
        /// <param name = "centerZ"><dd>  <p>The new z-coordinate of the center point.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method fails if the <em>centerZ</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the CenterZ property was previously animated, this method removes the animation and sets the CenterZ property to the specified static value.
        /// </p>
        /// </remarks>
        /// <doc-id>hh448965</doc-id>
        /// <unmanaged>HRESULT IDCompositionRotateTransform3D::SetCenterZ([In] float centerZ)</unmanaged>
        /// <unmanaged-short>IDCompositionRotateTransform3D::SetCenterZ</unmanaged-short>
        public unsafe void SetCenterZ(System.Single centerZ)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, centerZ, (*(void ***)this._nativePointer)[16]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("A08DEBDA-3258-4FA4-9F16-9174D3FE93B1")]
    public partial class SaturationEffect : SharpDX.DirectComposition.FilterEffect
    {
        public SaturationEffect(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator SaturationEffect(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new SaturationEffect(nativePtr);
        /// <summary>
        /// <p>Sets the saturation of the image.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>An animation that represents how the saturation of the image changes over time. This parameter must not be <c>null</c>. You can set the saturation to a value between 0 and 1. If you set it to 1 the output image is fully saturated. If you set it to 0 the output image is monochrome. The saturation value is unitless. The effect calculates a color matrix based on the saturation value (s in the equation here) using the following equation: </p></dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919765</doc-id>
        /// <unmanaged>HRESULT IDCompositionSaturationEffect::SetSaturation([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionSaturationEffect::SetSaturation</unmanaged-short>
        public unsafe void SetSaturation(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the saturation of the image.</p>
        /// </summary>
        /// <param name = "ratio"><dd>  <p>An animation that represents how the saturation of the image changes over time. This parameter must not be <c>null</c>. You can set the saturation to a value between 0 and 1. If you set it to 1 the output image is fully saturated. If you set it to 0 the output image is monochrome. The saturation value is unitless. The effect calculates a color matrix based on the saturation value (s in the equation here) using the following equation: </p></dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919765</doc-id>
        /// <unmanaged>HRESULT IDCompositionSaturationEffect::SetSaturation([In] float ratio)</unmanaged>
        /// <unmanaged-short>IDCompositionSaturationEffect::SetSaturation</unmanaged-short>
        public unsafe void SetSaturation(System.Single ratio)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, ratio, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("71FDE914-40EF-45ef-BD51-68B037C339F9")]
    public partial class ScaleTransform : SharpDX.DirectComposition.Transform
    {
        public ScaleTransform(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ScaleTransform(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ScaleTransform(nativePtr);
        /// <summary>
        /// <p>Animates the value of the ScaleX property of a 2D scale transform. The ScaleX property specifies the scale factor along the x-axis.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>An animation object that determines how the value of the ScaleX property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the ScaleX property unless this method is called again. If the ScaleX property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449046</doc-id>
        /// <unmanaged>HRESULT IDCompositionScaleTransform::SetScaleX([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionScaleTransform::SetScaleX</unmanaged-short>
        public unsafe void SetScaleX(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Animates the value of the ScaleX property of a 2D scale transform. The ScaleX property specifies the scale factor along the x-axis.</p>
        /// </summary>
        /// <param name = "scaleX"><dd>  <p>An animation object that determines how the value of the ScaleX property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the ScaleX property unless this method is called again. If the ScaleX property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449046</doc-id>
        /// <unmanaged>HRESULT IDCompositionScaleTransform::SetScaleX([In] float scaleX)</unmanaged>
        /// <unmanaged-short>IDCompositionScaleTransform::SetScaleX</unmanaged-short>
        public unsafe void SetScaleX(System.Single scaleX)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, scaleX, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of the ScaleY property of a 2D scale transform. The ScaleY property specifies the scale factor along the y-axis.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>The new y-axis scale factor.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method fails if the <em>scaleY</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the ScaleY property was previously animated, this method removes the animation and sets the ScaleY property to the specified static value.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449050</doc-id>
        /// <unmanaged>HRESULT IDCompositionScaleTransform::SetScaleY([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionScaleTransform::SetScaleY</unmanaged-short>
        public unsafe void SetScaleY(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of the ScaleY property of a 2D scale transform. The ScaleY property specifies the scale factor along the y-axis.</p>
        /// </summary>
        /// <param name = "scaleY"><dd>  <p>The new y-axis scale factor.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method fails if the <em>scaleY</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the ScaleY property was previously animated, this method removes the animation and sets the ScaleY property to the specified static value.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449050</doc-id>
        /// <unmanaged>HRESULT IDCompositionScaleTransform::SetScaleY([In] float scaleY)</unmanaged>
        /// <unmanaged-short>IDCompositionScaleTransform::SetScaleY</unmanaged-short>
        public unsafe void SetScaleY(System.Single scaleY)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, scaleY, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Animates the value of the CenterX property of a 2D scale transform. The CenterX property specifies the x-coordinate of the point about which scaling is performed.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>An animation object that determines how the value of the CenterX property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the CenterX property unless this method is called again. If the CenterX property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449034</doc-id>
        /// <unmanaged>HRESULT IDCompositionScaleTransform::SetCenterX([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionScaleTransform::SetCenterX</unmanaged-short>
        public unsafe void SetCenterX(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Animates the value of the CenterX property of a 2D scale transform. The CenterX property specifies the x-coordinate of the point about which scaling is performed.</p>
        /// </summary>
        /// <param name = "centerX"><dd>  <p>An animation object that determines how the value of the CenterX property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the CenterX property unless this method is called again. If the CenterX property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449034</doc-id>
        /// <unmanaged>HRESULT IDCompositionScaleTransform::SetCenterX([In] float centerX)</unmanaged>
        /// <unmanaged-short>IDCompositionScaleTransform::SetCenterX</unmanaged-short>
        public unsafe void SetCenterX(System.Single centerX)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, centerX, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of the CenterY property of a 2D scale transform. The CenterY property specifies the y-coordinate of the point about which scaling is performed. </p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>The new y-coordinate of the center point.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method fails if the <em>centerY</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the CenterY property was previously animated, this method removes the animation and sets the CenterY property to the specified static value.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449038</doc-id>
        /// <unmanaged>HRESULT IDCompositionScaleTransform::SetCenterY([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionScaleTransform::SetCenterY</unmanaged-short>
        public unsafe void SetCenterY(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of the CenterY property of a 2D scale transform. The CenterY property specifies the y-coordinate of the point about which scaling is performed. </p>
        /// </summary>
        /// <param name = "centerY"><dd>  <p>The new y-coordinate of the center point.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method fails if the <em>centerY</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the CenterY property was previously animated, this method removes the animation and sets the CenterY property to the specified static value.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449038</doc-id>
        /// <unmanaged>HRESULT IDCompositionScaleTransform::SetCenterY([In] float centerY)</unmanaged>
        /// <unmanaged-short>IDCompositionScaleTransform::SetCenterY</unmanaged-short>
        public unsafe void SetCenterY(System.Single centerY)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, centerY, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("2A9E9EAD-364B-4b15-A7C4-A1997F78B389")]
    public partial class ScaleTransform3D : SharpDX.DirectComposition.Transform3D
    {
        public ScaleTransform3D(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ScaleTransform3D(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ScaleTransform3D(nativePtr);
        /// <summary>
        /// <p>Animates the value of the ScaleX property of a scale transform. The ScaleX property specifies the scale factor along the x-axis.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>An animation object that determines how the value of the ScaleX property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the ScaleX property unless this method is called again. If the ScaleX property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449016</doc-id>
        /// <unmanaged>HRESULT IDCompositionScaleTransform3D::SetScaleX([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionScaleTransform3D::SetScaleX</unmanaged-short>
        public unsafe void SetScaleX(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Animates the value of the ScaleX property of a scale transform. The ScaleX property specifies the scale factor along the x-axis.</p>
        /// </summary>
        /// <param name = "scaleX"><dd>  <p>An animation object that determines how the value of the ScaleX property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the ScaleX property unless this method is called again. If the ScaleX property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449016</doc-id>
        /// <unmanaged>HRESULT IDCompositionScaleTransform3D::SetScaleX([In] float scaleX)</unmanaged>
        /// <unmanaged-short>IDCompositionScaleTransform3D::SetScaleX</unmanaged-short>
        public unsafe void SetScaleX(System.Single scaleX)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, scaleX, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of the ScaleY property of a 3D scale transform. The ScaleY property specifies the scale factor along the y-axis.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>The new y-axis scale factor.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method fails if the <em>scaleY</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the ScaleY property was previously animated, this method removes the animation and sets the ScaleY property to the specified static value.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449020</doc-id>
        /// <unmanaged>HRESULT IDCompositionScaleTransform3D::SetScaleY([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionScaleTransform3D::SetScaleY</unmanaged-short>
        public unsafe void SetScaleY(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of the ScaleY property of a 3D scale transform. The ScaleY property specifies the scale factor along the y-axis.</p>
        /// </summary>
        /// <param name = "scaleY"><dd>  <p>The new y-axis scale factor.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method fails if the <em>scaleY</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the ScaleY property was previously animated, this method removes the animation and sets the ScaleY property to the specified static value.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449020</doc-id>
        /// <unmanaged>HRESULT IDCompositionScaleTransform3D::SetScaleY([In] float scaleY)</unmanaged>
        /// <unmanaged-short>IDCompositionScaleTransform3D::SetScaleY</unmanaged-short>
        public unsafe void SetScaleY(System.Single scaleY)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, scaleY, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of the ScaleZ property of a 3D scale transform. The ScaleZ property specifies the scale factor along the z-axis.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>The new z-axis scale factor.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method fails if the <em>scaleZ</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the ScaleZ property was previously animated, this method removes the animation and sets the ScaleZ property to the specified static value.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449026</doc-id>
        /// <unmanaged>HRESULT IDCompositionScaleTransform3D::SetScaleZ([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionScaleTransform3D::SetScaleZ</unmanaged-short>
        public unsafe void SetScaleZ(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of the ScaleZ property of a 3D scale transform. The ScaleZ property specifies the scale factor along the z-axis.</p>
        /// </summary>
        /// <param name = "scaleZ"><dd>  <p>The new z-axis scale factor.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method fails if the <em>scaleZ</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the ScaleZ property was previously animated, this method removes the animation and sets the ScaleZ property to the specified static value.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449026</doc-id>
        /// <unmanaged>HRESULT IDCompositionScaleTransform3D::SetScaleZ([In] float scaleZ)</unmanaged>
        /// <unmanaged-short>IDCompositionScaleTransform3D::SetScaleZ</unmanaged-short>
        public unsafe void SetScaleZ(System.Single scaleZ)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, scaleZ, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of the CenterX property of a 3D scale transform.   The CenterX property specifies the x-coordinate of the point about which scaling is performed. </p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>The new x-coordinate of the center point.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method fails if the <em>centerX</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the CenterX property was previously animated, this method removes the animation and sets the CenterX property to the specified static value.
        /// </p>
        /// </remarks>
        /// <doc-id>hh448994</doc-id>
        /// <unmanaged>HRESULT IDCompositionScaleTransform3D::SetCenterX([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionScaleTransform3D::SetCenterX</unmanaged-short>
        public unsafe void SetCenterX(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of the CenterX property of a 3D scale transform.   The CenterX property specifies the x-coordinate of the point about which scaling is performed. </p>
        /// </summary>
        /// <param name = "centerX"><dd>  <p>The new x-coordinate of the center point.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method fails if the <em>centerX</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the CenterX property was previously animated, this method removes the animation and sets the CenterX property to the specified static value.
        /// </p>
        /// </remarks>
        /// <doc-id>hh448994</doc-id>
        /// <unmanaged>HRESULT IDCompositionScaleTransform3D::SetCenterX([In] float centerX)</unmanaged>
        /// <unmanaged-short>IDCompositionScaleTransform3D::SetCenterX</unmanaged-short>
        public unsafe void SetCenterX(System.Single centerX)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, centerX, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// Changes or animates the value of the CenterY property of a 3D scale transform. The CenterY property specifies the y-coordinate of the point about which scaling is performed.
        /// </summary>
        /// <param name = "animation">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <doc-id>hh449006</doc-id>
        /// <unmanaged>HRESULT IDCompositionScaleTransform3D::SetCenterY([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionScaleTransform3D::SetCenterY</unmanaged-short>
        public unsafe void SetCenterY(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }

        /// <summary>
        /// Changes or animates the value of the CenterY property of a 3D scale transform. The CenterY property specifies the y-coordinate of the point about which scaling is performed.
        /// </summary>
        /// <param name = "centerY">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <doc-id>hh449006</doc-id>
        /// <unmanaged>HRESULT IDCompositionScaleTransform3D::SetCenterY([In] float centerY)</unmanaged>
        /// <unmanaged-short>IDCompositionScaleTransform3D::SetCenterY</unmanaged-short>
        public unsafe void SetCenterY(System.Single centerY)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, centerY, (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of the CenterZ property of a 3D scale transform.   The CenterZ property specifies the z-coordinate of the point about which scaling is performed. </p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>The new z-coordinate of the center point.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method fails if the <em>centerZ</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the CenterZ property was previously animated, this method removes the animation and sets the CenterZ property to the specified static value.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449008</doc-id>
        /// <unmanaged>HRESULT IDCompositionScaleTransform3D::SetCenterZ([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionScaleTransform3D::SetCenterZ</unmanaged-short>
        public unsafe void SetCenterZ(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[13]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of the CenterZ property of a 3D scale transform.   The CenterZ property specifies the z-coordinate of the point about which scaling is performed. </p>
        /// </summary>
        /// <param name = "centerZ"><dd>  <p>The new z-coordinate of the center point.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method fails if the <em>centerZ</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the CenterZ property was previously animated, this method removes the animation and sets the CenterZ property to the specified static value.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449008</doc-id>
        /// <unmanaged>HRESULT IDCompositionScaleTransform3D::SetCenterZ([In] float centerZ)</unmanaged>
        /// <unmanaged-short>IDCompositionScaleTransform3D::SetCenterZ</unmanaged-short>
        public unsafe void SetCenterZ(System.Single centerZ)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, centerZ, (*(void ***)this._nativePointer)[14]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("4AD18AC0-CFD2-4C2F-BB62-96E54FDB6879")]
    public partial class ShadowEffect : SharpDX.DirectComposition.FilterEffect
    {
        public ShadowEffect(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ShadowEffect(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ShadowEffect(nativePtr);
        /// <summary>
        /// <p>Sets color of the shadow.</p>
        /// </summary>
        /// <doc-id>dn919771</doc-id>
        /// <unmanaged>SetColor</unmanaged>
        /// <unmanaged-short>SetColor</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector4 Color
        {
            set => SetColor(value);
        }

        /// <summary>
        /// <p>Sets the amount of blur to be applied to the alpha channel of the image.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p> The amount of blur to be applied to the alpha channel of the image. You can compute the blur radius of the kernel by multiplying the standard deviation by 3. The units of both the standard deviation and blur radius are DIPs. </p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919781</doc-id>
        /// <unmanaged>HRESULT IDCompositionShadowEffect::SetStandardDeviation([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionShadowEffect::SetStandardDeviation</unmanaged-short>
        public unsafe void SetStandardDeviation(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the amount of blur to be applied to the alpha channel of the image.</p>
        /// </summary>
        /// <param name = "amount"><dd>  <p> The amount of blur to be applied to the alpha channel of the image. You can compute the blur radius of the kernel by multiplying the standard deviation by 3. The units of both the standard deviation and blur radius are DIPs. </p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919781</doc-id>
        /// <unmanaged>HRESULT IDCompositionShadowEffect::SetStandardDeviation([In] float amount)</unmanaged>
        /// <unmanaged-short>IDCompositionShadowEffect::SetStandardDeviation</unmanaged-short>
        public unsafe void SetStandardDeviation(System.Single amount)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, amount, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets color of the shadow.</p>
        /// </summary>
        /// <param name = "color"><dd>  <p>The color of the shadow.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919771</doc-id>
        /// <unmanaged>HRESULT IDCompositionShadowEffect::SetColor([In] const D2D_VECTOR_4F&amp; color)</unmanaged>
        /// <unmanaged-short>IDCompositionShadowEffect::SetColor</unmanaged-short>
        internal unsafe void SetColor(SharpDX.Mathematics.Interop.RawVector4 color)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &color, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the red value for the color of the shadow.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>An animation that represents how the red value for the color of the shadow changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919775</doc-id>
        /// <unmanaged>HRESULT IDCompositionShadowEffect::SetRed([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionShadowEffect::SetRed</unmanaged-short>
        public unsafe void SetRed(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the red value for the color of the shadow.</p>
        /// </summary>
        /// <param name = "amount"><dd>  <p>An animation that represents how the red value for the color of the shadow changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919775</doc-id>
        /// <unmanaged>HRESULT IDCompositionShadowEffect::SetRed([In] float amount)</unmanaged>
        /// <unmanaged-short>IDCompositionShadowEffect::SetRed</unmanaged-short>
        public unsafe void SetRed(System.Single amount)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, amount, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the green value for the color of the shadow.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>The green value for the color of the shadow.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919772</doc-id>
        /// <unmanaged>HRESULT IDCompositionShadowEffect::SetGreen([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionShadowEffect::SetGreen</unmanaged-short>
        public unsafe void SetGreen(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the green value for the color of the shadow.</p>
        /// </summary>
        /// <param name = "amount"><dd>  <p>The green value for the color of the shadow.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919772</doc-id>
        /// <unmanaged>HRESULT IDCompositionShadowEffect::SetGreen([In] float amount)</unmanaged>
        /// <unmanaged-short>IDCompositionShadowEffect::SetGreen</unmanaged-short>
        public unsafe void SetGreen(System.Single amount)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, amount, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the blue value for the color of the shadow.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>The blue value for the color of the shadow.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919769</doc-id>
        /// <unmanaged>HRESULT IDCompositionShadowEffect::SetBlue([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionShadowEffect::SetBlue</unmanaged-short>
        public unsafe void SetBlue(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the blue value for the color of the shadow.</p>
        /// </summary>
        /// <param name = "amount"><dd>  <p>The blue value for the color of the shadow.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919769</doc-id>
        /// <unmanaged>HRESULT IDCompositionShadowEffect::SetBlue([In] float amount)</unmanaged>
        /// <unmanaged-short>IDCompositionShadowEffect::SetBlue</unmanaged-short>
        public unsafe void SetBlue(System.Single amount)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, amount, (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the alpha value for the effect.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>An animation that represents how the alpha value for the effect changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919768</doc-id>
        /// <unmanaged>HRESULT IDCompositionShadowEffect::SetAlpha([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionShadowEffect::SetAlpha</unmanaged-short>
        public unsafe void SetAlpha(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[13]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the alpha value for the effect.</p>
        /// </summary>
        /// <param name = "amount"><dd>  <p>An animation that represents how the alpha value for the effect changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919768</doc-id>
        /// <unmanaged>HRESULT IDCompositionShadowEffect::SetAlpha([In] float amount)</unmanaged>
        /// <unmanaged-short>IDCompositionShadowEffect::SetAlpha</unmanaged-short>
        public unsafe void SetAlpha(System.Single amount)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, amount, (*(void ***)this._nativePointer)[14]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("E57AA735-DCDB-4c72-9C61-0591F58889EE")]
    public partial class SkewTransform : SharpDX.DirectComposition.Transform
    {
        public SkewTransform(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator SkewTransform(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new SkewTransform(nativePtr);
        /// <summary>
        /// <p>Changes the value of the AngleX property of a 2D skew transform.   The AngleX property specifies the skew angle along the x-axis.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>The new skew angle of the x-axis, in degrees. A positive value creates a counterclockwise skew, and a negative value creates a clockwise skew. For values less than ?360 or greater than 360, the values wrap around and are treated as if the mathematical operation mod(360) was applied.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method fails if the <em>angleX</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the AngleX property was previously animated, this method removes the animation and sets the AngleX property to the specified static value.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449059</doc-id>
        /// <unmanaged>HRESULT IDCompositionSkewTransform::SetAngleX([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionSkewTransform::SetAngleX</unmanaged-short>
        public unsafe void SetAngleX(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of the AngleX property of a 2D skew transform.   The AngleX property specifies the skew angle along the x-axis.</p>
        /// </summary>
        /// <param name = "angleX"><dd>  <p>The new skew angle of the x-axis, in degrees. A positive value creates a counterclockwise skew, and a negative value creates a clockwise skew. For values less than ?360 or greater than 360, the values wrap around and are treated as if the mathematical operation mod(360) was applied.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method fails if the <em>angleX</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the AngleX property was previously animated, this method removes the animation and sets the AngleX property to the specified static value.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449059</doc-id>
        /// <unmanaged>HRESULT IDCompositionSkewTransform::SetAngleX([In] float angleX)</unmanaged>
        /// <unmanaged-short>IDCompositionSkewTransform::SetAngleX</unmanaged-short>
        public unsafe void SetAngleX(System.Single angleX)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, angleX, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of the AngleY property of a 2D skew transform. The AngleY property specifies the skew angle along the y-axis.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>The new skew angle of the y-axis, in degrees. A positive value creates a counterclockwise skew, and a negative value creates a clockwise skew. For values less than ?360 or greater than 360, the values wrap around and are treated as if the mathematical operation mod(360) was applied.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method fails if the <em>angleY</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the AngleY property was previously animated, this method removes the animation and sets the AngleY property to the specified static value.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449065</doc-id>
        /// <unmanaged>HRESULT IDCompositionSkewTransform::SetAngleY([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionSkewTransform::SetAngleY</unmanaged-short>
        public unsafe void SetAngleY(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of the AngleY property of a 2D skew transform. The AngleY property specifies the skew angle along the y-axis.</p>
        /// </summary>
        /// <param name = "angleY"><dd>  <p>The new skew angle of the y-axis, in degrees. A positive value creates a counterclockwise skew, and a negative value creates a clockwise skew. For values less than ?360 or greater than 360, the values wrap around and are treated as if the mathematical operation mod(360) was applied.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method fails if the <em>angleY</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the AngleY property was previously animated, this method removes the animation and sets the AngleY property to the specified static value.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449065</doc-id>
        /// <unmanaged>HRESULT IDCompositionSkewTransform::SetAngleY([In] float angleY)</unmanaged>
        /// <unmanaged-short>IDCompositionSkewTransform::SetAngleY</unmanaged-short>
        public unsafe void SetAngleY(System.Single angleY)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, angleY, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Animates the value of the CenterX property of a 2D skew transform. The CenterX property specifies the x-coordinate of the point about which the skew is performed.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>An animation object that determines how the value of the CenterX property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the CenterX property unless this method is called again. If the CenterX property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449073</doc-id>
        /// <unmanaged>HRESULT IDCompositionSkewTransform::SetCenterX([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionSkewTransform::SetCenterX</unmanaged-short>
        public unsafe void SetCenterX(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Animates the value of the CenterX property of a 2D skew transform. The CenterX property specifies the x-coordinate of the point about which the skew is performed.</p>
        /// </summary>
        /// <param name = "centerX"><dd>  <p>An animation object that determines how the value of the CenterX property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the CenterX property unless this method is called again. If the CenterX property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449073</doc-id>
        /// <unmanaged>HRESULT IDCompositionSkewTransform::SetCenterX([In] float centerX)</unmanaged>
        /// <unmanaged-short>IDCompositionSkewTransform::SetCenterX</unmanaged-short>
        public unsafe void SetCenterX(System.Single centerX)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, centerX, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of the CenterY property of a 2D skew transform. The CenterY property specifies the y-coordinate of the point about which the skew is performed.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>The new y-coordinate of the center point.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method fails if the <em>centerY</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the CenterY property was previously animated, this method removes the animation and sets the CenterY property to the specified static value.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449077</doc-id>
        /// <unmanaged>HRESULT IDCompositionSkewTransform::SetCenterY([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionSkewTransform::SetCenterY</unmanaged-short>
        public unsafe void SetCenterY(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of the CenterY property of a 2D skew transform. The CenterY property specifies the y-coordinate of the point about which the skew is performed.</p>
        /// </summary>
        /// <param name = "centerY"><dd>  <p>The new y-coordinate of the center point.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method fails if the <em>centerY</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the CenterY property was previously animated, this method removes the animation and sets the CenterY property to the specified static value.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449077</doc-id>
        /// <unmanaged>HRESULT IDCompositionSkewTransform::SetCenterY([In] float centerY)</unmanaged>
        /// <unmanaged-short>IDCompositionSkewTransform::SetCenterY</unmanaged-short>
        public unsafe void SetCenterY(System.Single centerY)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, centerY, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("BB8A4953-2C99-4F5A-96F5-4819027FA3AC")]
    public partial class Surface : SharpDX.ComObject
    {
        public Surface(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Surface(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Surface(nativePtr);
        /// <summary>
        /// <p>Initiates drawing on this Microsoft DirectComposition surface object. The update rectangle must be within the boundaries of the surface; otherwise, this method fails. </p>
        /// </summary>
        /// <param name = "updateRect"><dd>  <p>The rectangle to be updated. If this parameter is <c>null</c>, the entire bitmap is updated.</p> </dd></param>
        /// <param name = "iid"><dd>  <p>The identifier of the interface to retrieve.</p> </dd></param>
        /// <param name = "updateObject"><dd>  <p>Receives an interface reference of the type specified in the <em>iid</em> parameter.   This parameter must not be <c>null</c>.</p> <strong>Note</strong>??In Windows?8, this parameter was <em>surface</em>. ? </dd></param>
        /// <param name = "updateOffset"><dd>  <p>The offset into the surface where the application should draw updated content. This offset will reference the upper left corner of the update rectangle.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. </p></returns>
        /// <remarks>
        /// <p>This method enables an application to incrementally update the contents of a DirectComposition surface object. The application must use the following sequence: </p><ol> <li>Call <strong>BeginDraw</strong> to initiate the incremental update.</li> <li>Use the retrieved surface as a render target and draw the updated contents at the retrieved offset.</li> <li>Call the <strong>IDCompositionSurface::EndDraw</strong> method to finish the update.</li> </ol><p>The update object returned by this method is either a Direct2D device context or a DXGI surface, depending on the value of the <em>iid</em> parameter and on how the DirectComposition surface object was created. If the <em>iid</em> parameter is __uuidof(<see cref = "SharpDX.Direct2D1.DeviceContext"/>), then the returned object is a Direct2D device context that already has the DirectComposition surface selected as a render target. Otherwise, it is a DXGI surface which the application may use as a render target. In either case, the returned object is associated with the Direct2D or DXGI device passed by the application to the DCompositionCreateDevice2 function or the <strong>IDCompositionDevice2::CreateSurfaceFactory</strong> method. </p><p>The <em>iid</em> parameter may only be __uuidof(<see cref = "SharpDX.Direct2D1.DeviceContext"/>) if the DirectComposition surface object was created from a DirectComposition device or surface factory that was, itself, created with an associated Direct2D device. In particular, the application must have called either the DCompositionCreateDevice2 function or the <strong>IDCompositionDevice2::CreateSurfaceFactory</strong> method with a Direct2D device as the <em>renderingDevice</em> parameter. If the DirectComposition surface was created via a surface factory that was not associated with a Direct2D device, or if it was created directly via the <see cref = "SharpDX.DirectComposition.Device2"/> interface and the device was not directly associated with a Direct2D device, then passing __uuidof(<see cref = "SharpDX.Direct2D1.DeviceContext"/>) as the iid parameter causes this method to return E_INVALIDARG. </p><p>If the application successfully retrieves a Direct2D device context as the update object, then the application should not call either the ID2D1DeviceContext::BeginDraw or ID2D1DeviceContext::EndDraw methods on the returned Direct2D device context.
        /// </p><p>The retrieved offset is not necessarily the same as the top-left corner of the requested update rectangle. The application must transform its rendering primitives to draw within a rectangle of the same width and height as the input rectangle, but at the given offset. The application should not draw outside of this rectangle. </p><p>If the <em>updateRectangle</em> parameter is <c>null</c>, the entire surface is updated. In that case, because the retrieved offset still might not be (0,0), the application still needs to transform its rendering primitives accordingly. </p><p>If the surface is not a virtual surface, then the first time the application calls this method for a particular non-virtual surface, the update rectangle must cover the entire surface, either by specifying the full surface in the requested update rectangle, or by specifying <c>null</c> as the <em>updateRectangle</em> parameter. For virtual surfaces, the first call may be any sub-rectangle of the surface. </p><p>Because each call to this method might retrieve a different object in the <em>updateObject</em> surface, the application should not cache the retrieved surface reference. The application should release the retrieved reference as soon as it finishes drawing. </p><p>The retrieved surface rectangle does not contain the previous contents of the bitmap. The application must update every pixel in the update rectangle, either by first clearing the render target, or by issuing enough rendering primitives to fully cover the update rectangle. Because the initial contents of the update surface are undefined, failing to update every pixel leads to undefined behavior. </p><p>Only one DirectComposition surface can be updated at a time. An application must suspend drawing on one surface before beginning or resuming to draw on another surface. If the application calls <strong>BeginDraw</strong> twice, either for the same surface or for another surface belonging to the same DirectComposition device, without an intervening call to <strong>IDCompositionSurface::EndDraw</strong>, the second call fails. If the application calls <strong>IDCompositionDevice2::Commit</strong> without calling <strong>EndDraw</strong>, the update remains pending. The update takes effect only after the application calls <strong>EndDraw</strong> and then  calls the <strong>IDCompositionDevice2::Commit</strong> method.</p>
        /// </remarks>
        /// <doc-id>hh449100</doc-id>
        /// <unmanaged>HRESULT IDCompositionSurface::BeginDraw([In, Optional] const RECT* updateRect,[In] const GUID&amp; iid,[Out] void** updateObject,[Out] POINT* updateOffset)</unmanaged>
        /// <unmanaged-short>IDCompositionSurface::BeginDraw</unmanaged-short>
        public unsafe void BeginDraw(SharpDX.Mathematics.Interop.RawRectangle? updateRect, System.Guid iid, out System.IntPtr updateObject, out SharpDX.Mathematics.Interop.RawPoint updateOffset)
        {
            SharpDX.Mathematics.Interop.RawRectangle updateRect_;
            updateOffset = default (SharpDX.Mathematics.Interop.RawPoint);
            SharpDX.Result __result__;
            if (updateRect != null)
                updateRect_ = updateRect.Value;
            fixed (void *updateOffset_ = &updateOffset)
                fixed (void *updateObject_ = &updateObject)
                    __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, updateRect == null ? (void *)0 : &updateRect_, &iid, updateObject_, updateOffset_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Marks the end of drawing on this Microsoft DirectComposition surface object.</p>
        /// </summary>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code, which can include DCOMPOSITION_ERROR_SURFACE_NOT_BEING_RENDERED. </p></returns>
        /// <remarks>
        /// <p>This method completes an update that was begun by a previous call to the <strong>IDCompositionSurface::BeginDraw</strong> method. After this method returns, the application can start another update on the same surface object or on a different one. </p><p>If the application calls <strong>IDCompositionDevice2::Commit</strong> before calling <strong>IDCompositionSurface::EndDraw</strong> for a surface with a pending update, that update is not processed by that Commit call. The update only takes effect on screen after the application calls <strong>IDCompositionSurface::EndDraw</strong> followed by the IDCompositionDevice2::Commit method.</p>
        /// </remarks>
        /// <doc-id>hh449102</doc-id>
        /// <unmanaged>HRESULT IDCompositionSurface::EndDraw()</unmanaged>
        /// <unmanaged-short>IDCompositionSurface::EndDraw</unmanaged-short>
        public unsafe void EndDraw()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Suspends the drawing on this Microsoft DirectComposition surface object.</p>
        /// </summary>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code, which can include DCOMPOSITION_ERROR_SURFACE_BEING_RENDERED and DCOMPOSITION_ERROR_SURFACE_NOT_BEING_RENDERED. </p></returns>
        /// <remarks>
        /// <p>Because only one surface can be open for drawing at a time, calling <strong>SuspendDraw</strong> allows the user to call <strong>IDCompositionSurface::BeginDraw</strong> on a different surface. Drawing to this surface can be resumed by calling <strong>IDCompositionSurface::ResumeDraw</strong>.</p>
        /// </remarks>
        /// <doc-id>hh449106</doc-id>
        /// <unmanaged>HRESULT IDCompositionSurface::SuspendDraw()</unmanaged>
        /// <unmanaged-short>IDCompositionSurface::SuspendDraw</unmanaged-short>
        public unsafe void SuspendDraw()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Resumes drawing on this Microsoft DirectComposition surface object.</p>
        /// </summary>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code, which can include DCOMPOSITION_ERROR_SURFACE_BEING_RENDERED and DCOMPOSITION_ERROR_SURFACE_NOT_BEING_RENDERED. </p></returns>
        /// <remarks>
        /// <p> This method allows the surface update to continue unless there are other surfaces that have active, unsuspended draws.</p>
        /// </remarks>
        /// <doc-id>hh449104</doc-id>
        /// <unmanaged>HRESULT IDCompositionSurface::ResumeDraw()</unmanaged>
        /// <unmanaged-short>IDCompositionSurface::ResumeDraw</unmanaged-short>
        public unsafe void ResumeDraw()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Scrolls a rectangular area of a Microsoft DirectComposition logical surface.</p>
        /// </summary>
        /// <param name = "scrollRect"><dd> <p>The rectangular area of the surface to be scrolled, relative to the upper-left corner of the surface. If this parameter is <c>null</c>, the entire surface is scrolled.</p> </dd></param>
        /// <param name = "clipRect"><dd> <p>The <em>clipRect</em> clips the destination (<em>scrollRect</em> after offset) of the scroll.The only bitmap content that will be scrolled are those that remain inside the clip rectangle after the scroll is completed.</p> </dd></param>
        /// <param name = "offsetX"><dd> <p>The amount of horizontal scrolling, in pixels. Use positive values to scroll right, and negative values to scroll left.</p> </dd></param>
        /// <param name = "offsetY"><dd> <p>The amount of vertical scrolling, in pixels. Use positive values to scroll down, and negative values to scroll up.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method allows an application to blt/copy a sub-rectangle of a DirectComposition surface object. This avoids re-rendering content that is already available.   </p><p>The <em>scrollRect</em> rectangle must be contained in the boundaries of the surface.  If the <em>scrollRect</em> rectangle goes outside the bounds of the surface, this method fails. </p><p>The bits copied by the scroll operation (source) are defined by the intersection of the <em>scrollRect</em> and <em>clipRect</em> rectangles.  </p><p>The bits shown on the screen (destination) are defined by the intersection of the offset source rectangle and <em>clipRect</em>. </p><p>Scroll operations can only be called before calling <strong>BeginDraw</strong> or after calling <strong>EndDraw</strong>.  Suspended or resumed surfaces are not candidates for scrolling because they are still being updated. </p><p>The application is responsible for ensuring that the scrollable area for an <strong><see cref = "SharpDX.DirectComposition.VirtualSurface"/></strong> is limited to valid pixels. The behavior for invalid pixels in the <em>scrollRect</em> is undefined.  </p><p>Virtual surface sub-rectangular areas that were discarded by a trim or a resize operation can't be scrolled even if the trim or resize is applied in the same batch.  <strong>Trim</strong> and <strong>Resize</strong> are applied immediately. </p>
        /// </remarks>
        /// <doc-id>hh707486</doc-id>
        /// <unmanaged>HRESULT IDCompositionSurface::Scroll([In, Optional] const RECT* scrollRect,[In, Optional] const RECT* clipRect,[In] int offsetX,[In] int offsetY)</unmanaged>
        /// <unmanaged-short>IDCompositionSurface::Scroll</unmanaged-short>
        public unsafe void Scroll(SharpDX.Mathematics.Interop.RawRectangle? scrollRect, SharpDX.Mathematics.Interop.RawRectangle? clipRect, System.Int32 offsetX, System.Int32 offsetY)
        {
            SharpDX.Mathematics.Interop.RawRectangle scrollRect_;
            SharpDX.Mathematics.Interop.RawRectangle clipRect_;
            SharpDX.Result __result__;
            if (scrollRect != null)
                scrollRect_ = scrollRect.Value;
            if (clipRect != null)
                clipRect_ = clipRect.Value;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, scrollRect == null ? (void *)0 : &scrollRect_, clipRect == null ? (void *)0 : &clipRect_, offsetX, offsetY, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("E334BC12-3937-4E02-85EB-FCF4EB30D2C8")]
    public partial class SurfaceFactory : SharpDX.ComObject
    {
        public SurfaceFactory(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator SurfaceFactory(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new SurfaceFactory(nativePtr);
        /// <summary>
        /// <p>Creates a surface object that can be associated with one or more visuals for composition.</p>
        /// </summary>
        /// <param name = "width"><dd> <p>The width of the surface, in pixels.</p> </dd></param>
        /// <param name = "height"><dd> <p>The height of the surface, in pixels.</p> </dd></param>
        /// <param name = "pixelFormat"><dd> <p>The pixel format of the surface.</p> </dd></param>
        /// <param name = "alphaMode"><dd> <p>The format of the alpha channel, if an alpha channel is included in the pixel format. This can be one of DXGI_ALPHA_MODE_PREMULTIPLIED or DXGI_ALPHA_MODE_IGNORE. It can also be DXGI_ALPHA_MODE_UNSPECIFIED, which is interpreted as DXGI_ALPHA_MODE_IGNORE.</p> </dd></param>
        /// <param name = "surface"><dd> <p> The newly created surface object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>A Microsoft DirectComposition surface is a rectangular array of pixels that can be associated with a visual for composition.  A newly created surface object is in an uninitialized state. While it is uninitialized, the surface has no effect on the composition of the visual tree. It behaves exactly like a surface that has 100% transparent pixels.  </p><p>To initialize the surface with pixel data, use the <strong>IDCompositionSurface::BeginDraw</strong> method. The first call to this method must cover the entire surface area to provide an initial value for every pixel. Subsequent calls may specify smaller sub-rectangles of the surface to update. </p><p>This method will fail if either the width or height exceed the max texture size. If your scenario requires dimensions beyond the max texture size, use <strong>CreateVirtualSurface</strong> method.</p><p>DirectComposition surfaces support the following pixel formats:
        /// </p><ul> <li>DXGI_FORMAT_B8G8R8A8_UNORM
        /// </li> <li>DXGI_FORMAT_R8G8B8A8_UNORM </li> <li>DXGI_FORMAT_R16G16B16A16_FLOAT</li> </ul>
        /// </remarks>
        /// <doc-id>dn280424</doc-id>
        /// <unmanaged>HRESULT IDCompositionSurfaceFactory::CreateSurface([In] unsigned int width,[In] unsigned int height,[In] DXGI_FORMAT pixelFormat,[In] DXGI_ALPHA_MODE alphaMode,[Out, Fast] IDCompositionSurface** surface)</unmanaged>
        /// <unmanaged-short>IDCompositionSurfaceFactory::CreateSurface</unmanaged-short>
        internal unsafe void CreateSurface(System.Int32 width, System.Int32 height, SharpDX.DXGI.Format pixelFormat, SharpDX.DXGI.AlphaMode alphaMode, SharpDX.DirectComposition.Surface surface)
        {
            System.IntPtr surface_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, width, height, unchecked ((System.Int32)pixelFormat), unchecked ((System.Int32)alphaMode), &surface_, (*(void ***)this._nativePointer)[3]);
            (surface).NativePointer = surface_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a sparsely populated surface that can be associated with one or more visuals for composition.</p>
        /// </summary>
        /// <param name = "initialWidth"><dd> <p>The width of the surface, in pixels. The maximum width is 16,777,216 pixels.</p> </dd></param>
        /// <param name = "initialHeight"><dd> <p>The height of the surface, in pixels.The maximum height is 16,777,216 pixels.</p> </dd></param>
        /// <param name = "pixelFormat"><dd> <p>The pixel format of the surface.</p> </dd></param>
        /// <param name = "alphaMode"><dd> <p>The format of the alpha channel, if an alpha channel is included in the pixel format. This can be one of DXGI_ALPHA_MODE_PREMULTIPLIED or DXGI_ALPHA_MODE_IGNORE. It can also be DXGI_ALPHA_MODE_UNSPECIFIED, which is interpreted as DXGI_ALPHA_MODE_IGNORE.</p> </dd></param>
        /// <param name = "virtualSurface"><dd> <p> The newly created virtual surface object. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>A newly created virtual surface object is in an uninitialized state. While it is uninitialized, the surface has no effect on the composition of the visual tree. It behaves exactly like a surface that is initialized with 100% transparent pixels.  </p><p>To initialize the surface with pixel data, use the <strong>IDCompositionSurface::BeginDraw</strong> method. This method not only provides pixels for the surface, but it also allocates actual storage space for those pixels. The memory allocation persists until the application returns some of the memory to the system. The application can free part or all of the allocated memory by calling the <strong>IDCompositionVirtualSurface::Trim</strong> or <strong>IDCompositionVirtualSurface::Resize</strong> method.</p><p>Microsoft DirectComposition surfaces support the following pixel formats:
        /// </p><ul> <li>DXGI_FORMAT_B8G8R8A8_UNORM
        /// </li> <li>DXGI_FORMAT_R8G8B8A8_UNORM </li> <li>DXGI_FORMAT_R16G16B16A16_FLOAT</li> </ul>
        /// </remarks>
        /// <doc-id>dn280425</doc-id>
        /// <unmanaged>HRESULT IDCompositionSurfaceFactory::CreateVirtualSurface([In] unsigned int initialWidth,[In] unsigned int initialHeight,[In] DXGI_FORMAT pixelFormat,[In] DXGI_ALPHA_MODE alphaMode,[Out, Fast] IDCompositionVirtualSurface** virtualSurface)</unmanaged>
        /// <unmanaged-short>IDCompositionSurfaceFactory::CreateVirtualSurface</unmanaged-short>
        internal unsafe void CreateVirtualSurface(System.Int32 initialWidth, System.Int32 initialHeight, SharpDX.DXGI.Format pixelFormat, SharpDX.DXGI.AlphaMode alphaMode, SharpDX.DirectComposition.VirtualSurface virtualSurface)
        {
            System.IntPtr virtualSurface_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, initialWidth, initialHeight, unchecked ((System.Int32)pixelFormat), unchecked ((System.Int32)alphaMode), &virtualSurface_, (*(void ***)this._nativePointer)[4]);
            (virtualSurface).NativePointer = virtualSurface_;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("9B7E82E2-69C5-4EB4-A5F5-A7033F5132CD")]
    public partial class TableTransferEffect : SharpDX.DirectComposition.FilterEffect
    {
        public TableTransferEffect(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator TableTransferEffect(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new TableTransferEffect(nativePtr);
        /// <summary>
        /// <p>Specifies whether to apply the transfer function to the red channel.</p>
        /// </summary>
        /// <doc-id>dn919797</doc-id>
        /// <unmanaged>SetRedDisable</unmanaged>
        /// <unmanaged-short>SetRedDisable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool RedDisable
        {
            set => SetRedDisable(value);
        }

        /// <summary>
        /// <p>Specifies whether to apply the transfer function to the green channel.</p>
        /// </summary>
        /// <doc-id>dn919793</doc-id>
        /// <unmanaged>SetGreenDisable</unmanaged>
        /// <unmanaged-short>SetGreenDisable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool GreenDisable
        {
            set => SetGreenDisable(value);
        }

        /// <summary>
        /// <p>Specifies whether to apply the transfer function to the blue channel.</p>
        /// </summary>
        /// <doc-id>dn919788</doc-id>
        /// <unmanaged>SetBlueDisable</unmanaged>
        /// <unmanaged-short>SetBlueDisable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool BlueDisable
        {
            set => SetBlueDisable(value);
        }

        /// <summary>
        /// <p>Specifies whether to apply the transfer function to the Alpha channel.</p>
        /// </summary>
        /// <doc-id>dn919784</doc-id>
        /// <unmanaged>SetAlphaDisable</unmanaged>
        /// <unmanaged-short>SetAlphaDisable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool AlphaDisable
        {
            set => SetAlphaDisable(value);
        }

        /// <summary>
        /// <p>Specifies whether the effect clamps color values to between 0 and 1 before the effect passes the values to the next effect in the graph.</p>
        /// </summary>
        /// <doc-id>dn919792</doc-id>
        /// <unmanaged>SetClampOutput</unmanaged>
        /// <unmanaged-short>SetClampOutput</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool ClampOutput
        {
            set => SetClampOutput(value);
        }

        /// <summary>
        /// <p>Sets the list of values used to define the transfer function for the red channel.</p>
        /// </summary>
        /// <param name = "tableValues"><dd>  <p>The list of values used to define the transfer function for the red channel.</p> </dd></param>
        /// <param name = "count"><dd>  <p>The number of values in the tableValues parameter.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919798</doc-id>
        /// <unmanaged>HRESULT IDCompositionTableTransferEffect::SetRedTable([In, Buffer] const float* tableValues,[In] unsigned int count)</unmanaged>
        /// <unmanaged-short>IDCompositionTableTransferEffect::SetRedTable</unmanaged-short>
        public unsafe void SetRedTable(System.Single[] tableValues, System.Int32 count)
        {
            SharpDX.Result __result__;
            fixed (void *tableValues_ = tableValues)
                __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, tableValues_, count, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the list of values used to define the transfer function for the green channel.</p>
        /// </summary>
        /// <param name = "tableValues"><dd>  <p>The list of values used to define the transfer function for the green channel.</p> </dd></param>
        /// <param name = "count"><dd>  <p>The number of values in the tableValues parameter.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919794</doc-id>
        /// <unmanaged>HRESULT IDCompositionTableTransferEffect::SetGreenTable([In, Buffer] const float* tableValues,[In] unsigned int count)</unmanaged>
        /// <unmanaged-short>IDCompositionTableTransferEffect::SetGreenTable</unmanaged-short>
        public unsafe void SetGreenTable(System.Single[] tableValues, System.Int32 count)
        {
            SharpDX.Result __result__;
            fixed (void *tableValues_ = tableValues)
                __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, tableValues_, count, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the list of values used to define the transfer function for the blue channel.</p>
        /// </summary>
        /// <param name = "tableValues"><dd>  <p>The list of values used to define the transfer function for the blue channel.</p> </dd></param>
        /// <param name = "count"><dd>  <p>The number of values in the tableValues parameter.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919789</doc-id>
        /// <unmanaged>HRESULT IDCompositionTableTransferEffect::SetBlueTable([In, Buffer] const float* tableValues,[In] unsigned int count)</unmanaged>
        /// <unmanaged-short>IDCompositionTableTransferEffect::SetBlueTable</unmanaged-short>
        public unsafe void SetBlueTable(System.Single[] tableValues, System.Int32 count)
        {
            SharpDX.Result __result__;
            fixed (void *tableValues_ = tableValues)
                __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, tableValues_, count, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the list of values used to define the transfer function for the alpha channel.</p>
        /// </summary>
        /// <param name = "tableValues"><dd>  <p>The list of values used to define the transfer function for the alpha channel.</p> </dd></param>
        /// <param name = "count"><dd>  <p>The number of values in the tableValues parameter.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919785</doc-id>
        /// <unmanaged>HRESULT IDCompositionTableTransferEffect::SetAlphaTable([In, Buffer] const float* tableValues,[In] unsigned int count)</unmanaged>
        /// <unmanaged-short>IDCompositionTableTransferEffect::SetAlphaTable</unmanaged-short>
        public unsafe void SetAlphaTable(System.Single[] tableValues, System.Int32 count)
        {
            SharpDX.Result __result__;
            fixed (void *tableValues_ = tableValues)
                __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, tableValues_, count, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Specifies whether to apply the transfer function to the red channel.</p>
        /// </summary>
        /// <param name = "redDisable"><dd>  <p> A boolean value that specifies whether to apply the transfer function to the red channel. If you set this to TRUE the effect does not apply the transfer function to the red channel. If you set this to <see cref = "SharpDX.Result.False"/> it applies the RedTableTransfer function to the red channel. </p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919797</doc-id>
        /// <unmanaged>HRESULT IDCompositionTableTransferEffect::SetRedDisable([In] BOOL redDisable)</unmanaged>
        /// <unmanaged-short>IDCompositionTableTransferEffect::SetRedDisable</unmanaged-short>
        internal unsafe void SetRedDisable(SharpDX.Mathematics.Interop.RawBool redDisable)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint0(this._nativePointer, redDisable, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Specifies whether to apply the transfer function to the green channel.</p>
        /// </summary>
        /// <param name = "greenDisable"><dd>  <p> A boolean value that specifies whether to apply the transfer function to the green channel. If you set this to TRUE the effect does not apply the transfer function to the green channel. If you set this to <see cref = "SharpDX.Result.False"/> it applies the GreenTableTransfer function to the green channel. </p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919793</doc-id>
        /// <unmanaged>HRESULT IDCompositionTableTransferEffect::SetGreenDisable([In] BOOL greenDisable)</unmanaged>
        /// <unmanaged-short>IDCompositionTableTransferEffect::SetGreenDisable</unmanaged-short>
        internal unsafe void SetGreenDisable(SharpDX.Mathematics.Interop.RawBool greenDisable)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint0(this._nativePointer, greenDisable, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Specifies whether to apply the transfer function to the blue channel.</p>
        /// </summary>
        /// <param name = "blueDisable"><dd>  <p> A boolean value that specifies whether to apply the transfer function to the blue channel. If you set this to TRUE the effect does not apply the transfer function to the blue channel. If you set this to <see cref = "SharpDX.Result.False"/> it applies the BlueTableTransfer function to the Blue channel. </p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919788</doc-id>
        /// <unmanaged>HRESULT IDCompositionTableTransferEffect::SetBlueDisable([In] BOOL blueDisable)</unmanaged>
        /// <unmanaged-short>IDCompositionTableTransferEffect::SetBlueDisable</unmanaged-short>
        internal unsafe void SetBlueDisable(SharpDX.Mathematics.Interop.RawBool blueDisable)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint0(this._nativePointer, blueDisable, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Specifies whether to apply the transfer function to the Alpha channel.</p>
        /// </summary>
        /// <param name = "alphaDisable"><dd>  <p> A boolean value that specifies whether to apply the transfer function to the alpha channel. If you set this to TRUE the effect does not apply the transfer function to the Alpha channel. If you set this to <see cref = "SharpDX.Result.False"/> it applies the AlphaTableTransfer function to the Alpha channel. </p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919784</doc-id>
        /// <unmanaged>HRESULT IDCompositionTableTransferEffect::SetAlphaDisable([In] BOOL alphaDisable)</unmanaged>
        /// <unmanaged-short>IDCompositionTableTransferEffect::SetAlphaDisable</unmanaged-short>
        internal unsafe void SetAlphaDisable(SharpDX.Mathematics.Interop.RawBool alphaDisable)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint0(this._nativePointer, alphaDisable, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Specifies whether the effect clamps color values to between 0 and 1 before the effect passes the values to the next effect in the graph.</p>
        /// </summary>
        /// <param name = "clampOutput"><dd>  <p> A boolean value that specifies whether the effect clamps color values to between 0 and 1 before the effect passes the values to the next effect in the graph. If you set this to TRUE the effect will clamp the values. If you set this to <see cref = "SharpDX.Result.False"/>, the effect will not clamp the color values, but other effects and the output surface may clamp the values if they are not of high enough precision. The effect clamps the values before it premultiplies the alpha. </p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919792</doc-id>
        /// <unmanaged>HRESULT IDCompositionTableTransferEffect::SetClampOutput([In] BOOL clampOutput)</unmanaged>
        /// <unmanaged-short>IDCompositionTableTransferEffect::SetClampOutput</unmanaged-short>
        internal unsafe void SetClampOutput(SharpDX.Mathematics.Interop.RawBool clampOutput)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint0(this._nativePointer, clampOutput, (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets a value in the red table.</p>
        /// </summary>
        /// <param name = "index"><dd>  <p>The index of the value to set.</p> </dd></param>
        /// <param name = "animation"><dd>  <p>An animation that represents how the value changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919800</doc-id>
        /// <unmanaged>HRESULT IDCompositionTableTransferEffect::SetRedTableValue([In] unsigned int index,[In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionTableTransferEffect::SetRedTableValue</unmanaged-short>
        public unsafe void SetRedTableValue(System.Int32 index, SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, index, (void *)animation_, (*(void ***)this._nativePointer)[13]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets a value in the red table.</p>
        /// </summary>
        /// <param name = "index"><dd>  <p>The index of the value to set.</p> </dd></param>
        /// <param name = "value"><dd>  <p>An animation that represents how the value changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919800</doc-id>
        /// <unmanaged>HRESULT IDCompositionTableTransferEffect::SetRedTableValue([In] unsigned int index,[In] float value)</unmanaged>
        /// <unmanaged-short>IDCompositionTableTransferEffect::SetRedTableValue</unmanaged-short>
        public unsafe void SetRedTableValue(System.Int32 index, System.Single value)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, index, value, (*(void ***)this._nativePointer)[14]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets a value in the green table.</p>
        /// </summary>
        /// <param name = "index"><dd>  <p>The index of the value to set.</p> </dd></param>
        /// <param name = "animation"><dd>  <p>The value to set.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919795</doc-id>
        /// <unmanaged>HRESULT IDCompositionTableTransferEffect::SetGreenTableValue([In] unsigned int index,[In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionTableTransferEffect::SetGreenTableValue</unmanaged-short>
        public unsafe void SetGreenTableValue(System.Int32 index, SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, index, (void *)animation_, (*(void ***)this._nativePointer)[15]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets a value in the green table.</p>
        /// </summary>
        /// <param name = "index"><dd>  <p>The index of the value to set.</p> </dd></param>
        /// <param name = "value"><dd>  <p>The value to set.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919795</doc-id>
        /// <unmanaged>HRESULT IDCompositionTableTransferEffect::SetGreenTableValue([In] unsigned int index,[In] float value)</unmanaged>
        /// <unmanaged-short>IDCompositionTableTransferEffect::SetGreenTableValue</unmanaged-short>
        public unsafe void SetGreenTableValue(System.Int32 index, System.Single value)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, index, value, (*(void ***)this._nativePointer)[16]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets a value in the blue table.</p>
        /// </summary>
        /// <param name = "index"><dd>  <p>The index of the value to set.</p> </dd></param>
        /// <param name = "animation"><dd>  <p>An animation that represents how the value changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919791</doc-id>
        /// <unmanaged>HRESULT IDCompositionTableTransferEffect::SetBlueTableValue([In] unsigned int index,[In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionTableTransferEffect::SetBlueTableValue</unmanaged-short>
        public unsafe void SetBlueTableValue(System.Int32 index, SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, index, (void *)animation_, (*(void ***)this._nativePointer)[17]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets a value in the blue table.</p>
        /// </summary>
        /// <param name = "index"><dd>  <p>The index of the value to set.</p> </dd></param>
        /// <param name = "value"><dd>  <p>An animation that represents how the value changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919791</doc-id>
        /// <unmanaged>HRESULT IDCompositionTableTransferEffect::SetBlueTableValue([In] unsigned int index,[In] float value)</unmanaged>
        /// <unmanaged-short>IDCompositionTableTransferEffect::SetBlueTableValue</unmanaged-short>
        public unsafe void SetBlueTableValue(System.Int32 index, System.Single value)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, index, value, (*(void ***)this._nativePointer)[18]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets a value in the alpha table.</p>
        /// </summary>
        /// <param name = "index"><dd>  <p>The index of the value to set.</p> </dd></param>
        /// <param name = "animation"><dd>  <p>The new value.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919786</doc-id>
        /// <unmanaged>HRESULT IDCompositionTableTransferEffect::SetAlphaTableValue([In] unsigned int index,[In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionTableTransferEffect::SetAlphaTableValue</unmanaged-short>
        public unsafe void SetAlphaTableValue(System.Int32 index, SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, index, (void *)animation_, (*(void ***)this._nativePointer)[19]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets a value in the alpha table.</p>
        /// </summary>
        /// <param name = "index"><dd>  <p>The index of the value to set.</p> </dd></param>
        /// <param name = "value"><dd>  <p>The new value.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919786</doc-id>
        /// <unmanaged>HRESULT IDCompositionTableTransferEffect::SetAlphaTableValue([In] unsigned int index,[In] float value)</unmanaged>
        /// <unmanaged-short>IDCompositionTableTransferEffect::SetAlphaTableValue</unmanaged-short>
        public unsafe void SetAlphaTableValue(System.Int32 index, System.Single value)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, index, value, (*(void ***)this._nativePointer)[20]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("eacdd04c-117e-4e17-88f4-d1b12b0e3d89")]
    public partial class Target : SharpDX.ComObject
    {
        public Target(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Target(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Target(nativePtr);
        /// <summary>
        /// <p>Sets a visual object as the new root object of a visual tree.</p>
        /// </summary>
        /// <remarks>
        /// <p>A visual can be either the root of a single visual tree, or a child of another visual, but it cannot be both at the same time. This method fails if the <em>visual</em> parameter is already the root of another visual tree, or is a child of another visual.</p><p>If <em>visual</em> is <c>null</c>, the visual tree is empty. If there was a previous non-<c>null</c> root visual, that visual becomes available for use as the root of another visual tree, or as a child of another visual.</p>
        /// </remarks>
        /// <doc-id>hh449109</doc-id>
        /// <unmanaged>SetRoot</unmanaged>
        /// <unmanaged-short>SetRoot</unmanaged-short>
        public SharpDX.DirectComposition.Visual Root
        {
            set => SetRoot(value);
        }

        /// <summary>
        /// <p>Sets a visual object as the new root object of a visual tree.</p>
        /// </summary>
        /// <param name = "visual"><dd>  <p>The visual object that is the new root of this visual tree. This parameter can be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>A visual can be either the root of a single visual tree, or a child of another visual, but it cannot be both at the same time. This method fails if the <em>visual</em> parameter is already the root of another visual tree, or is a child of another visual.</p><p>If <em>visual</em> is <c>null</c>, the visual tree is empty. If there was a previous non-<c>null</c> root visual, that visual becomes available for use as the root of another visual tree, or as a child of another visual.</p>
        /// </remarks>
        /// <doc-id>hh449109</doc-id>
        /// <unmanaged>HRESULT IDCompositionTarget::SetRoot([In, Optional] IDCompositionVisual* visual)</unmanaged>
        /// <unmanaged-short>IDCompositionTarget::SetRoot</unmanaged-short>
        internal unsafe void SetRoot(SharpDX.DirectComposition.Visual visual)
        {
            System.IntPtr visual_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            visual_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Visual>(visual);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)visual_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("FD55FAA7-37E0-4c20-95D2-9BE45BC33F55")]
    public partial class Transform : SharpDX.DirectComposition.Transform3D
    {
        public Transform(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Transform(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Transform(nativePtr);
    }

    [System.Runtime.InteropServices.GuidAttribute("71185722-246B-41f2-AAD1-0443F7F4BFC2")]
    public partial class Transform3D : SharpDX.DirectComposition.Effect
    {
        public Transform3D(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Transform3D(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Transform3D(nativePtr);
    }

    [System.Runtime.InteropServices.GuidAttribute("06791122-C6F0-417d-8323-269E987F5954")]
    public partial class TranslateTransform : SharpDX.DirectComposition.Transform
    {
        public TranslateTransform(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator TranslateTransform(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new TranslateTransform(nativePtr);
        /// <summary>
        /// <p>Changes the value of the OffsetX property of a 2D translation transform. The OffsetX property specifies the distance to translate along the x-axis.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p> The distance to translate along the x-axis, in pixels.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method perfoms an affine transformation, which moves every point by a fixed distance in the same direction. It is similar to shifting the origin of the coordinate space. </p><p>This method fails if the <em>offsetX</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the OffsetX property was previously animated, this method removes the animation and sets the OffsetX property to the specified static value.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449124</doc-id>
        /// <unmanaged>HRESULT IDCompositionTranslateTransform::SetOffsetX([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionTranslateTransform::SetOffsetX</unmanaged-short>
        public unsafe void SetOffsetX(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of the OffsetX property of a 2D translation transform. The OffsetX property specifies the distance to translate along the x-axis.</p>
        /// </summary>
        /// <param name = "offsetX"><dd>  <p> The distance to translate along the x-axis, in pixels.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method perfoms an affine transformation, which moves every point by a fixed distance in the same direction. It is similar to shifting the origin of the coordinate space. </p><p>This method fails if the <em>offsetX</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the OffsetX property was previously animated, this method removes the animation and sets the OffsetX property to the specified static value.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449124</doc-id>
        /// <unmanaged>HRESULT IDCompositionTranslateTransform::SetOffsetX([In] float offsetX)</unmanaged>
        /// <unmanaged-short>IDCompositionTranslateTransform::SetOffsetX</unmanaged-short>
        public unsafe void SetOffsetX(System.Single offsetX)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, offsetX, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// Changes or animates the value of the OffsetY property of a 2D translation transform. The OffsetY property specifies the translation along the y-axis.
        /// </summary>
        /// <param name = "animation">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <doc-id>hh449131</doc-id>
        /// <unmanaged>HRESULT IDCompositionTranslateTransform::SetOffsetY([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionTranslateTransform::SetOffsetY</unmanaged-short>
        public unsafe void SetOffsetY(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// Changes or animates the value of the OffsetY property of a 2D translation transform. The OffsetY property specifies the translation along the y-axis.
        /// </summary>
        /// <param name = "offsetY">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <doc-id>hh449131</doc-id>
        /// <unmanaged>HRESULT IDCompositionTranslateTransform::SetOffsetY([In] float offsetY)</unmanaged>
        /// <unmanaged-short>IDCompositionTranslateTransform::SetOffsetY</unmanaged-short>
        public unsafe void SetOffsetY(System.Single offsetY)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, offsetY, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("91636D4B-9BA1-4532-AAF7-E3344994D788")]
    public partial class TranslateTransform3D : SharpDX.DirectComposition.Transform3D
    {
        public TranslateTransform3D(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator TranslateTransform3D(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new TranslateTransform3D(nativePtr);
        /// <summary>
        /// <p>Animates the value of the OffsetX property of a 3D translation transform effect. The OffsetX property specifies the distance to translate along the x-axis.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>An animation object that determines how the value of the OffsetX property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the OffsetX property unless this method is called again. If the OffsetX property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449116</doc-id>
        /// <unmanaged>HRESULT IDCompositionTranslateTransform3D::SetOffsetX([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionTranslateTransform3D::SetOffsetX</unmanaged-short>
        public unsafe void SetOffsetX(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Animates the value of the OffsetX property of a 3D translation transform effect. The OffsetX property specifies the distance to translate along the x-axis.</p>
        /// </summary>
        /// <param name = "offsetX"><dd>  <p>An animation object that determines how the value of the OffsetX property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the OffsetX property unless this method is called again. If the OffsetX property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449116</doc-id>
        /// <unmanaged>HRESULT IDCompositionTranslateTransform3D::SetOffsetX([In] float offsetX)</unmanaged>
        /// <unmanaged-short>IDCompositionTranslateTransform3D::SetOffsetX</unmanaged-short>
        public unsafe void SetOffsetX(System.Single offsetX)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, offsetX, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Animates the value of the OffsetY property of a 3D translation transform effect. The OffsetY property specifies the distance to translate along the y-axis.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>An animation object that determines how the value of the OffsetY property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the OffsetY property unless this method is called again. If the OffsetY property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449119</doc-id>
        /// <unmanaged>HRESULT IDCompositionTranslateTransform3D::SetOffsetY([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionTranslateTransform3D::SetOffsetY</unmanaged-short>
        public unsafe void SetOffsetY(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Animates the value of the OffsetY property of a 3D translation transform effect. The OffsetY property specifies the distance to translate along the y-axis.</p>
        /// </summary>
        /// <param name = "offsetY"><dd>  <p>An animation object that determines how the value of the OffsetY property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the OffsetY property unless this method is called again. If the OffsetY property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449119</doc-id>
        /// <unmanaged>HRESULT IDCompositionTranslateTransform3D::SetOffsetY([In] float offsetY)</unmanaged>
        /// <unmanaged-short>IDCompositionTranslateTransform3D::SetOffsetY</unmanaged-short>
        public unsafe void SetOffsetY(System.Single offsetY)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, offsetY, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Animates the value of the OffsetZ property of a 3D translation transform effect. The OffsetZ property specifies the distance to translate along the z-axis.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>An animation object that determines how the value of the OffsetZ property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the OffsetZ property unless this method is called again. If the OffsetZ property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface that created the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449122</doc-id>
        /// <unmanaged>HRESULT IDCompositionTranslateTransform3D::SetOffsetZ([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionTranslateTransform3D::SetOffsetZ</unmanaged-short>
        public unsafe void SetOffsetZ(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Animates the value of the OffsetZ property of a 3D translation transform effect. The OffsetZ property specifies the distance to translate along the z-axis.</p>
        /// </summary>
        /// <param name = "offsetZ"><dd>  <p>An animation object that determines how the value of the OffsetZ property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the OffsetZ property unless this method is called again. If the OffsetZ property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface that created the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449122</doc-id>
        /// <unmanaged>HRESULT IDCompositionTranslateTransform3D::SetOffsetZ([In] float offsetZ)</unmanaged>
        /// <unmanaged-short>IDCompositionTranslateTransform3D::SetOffsetZ</unmanaged-short>
        public unsafe void SetOffsetZ(System.Single offsetZ)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, offsetZ, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("A6A55BDA-C09C-49F3-9193-A41922C89715")]
    public partial class TurbulenceEffect : SharpDX.DirectComposition.FilterEffect
    {
        public TurbulenceEffect(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator TurbulenceEffect(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new TurbulenceEffect(nativePtr);
        /// <summary>
        /// <p>Sets the coordinates where the turbulence output is generated.</p>
        /// </summary>
        /// <doc-id>dn919805</doc-id>
        /// <unmanaged>SetOffset</unmanaged>
        /// <unmanaged-short>SetOffset</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 Offset
        {
            set => SetOffset(value);
        }

        /// <summary>
        /// <p>Sets the base frequencies in the X and Y direction.</p>
        /// </summary>
        /// <doc-id>dn919802</doc-id>
        /// <unmanaged>SetBaseFrequency</unmanaged>
        /// <unmanaged-short>SetBaseFrequency</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 BaseFrequency
        {
            set => SetBaseFrequency(value);
        }

        /// <summary>
        /// <p>Sets the size of the turbulence output.</p>
        /// </summary>
        /// <doc-id>dn919807</doc-id>
        /// <unmanaged>SetSize</unmanaged>
        /// <unmanaged-short>SetSize</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 Size
        {
            set => SetSize(value);
        }

        /// <summary>
        /// <p>Sets the number of octaves for the noise function.</p>
        /// </summary>
        /// <doc-id>dn919804</doc-id>
        /// <unmanaged>SetNumOctaves</unmanaged>
        /// <unmanaged-short>SetNumOctaves</unmanaged-short>
        public System.Int32 NumOctaves
        {
            set => SetNumOctaves(value);
        }

        /// <summary>
        /// <p>Sets the seed for the pseudo random generator.</p>
        /// </summary>
        /// <doc-id>dn919806</doc-id>
        /// <unmanaged>SetSeed</unmanaged>
        /// <unmanaged-short>SetSeed</unmanaged-short>
        public System.Int32 Seed
        {
            set => SetSeed(value);
        }

        /// <summary>
        /// <p>Sets the turbulence noise mode.</p>
        /// </summary>
        /// <doc-id>dn919803</doc-id>
        /// <unmanaged>SetNoise</unmanaged>
        /// <unmanaged-short>SetNoise</unmanaged-short>
        public SharpDX.Direct2D1.TurbulenceNoise Noise
        {
            set => SetNoise(value);
        }

        /// <summary>
        /// <p>Specifies whether stitching is on or off.</p>
        /// </summary>
        /// <doc-id>dn919808</doc-id>
        /// <unmanaged>SetStitchable</unmanaged>
        /// <unmanaged-short>SetStitchable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool Stitchable
        {
            set => SetStitchable(value);
        }

        /// <summary>
        /// <p>Sets the coordinates where the turbulence output is generated.</p>
        /// </summary>
        /// <param name = "offset"><dd>  <p> The coordinates where the turbulence output is generated. The algorithm used to generate the Perlin noise is position dependent, so a different offset results in a different output. This value is not bounded and the units are specified in DIPs </p> <strong>Note</strong>??Note  The offset does not have the same effect as a translation because the noise function output is infinite and the function will wrap around the tile. ? </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919805</doc-id>
        /// <unmanaged>HRESULT IDCompositionTurbulenceEffect::SetOffset([In] const D2D_VECTOR_2F&amp; offset)</unmanaged>
        /// <unmanaged-short>IDCompositionTurbulenceEffect::SetOffset</unmanaged-short>
        internal unsafe void SetOffset(SharpDX.Mathematics.Interop.RawVector2 offset)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &offset, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the base frequencies in the X and Y direction.</p>
        /// </summary>
        /// <param name = "frequency"><dd>  <p> The base frequencies in the X and Y direction. This must be greater than 0. The units are specified in 1/DIPs. A value of 1 (1/DIPs) for the base frequency results in the Perlin noise completing an entire cycle between two pixels. The ease interpolation for these pixels results in completely random pixels, since there is no correlation between the pixels. A value of 0.1(1/DIPs) for the base frequency results in the Perlin noise function repeating every 10 DIPs. This results in correlation between pixels and the typical turbulence effect is visible. </p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919802</doc-id>
        /// <unmanaged>HRESULT IDCompositionTurbulenceEffect::SetBaseFrequency([In] const D2D_VECTOR_2F&amp; frequency)</unmanaged>
        /// <unmanaged-short>IDCompositionTurbulenceEffect::SetBaseFrequency</unmanaged-short>
        internal unsafe void SetBaseFrequency(SharpDX.Mathematics.Interop.RawVector2 frequency)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &frequency, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the size of the turbulence output.</p>
        /// </summary>
        /// <param name = "size"><dd>  <p>The size of the turbulence output</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919807</doc-id>
        /// <unmanaged>HRESULT IDCompositionTurbulenceEffect::SetSize([In] const D2D_VECTOR_2F&amp; size)</unmanaged>
        /// <unmanaged-short>IDCompositionTurbulenceEffect::SetSize</unmanaged-short>
        internal unsafe void SetSize(SharpDX.Mathematics.Interop.RawVector2 size)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &size, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the number of octaves for the noise function.</p>
        /// </summary>
        /// <param name = "numOctaves"><dd>  <p>The number of octaves for the noise function. This value must be greater than 0.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919804</doc-id>
        /// <unmanaged>HRESULT IDCompositionTurbulenceEffect::SetNumOctaves([In] unsigned int numOctaves)</unmanaged>
        /// <unmanaged-short>IDCompositionTurbulenceEffect::SetNumOctaves</unmanaged-short>
        internal unsafe void SetNumOctaves(System.Int32 numOctaves)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, numOctaves, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the seed for the pseudo random generator.</p>
        /// </summary>
        /// <param name = "seed"><dd>  <p>The seed for the pseudo random generator. This value is unbounded.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919806</doc-id>
        /// <unmanaged>HRESULT IDCompositionTurbulenceEffect::SetSeed([In] unsigned int seed)</unmanaged>
        /// <unmanaged-short>IDCompositionTurbulenceEffect::SetSeed</unmanaged-short>
        internal unsafe void SetSeed(System.Int32 seed)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, seed, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the turbulence noise mode.</p>
        /// </summary>
        /// <param name = "noise"><dd>  <p>The turbulence noise mode. Indicates whether to generate a bitmap based on Fractal Noise or the Turbulence function.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919803</doc-id>
        /// <unmanaged>HRESULT IDCompositionTurbulenceEffect::SetNoise([In] D2D1_TURBULENCE_NOISE noise)</unmanaged>
        /// <unmanaged-short>IDCompositionTurbulenceEffect::SetNoise</unmanaged-short>
        internal unsafe void SetNoise(SharpDX.Direct2D1.TurbulenceNoise noise)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)noise), (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Specifies whether stitching is on or off.</p>
        /// </summary>
        /// <param name = "stitchable"><dd>  <p> A boolean value that specifies whether stitching is on or off. The base frequency is adjusted so that the output bitmap can be stitched. This is useful if you want to tile multiple copies of the turbulence effect output. If this value is TRUE, the output bitmap can be tiled (using the tile effect) without the appearance of seams and the base frequency is adjusted so that output bitmap can be stitched. If this value is <see cref = "SharpDX.Result.False"/>, the base frequency is not adjusted, so seams may appear between tiles if the bitmap is tiled. </p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn919808</doc-id>
        /// <unmanaged>HRESULT IDCompositionTurbulenceEffect::SetStitchable([In] BOOL stitchable)</unmanaged>
        /// <unmanaged-short>IDCompositionTurbulenceEffect::SetStitchable</unmanaged-short>
        internal unsafe void SetStitchable(SharpDX.Mathematics.Interop.RawBool stitchable)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint0(this._nativePointer, stitchable, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("AE471C51-5F53-4A24-8D3E-D0C39C30B3F0")]
    public partial class VirtualSurface : SharpDX.DirectComposition.Surface
    {
        public VirtualSurface(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator VirtualSurface(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new VirtualSurface(nativePtr);
        /// <summary>
        /// <p>Changes the logical size of this virtual surface object.</p>
        /// </summary>
        /// <param name = "width"><dd>  <p>The new width of the virtual surface, in pixels. The maximum width is 16,777,216 pixels.</p> </dd></param>
        /// <param name = "height"><dd>  <p>The new height of the virtual surface, in pixels. The maximum height is 16,777,216 pixels.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>When a virtual surface is resized, its contents are preserved up to the new boundaries of the surface. If the surface is made smaller, any previously allocated pixels that fall outside of the new width or height are discarded.</p><p>This method fails if <strong>IDCompositionSurface::BeginDraw</strong> was called for this bitmap without a corresponding call to <strong>IDCompositionSurface::EndDraw</strong>.</p><p>This method fails if <em>width</em> or <em>height</em> exceeds 16,777,216 pixels. </p>
        /// </remarks>
        /// <doc-id>hh449135</doc-id>
        /// <unmanaged>HRESULT IDCompositionVirtualSurface::Resize([In] unsigned int width,[In] unsigned int height)</unmanaged>
        /// <unmanaged-short>IDCompositionVirtualSurface::Resize</unmanaged-short>
        public unsafe void Resize(System.Int32 width, System.Int32 height)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, width, height, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Discards pixels that fall outside of the specified trim rectangles.</p>
        /// </summary>
        /// <param name = "rectangles"><dd>  <p>An array of rectangles to keep.</p> </dd></param>
        /// <param name = "count"><dd>  <p>The number of rectangles in the <em>rectangles</em> array.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>A virtual surface might not  have enough storage for every pixel in the surface. An application instructs the composition engine to allocate memory for the surface by calling the <strong>IDCompositionSurface::BeginDraw</strong> method, and to release memory for the surface by calling the <strong>IDCompositionVirtualSurface::Trim</strong> method. The array of rectangles represents the regions of the virtual surface that should remain allocated after this method returns. Any pixels that are outside the specified set of rectangles are no longer used for texturing, and their memory may be reclaimed. </p><p>If the <em>count</em> parameter is zero, no pixels are kept, and all of the memory allocated for the virtual surface may be reclaimed. The <em>rectangles</em> parameter can be <c>null</c> only if the <em>count</em> parameter is zero. This method fails if <strong>IDCompositionSurface::BeginDraw</strong> was called for this bitmap without a corresponding call to <strong>IDCompositionSurface::EndDraw</strong>.</p>
        /// </remarks>
        /// <doc-id>hh449137</doc-id>
        /// <unmanaged>HRESULT IDCompositionVirtualSurface::Trim([In, Buffer, Optional] const RECT* rectangles,[In] unsigned int count)</unmanaged>
        /// <unmanaged-short>IDCompositionVirtualSurface::Trim</unmanaged-short>
        public unsafe void Trim(SharpDX.Mathematics.Interop.RawRectangle[] rectangles, System.Int32 count)
        {
            SharpDX.Result __result__;
            fixed (void *rectangles_ = rectangles)
                __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, rectangles_, count, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("4d93059d-097b-4651-9a60-f0f25116e2f3")]
    public partial class Visual : SharpDX.ComObject
    {
        public Visual(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Visual(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Visual(nativePtr);
        /// <summary>
        /// <p>Sets the Effect property of this visual. The Effect property modifies how the subtree that is rooted at this visual is blended with the background, and can apply a 3D perspective transform to the visual. </p>
        /// </summary>
        /// <remarks>
        /// <p>This method creates an implicit off-screen surface to which the subtree that is rooted at this visual is composed. The surface is used as one of the inputs to the specified effect. The output of the effect is composed directly to the composition target. Some effects also use the composition target as another implicit input. This is typically the case for compositional or blend effects such as opacity, where the composition target is considered to be the "background." In that case, any visuals that are "behind" the current visual are included in the composition target when the current visual is rendered and are considered to be the "background" that this visual composes to. </p><p>If this visual is not the root of a visual tree and one of its ancestors also has an effect applied to it, the off-screen surface created by the closest ancestor is the composition target to which this visual's effect is composed. Otherwise, the composition target is the root composition target. As a consequence, the background for compositional and blend effects includes only the visuals up to the closest ancestor that itself has an effect. Conversely, any effects applied to visuals under the current visual use the newly created off-screen surface as the background, which may affect how those visuals ultimately compose on top of what the end user perceives as being "behind" those visuals. </p><p>If the <em>effect</em> parameter is <c>null</c>,  no bitmap effect is applied to this visual. Any previous effects that were associated with this visual are removed. The off-screen surface is also removed and the visual subtree is composed directly to the parent composition target, which may also affect how compositional or blend effects under this visual are rendered. </p><p>This method fails if <em>effect</em> is an invalid reference or if it was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface that created this visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method. </p>
        /// </remarks>
        /// <doc-id>hh449159</doc-id>
        /// <unmanaged>SetEffect</unmanaged>
        /// <unmanaged-short>SetEffect</unmanaged-short>
        public SharpDX.DirectComposition.Effect Effect
        {
            set => SetEffect(value);
        }

        /// <summary>
        /// <p>Sets the BitmapInterpolationMode property, which specifies the mode for Microsoft DirectComposition to use when interpolating pixels from bitmaps that are not axis-aligned or drawn exactly at scale. </p>
        /// </summary>
        /// <remarks>
        /// <p>The interpolation mode affects how a bitmap is composed when it is transformed such that there is no one-to-one correspondence between pixels in the bitmap and pixels on the screen. </p><p>By default, a visual inherits the interpolation mode of the parent visual, which may inherit the interpolation mode of its parent visual, and so on. A visual uses the default interpolation mode if this method is never called for the visual, or if this method is called with <strong>DCOMPOSITION_BITMAP_INTERPOLATION_MODE_INHERIT</strong>. If no visuals set the interpolation mode, the default for the entire visual tree is nearest neighbor interpolation, which offers the lowest visual quality but the highest performance. </p><p>If the <em>interpolationMode</em> parameter is anything other than <strong>DCOMPOSITION_BITMAP_INTERPOLATION_MODE_INHERIT</strong>, this visual's bitmap is composed with the specified interpolation mode, and this mode becomes the new default mode for the children of this visual. That is, if the interpolation mode of this visual's children is unchanged or explicitly set to <strong>DCOMPOSITION_BITMAP_INTERPOLATION_MODE_INHERIT</strong>, the bitmaps of the child visuals are composed using the interpolation mode of this visual.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449147</doc-id>
        /// <unmanaged>SetBitmapInterpolationMode</unmanaged>
        /// <unmanaged-short>SetBitmapInterpolationMode</unmanaged-short>
        public SharpDX.DirectComposition.BitmapInterpolationMode BitmapInterpolationMode
        {
            set => SetBitmapInterpolationMode(value);
        }

        /// <summary>
        /// <p>Sets the BorderMode property, which specifies how to compose the edges of bitmaps and clips associated with this visual, or with visuals in the subtree rooted at this visual.</p>
        /// </summary>
        /// <remarks>
        /// <p>The border mode affects how the edges of a bitmap are composed when the bitmap is transformed such that the edges are not exactly axis-aligned and at precise pixel boundaries. It also affects how content is clipped at the corners of a clip that has rounded corners, and at the edge of a clip that is transformed such that the edges are not exactly axis-aligned and at precise pixel boundaries. </p><p>By default, a visual inherits the border mode of  its parent visual, which may inherit the border mode of its parent visual, and so on. A visual uses the default border mode if this method is never called for the visual, or if this method is called with <strong>DCOMPOSITION_BORDER_MODE_INHERIT</strong>. If no visuals set the border mode, the default for the entire visual tree is aliased rendering, which offers the lowest visual quality but the highest performance. </p><p>If the <em>borderMode</em> parameter is anything other than <strong>DCOMPOSITION_BORDER_MODE_INHERIT</strong>, this visual's bitmap and clip are composed with the specified border mode. In addition, this border mode becomes the new default for the children of the current visual. That is, if the border mode of this visual's children is unchanged or explicitly set to <strong>DCOMPOSITION_BORDER_MODE_INHERIT</strong>, the bitmaps and clips of the child visuals are composed using the border mode of this visual.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449149</doc-id>
        /// <unmanaged>SetBorderMode</unmanaged>
        /// <unmanaged-short>SetBorderMode</unmanaged-short>
        public SharpDX.DirectComposition.BorderMode BorderMode
        {
            set => SetBorderMode(value);
        }

        /// <summary>
        /// <p>Sets the Content property of this visual to the specified bitmap or window wrapper.</p>
        /// </summary>
        /// <remarks>
        /// <p> The <em>content</em> parameter must point to one of the following:</p><ul> <li>An object that implements the <strong><see cref = "SharpDX.DirectComposition.Surface"/></strong> interface.</li> <li>An object that implements the <strong><see cref = "SharpDX.DXGI.SwapChain1"/></strong> interface.</li> <li>A wrapper object that is returned by the <strong>CreateSurfaceFromHandle</strong> or  <strong>CreateSurfaceFromHwnd</strong> method.
        /// </li> </ul><p>The new content replaces any content that was previously associated with the visual. If the <em>content</em> parameter is <c>null</c>, the visual has no associated content.</p><p>A visual can be associated with a bitmap object or a window wrapper. A bitmap is either a Microsoft DirectX swap chain or a Microsoft DirectComposition surface.</p><p>A window wrapper is created with the <strong>CreateSurfaceFromHwnd</strong> method and is a stand-in for the rasterization of another window, which must be a top-level window or a layered child window. A window wrapper is conceptually equivalent to a bitmap that is the size of the target window on which the contents of the window are drawn. The contents include the target window's child windows (layered or otherwise), and any DirectComposition content that is drawn in the child windows. </p><p>A DirectComposition surface wrapper is created with the <strong>CreateSurfaceFromHandle</strong> method and is a reference to a swap chain. An application might use a surface wrapper in a cross-process scenario where one process creates the swap chain and another process associates the bitmap with a visual.</p><p>The bitmap is always drawn at position (0,0) relative to the visual's coordinate system, although the coordinate system is directly affected by the OffsetX, OffsetY, and Transform properties, as well as indirectly by the transformations on ancestor visuals. The bitmap of a visual is always drawn behind the children of that visual.</p>
        /// </remarks>
        /// <doc-id>hh449157</doc-id>
        /// <unmanaged>SetContent</unmanaged>
        /// <unmanaged-short>SetContent</unmanaged-short>
        public SharpDX.IUnknown Content
        {
            set => SetContent(value);
        }

        /// <summary>
        /// <p>Sets the blending mode for this visual.</p>
        /// </summary>
        /// <remarks>
        /// <p>The composite mode determines how visual's bitmap is blended with the screen. By default, the visual is blended with "source over" semantics; that is, the colors are blended with per-pixel transparency.</p>
        /// </remarks>
        /// <doc-id>hh802902</doc-id>
        /// <unmanaged>SetCompositeMode</unmanaged>
        /// <unmanaged-short>SetCompositeMode</unmanaged-short>
        public SharpDX.DirectComposition.CompositeMode CompositeMode
        {
            set => SetCompositeMode(value);
        }

        /// <summary>
        /// <p>Changes the value of the OffsetX property of this visual.  The OffsetX property specifies the new offset of the visual along the x-axis, relative to the parent visual.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>The new offset of the visual along the x-axis, in pixels.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method fails if the <em>offsetX</em> parameter is NaN, positive infinity, or negative infinity. </p><p>Changing the OffsetX property of a visual transforms the coordinate system of the entire visual subtree that is rooted at that visual. If the Clip property of this visual is specified, the clip rectangle is also transformed. </p><p>A transformation that is specified by the Transform property is applied after the OffsetX property.  In other words, the effect of setting the Transform property and the OffsetX property is the same as setting only the Transform property on a transform group  object where the first member of the group is an <strong><see cref = "SharpDX.DirectComposition.TranslateTransform"/></strong> object that has the same OffsetX value as <em>offsetX</em>. However, you should use  <strong>IDCompositionVisual::SetOffsetX</strong> whenever possible because it is slightly faster.</p><p>If the OffsetX and OffsetY properties are set to 0, and the Transform property is set to <c>null</c>, the coordinate system of the visual is the same as that of its parent.</p><p>If the OffsetX property was previously animated, this method removes the animation and sets the property to the specified static value.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449161</doc-id>
        /// <unmanaged>HRESULT IDCompositionVisual::SetOffsetX([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionVisual::SetOffsetX</unmanaged-short>
        public unsafe void SetOffsetX(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of the OffsetX property of this visual.  The OffsetX property specifies the new offset of the visual along the x-axis, relative to the parent visual.</p>
        /// </summary>
        /// <param name = "offsetX"><dd>  <p>The new offset of the visual along the x-axis, in pixels.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method fails if the <em>offsetX</em> parameter is NaN, positive infinity, or negative infinity. </p><p>Changing the OffsetX property of a visual transforms the coordinate system of the entire visual subtree that is rooted at that visual. If the Clip property of this visual is specified, the clip rectangle is also transformed. </p><p>A transformation that is specified by the Transform property is applied after the OffsetX property.  In other words, the effect of setting the Transform property and the OffsetX property is the same as setting only the Transform property on a transform group  object where the first member of the group is an <strong><see cref = "SharpDX.DirectComposition.TranslateTransform"/></strong> object that has the same OffsetX value as <em>offsetX</em>. However, you should use  <strong>IDCompositionVisual::SetOffsetX</strong> whenever possible because it is slightly faster.</p><p>If the OffsetX and OffsetY properties are set to 0, and the Transform property is set to <c>null</c>, the coordinate system of the visual is the same as that of its parent.</p><p>If the OffsetX property was previously animated, this method removes the animation and sets the property to the specified static value.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449161</doc-id>
        /// <unmanaged>HRESULT IDCompositionVisual::SetOffsetX([In] float offsetX)</unmanaged>
        /// <unmanaged-short>IDCompositionVisual::SetOffsetX</unmanaged-short>
        public unsafe void SetOffsetX(System.Single offsetX)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, offsetX, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of the OffsetY property of this visual.  The OffsetY property specifies the new offset of the visual along the y-axis, relative to the parent visual.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>The new offset of the visual along the y-axis, in pixels.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method fails if the <em>offsetY</em> parameter is NaN, positive infinity, or negative infinity. </p><p>Changing the OffsetY property transforms the coordinate system of the entire visual subtree that is rooted at this visual. If the Clip property of this visual is specified, the clip rectangle is also transformed. </p><p>A transformation that is specified by the Transform property is applied after the OffsetY property.  In other words, the effect of setting the Transform property and the OffsetY property is the same as setting only the Transform property on a transform group object where the first member of the group is an <strong><see cref = "SharpDX.DirectComposition.TranslateTransform"/></strong> object that has the same OffsetY value as <em>offsetY</em>. However, you should use  <strong>IDCompositionVisual::SetOffsetY</strong> whenever possible because it is slightly faster.</p><p>If the OffsetX and OffsetY properties are set to 0, and the Transform property is set to <c>null</c>, the coordinate system of the visual is the same as that of its parent.</p><p>If the OffsetY property was previously animated, this method removes the animation and sets the property to the specified static value.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449167</doc-id>
        /// <unmanaged>HRESULT IDCompositionVisual::SetOffsetY([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionVisual::SetOffsetY</unmanaged-short>
        public unsafe void SetOffsetY(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of the OffsetY property of this visual.  The OffsetY property specifies the new offset of the visual along the y-axis, relative to the parent visual.</p>
        /// </summary>
        /// <param name = "offsetY"><dd>  <p>The new offset of the visual along the y-axis, in pixels.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method fails if the <em>offsetY</em> parameter is NaN, positive infinity, or negative infinity. </p><p>Changing the OffsetY property transforms the coordinate system of the entire visual subtree that is rooted at this visual. If the Clip property of this visual is specified, the clip rectangle is also transformed. </p><p>A transformation that is specified by the Transform property is applied after the OffsetY property.  In other words, the effect of setting the Transform property and the OffsetY property is the same as setting only the Transform property on a transform group object where the first member of the group is an <strong><see cref = "SharpDX.DirectComposition.TranslateTransform"/></strong> object that has the same OffsetY value as <em>offsetY</em>. However, you should use  <strong>IDCompositionVisual::SetOffsetY</strong> whenever possible because it is slightly faster.</p><p>If the OffsetX and OffsetY properties are set to 0, and the Transform property is set to <c>null</c>, the coordinate system of the visual is the same as that of its parent.</p><p>If the OffsetY property was previously animated, this method removes the animation and sets the property to the specified static value.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449167</doc-id>
        /// <unmanaged>HRESULT IDCompositionVisual::SetOffsetY([In] float offsetY)</unmanaged>
        /// <unmanaged-short>IDCompositionVisual::SetOffsetY</unmanaged-short>
        public unsafe void SetOffsetY(System.Single offsetY)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, offsetY, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// Sets the Transform property of this visual. The Transform  property specifies a 2D transform used to modify the coordinate system of this visual. The property can specify either a  3-by-2 transform matrix or a transform object.
        /// </summary>
        /// <param name = "transform">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <doc-id>hh449178</doc-id>
        /// <unmanaged>HRESULT IDCompositionVisual::SetTransform([In, Optional] IDCompositionTransform* transform)</unmanaged>
        /// <unmanaged-short>IDCompositionVisual::SetTransform</unmanaged-short>
        public unsafe void SetTransform(SharpDX.DirectComposition.Transform transform)
        {
            System.IntPtr transform_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            transform_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Transform>(transform);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)transform_, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// Sets the Transform property of this visual. The Transform  property specifies a 2D transform used to modify the coordinate system of this visual. The property can specify either a  3-by-2 transform matrix or a transform object.
        /// </summary>
        /// <param name = "matrix">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <doc-id>hh449178</doc-id>
        /// <unmanaged>HRESULT IDCompositionVisual::SetTransform([In] const D2D_MATRIX_3X2_F&amp; matrix)</unmanaged>
        /// <unmanaged-short>IDCompositionVisual::SetTransform</unmanaged-short>
        public unsafe void SetTransform(ref SharpDX.Mathematics.Interop.RawMatrix3x2 matrix)
        {
            SharpDX.Result __result__;
            fixed (void *matrix_ = &matrix)
                __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, matrix_, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the TransformParent property of this visual. The TransformParent property establishes the coordinate system relative to which this visual is composed.</p>
        /// </summary>
        /// <param name = "visual"><dd>  <p>The new visual that establishes the base coordinate system for this visual. This parameter can be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>The coordinate system of a visual is modified by the OffsetX, OffsetY, and Transform properties. Normally, these properties define the coordinate system of a visual relative to its immediate parent. This method specifies the  visual relative to which the coordinate system for this visual is based. The specified visual must be an ancestor of the current visual. If it is not an ancestor, the coordinate system is based on this visual's immediate parent, just as if the TransformParent property were set to <c>null</c>. Because visuals can be reparented, this property can take effect again if the specified visual becomes an ancestor of the target visual through a reparenting operation. </p><p>If the <em>visual</em> parameter is <c>null</c>, the coordinate system is always transformed relative to the visual's immediate parent. This is the default behavior if this method is not used.  </p><p>This method fails if the <em>visual</em> parameter is an invalid reference or if it was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface as this visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449172</doc-id>
        /// <unmanaged>HRESULT IDCompositionVisual::SetTransformParent([In, Optional] IDCompositionVisual* visual)</unmanaged>
        /// <unmanaged-short>IDCompositionVisual::SetTransformParent</unmanaged-short>
        public unsafe void SetTransformParent(SharpDX.DirectComposition.Visual visual)
        {
            System.IntPtr visual_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            visual_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Visual>(visual);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)visual_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the Effect property of this visual. The Effect property modifies how the subtree that is rooted at this visual is blended with the background, and can apply a 3D perspective transform to the visual. </p>
        /// </summary>
        /// <param name = "effect"><dd>  <p>A reference to an effect object. This parameter can be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method creates an implicit off-screen surface to which the subtree that is rooted at this visual is composed. The surface is used as one of the inputs to the specified effect. The output of the effect is composed directly to the composition target. Some effects also use the composition target as another implicit input. This is typically the case for compositional or blend effects such as opacity, where the composition target is considered to be the "background." In that case, any visuals that are "behind" the current visual are included in the composition target when the current visual is rendered and are considered to be the "background" that this visual composes to. </p><p>If this visual is not the root of a visual tree and one of its ancestors also has an effect applied to it, the off-screen surface created by the closest ancestor is the composition target to which this visual's effect is composed. Otherwise, the composition target is the root composition target. As a consequence, the background for compositional and blend effects includes only the visuals up to the closest ancestor that itself has an effect. Conversely, any effects applied to visuals under the current visual use the newly created off-screen surface as the background, which may affect how those visuals ultimately compose on top of what the end user perceives as being "behind" those visuals. </p><p>If the <em>effect</em> parameter is <c>null</c>,  no bitmap effect is applied to this visual. Any previous effects that were associated with this visual are removed. The off-screen surface is also removed and the visual subtree is composed directly to the parent composition target, which may also affect how compositional or blend effects under this visual are rendered. </p><p>This method fails if <em>effect</em> is an invalid reference or if it was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface that created this visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method. </p>
        /// </remarks>
        /// <doc-id>hh449159</doc-id>
        /// <unmanaged>HRESULT IDCompositionVisual::SetEffect([In, Optional] IDCompositionEffect* effect)</unmanaged>
        /// <unmanaged-short>IDCompositionVisual::SetEffect</unmanaged-short>
        internal unsafe void SetEffect(SharpDX.DirectComposition.Effect effect)
        {
            System.IntPtr effect_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            effect_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Effect>(effect);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)effect_, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the BitmapInterpolationMode property, which specifies the mode for Microsoft DirectComposition to use when interpolating pixels from bitmaps that are not axis-aligned or drawn exactly at scale. </p>
        /// </summary>
        /// <param name = "interpolationMode"><dd>  <p>The interpolation mode to use.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>The interpolation mode affects how a bitmap is composed when it is transformed such that there is no one-to-one correspondence between pixels in the bitmap and pixels on the screen. </p><p>By default, a visual inherits the interpolation mode of the parent visual, which may inherit the interpolation mode of its parent visual, and so on. A visual uses the default interpolation mode if this method is never called for the visual, or if this method is called with <strong>DCOMPOSITION_BITMAP_INTERPOLATION_MODE_INHERIT</strong>. If no visuals set the interpolation mode, the default for the entire visual tree is nearest neighbor interpolation, which offers the lowest visual quality but the highest performance. </p><p>If the <em>interpolationMode</em> parameter is anything other than <strong>DCOMPOSITION_BITMAP_INTERPOLATION_MODE_INHERIT</strong>, this visual's bitmap is composed with the specified interpolation mode, and this mode becomes the new default mode for the children of this visual. That is, if the interpolation mode of this visual's children is unchanged or explicitly set to <strong>DCOMPOSITION_BITMAP_INTERPOLATION_MODE_INHERIT</strong>, the bitmaps of the child visuals are composed using the interpolation mode of this visual.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449147</doc-id>
        /// <unmanaged>HRESULT IDCompositionVisual::SetBitmapInterpolationMode([In] DCOMPOSITION_BITMAP_INTERPOLATION_MODE interpolationMode)</unmanaged>
        /// <unmanaged-short>IDCompositionVisual::SetBitmapInterpolationMode</unmanaged-short>
        internal unsafe void SetBitmapInterpolationMode(SharpDX.DirectComposition.BitmapInterpolationMode interpolationMode)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)interpolationMode), (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the BorderMode property, which specifies how to compose the edges of bitmaps and clips associated with this visual, or with visuals in the subtree rooted at this visual.</p>
        /// </summary>
        /// <param name = "borderMode"><dd>  <p>The border mode to use.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>The border mode affects how the edges of a bitmap are composed when the bitmap is transformed such that the edges are not exactly axis-aligned and at precise pixel boundaries. It also affects how content is clipped at the corners of a clip that has rounded corners, and at the edge of a clip that is transformed such that the edges are not exactly axis-aligned and at precise pixel boundaries. </p><p>By default, a visual inherits the border mode of  its parent visual, which may inherit the border mode of its parent visual, and so on. A visual uses the default border mode if this method is never called for the visual, or if this method is called with <strong>DCOMPOSITION_BORDER_MODE_INHERIT</strong>. If no visuals set the border mode, the default for the entire visual tree is aliased rendering, which offers the lowest visual quality but the highest performance. </p><p>If the <em>borderMode</em> parameter is anything other than <strong>DCOMPOSITION_BORDER_MODE_INHERIT</strong>, this visual's bitmap and clip are composed with the specified border mode. In addition, this border mode becomes the new default for the children of the current visual. That is, if the border mode of this visual's children is unchanged or explicitly set to <strong>DCOMPOSITION_BORDER_MODE_INHERIT</strong>, the bitmaps and clips of the child visuals are composed using the border mode of this visual.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449149</doc-id>
        /// <unmanaged>HRESULT IDCompositionVisual::SetBorderMode([In] DCOMPOSITION_BORDER_MODE borderMode)</unmanaged>
        /// <unmanaged-short>IDCompositionVisual::SetBorderMode</unmanaged-short>
        internal unsafe void SetBorderMode(SharpDX.DirectComposition.BorderMode borderMode)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)borderMode), (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
        }

        /// <summary>
        /// Sets the Clip property of this visual to the specified rectangular region or clip object. The Clip property restricts the rendering of the visual subtree that is rooted at this visual to a rectangular region.
        /// </summary>
        /// <param name = "clip">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <doc-id>hh449155</doc-id>
        /// <unmanaged>HRESULT IDCompositionVisual::SetClip([In, Optional] IDCompositionClip* clip)</unmanaged>
        /// <unmanaged-short>IDCompositionVisual::SetClip</unmanaged-short>
        public unsafe void SetClip(SharpDX.DirectComposition.Clip clip)
        {
            System.IntPtr clip_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            clip_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Clip>(clip);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)clip_, (*(void ***)this._nativePointer)[13]);
            __result__.CheckError();
        }

        /// <summary>
        /// Sets the Clip property of this visual to the specified rectangular region or clip object. The Clip property restricts the rendering of the visual subtree that is rooted at this visual to a rectangular region.
        /// </summary>
        /// <param name = "rect">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <doc-id>hh449155</doc-id>
        /// <unmanaged>HRESULT IDCompositionVisual::SetClip([In] const D2D_RECT_F&amp; rect)</unmanaged>
        /// <unmanaged-short>IDCompositionVisual::SetClip</unmanaged-short>
        public unsafe void SetClip(SharpDX.Mathematics.Interop.RawRectangleF rect)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &rect, (*(void ***)this._nativePointer)[14]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the Content property of this visual to the specified bitmap or window wrapper.</p>
        /// </summary>
        /// <param name = "content"><dd>  <p>The object that is the new content of this visual. This parameter can be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p> The <em>content</em> parameter must point to one of the following:</p><ul> <li>An object that implements the <strong><see cref = "SharpDX.DirectComposition.Surface"/></strong> interface.</li> <li>An object that implements the <strong><see cref = "SharpDX.DXGI.SwapChain1"/></strong> interface.</li> <li>A wrapper object that is returned by the <strong>CreateSurfaceFromHandle</strong> or  <strong>CreateSurfaceFromHwnd</strong> method.
        /// </li> </ul><p>The new content replaces any content that was previously associated with the visual. If the <em>content</em> parameter is <c>null</c>, the visual has no associated content.</p><p>A visual can be associated with a bitmap object or a window wrapper. A bitmap is either a Microsoft DirectX swap chain or a Microsoft DirectComposition surface.</p><p>A window wrapper is created with the <strong>CreateSurfaceFromHwnd</strong> method and is a stand-in for the rasterization of another window, which must be a top-level window or a layered child window. A window wrapper is conceptually equivalent to a bitmap that is the size of the target window on which the contents of the window are drawn. The contents include the target window's child windows (layered or otherwise), and any DirectComposition content that is drawn in the child windows. </p><p>A DirectComposition surface wrapper is created with the <strong>CreateSurfaceFromHandle</strong> method and is a reference to a swap chain. An application might use a surface wrapper in a cross-process scenario where one process creates the swap chain and another process associates the bitmap with a visual.</p><p>The bitmap is always drawn at position (0,0) relative to the visual's coordinate system, although the coordinate system is directly affected by the OffsetX, OffsetY, and Transform properties, as well as indirectly by the transformations on ancestor visuals. The bitmap of a visual is always drawn behind the children of that visual.</p>
        /// </remarks>
        /// <doc-id>hh449157</doc-id>
        /// <unmanaged>HRESULT IDCompositionVisual::SetContent([In, Optional] IUnknown* content)</unmanaged>
        /// <unmanaged-short>IDCompositionVisual::SetContent</unmanaged-short>
        internal unsafe void SetContent(SharpDX.IUnknown content)
        {
            System.IntPtr content_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            content_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(content);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)content_, (*(void ***)this._nativePointer)[15]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Adds a new child visual to the children list of this visual.</p>
        /// </summary>
        /// <param name = "visual"><dd>  <p>The child visual to add. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <param name = "insertAbove"><dd>  <p>TRUE to place the new child visual in front of the visual specified by the <em>referenceVisual</em> parameter, or <see cref = "SharpDX.Result.False"/> to place it behind <em>referenceVisual</em>.</p> </dd></param>
        /// <param name = "referenceVisual"><dd>  <p>The existing child visual next to which the new visual should be added.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Child visuals are arranged in an ordered list. The contents of a child visual are drawn in front of (or above) the contents of its parent visual,  but behind (or below) the contents of its children.</p><p>The <em>referenceVisual</em> parameter must be an existing child of the parent visual, or it must be <c>null</c>. The <em>insertAbove</em> parameter indicates whether the new child should be rendered immediately above the reference visual in the Z order, or immediately below it.</p><p>If the <em>referenceVisual</em> parameter is <c>null</c>, the specified visual is rendered above or below all children of the parent visual, depending on the value of the <em>insertAbove</em> parameter. If <em>insertAbove</em> is TRUE, the new child visual is above no sibling, therefore it is rendered  below all of its siblings. Conversely, if <em>insertAbove</em> is <see cref = "SharpDX.Result.False"/>, the visual is below no sibling, therefore it is rendered above all of its siblings.</p><p>The visual specified by the <em>visual</em> parameter cannot be either a child of a single other visual, or the root of a visual tree that is associated with a composition target. If <em>visual</em> is already a child of another visual, <strong>AddVisual</strong> fails. The child visual must be removed from the children list of its previous parent before adding it to the children list of the new parent. If <em>visual</em> is the root of a visual tree, the visual must be dissociated from that visual tree before adding it to the children list of the new parent. To dissociate the visual from a visual tree, call the <strong>IDCompositionTarget::SetRoot</strong> method and specify either a different visual or <c>null</c> as the <em>visual</em> parameter.</p><p>A child visual need not have been created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface as its parent. When visuals from different devices are combined in the same visual tree,  Microsoft DirectComposition composes the  tree as it normally would, except that changes to a particular visual take effect only when <strong>IDCompositionDevice::Commit</strong> is called on the device object that created the visual. The ability to combine visuals from different devices  enables multiple threads to create and manipulate a single visual tree while maintaining independent devices that can be used to commit changes asynchronously</p><p>This method fails if <em>visual</em> or <em>referenceVisual</em> is an invalid reference, or if the visual referenced by the <em>referenceVisual</em> parameter is not a child of the parent visual. These  interfaces cannot be custom implementations; only interfaces created by DirectComposition can be used with this method.
        /// </p>
        /// </remarks>
        /// <doc-id>hh449141</doc-id>
        /// <unmanaged>HRESULT IDCompositionVisual::AddVisual([In] IDCompositionVisual* visual,[In] BOOL insertAbove,[In, Optional] IDCompositionVisual* referenceVisual)</unmanaged>
        /// <unmanaged-short>IDCompositionVisual::AddVisual</unmanaged-short>
        public unsafe void AddVisual(SharpDX.DirectComposition.Visual visual, SharpDX.Mathematics.Interop.RawBool insertAbove, SharpDX.DirectComposition.Visual referenceVisual)
        {
            System.IntPtr visual_ = System.IntPtr.Zero;
            System.IntPtr referenceVisual_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            visual_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Visual>(visual);
            referenceVisual_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Visual>(referenceVisual);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint0(this._nativePointer, (void *)visual_, insertAbove, (void *)referenceVisual_, (*(void ***)this._nativePointer)[16]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Removes a child visual from the children list of this visual.</p>
        /// </summary>
        /// <param name = "visual"><dd>  <p>The child visual to remove from the children list. This parameter must not be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>The child visual is removed from the list of children. The order of the remaining child visuals is not changed.</p><p>This method fails if <em>visual</em> is not a child of the parent visual.</p>
        /// </remarks>
        /// <doc-id>hh449145</doc-id>
        /// <unmanaged>HRESULT IDCompositionVisual::RemoveVisual([In] IDCompositionVisual* visual)</unmanaged>
        /// <unmanaged-short>IDCompositionVisual::RemoveVisual</unmanaged-short>
        public unsafe void RemoveVisual(SharpDX.DirectComposition.Visual visual)
        {
            System.IntPtr visual_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            visual_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Visual>(visual);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)visual_, (*(void ***)this._nativePointer)[17]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Removes all visuals from the children list of this visual.</p>
        /// </summary>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>This method can be called even if this visual has no children. </p>
        /// </remarks>
        /// <doc-id>hh449143</doc-id>
        /// <unmanaged>HRESULT IDCompositionVisual::RemoveAllVisuals()</unmanaged>
        /// <unmanaged-short>IDCompositionVisual::RemoveAllVisuals</unmanaged-short>
        public unsafe void RemoveAllVisuals()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[18]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the blending mode for this visual.</p>
        /// </summary>
        /// <param name = "compositeMode"><dd>  <p>The blending mode to use when composing the visual to the screen.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>The composite mode determines how visual's bitmap is blended with the screen. By default, the visual is blended with "source over" semantics; that is, the colors are blended with per-pixel transparency.</p>
        /// </remarks>
        /// <doc-id>hh802902</doc-id>
        /// <unmanaged>HRESULT IDCompositionVisual::SetCompositeMode([In] DCOMPOSITION_COMPOSITE_MODE compositeMode)</unmanaged>
        /// <unmanaged-short>IDCompositionVisual::SetCompositeMode</unmanaged-short>
        internal unsafe void SetCompositeMode(SharpDX.DirectComposition.CompositeMode compositeMode)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)compositeMode), (*(void ***)this._nativePointer)[19]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("E8DE1639-4331-4B26-BC5F-6A321D347A85")]
    public partial class Visual2 : SharpDX.DirectComposition.Visual
    {
        public Visual2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Visual2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Visual2(nativePtr);
        /// <summary>
        /// <p>Sets the opacity mode for this visual.</p>
        /// </summary>
        /// <remarks>
        /// <p>The opacity mode affects how the Opacity property of an effect group object affects the composition of a visual sub-tree. DirectComposition supports two opacity modes: Layer and Multiply. In Layer mode, each visual sub-tree can be logically viewed as a bitmap that contains the opaque rasterization of that entire sub-tree, to which the opacity value is then applied. In this manner, overlapping opaque surfaces blend with the sub-tree?s background, but not with each other. In contrast, in Multiply mode the opacity is applied individually to each surface as it is composed, so surfaces blend with each other. Multiply mode is faster than Layer mode and always preferred if the visual tree contains entirely non-overlapping contents. However, Multiply mode may produce undesired visual results for overlapping elements. </p><p>By default, a visual inherits the opacity mode of its parent visual, which may inherit the opacity mode of its parent visual, and so on. A visual uses the DCOMPOSITION_OPACITY_MODE_LAYER mode if this method is never called for the visual, or if this method is called with DCOMPOSITION_OPACITY_MODE_INHERIT. If no visuals set the opacity mode, the default for the entire visual tree is DCOMPOSITION_OPACITY_MODE_LAYER.  </p><p>If the <em>opacityMode</em> parameter is anything other than DCOMPOSITION_OPACITY_MODE_INHERIT, this visual's surfaces are composed with the specified opacity mode. In addition, this opacity mode becomes the new default for the children of the current visual. That is, if the opacity mode of this visual's children is unchanged or explicitly set to DCOMPOSITION_OPACITY_MODE_INHERIT, the surfaces the child visuals are composed using the opacity mode of this visual.
        /// </p>
        /// </remarks>
        /// <doc-id>dn280428</doc-id>
        /// <unmanaged>SetOpacityMode</unmanaged>
        /// <unmanaged-short>SetOpacityMode</unmanaged-short>
        public SharpDX.DirectComposition.OpacityMode OpacityMode
        {
            set => SetOpacityMode(value);
        }

        /// <summary>
        /// <p>Specifies whether or not surfaces that have 3D transformations applied to them should be displayed when facing away from the observer.</p>
        /// </summary>
        /// <remarks>
        /// <p>The back face visibility property affects how surfaces that have 3D transformations applied are rendered. </p><p>By default, a visual inherits the back face visibility property of its parent visual, which may inherit the back face visibility property of its parent visual, and so on. A visual uses the DCOMPOSITION_BACKFACE_VISIBILITY_VISIBLE mode if this method is never called for the visual, or if this method is called with DCOMPOSITION_BACKFACE_VISIBILITY_INHERIT. If no visuals set the back face visibility property, the default for the entire visual tree is DCOMPOSITION_BACKFACE_VISIBILITY_VISIBLE.  </p><p>If the <em>visibility</em> parameter is anything other than DCOMPOSITION_BACKFACE_VISIBILITY_INHERIT, this visual's surfaces are composed with the specified visibility mode. In addition, this visibility mode becomes the new default for the children of the current visual. That is, if the visibility mode of this visual's children is unchanged or explicitly set to DCOMPOSITION_BACKFACE_VISIBILITY_INHERIT, the surfaces the child visuals are composed using the visibility mode of this visual.
        /// </p>
        /// </remarks>
        /// <doc-id>dn280427</doc-id>
        /// <unmanaged>SetBackFaceVisibility</unmanaged>
        /// <unmanaged-short>SetBackFaceVisibility</unmanaged-short>
        public SharpDX.DirectComposition.BackFaceVisibility BackFaceVisibility
        {
            set => SetBackFaceVisibility(value);
        }

        /// <summary>
        /// <p>Sets the opacity mode for this visual.</p>
        /// </summary>
        /// <param name = "mode"><dd> <p> The opacity mode to use when composing the visual to the screen.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>The opacity mode affects how the Opacity property of an effect group object affects the composition of a visual sub-tree. DirectComposition supports two opacity modes: Layer and Multiply. In Layer mode, each visual sub-tree can be logically viewed as a bitmap that contains the opaque rasterization of that entire sub-tree, to which the opacity value is then applied. In this manner, overlapping opaque surfaces blend with the sub-tree?s background, but not with each other. In contrast, in Multiply mode the opacity is applied individually to each surface as it is composed, so surfaces blend with each other. Multiply mode is faster than Layer mode and always preferred if the visual tree contains entirely non-overlapping contents. However, Multiply mode may produce undesired visual results for overlapping elements. </p><p>By default, a visual inherits the opacity mode of its parent visual, which may inherit the opacity mode of its parent visual, and so on. A visual uses the DCOMPOSITION_OPACITY_MODE_LAYER mode if this method is never called for the visual, or if this method is called with DCOMPOSITION_OPACITY_MODE_INHERIT. If no visuals set the opacity mode, the default for the entire visual tree is DCOMPOSITION_OPACITY_MODE_LAYER.  </p><p>If the <em>opacityMode</em> parameter is anything other than DCOMPOSITION_OPACITY_MODE_INHERIT, this visual's surfaces are composed with the specified opacity mode. In addition, this opacity mode becomes the new default for the children of the current visual. That is, if the opacity mode of this visual's children is unchanged or explicitly set to DCOMPOSITION_OPACITY_MODE_INHERIT, the surfaces the child visuals are composed using the opacity mode of this visual.
        /// </p>
        /// </remarks>
        /// <doc-id>dn280428</doc-id>
        /// <unmanaged>HRESULT IDCompositionVisual2::SetOpacityMode([In] DCOMPOSITION_OPACITY_MODE mode)</unmanaged>
        /// <unmanaged-short>IDCompositionVisual2::SetOpacityMode</unmanaged-short>
        internal unsafe void SetOpacityMode(SharpDX.DirectComposition.OpacityMode mode)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)mode), (*(void ***)this._nativePointer)[20]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Specifies whether or not surfaces that have 3D transformations applied to them should be displayed when facing away from the observer.</p>
        /// </summary>
        /// <param name = "visibility"><dd> <p>The back face visibility to use when composing surfaces in this visual?s sub-tree to the screen.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>The back face visibility property affects how surfaces that have 3D transformations applied are rendered. </p><p>By default, a visual inherits the back face visibility property of its parent visual, which may inherit the back face visibility property of its parent visual, and so on. A visual uses the DCOMPOSITION_BACKFACE_VISIBILITY_VISIBLE mode if this method is never called for the visual, or if this method is called with DCOMPOSITION_BACKFACE_VISIBILITY_INHERIT. If no visuals set the back face visibility property, the default for the entire visual tree is DCOMPOSITION_BACKFACE_VISIBILITY_VISIBLE.  </p><p>If the <em>visibility</em> parameter is anything other than DCOMPOSITION_BACKFACE_VISIBILITY_INHERIT, this visual's surfaces are composed with the specified visibility mode. In addition, this visibility mode becomes the new default for the children of the current visual. That is, if the visibility mode of this visual's children is unchanged or explicitly set to DCOMPOSITION_BACKFACE_VISIBILITY_INHERIT, the surfaces the child visuals are composed using the visibility mode of this visual.
        /// </p>
        /// </remarks>
        /// <doc-id>dn280427</doc-id>
        /// <unmanaged>HRESULT IDCompositionVisual2::SetBackFaceVisibility([In] DCOMPOSITION_BACKFACE_VISIBILITY visibility)</unmanaged>
        /// <unmanaged-short>IDCompositionVisual2::SetBackFaceVisibility</unmanaged-short>
        internal unsafe void SetBackFaceVisibility(SharpDX.DirectComposition.BackFaceVisibility visibility)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)visibility), (*(void ***)this._nativePointer)[21]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("2775F462-B6C1-4015-B0BE-B3E7D6A4976D")]
    public partial class Visual3 : SharpDX.DirectComposition.VisualDebug
    {
        public Visual3(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Visual3(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Visual3(nativePtr);
        /// <summary>
        /// <p>Sets the depth mode property associated with this visual.</p>
        /// </summary>
        /// <doc-id>mt589904</doc-id>
        /// <unmanaged>SetDepthMode</unmanaged>
        /// <unmanaged-short>SetDepthMode</unmanaged-short>
        public SharpDX.DirectComposition.DepthMode DepthMode
        {
            set => SetDepthMode(value);
        }

        /// <summary>
        /// <p>Changes the value of the visual's Visible property.</p>
        /// </summary>
        /// <doc-id>mt589911</doc-id>
        /// <unmanaged>SetVisible</unmanaged>
        /// <unmanaged-short>SetVisible</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool Visible
        {
            set => SetVisible(value);
        }

        /// <summary>
        /// <p>Sets the depth mode property associated with this visual.</p>
        /// </summary>
        /// <param name = "mode"><dd>  <p>The new depth mode.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>mt589904</doc-id>
        /// <unmanaged>HRESULT IDCompositionVisual3::SetDepthMode([In] DCOMPOSITION_DEPTH_MODE mode)</unmanaged>
        /// <unmanaged-short>IDCompositionVisual3::SetDepthMode</unmanaged-short>
        internal unsafe void SetDepthMode(SharpDX.DirectComposition.DepthMode mode)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)mode), (*(void ***)this._nativePointer)[26]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of OffsetZ property.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>The new value.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>mt589905</doc-id>
        /// <unmanaged>HRESULT IDCompositionVisual3::SetOffsetZ([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionVisual3::SetOffsetZ</unmanaged-short>
        public unsafe void SetOffsetZ(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[27]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of OffsetZ property.</p>
        /// </summary>
        /// <param name = "offsetZ"><dd>  <p>The new value.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>mt589905</doc-id>
        /// <unmanaged>HRESULT IDCompositionVisual3::SetOffsetZ([In] float offsetZ)</unmanaged>
        /// <unmanaged-short>IDCompositionVisual3::SetOffsetZ</unmanaged-short>
        public unsafe void SetOffsetZ(System.Single offsetZ)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, offsetZ, (*(void ***)this._nativePointer)[28]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the value of the visual's opacity property.</p>
        /// </summary>
        /// <param name = "animation"><dd>  <p>The new value for the opacity property.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>mt589908</doc-id>
        /// <unmanaged>HRESULT IDCompositionVisual3::SetOpacity([In] IDCompositionAnimation* animation)</unmanaged>
        /// <unmanaged-short>IDCompositionVisual3::SetOpacity</unmanaged-short>
        public unsafe void SetOpacity(SharpDX.DirectComposition.Animation animation)
        {
            System.IntPtr animation_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            animation_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Animation>(animation);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)animation_, (*(void ***)this._nativePointer)[29]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the value of the visual's opacity property.</p>
        /// </summary>
        /// <param name = "opacity"><dd>  <p>The new value for the opacity property.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>mt589908</doc-id>
        /// <unmanaged>HRESULT IDCompositionVisual3::SetOpacity([In] float opacity)</unmanaged>
        /// <unmanaged-short>IDCompositionVisual3::SetOpacity</unmanaged-short>
        public unsafe void SetOpacity(System.Single opacity)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, opacity, (*(void ***)this._nativePointer)[30]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the Transform property of this visual to the specified 3D transform object.</p>
        /// </summary>
        /// <param name = "transform"><dd>  <p>The transform object that is used to modify  the coordinate system of this visual. This parameter can point to  an <strong><see cref = "SharpDX.DirectComposition.Transform"/></strong> interface or one of its derived interfaces. This parameter can be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Setting the Transform property transforms the coordinate system of the entire visual subtree that is rooted at this visual. If the Clip property of this visual is specified, the clip rectangle is also transformed. </p><p>If the Transform property previously specified a transform matrix, the newly specified transform object replaces the transform matrix.</p><p>A transformation specified by the Transform property is applied after the OffsetX and OffsetY properties. In other words, the effect of setting the Transform property and the OffsetX and OffsetY properties is the same as setting only the Transform property on a transform group where the first member of the group is an <strong><see cref = "SharpDX.DirectComposition.TranslateTransform"/></strong> object that has those same OffsetX and OffsetY values. However, you should use the <strong>IDCompositionVisual::SetOffsetX</strong> and <strong>SetOffsetY</strong> methods whenever possible because they are slightly faster. </p><p>This method fails if <em>transform</em> is an invalid reference or if it was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface that created this visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.
        /// </p><p>If the <em>transform</em> parameter is <c>null</c>, the coordinate system of this visual is transformed only by its OffsetX and OffsetY properties. Setting the Transform property to <c>null</c> is equivalent to setting it to an <strong><see cref = "SharpDX.DirectComposition.MatrixTransform"/></strong> object where the specified matrix is the identity matrix. However, an application should set the Transform property to <c>null</c> whenever possible because it is slightly faster.</p><p>If the OffsetX and OffsetY properties are set to 0, and the Transform property is set to <c>null</c>, the coordinate system of the visual is the same as that of its parent.</p>
        /// </remarks>
        /// <doc-id>dn904493</doc-id>
        /// <unmanaged>HRESULT IDCompositionVisual3::SetTransform([In, Optional] IDCompositionTransform3D* transform)</unmanaged>
        /// <unmanaged-short>IDCompositionVisual3::SetTransform</unmanaged-short>
        public unsafe void SetTransform(SharpDX.DirectComposition.Transform3D transform)
        {
            System.IntPtr transform_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            transform_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectComposition.Transform3D>(transform);
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (void *)transform_, (*(void ***)this._nativePointer)[31]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the Transform property of this visual to the specified 3D transform object.</p>
        /// </summary>
        /// <param name = "matrix"><dd>  <p>The transform object that is used to modify  the coordinate system of this visual. This parameter can point to  an <strong><see cref = "SharpDX.DirectComposition.Transform"/></strong> interface or one of its derived interfaces. This parameter can be <c>null</c>.</p> </dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Setting the Transform property transforms the coordinate system of the entire visual subtree that is rooted at this visual. If the Clip property of this visual is specified, the clip rectangle is also transformed. </p><p>If the Transform property previously specified a transform matrix, the newly specified transform object replaces the transform matrix.</p><p>A transformation specified by the Transform property is applied after the OffsetX and OffsetY properties. In other words, the effect of setting the Transform property and the OffsetX and OffsetY properties is the same as setting only the Transform property on a transform group where the first member of the group is an <strong><see cref = "SharpDX.DirectComposition.TranslateTransform"/></strong> object that has those same OffsetX and OffsetY values. However, you should use the <strong>IDCompositionVisual::SetOffsetX</strong> and <strong>SetOffsetY</strong> methods whenever possible because they are slightly faster. </p><p>This method fails if <em>transform</em> is an invalid reference or if it was not created by the same <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> interface that created this visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.
        /// </p><p>If the <em>transform</em> parameter is <c>null</c>, the coordinate system of this visual is transformed only by its OffsetX and OffsetY properties. Setting the Transform property to <c>null</c> is equivalent to setting it to an <strong><see cref = "SharpDX.DirectComposition.MatrixTransform"/></strong> object where the specified matrix is the identity matrix. However, an application should set the Transform property to <c>null</c> whenever possible because it is slightly faster.</p><p>If the OffsetX and OffsetY properties are set to 0, and the Transform property is set to <c>null</c>, the coordinate system of the visual is the same as that of its parent.</p>
        /// </remarks>
        /// <doc-id>dn904493</doc-id>
        /// <unmanaged>HRESULT IDCompositionVisual3::SetTransform([In] const D2D_MATRIX_4X4_F&amp; matrix)</unmanaged>
        /// <unmanaged-short>IDCompositionVisual3::SetTransform</unmanaged-short>
        public unsafe void SetTransform(ref SharpDX.Mathematics.Interop.RawMatrix matrix)
        {
            SharpDX.Result __result__;
            fixed (void *matrix_ = &matrix)
                __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, matrix_, (*(void ***)this._nativePointer)[32]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the value of the visual's Visible property.</p>
        /// </summary>
        /// <param name = "visible"><dd>  <p>The new value for the visible property.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>mt589911</doc-id>
        /// <unmanaged>HRESULT IDCompositionVisual3::SetVisible([In] BOOL visible)</unmanaged>
        /// <unmanaged-short>IDCompositionVisual3::SetVisible</unmanaged-short>
        internal unsafe void SetVisible(SharpDX.Mathematics.Interop.RawBool visible)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint0(this._nativePointer, visible, (*(void ***)this._nativePointer)[33]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("FED2B808-5EB4-43A0-AEA3-35F65280F91B")]
    public partial class VisualDebug : SharpDX.DirectComposition.Visual2
    {
        public VisualDebug(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator VisualDebug(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new VisualDebug(nativePtr);
        /// <summary>
        /// <p>Enables a visual heatmap that represents overdraw regions.</p>
        /// </summary>
        /// <param name = "color"><dd></dd></param>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Heatmaps can be enabled by calling <strong>EnableHeatMap</strong>. The heatmaps are drawn on the source of the VisualDebug visual and child visuals. The heatmaps are represented in a specified color for all visual content. The heatmap color must have an transparency in order to see the overlaying overdraw regions. The colored surfaces are blended together to visually show all overdraw regions in a single view. </p>
        /// </remarks>
        /// <doc-id>dn280432</doc-id>
        /// <unmanaged>HRESULT IDCompositionVisualDebug::EnableHeatMap([In] const D2D_COLOR_F&amp; color)</unmanaged>
        /// <unmanaged-short>IDCompositionVisualDebug::EnableHeatMap</unmanaged-short>
        public unsafe void EnableHeatMap(SharpDX.Mathematics.Interop.RawColor4 color)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, &color, (*(void ***)this._nativePointer)[22]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Disables visual heatmaps.</p>
        /// </summary>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <doc-id>dn280430</doc-id>
        /// <unmanaged>HRESULT IDCompositionVisualDebug::DisableHeatMap()</unmanaged>
        /// <unmanaged-short>IDCompositionVisualDebug::DisableHeatMap</unmanaged-short>
        public unsafe void DisableHeatMap()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[23]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Enables highlighting visuals when content is being redrawn.</p>
        /// </summary>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <remarks>
        /// <p>Highlighting redraw regions can be enabled by calling <strong>EnableRedrawRegions</strong>.  With this function, redrawn client areas are visually highlighted every frame the visual is updated. Redraw regions are drawn on the source of the VisualDebug and child visuals. Redraw is triggered when properties of a visual are updated. The updated visusal does not neccessarly need to visually change to trigger a redraw. The highlighting will cycle through Blue, Yellow, Pink and Green to provide an order of which content is being updated. The redraw regions are only visible while the window of the VisualDebug is being updated. </p>
        /// </remarks>
        /// <doc-id>dn280433</doc-id>
        /// <unmanaged>HRESULT IDCompositionVisualDebug::EnableRedrawRegions()</unmanaged>
        /// <unmanaged-short>IDCompositionVisualDebug::EnableRedrawRegions</unmanaged-short>
        public unsafe void EnableRedrawRegions()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[24]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Disables visual redraw regions.</p>
        /// </summary>
        /// <returns><p>If the function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>
        /// <doc-id>dn280431</doc-id>
        /// <unmanaged>HRESULT IDCompositionVisualDebug::DisableRedrawRegions()</unmanaged>
        /// <unmanaged-short>IDCompositionVisualDebug::DisableRedrawRegions</unmanaged-short>
        public unsafe void DisableRedrawRegions()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectComposition.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[25]);
            __result__.CheckError();
        }
    }
}
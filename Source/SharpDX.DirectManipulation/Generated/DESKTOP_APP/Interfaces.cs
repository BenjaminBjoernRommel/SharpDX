// <auto-generated/>

namespace SharpDX.DirectManipulation
{
    [System.Runtime.InteropServices.GuidAttribute("6D5954D4-2003-4356-9B31-D051C9FF0AF7")]
    public partial class AutoScrollBehavior : SharpDX.ComObject
    {
        public AutoScrollBehavior(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator AutoScrollBehavior(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new AutoScrollBehavior(nativePtr);
        /// <summary>
        /// <p>Performs the auto-scroll animation for the viewport this behavior is attached to. </p>
        /// </summary>
        /// <param name = "motionTypes"><dd> <p>A combination of <strong>DIRECTMANIPULATION_MOTION_TRANSLATEX</strong> and <strong>DIRECTMANIPULATION_MOTION_TRANSLATEY</strong> from <strong><see cref = "SharpDX.DirectManipulation.MotionTypes"/></strong>. <strong>DIRECTMANIPULATION_MOTION_NONE</strong> cannot be specified.</p> </dd></param>
        /// <param name = "scrollMotion"><dd> <p>One of the values from <strong><see cref = "SharpDX.DirectManipulation.AutoScrollConfiguration"/></strong>. </p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p><strong>SetConfiguration</strong> takes effect immediately. If the content is not in inertia, and <strong>DIRECTMANIPULATION_AUTOSCROLL_CONFIGURATION_STOP</strong> is specified for <em>scrollMotion</em>, then this method returns S_FALSE. </p>
        /// </remarks>
        /// <doc-id>dn280388</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationAutoScrollBehavior::SetConfiguration([In] DIRECTMANIPULATION_MOTION_TYPES motionTypes,[In] DIRECTMANIPULATION_AUTOSCROLL_CONFIGURATION scrollMotion)</unmanaged>
        /// <unmanaged-short>IDirectManipulationAutoScrollBehavior::SetConfiguration</unmanaged-short>
        public unsafe void SetConfiguration(SharpDX.DirectManipulation.MotionTypes motionTypes, SharpDX.DirectManipulation.AutoScrollConfiguration scrollMotion)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)motionTypes), unchecked ((System.Int32)scrollMotion), (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("537A0825-0387-4EFA-B62F-71EB1F085A7E")]
    public partial interface Compositor : SharpDX.IUnknown
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("D38C7822-F1CB-43CB-B4B9-AC0C767A412E")]
    public partial class Compositor2 : SharpDX.DirectManipulation.CompositorNative
    {
        public Compositor2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Compositor2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Compositor2(nativePtr);
        /// <summary>
        /// <p>Associates content (owned by the component host) with the compositor, assigns a composition device to the content, and specifies the position of the content in the composition tree relative to other composition visuals. Represents a compositor object that associates manipulated content with drawing surfaces across multiple processes.</p>
        /// </summary>
        /// <param name = "content"><dd> <p>The content to add to the composition tree.</p> <p><em>content</em> is placed  between <em>parentVisual</em> and <em>childVisual</em> in the composition tree. </p> <p>Only primary content, created at the same time as the viewport, is valid.</p> </dd></param>
        /// <param name = "device"><dd> <p>The device used to compose the content. </p> <strong>Note</strong>??<em>device</em> is created by the application. ? </dd></param>
        /// <param name = "arentVisualRef"><dd> <p>The parent visuals in the composition tree of the content being added.</p> <p><em>parentVisual</em> must also be a parent of <em>childVisual</em> in the composition tree.</p> </dd></param>
        /// <param name = "childVisual"><dd> <p>The child visuals in the composition tree of the content being added.</p> <p><em>parentVisual</em> must also be a parent of <em>childVisual</em> in the composition tree.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>This method inserts a small visual tree (owned by the Direct Manipulation device) between the <em>parentVisual</em> and the <em>childVisual</em>. Transforms can then be applied to the inserted content.  
        /// </p><p>All content, regardless of type, must be added to the compositor. </p><p>If the application uses a system-provided <strong><see cref = "SharpDX.DirectManipulation.Compositor"/></strong>:</p><ul> <li><em>device</em> must be an  <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> object, and parent and child visuals must be <strong><see cref = "SharpDX.DirectComposition.Visual"/></strong> objects.</li> <li><em>device</em>, <em>parentVisual</em>, and <em>childVisual</em> cannot be <c>null</c>. </li> <li><em>device</em>, <em>parentVisual</em>, and <em>childVisual</em> objects are created and owned by the application.
        /// </li> <li>When content is added to the composition tree using this method, the new composition visuals are inserted between <em>parentVisual</em> and <em>childVisual</em>. The new visuals should not be destroyed until they are disassociated from the compositor with <strong>RemoveContent</strong>.</li> </ul><p>If the application uses a custom implementation of <strong><see cref = "SharpDX.DirectManipulation.Compositor"/></strong>:</p><ul> <li><em>device</em>, <em>parentVisual</em>, and <em>childVisual</em> must be a valid type for the compositor. They do not have to be <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> or <strong><see cref = "SharpDX.DirectComposition.Visual"/></strong> objects.</li> <li><em>device</em>, <em>parentVisual</em>, and <em>childVisual</em> can be <c>null</c>, depending on the compositor. </li> </ul><p>The cross-process reference events (<strong>WM_POINTERROUTEDAWAY</strong>, <strong>WM_POINTERROUTEDRELEASED</strong>, and <strong>WM_POINTERROUTEDTO</strong>) should be handled appropriately. </p>
        /// </remarks>
        /// <doc-id>mt622455</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationCompositor2::AddContentWithCrossProcessChaining([In] IDirectManipulationPrimaryContent* content,[In, Optional] IUnknown* device,[In, Optional] IUnknown* parentVisual,[In, Optional] IUnknown* childVisual)</unmanaged>
        /// <unmanaged-short>IDirectManipulationCompositor2::AddContentWithCrossProcessChaining</unmanaged-short>
        public unsafe void AddContentWithCrossProcessChaining(SharpDX.DirectManipulation.PrimaryContent content, SharpDX.IUnknown device, SharpDX.IUnknown arentVisualRef, SharpDX.IUnknown childVisual)
        {
            System.IntPtr content_ = System.IntPtr.Zero;
            System.IntPtr device_ = System.IntPtr.Zero;
            System.IntPtr arentVisualRef_ = System.IntPtr.Zero;
            System.IntPtr childVisual_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            content_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectManipulation.PrimaryContent>(content);
            device_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(device);
            arentVisualRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(arentVisualRef);
            childVisual_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(childVisual);
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)content_, (void *)device_, (void *)arentVisualRef_, (void *)childVisual_, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("537A0825-0387-4EFA-B62F-71EB1F085A7E")]
    public partial class CompositorNative : SharpDX.ComObject, SharpDX.DirectManipulation.Compositor
    {
        public CompositorNative(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator CompositorNative(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new CompositorNative(nativePtr);
        /// <summary>
        /// <p>Associates content (owned by the caller) with the compositor, assigns a composition device to the content, and specifies the position of the content in the composition tree relative to other composition visuals. </p>
        /// </summary>
        /// <param name = "content"><dd> <p>The content to add to the composition tree.</p> <p><em>content</em> is placed  between <em>parentVisual</em> and <em>childVisual</em> in the composition tree. </p> </dd></param>
        /// <param name = "device"><dd> <p>The device used to compose the content. </p> <strong>Note</strong>??<em>device</em> is created by the application. ? </dd></param>
        /// <param name = "arentVisualRef"><dd> <p>The parent visuals in the composition tree of the content being added.</p> <p><em>parentVisual</em> must also be a parent of <em>childVisual</em> in the composition tree.</p> </dd></param>
        /// <param name = "childVisual"><dd> <p>The child visuals in the composition tree of the content being added.</p> <p><em>parentVisual</em> must also be a parent of <em>childVisual</em> in the composition tree.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>This method inserts a small visual tree (owned by the Direct Manipulation device) between the <em>parentVisual</em> and the <em>childVisual</em>. Transforms can then be applied to the inserted content.  
        /// </p><p>All content, regardless of type, must be added to the compositor. This can be primary content, obtained from the viewport by calling <strong>GetPrimaryContent</strong>, or secondary content, such as a panning indicator, created by calling <strong>CreateContent</strong>.
        /// </p><p>If the application uses a system-provided <strong><see cref = "SharpDX.DirectManipulation.Compositor"/></strong>:</p><ul> <li><em>device</em> must be an  <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> object, and parent and child visuals must be <strong><see cref = "SharpDX.DirectComposition.Visual"/></strong> objects.</li> <li><em>device</em>, <em>parentVisual</em>, and <em>childVisual</em> cannot be <c>null</c>. </li> <li><em>device</em>, <em>parentVisual</em>, and <em>childVisual</em> objects are created and owned by the application.
        /// </li> <li>When content is added to the composition tree using this method, the new composition visuals are inserted between <em>parentVisual</em> and <em>childVisual</em>. The new visuals should not be destroyed until they are disassociated from the compositor with <strong>RemoveContent</strong>.</li> </ul><p>If the application uses a custom implementation of <strong><see cref = "SharpDX.DirectManipulation.Compositor"/></strong>:</p><ul> <li><em>device</em>, <em>parentVisual</em>, and <em>childVisual</em> must be a valid type for the compositor. They do not have to be <strong><see cref = "SharpDX.DirectComposition.Device"/></strong> or <strong><see cref = "SharpDX.DirectComposition.Visual"/></strong> objects.</li> <li><em>device</em>, <em>parentVisual</em>, and <em>childVisual</em> can be <c>null</c>, depending on the compositor. </li> </ul>
        /// </remarks>
        /// <doc-id>hh768898</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationCompositor::AddContent([In] IDirectManipulationContent* content,[In, Optional] IUnknown* device,[In, Optional] IUnknown* parentVisual,[In, Optional] IUnknown* childVisual)</unmanaged>
        /// <unmanaged-short>IDirectManipulationCompositor::AddContent</unmanaged-short>
        public unsafe void AddContent(SharpDX.DirectManipulation.Content content, SharpDX.IUnknown device, SharpDX.IUnknown arentVisualRef, SharpDX.IUnknown childVisual)
        {
            System.IntPtr content_ = System.IntPtr.Zero;
            System.IntPtr device_ = System.IntPtr.Zero;
            System.IntPtr arentVisualRef_ = System.IntPtr.Zero;
            System.IntPtr childVisual_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            content_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectManipulation.Content>(content);
            device_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(device);
            arentVisualRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(arentVisualRef);
            childVisual_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(childVisual);
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)content_, (void *)device_, (void *)arentVisualRef_, (void *)childVisual_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Removes content from the compositor.</p>
        /// </summary>
        /// <param name = "content"><dd> <p>The content to remove from the composition tree.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>This method removes content added with <strong>AddContent</strong> and restores the original relationships between parent visuals and child visuals in the composition tree. In other words, <strong>RemoveContent</strong> undoes <strong>AddContent</strong>.</p>
        /// </remarks>
        /// <doc-id>hh768899</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationCompositor::RemoveContent([In] IDirectManipulationContent* content)</unmanaged>
        /// <unmanaged-short>IDirectManipulationCompositor::RemoveContent</unmanaged-short>
        public unsafe void RemoveContent(SharpDX.DirectManipulation.Content content)
        {
            System.IntPtr content_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            content_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectManipulation.Content>(content);
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)content_, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> </p><p> Sets the update manager used to send compositor updates to Direct Manipulation. </p>
        /// </summary>
        /// <param name = "updateManager">No documentation.</param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Retrieve <em>updateManager</em> by calling <strong>GetUpdateManager</strong>.</p><p>Call this method during Direct Manipulation initialization to connect the compositor to the <em>update manager</em>.</p>
        /// </remarks>
        /// <doc-id>hh768900</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationCompositor::SetUpdateManager([In] IDirectManipulationUpdateManager* updateManager)</unmanaged>
        /// <unmanaged-short>IDirectManipulationCompositor::SetUpdateManager</unmanaged-short>
        public unsafe void SetUpdateManager(SharpDX.DirectManipulation.UpdateManager updateManager)
        {
            System.IntPtr updateManager_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            updateManager_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectManipulation.UpdateManager>(updateManager);
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)updateManager_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Commits all pending updates in the compositor to the system for rendering.</p>
        /// </summary>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>This method enables Direct Manipulation to flush any pending changes to its visuals before a system event, such as a process suspension.</p>
        /// </remarks>
        /// <doc-id>jj647930</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationCompositor::Flush()</unmanaged>
        /// <unmanaged-short>IDirectManipulationCompositor::Flush</unmanaged-short>
        public unsafe void Flush()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("B89962CB-3D89-442B-BB58-5098FA0F9F16")]
    public partial class Content : SharpDX.ComObject
    {
        public Content(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Content(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Content(nativePtr);
        /// <summary>
        /// <p>Retrieves or sets the bounding rectangle of the content, relative to the bounding rectangle of the viewport (if defined).</p>
        /// </summary>
        /// <remarks>
        /// <p>If the bounding rectangle  has not been set using <strong>SetContentRect</strong>, then <strong>UI_E_VALUE_NOT_SET</strong> is returned. However, the actual content rectangle is (-FLT_MAX, -FLT_MAX, FLT_MAX, FLT_MAX).</p>
        /// </remarks>
        /// <doc-id>hh768901</doc-id>
        /// <unmanaged>GetContentRect / SetContentRect</unmanaged>
        /// <unmanaged-short>GetContentRect</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawRectangle ContentRect
        {
            get
            {
                GetContentRect(out var __output__);
                return __output__;
            }

            set => SetContentRect(value);
        }

        /// <summary>
        /// <p>Retrieves the bounding rectangle of the content, relative to the bounding rectangle of the viewport (if defined).</p>
        /// </summary>
        /// <param name = "contentSize"><dd> <p>The bounding rectangle of the content.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>If the bounding rectangle  has not been set using <strong>SetContentRect</strong>, then <strong>UI_E_VALUE_NOT_SET</strong> is returned. However, the actual content rectangle is (-FLT_MAX, -FLT_MAX, FLT_MAX, FLT_MAX).</p>
        /// </remarks>
        /// <doc-id>hh768901</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationContent::GetContentRect([Out] RECT* contentSize)</unmanaged>
        /// <unmanaged-short>IDirectManipulationContent::GetContentRect</unmanaged-short>
        internal unsafe void GetContentRect(out SharpDX.Mathematics.Interop.RawRectangle contentSize)
        {
            contentSize = default (SharpDX.Mathematics.Interop.RawRectangle);
            SharpDX.Result __result__;
            fixed (void *contentSize_ = &contentSize)
                __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, contentSize_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Specifies the bounding rectangle of the content, relative to its viewport.
        /// </p>
        /// </summary>
        /// <param name = "contentSize"><dd> <p>The bounding rectangle of the content.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The default bounding rectangle is (-FLT_MAX, -FLT_MAX, FLT_MAX, FLT_MAX).</p>
        /// </remarks>
        /// <doc-id>hh768903</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationContent::SetContentRect([In] const RECT* contentSize)</unmanaged>
        /// <unmanaged-short>IDirectManipulationContent::SetContentRect</unmanaged-short>
        internal unsafe void SetContentRect(SharpDX.Mathematics.Interop.RawRectangle contentSize)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, &contentSize, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the viewport that contains the content.</p>
        /// </summary>
        /// <param name = "riid"><dd> <p>A reference to the identifier of the interface to use.</p> </dd></param>
        /// <param name = "@object"><dd> <p>The viewport object.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh447011</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationContent::GetViewport([In] const GUID&amp; riid,[Out] void** object)</unmanaged>
        /// <unmanaged-short>IDirectManipulationContent::GetViewport</unmanaged-short>
        public unsafe void GetViewport(System.Guid riid, out System.IntPtr @object)
        {
            SharpDX.Result __result__;
            fixed (void *@object_ = &@object)
                __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, &riid, @object_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> </p><p>Retrieves the tag object set on this content. </p>
        /// </summary>
        /// <param name = "riid"><dd> <p>A reference to the identifier of the interface to use. The tag object typically implements this interface.</p> </dd></param>
        /// <param name = "@object"><dd> <p>The tag object.</p> </dd></param>
        /// <param name = "id"><dd> <p>The ID portion of the tag.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p><strong>GetTag</strong> and <strong>SetTag</strong> are useful for associating an external COM object with the content without an external mapping between the two. They can also be used to pass information to callbacks generated for the content.</p><p><strong>GetTag</strong> queries the tag value for the specified interface and returns a reference to that interface.</p><p>A tag is a pairing of an integer ID (<em>id</em>) with a Component Object Model (COM) object (<em>object</em>). It can be used by an app to identify a motion.
        /// The parameters are optional, so that the method can return both parts of the tag, the identifier portion, or the tag object. </p>
        /// </remarks>
        /// <doc-id>hh447009</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationContent::GetTag([In] const GUID&amp; riid,[Out, Optional] void** object,[Out, Optional] unsigned int* id)</unmanaged>
        /// <unmanaged-short>IDirectManipulationContent::GetTag</unmanaged-short>
        public unsafe void GetTag(System.Guid riid, out System.IntPtr @object, out System.Int32 id)
        {
            SharpDX.Result __result__;
            fixed (void *id_ = &id)
                fixed (void *@object_ = &@object)
                    __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, &riid, @object_, id_, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Specifies the tag object for the content. </p>
        /// </summary>
        /// <param name = "@object"><dd> <p>The object portion of the tag.</p> </dd></param>
        /// <param name = "id"><dd> <p>The ID portion of the tag.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p> <strong>GetTag</strong> and <strong>SetTag</strong> are useful for associating an external COM object with the content without an external mapping between the two. They can also be used to pass information to callbacks generated for the content.</p><p>A tag is a pairing of an integer ID  (<em>id</em>) with a Component Object Model (COM) object (<em>object</em>). It can be used by an app to store and retrieve an arbitrary object associated with the content.</p><p>The <em>object</em> parameter is optional, so that the method can set just the identifier portion. </p>
        /// </remarks>
        /// <doc-id>hh447021</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationContent::SetTag([In, Optional] IUnknown* object,[In] unsigned int id)</unmanaged>
        /// <unmanaged-short>IDirectManipulationContent::SetTag</unmanaged-short>
        public unsafe void SetTag(SharpDX.IUnknown @object, System.Int32 id)
        {
            System.IntPtr @object_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            @object_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(@object);
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)@object_, id, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the final transform applied to the content.</p>
        /// </summary>
        /// <param name = "matrix"><dd> <p>The transform matrix.</p> </dd></param>
        /// <param name = "pointCount"><dd> <p>The size of the transform matrix. This value is always 6, because a 3x2 matrix is used for all direct manipulation transforms.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>This transform might contain the other custom curves applied during manipulation and inertia.</p><p>This transform contains both the content transform and the sync transform set with <strong>SyncContentTransform</strong>. 
        /// </p><p></p><dl> <dt>The relationship between the three primary transforms is defined as:</dt> <dd> <code>Output transform = Pixel rounding (Sync transform * Content transform)</code> </dd> </dl>
        /// </remarks>
        /// <doc-id>hh447007</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationContent::GetOutputTransform([Out, Buffer] float* matrix,[In] DWORD pointCount)</unmanaged>
        /// <unmanaged-short>IDirectManipulationContent::GetOutputTransform</unmanaged-short>
        internal unsafe void GetOutputTransform(System.Single[] matrix, System.Int32 pointCount)
        {
            SharpDX.Result __result__;
            fixed (void *matrix_ = matrix)
                __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, matrix_, pointCount, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Retrieves the transform applied to the content.</p>
        /// </summary>
        /// <param name = "matrix"><dd> <p>The transform matrix.</p> </dd></param>
        /// <param name = "pointCount"><dd> <p>The size of the transform matrix. This value is always 6, because a 3x2 matrix is used for all direct manipulation transforms.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>This transform contains the default overpan and bounce curves during manipulation and inertia.</p><p>This transform does not contain the sync transform set with <strong>SyncContentTransform</strong>.</p><p></p><dl> <dt>The relationship between the three primary transforms is defined as:</dt> <dd> <code>Output transform = Pixel rounding (Sync transform * Content transform)</code> </dd> </dl><p>When this method returns, the format of <em>matrix</em> is:</p><dl> <dd><em>matrix</em>[0]=ScaleX</dd> <dd><em>matrix</em>[1]=Unused</dd> <dd><em>matrix</em>[2]=Unused</dd> <dd><em>matrix</em>[3]=ScaleY
        /// </dd> <dd><em>matrix</em>[4]=TranslateX</dd> <dd><em>matrix</em>[5]=TranslateY</dd> </dl>
        /// </remarks>
        /// <doc-id>hh768902</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationContent::GetContentTransform([Out, Buffer] float* matrix,[In] DWORD pointCount)</unmanaged>
        /// <unmanaged-short>IDirectManipulationContent::GetContentTransform</unmanaged-short>
        internal unsafe void GetContentTransform(System.Single[] matrix, System.Int32 pointCount)
        {
            SharpDX.Result __result__;
            fixed (void *matrix_ = matrix)
                __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, matrix_, pointCount, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Modifies the content transform while maintaining the output transform.</p>
        /// </summary>
        /// <param name = "matrix"><dd> <p>The transform matrix.</p> </dd></param>
        /// <param name = "pointCount"><dd> <p>The size of the transform matrix. This value is always 6, because a 3x2 matrix is used for all direct manipulation transforms.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>This method will fail if the viewport state is <strong>DIRECTMANIPULATION_RUNNING</strong>, <strong>DIRECTMANIPULATION_INERTIA</strong> or <strong>DIRECTMANIPULATION_SUSPENDED</strong>.</p><p>This method is useful when the application wants to apply transforms on top of the content transforms at the end of a manipulation, while preserving the visual output transform of the content.</p><p></p><dl> <dt>The relationship between the three primary transforms is defined as:</dt> <dd> <code>Output transform = Pixel rounding (Sync transform * Content transform)</code> </dd> </dl>
        /// </remarks>
        /// <doc-id>hh768904</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationContent::SyncContentTransform([In, Buffer] const float* matrix,[In] DWORD pointCount)</unmanaged>
        /// <unmanaged-short>IDirectManipulationContent::SyncContentTransform</unmanaged-short>
        internal unsafe void SyncContentTransform(System.Single[] matrix, System.Int32 pointCount)
        {
            SharpDX.Result __result__;
            fixed (void *matrix_ = matrix)
                __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, matrix_, pointCount, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("652D5C71-FE60-4A98-BE70-E5F21291E7F1")]
    public partial class DeferContactService : SharpDX.ComObject
    {
        public DeferContactService(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DeferContactService(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DeferContactService(nativePtr);
        /// <summary>
        /// <p>Specifies the amount of time to defer the execution of a call to <strong>SetContact</strong> for this <em>referenceId</em>.</p><p><strong>DeferContact</strong> must be called before <strong>SetContact</strong>.</p>
        /// </summary>
        /// <param name = "pointerId">No documentation.</param>
        /// <param name = "timeout">No documentation.</param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn972380</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationDeferContactService::DeferContact([In] unsigned int pointerId,[In] unsigned int timeout)</unmanaged>
        /// <unmanaged-short>IDirectManipulationDeferContactService::DeferContact</unmanaged-short>
        public unsafe void DeferContact(System.Int32 pointerId, System.Int32 timeout)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, pointerId, timeout, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Cancel all scheduled calls to <strong>SetContact</strong> for this <em>referenceId</em>.    </p>
        /// </summary>
        /// <param name = "pointerId">No documentation.</param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>This function fails if the timeout specified in <strong>DeferContact</strong> has already been reached.  </p>
        /// </remarks>
        /// <doc-id>dn972378</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationDeferContactService::CancelContact([In] unsigned int pointerId)</unmanaged>
        /// <unmanaged-short>IDirectManipulationDeferContactService::CancelContact</unmanaged-short>
        public unsafe void CancelContact(System.Int32 pointerId)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, pointerId, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Cancel the deferral set in <strong>DeferContact</strong> and process the scheduled <strong>SetContact</strong> call for this <em>referenceId</em>.    </p>
        /// </summary>
        /// <param name = "pointerId">No documentation.</param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn972379</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationDeferContactService::CancelDeferral([In] unsigned int pointerId)</unmanaged>
        /// <unmanaged-short>IDirectManipulationDeferContactService::CancelDeferral</unmanaged-short>
        public unsafe void CancelDeferral(System.Int32 pointerId)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, pointerId, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("814B5AF5-C2C8-4270-A9B7-A198CE8D02FA")]
    public partial class DragDropBehavior : SharpDX.ComObject
    {
        public DragDropBehavior(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DragDropBehavior(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DragDropBehavior(nativePtr);
        /// <summary>
        /// <p>Sets the configuration of the drag-drop interaction for the viewport this behavior is attached to. </p>
        /// </summary>
        /// <remarks>
        /// <p>The configuration of the behavior can be set before or after it has been added to a viewport. If a configuration change is made while an interaction is occurring, the new configuration takes effect on the next interaction. ?
        /// </p><p> <strong>IDirectManipulationViewport::ActivateConfiguration</strong> should not be called prior to calling <strong>IDirectManipulationDragDropBehavior::SetConfiguration</strong>. This will result in  unexpected behavior.</p>
        /// </remarks>
        /// <doc-id>dn280391</doc-id>
        /// <unmanaged>SetConfiguration</unmanaged>
        /// <unmanaged-short>SetConfiguration</unmanaged-short>
        public SharpDX.DirectManipulation.DragDropConfiguration Configuration
        {
            set => SetConfiguration(value);
        }

        /// <summary>
        /// <p>Gets the status of the drag-drop interaction for the viewport this behavior is attached to. </p>
        /// </summary>
        /// <remarks>
        /// <p>This method returns the drag-drop status at the time of the call and not at the time when the return value is read.</p>
        /// </remarks>
        /// <doc-id>dn280390</doc-id>
        /// <unmanaged>GetStatus</unmanaged>
        /// <unmanaged-short>GetStatus</unmanaged-short>
        public SharpDX.DirectManipulation.DragDropStatus Status
        {
            get
            {
                GetStatus(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Sets the configuration of the drag-drop interaction for the viewport this behavior is attached to. </p>
        /// </summary>
        /// <param name = "configuration"><dd> <p>Combination  of values from <strong><see cref = "SharpDX.DirectManipulation.DragDropConfiguration"/></strong>.</p> <p>For the configuration to be valid, <em>configuration</em> must contain exactly one of the following three values:</p><ul> <li><strong>DIRECTMANIPULATION_DRAG_DROP_CONFIGURATION_SELECT_ONLY</strong></li> <li><strong>DIRECTMANIPULATION_DRAG_DROP_CONFIGURATION_SELECT_DRAG</strong></li> <li><strong>DIRECTMANIPULATION_DRAG_DROP_CONFIGURATION_HOLD_DRAG</strong></li> </ul> <p>If <strong>DIRECTMANIPULATION_DRAG_DROP_CONFIGURATION_SELECT_ONLY</strong> or  <strong>DIRECTMANIPULATION_DRAG_DROP_CONFIGURATION_SELECT_DRAG</strong> is specified, one of <strong>DIRECTMANIPULATION_DRAG_DROP_CONFIGURATION_VERTICAL</strong> or <strong>DIRECTMANIPULATION_DRAG_DROP_CONFIGURATION_HORIZONTAL</strong> is required.</p> <p>If <strong>DIRECTMANIPULATION_DRAG_DROP_CONFIGURATION_HOLD_DRAG</strong> is specified, both <strong>DIRECTMANIPULATION_DRAG_DROP_CONFIGURATION_VERTICAL</strong> and <strong>DIRECTMANIPULATION_DRAG_DROP_CONFIGURATION_HORIZONTAL</strong> are required.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The configuration of the behavior can be set before or after it has been added to a viewport. If a configuration change is made while an interaction is occurring, the new configuration takes effect on the next interaction. ?
        /// </p><p> <strong>IDirectManipulationViewport::ActivateConfiguration</strong> should not be called prior to calling <strong>IDirectManipulationDragDropBehavior::SetConfiguration</strong>. This will result in  unexpected behavior.</p>
        /// </remarks>
        /// <doc-id>dn280391</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationDragDropBehavior::SetConfiguration([In] DIRECTMANIPULATION_DRAG_DROP_CONFIGURATION configuration)</unmanaged>
        /// <unmanaged-short>IDirectManipulationDragDropBehavior::SetConfiguration</unmanaged-short>
        internal unsafe void SetConfiguration(SharpDX.DirectManipulation.DragDropConfiguration configuration)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)configuration), (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the status of the drag-drop interaction for the viewport this behavior is attached to. </p>
        /// </summary>
        /// <param name = "status"><dd> <p>One of the values from <strong><see cref = "SharpDX.DirectManipulation.DragDropStatus"/></strong>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>This method returns the drag-drop status at the time of the call and not at the time when the return value is read.</p>
        /// </remarks>
        /// <doc-id>dn280390</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationDragDropBehavior::GetStatus([Out] DIRECTMANIPULATION_DRAG_DROP_STATUS* status)</unmanaged>
        /// <unmanaged-short>IDirectManipulationDragDropBehavior::GetStatus</unmanaged-short>
        internal unsafe void GetStatus(out SharpDX.DirectManipulation.DragDropStatus status)
        {
            SharpDX.Result __result__;
            fixed (void *status_ = &status)
                __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, status_, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("1FA11B10-701B-41AE-B5F2-49E36BD595AA")]
    public partial class DragDropEventHandler : SharpDX.ComObject
    {
        public DragDropEventHandler(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DragDropEventHandler(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DragDropEventHandler(nativePtr);
        /// <summary>
        /// <p>Called when a status change happens in the viewport that the drag-and-drop behavior is attached to. </p>
        /// </summary>
        /// <param name = "viewport"><dd> <p>The updated viewport.</p> </dd></param>
        /// <param name = "current"><dd> <p>The current state of the drag-drop interaction from <strong><see cref = "SharpDX.DirectManipulation.DragDropStatus"/></strong>. </p> </dd></param>
        /// <param name = "previous"><dd> <p>The previous state of the drag-drop interaction from <strong><see cref = "SharpDX.DirectManipulation.DragDropStatus"/></strong>. </p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>If a class  is implementing <strong><see cref = "SharpDX.DirectManipulation.ViewportEventHandler"/></strong> it should also implement <strong><see cref = "SharpDX.DirectManipulation.DragDropEventHandler"/></strong> if that viewport will use drag and drop. Direct Manipulation will query the <strong><see cref = "SharpDX.DirectManipulation.ViewportEventHandler"/></strong> instances to verify that  they also implement <strong><see cref = "SharpDX.DirectManipulation.DragDropEventHandler"/></strong>.
        /// </p>
        /// </remarks>
        /// <doc-id>dn280393</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationDragDropEventHandler::OnDragDropStatusChange([In] IDirectManipulationViewport2* viewport,[In] DIRECTMANIPULATION_DRAG_DROP_STATUS current,[In] DIRECTMANIPULATION_DRAG_DROP_STATUS previous)</unmanaged>
        /// <unmanaged-short>IDirectManipulationDragDropEventHandler::OnDragDropStatusChange</unmanaged-short>
        public unsafe void OnDragDropStatusChange(SharpDX.DirectManipulation.Viewport2 viewport, SharpDX.DirectManipulation.DragDropStatus current, SharpDX.DirectManipulation.DragDropStatus previous)
        {
            System.IntPtr viewport_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            viewport_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectManipulation.Viewport2>(viewport);
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)viewport_, unchecked ((System.Int32)current), unchecked ((System.Int32)previous), (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("fb759dba-6f4c-4c01-874e-19c8a05907f9")]
    public partial class FrameInfoProvider : SharpDX.ComObject
    {
        public FrameInfoProvider(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator FrameInfoProvider(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new FrameInfoProvider(nativePtr);
        /// <summary>
        /// <p>Retrieves the composition timing information from the compositor.</p>
        /// </summary>
        /// <param name = "time"><dd> <p>The current time, in milliseconds.</p> </dd></param>
        /// <param name = "rocessTimeRef"><dd> <p>The time, in milliseconds, when the compositor begins constructing the next frame.</p> </dd></param>
        /// <param name = "compositionTime"><dd> <p>The time, in milliseconds, when the compositor finishes composing and drawing the next frame on the screen.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The system implementation of <strong><see cref = "SharpDX.DirectManipulation.FrameInfoProvider"/></strong> uses DirectComposition. <strong>GetFrameStatistics</strong> is used to calculate the parameter values for <strong>GetNextFrameInfo</strong>.</p>
        /// </remarks>
        /// <doc-id>hh446977</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationFrameInfoProvider::GetNextFrameInfo([Out] unsigned longlong* time,[Out] unsigned longlong* processTime,[Out] unsigned longlong* compositionTime)</unmanaged>
        /// <unmanaged-short>IDirectManipulationFrameInfoProvider::GetNextFrameInfo</unmanaged-short>
        public unsafe void GetNextFrameInfo(out System.Int64 time, out System.Int64 rocessTimeRef, out System.Int64 compositionTime)
        {
            SharpDX.Result __result__;
            fixed (void *compositionTime_ = &compositionTime)
                fixed (void *rocessTimeRef_ = &rocessTimeRef)
                    fixed (void *time_ = &time)
                        __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, time_, rocessTimeRef_, compositionTime_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("E43F45B8-42B4-403E-B1F2-273B8F510830")]
    public partial class InteractionEventHandler : SharpDX.ComObject
    {
        public InteractionEventHandler(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator InteractionEventHandler(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new InteractionEventHandler(nativePtr);
        /// <summary>
        /// <p>Called when an interaction is detected.</p>
        /// </summary>
        /// <param name = "viewport"><dd> <p>The viewport on which the interaction was detected.</p> </dd></param>
        /// <param name = "interaction"><dd> <p>One of the values from <strong><see cref = "SharpDX.DirectManipulation.InteractionType"/></strong>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn280395</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationInteractionEventHandler::OnInteraction([In] IDirectManipulationViewport2* viewport,[In] DIRECTMANIPULATION_INTERACTION_TYPE interaction)</unmanaged>
        /// <unmanaged-short>IDirectManipulationInteractionEventHandler::OnInteraction</unmanaged-short>
        public unsafe void OnInteraction(SharpDX.DirectManipulation.Viewport2 viewport, SharpDX.DirectManipulation.InteractionType interaction)
        {
            System.IntPtr viewport_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            viewport_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectManipulation.Viewport2>(viewport);
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)viewport_, unchecked ((System.Int32)interaction), (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("FBF5D3B4-70C7-4163-9322-5A6F660D6FBC")]
    public partial class Manager : SharpDX.ComObject
    {
        public Manager(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Manager(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Manager(nativePtr);
                ///<summary>Constant VerticalIndicatorContent</summary>
        ///<unmanaged>CLSID_VerticalIndicatorContent</unmanaged>
        public static readonly System.Guid VerticalIndicatorContent = new System.Guid("a10b5f17-afe0-4aa2-91e9-3e7001d2e6b4");
                ///<summary>Constant HorizontalIndicatorContent</summary>
        ///<unmanaged>CLSID_HorizontalIndicatorContent</unmanaged>
        public static readonly System.Guid HorizontalIndicatorContent = new System.Guid("e7d18cf5-3ec7-44d5-a76b-3770f3cf903d");
                ///<summary>Constant VirtualViewportContent</summary>
        ///<unmanaged>CLSID_VirtualViewportContent</unmanaged>
        public static readonly System.Guid VirtualViewportContent = new System.Guid("3206a19a-86f0-4cb4-a7f3-16e3b7e2d852");
        /// <summary>
        /// <p>Activates Direct Manipulation for processing input and  handling callbacks on the specified window. </p>
        /// </summary>
        /// <param name = "window">No documentation.</param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The manipulation manager is deactivated, by default. The manager does not receive or respond to input and callbacks until <strong>Activate</strong> is called for the window.  </p><p>Calls to <strong>Activate</strong> and <strong>Deactivate</strong> are reference counted.
        /// </p>
        /// </remarks>
        /// <doc-id>hh447029</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationManager::Activate([In] HWND window)</unmanaged>
        /// <unmanaged-short>IDirectManipulationManager::Activate</unmanaged-short>
        public unsafe void Activate(System.IntPtr window)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)window, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Deactivates Direct Manipulation for processing input and  handling callbacks on the specified window. </p>
        /// </summary>
        /// <param name = "window">No documentation.</param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The manipulation manager is deactivated by default. The manager does not receive or respond to input until <strong>Activate</strong> is called. The manipulation manager should be deactivated when the app does not receive or respond to input. For example, when the app is minimized.</p><p>Calls to <strong>Activate</strong> and <strong>Deactivate</strong> are reference counted.
        /// </p>
        /// </remarks>
        /// <doc-id>hh447036</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationManager::Deactivate([In] HWND window)</unmanaged>
        /// <unmanaged-short>IDirectManipulationManager::Deactivate</unmanaged-short>
        public unsafe void Deactivate(System.IntPtr window)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)window, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Registers a dedicated thread for hit testing.</p>
        /// </summary>
        /// <param name = "window"><dd> <p>The handle of the main app window (typically created from the UI thread).</p> </dd></param>
        /// <param name = "hitTestWindow"><dd> <p>The handle of the window in which hit testing is registered (should be created from the hit testing thread). Pass in nullptr to unregister a previously registered hit-test target.</p> </dd></param>
        /// <param name = "type"><dd> <p>One of the values from <strong><see cref = "SharpDX.DirectManipulation.HitTestType"/></strong>. Specifies whether the UI window or the hit testing window (or both) receives the hit testing <strong>WM_POINTERDOWN</strong> message , and in what order.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Hit testing is typically performed on the application UI thread. The application receives a <strong>WM_POINTERDOWN</strong> message on which hit-testing is performed. If a manipulation is required, <strong>SetContact</strong> is called on one or more viewports. An application can use the <strong>RegisterHitTestTarget</strong> method to delegate this hit-testing responsibility to a separate hit-testing thread.
        /// </p><p>Once a dedicated hit-test target is successfully registered, <strong>WM_POINTERDOWN</strong> messages are processed on the hit-testing thread. If a manipulation, such as pan or zoom, is required, <strong>SetContact</strong> is called from this thread.
        /// </p><p>If <strong>SetContact</strong> is not called from the hit-testing thread, <strong>WM_POINTERDOWN</strong> messages may be processed on the UI thread, depending on the <strong><see cref = "SharpDX.DirectManipulation.HitTestType"/></strong> specified during registration.
        /// </p><p>If <strong>SetContact</strong> is not called by either the hit-test thread or the UI thread, Direct Manipulation ignores the input which is then handled on the UI thread.
        /// </p>
        /// </remarks>
        /// <doc-id>hh768905</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationManager::RegisterHitTestTarget([In] HWND window,[In, Optional] HWND hitTestWindow,[In] DIRECTMANIPULATION_HITTEST_TYPE type)</unmanaged>
        /// <unmanaged-short>IDirectManipulationManager::RegisterHitTestTarget</unmanaged-short>
        public unsafe void RegisterHitTestTarget(System.IntPtr window, System.IntPtr hitTestWindow, SharpDX.DirectManipulation.HitTestType type)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)window, (void *)hitTestWindow, unchecked ((System.Int32)type), (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Passes keyboard and mouse messages to the manipulation manager on the app's UI thread.</p>
        /// </summary>
        /// <param name = "message"><dd> <p>The input message to process.</p> </dd></param>
        /// <param name = "handled"><dd> <p><strong>TRUE</strong> if no further processing should be done with this message; otherwise, <strong><see cref = "SharpDX.Result.False"/></strong>.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Call this method for mouse and keyboard input.</p>
        /// </remarks>
        /// <doc-id>hh447040</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationManager::ProcessInput([In] const MSG* message,[Out] BOOL* handled)</unmanaged>
        /// <unmanaged-short>IDirectManipulationManager::ProcessInput</unmanaged-short>
        public unsafe void ProcessInput(ref SharpDX.Win32.NativeMessage message, out SharpDX.Mathematics.Interop.RawBool handled)
        {
            handled = default (SharpDX.Mathematics.Interop.RawBool);
            SharpDX.Result __result__;
            fixed (void *handled_ = &handled)
                fixed (void *message_ = &message)
                    __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, message_, handled_, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets a reference to an <strong><see cref = "SharpDX.DirectManipulation.UpdateManager"/></strong> object that receives compositor updates. </p>
        /// </summary>
        /// <param name = "riid">No documentation.</param>
        /// <param name = "@object">No documentation.</param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>For the compositor to respond to update events from Direct Manipulation, you must associate <strong><see cref = "SharpDX.DirectManipulation.UpdateManager"/></strong> to an <strong><see cref = "SharpDX.DirectManipulation.Compositor"/></strong> object during initialization. Use  <strong>GetUpdateManager</strong> to obtain a reference to a <strong><see cref = "SharpDX.DirectManipulation.UpdateManager"/></strong> object. Pass this reference to the compositor using the <strong>SetUpdateManager</strong> method.</p>
        /// </remarks>
        /// <doc-id>hh447038</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationManager::GetUpdateManager([In] const GUID&amp; riid,[Out] void** object)</unmanaged>
        /// <unmanaged-short>IDirectManipulationManager::GetUpdateManager</unmanaged-short>
        public unsafe void GetUpdateManager(System.Guid riid, out System.IntPtr @object)
        {
            SharpDX.Result __result__;
            fixed (void *@object_ = &@object)
                __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, &riid, @object_, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>The factory method that is used to create a new <strong><see cref = "SharpDX.DirectManipulation.Viewport"/></strong> object.</p><p>The viewport manages the interaction state and mapping of input to output actions.</p>
        /// </summary>
        /// <param name = "frameInfo">No documentation.</param>
        /// <param name = "window">No documentation.</param>
        /// <param name = "riid">No documentation.</param>
        /// <param name = "@object">No documentation.</param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh447034</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationManager::CreateViewport([In, Optional] IDirectManipulationFrameInfoProvider* frameInfo,[In] HWND window,[In] const GUID&amp; riid,[Out] void** object)</unmanaged>
        /// <unmanaged-short>IDirectManipulationManager::CreateViewport</unmanaged-short>
        internal unsafe void CreateViewport(SharpDX.DirectManipulation.FrameInfoProvider frameInfo, System.IntPtr window, System.Guid riid, out System.IntPtr @object)
        {
            System.IntPtr frameInfo_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            frameInfo_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectManipulation.FrameInfoProvider>(frameInfo);
            fixed (void *@object_ = &@object)
                __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)frameInfo_, (void *)window, &riid, @object_, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>The factory method that is used to create an instance of secondary content (such as a panning indicator) inside a viewport.</p>
        /// </summary>
        /// <param name = "frameInfo"><dd> <p>The frame info provider for the secondary content. This should match the frame info provider used to create the viewport.</p> </dd></param>
        /// <param name = "clsid"><dd> <p>Class identifier (CLSID) of the secondary content. This ID specifies the content type.</p> </dd></param>
        /// <param name = "riid"><dd> <p>IID of the interface.</p> </dd></param>
        /// <param name = "@object"><dd> <p>The secondary content object that implements the specified interface.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Primary content is automatically created at the same time as the viewport and has a one-to-one relationship to a viewport. Therefore, it is not possible to create, add, or remove primary content.</p><p>Secondary content is created independently from the viewport. There is no limit to how much secondary content can be added or removed from a viewport. All secondary content transforms are derived from those supported by the primary content with specific rules applied based on the intended purpose of the element (identified by its Class identifier (CLSID)).</p>
        /// </remarks>
        /// <doc-id>hh447030</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationManager::CreateContent([In, Optional] IDirectManipulationFrameInfoProvider* frameInfo,[In] const GUID&amp; clsid,[In] const GUID&amp; riid,[Out] void** object)</unmanaged>
        /// <unmanaged-short>IDirectManipulationManager::CreateContent</unmanaged-short>
        internal unsafe void CreateContent(SharpDX.DirectManipulation.FrameInfoProvider frameInfo, System.Guid clsid, System.Guid riid, out System.IntPtr @object)
        {
            System.IntPtr frameInfo_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            frameInfo_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectManipulation.FrameInfoProvider>(frameInfo);
            fixed (void *@object_ = &@object)
                __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)frameInfo_, &clsid, &riid, @object_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("FA1005E9-3D16-484C-BFC9-62B61E56EC4E")]
    public partial class Manager2 : SharpDX.DirectManipulation.Manager
    {
        public Manager2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Manager2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Manager2(nativePtr);
                ///<summary>Constant DragDropConfigurationBehavior</summary>
        ///<unmanaged>CLSID_DragDropConfigurationBehavior</unmanaged>
        public static readonly System.Guid DragDropConfigurationBehavior = new System.Guid("09b01b3e-ba6c-454d-82e8-95e352329f23");
                ///<summary>Constant AutoScrollBehavior</summary>
        ///<unmanaged>CLSID_AutoScrollBehavior</unmanaged>
        public static readonly System.Guid AutoScrollBehavior = new System.Guid("26126a51-3c70-4c9a-aec2-948849eeb093");
        /// <summary>
        /// <p>Factory method to create a behavior.</p>
        /// </summary>
        /// <param name = "clsid"><dd> <p>CLSID of the behavior. The CLSID specifies the type of behavior.</p> </dd></param>
        /// <param name = "riid"><dd> <p>The IID of the behavior interface to create.</p> </dd></param>
        /// <param name = "@object"><dd> <p>The new behavior object that implements the specified interface.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn280397</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationManager2::CreateBehavior([In] const GUID&amp; clsid,[In] const GUID&amp; riid,[Out] void** object)</unmanaged>
        /// <unmanaged-short>IDirectManipulationManager2::CreateBehavior</unmanaged-short>
        internal unsafe void CreateBehavior(System.Guid clsid, System.Guid riid, out System.IntPtr @object)
        {
            SharpDX.Result __result__;
            fixed (void *@object_ = &@object)
                __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, &clsid, &riid, @object_, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("2CB6B33D-FFE8-488C-B750-FBDFE88DCA8C")]
    public partial class Manager3 : SharpDX.DirectManipulation.Manager2
    {
        public Manager3(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Manager3(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Manager3(nativePtr);
        /// <summary>
        /// <p>Retrieves an <strong><see cref = "SharpDX.DirectManipulation.DeferContactService"/></strong> object.</p>
        /// </summary>
        /// <param name = "clsid">No documentation.</param>
        /// <param name = "riid">No documentation.</param>
        /// <param name = "@object">No documentation.</param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>mt622457</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationManager3::GetService([In] const GUID&amp; clsid,[In] const GUID&amp; riid,[Out] void** object)</unmanaged>
        /// <unmanaged-short>IDirectManipulationManager3::GetService</unmanaged-short>
        public unsafe void GetService(System.Guid clsid, System.Guid riid, out System.IntPtr @object)
        {
            SharpDX.Result __result__;
            fixed (void *@object_ = &@object)
                __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, &clsid, &riid, @object_, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("C12851E4-1698-4625-B9B1-7CA3EC18630B")]
    public partial class PrimaryContent : SharpDX.ComObject
    {
        public PrimaryContent(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator PrimaryContent(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new PrimaryContent(nativePtr);
        /// <summary>
        /// <p>Sets the horizontal alignment of the primary content relative to the viewport.</p>
        /// </summary>
        /// <remarks>
        /// <p>If you have activated a configuration consisting only of zoom or zoom inertia, specify DIRECTMANIPULATION_HORIZONTALALIGNMENT_UNLOCKCENTER to respect the zoom center point.</p>
        /// </remarks>
        /// <doc-id>hh768909</doc-id>
        /// <unmanaged>SetHorizontalAlignment</unmanaged>
        /// <unmanaged-short>SetHorizontalAlignment</unmanaged-short>
        public SharpDX.DirectManipulation.HorizontalAlignment HorizontalAlignment
        {
            set => SetHorizontalAlignment(value);
        }

        /// <summary>
        /// <p>Specifies the vertical alignment of the primary content in the viewport.</p>
        /// </summary>
        /// <remarks>
        /// <p>If you have activated a configuration consisting only of zoom or zoom inertia, specify <strong>DIRECTMANIPULATION_VERTICALALIGNMENT_UNLOCKCENTER</strong> to respect the zoom center point.</p>
        /// </remarks>
        /// <doc-id>hh768914</doc-id>
        /// <unmanaged>SetVerticalAlignment</unmanaged>
        /// <unmanaged-short>SetVerticalAlignment</unmanaged-short>
        public SharpDX.DirectManipulation.VerticalAlignment VerticalAlignment
        {
            set => SetVerticalAlignment(value);
        }

        /// <summary>
        /// <p> Specifies snap points for the inertia end position at uniform intervals.</p>
        /// </summary>
        /// <param name = "motion"><dd> <p>One of the <strong><see cref = "SharpDX.DirectManipulation.MotionTypes"/></strong> enumeration values.</p> </dd></param>
        /// <param name = "interval"><dd> <p>The interval between each snap point.</p> </dd></param>
        /// <param name = "offset"><dd> <p>The offset from the coordinate specified in <strong>SetSnapCoordinate</strong>.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Snap point locations are in content coordinate units. </p><p>Specify snap points through <strong>SetSnapPoints</strong> or <strong>SetSnapInterval</strong>. </p><p>If snap points are invalid (for example, outside of the content boundaries), they are ignored and the content is always within the content boundaries. </p><p>Snap points are not at boundaries by default. If you wish for content to stop at a boundary, a snap point must be set at the boundary.</p><p> Snap points set by <strong>SetSnapInterval</strong> can be cleared by calling <strong>SetSnapInterval</strong> with an interval of 0.0f.</p>
        /// </remarks>
        /// <doc-id>hh768911</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationPrimaryContent::SetSnapInterval([In] DIRECTMANIPULATION_MOTION_TYPES motion,[In] float interval,[In] float offset)</unmanaged>
        /// <unmanaged-short>IDirectManipulationPrimaryContent::SetSnapInterval</unmanaged-short>
        public unsafe void SetSnapInterval(SharpDX.DirectManipulation.MotionTypes motion, System.Single interval, System.Single offset)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)motion), interval, offset, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Specifies the snap points for the inertia rest position.</p>
        /// </summary>
        /// <param name = "motion"><dd> <p>One or more of the <strong><see cref = "SharpDX.DirectManipulation.MotionTypes"/></strong> enumeration values. Only <strong>DIRECTMANIPULATION_MOTION_TRANSLATE_X</strong>, <strong>DIRECTMANIPULATION_MOTION_TRANSLATE_Y</strong>, or <strong>DIRECTMANIPULATION_MOTION_ZOOM</strong> are allowed.</p> </dd></param>
        /// <param name = "ointsRef"><dd> <p>An array of snap points within the boundaries of the content to snap to. Should be specified in increasing order relative to the origin set in <strong>SetSnapCoordinate</strong>.</p> </dd></param>
        /// <param name = "pointCount"><dd> <p> The size of the array of snap points. Should be greater than 0.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If there is no change in the snap points, this method can return <strong>S_FALSE</strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. If invalid snap points are specified, existing snap points might be affected.</p></returns>
        /// <remarks>
        /// <p>If snap points are invalid (for example, outside of the content boundaries), they are ignored and the content is always within the content boundaries. </p>
        /// </remarks>
        /// <doc-id>hh768912</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationPrimaryContent::SetSnapPoints([In] DIRECTMANIPULATION_MOTION_TYPES motion,[In, Buffer, Optional] const float* points,[In] DWORD pointCount)</unmanaged>
        /// <unmanaged-short>IDirectManipulationPrimaryContent::SetSnapPoints</unmanaged-short>
        public unsafe void SetSnapPoints(SharpDX.DirectManipulation.MotionTypes motion, System.Single[] ointsRef, System.Int32 pointCount)
        {
            SharpDX.Result __result__;
            fixed (void *ointsRef_ = ointsRef)
                __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)motion), ointsRef_, pointCount, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Specifies the type of snap point.</p>
        /// </summary>
        /// <param name = "motion"><dd> <p>One or more of the <strong><see cref = "SharpDX.DirectManipulation.MotionTypes"/></strong> enumeration values.</p> </dd></param>
        /// <param name = "type"><dd> <p>One of the <strong><see cref = "SharpDX.DirectManipulation.SnapPointType"/></strong> enumeration values.</p> <p>If set to <strong>DIRECTMANIPULATION_SNAPPOINT_TYPE_NONE</strong>, snap points specified through <strong>SetSnapPoints</strong> or <strong>SetSnapInterval</strong> are cleared.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh768913</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationPrimaryContent::SetSnapType([In] DIRECTMANIPULATION_MOTION_TYPES motion,[In] DIRECTMANIPULATION_SNAPPOINT_TYPE type)</unmanaged>
        /// <unmanaged-short>IDirectManipulationPrimaryContent::SetSnapType</unmanaged-short>
        public unsafe void SetSnapType(SharpDX.DirectManipulation.MotionTypes motion, SharpDX.DirectManipulation.SnapPointType type)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)motion), unchecked ((System.Int32)type), (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Specifies the coordinate system for snap points or snap intervals. </p>
        /// </summary>
        /// <param name = "motion"><dd> <p>One of the values from <strong><see cref = "SharpDX.DirectManipulation.MotionTypes"/></strong>. </p> </dd></param>
        /// <param name = "coordinate"><dd> <p>One of the values from <strong><see cref = "SharpDX.DirectManipulation.SnapPointCoordinate"/></strong>. </p> <p>If <em>motion</em> is set to translation (<strong>DIRECTMANIPULATION_MOTION_TRANSLATEX</strong> or <strong>DIRECTMANIPULATION_MOTION_TRANSLATEY</strong>), all values of <strong><see cref = "SharpDX.DirectManipulation.SnapPointCoordinate"/></strong> are valid. </p> <p>If <em>motion</em> is set to <strong>DIRECTMANIPULATION_MOTION_ZOOM</strong>, only <strong>DIRECTMANIPULATION_COORDINATE_ORIGIN</strong> of <strong><see cref = "SharpDX.DirectManipulation.SnapPointCoordinate"/></strong> is valid (<em>origin</em> must be set to 0.0f).</p> </dd></param>
        /// <param name = "origin"><dd> <p>The initial, or starting, snap point. All snap points are relative to this one. Only used when  <strong>DIRECTMANIPULATION_COORDINATE_ORIGIN</strong> is set. </p> <p>If <em>motion</em> is set to <strong>DIRECTMANIPULATION_MOTION_ZOOM</strong>, then <em>origin</em> must be set to 0.0f.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The origin is relative to the content boundaries. If no boundary has been set (<strong>SetContentRect</strong> is never called) the default boundaries are (-FLT_MAX, FLT_MAX). </p>
        /// </remarks>
        /// <doc-id>hh768910</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationPrimaryContent::SetSnapCoordinate([In] DIRECTMANIPULATION_MOTION_TYPES motion,[In] DIRECTMANIPULATION_SNAPPOINT_COORDINATE coordinate,[In] float origin)</unmanaged>
        /// <unmanaged-short>IDirectManipulationPrimaryContent::SetSnapCoordinate</unmanaged-short>
        public unsafe void SetSnapCoordinate(SharpDX.DirectManipulation.MotionTypes motion, SharpDX.DirectManipulation.SnapPointCoordinate coordinate, System.Single origin)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)motion), unchecked ((System.Int32)coordinate), origin, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Specifies the minimum and maximum boundaries for zoom.</p>
        /// </summary>
        /// <param name = "zoomMinimum"><dd> <p>The minimum zoom level allowed. Must be greater than or equal to 0.1f, which corresponds to 100% zoom.</p> </dd></param>
        /// <param name = "zoomMaximum"><dd> <p>The maximum zoom allowed. Must be greater than <em>zoomMinimum</em> and less than FLT_MAX.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>If the content is outside the new boundaries, and the viewport is ENABLED or READY, then the content is reset to be within the new boundaries. If inertia configuration is enabled, the reset operation uses an inertia animation. </p>
        /// </remarks>
        /// <doc-id>hh768915</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationPrimaryContent::SetZoomBoundaries([In] float zoomMinimum,[In] float zoomMaximum)</unmanaged>
        /// <unmanaged-short>IDirectManipulationPrimaryContent::SetZoomBoundaries</unmanaged-short>
        public unsafe void SetZoomBoundaries(System.Single zoomMinimum, System.Single zoomMaximum)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, zoomMinimum, zoomMaximum, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the horizontal alignment of the primary content relative to the viewport.</p>
        /// </summary>
        /// <param name = "alignment"><dd> <p>One or more values from <strong><see cref = "SharpDX.DirectManipulation.HorizontalAlignment"/></strong>. The default is <strong>DIRECTMANIPULATION_HORIZONTALALIGNMENT_NONE</strong>.</p> <strong>Note</strong>??You cannot combine the following options: DIRECTMANIPULATION_HORIZONTALALIGNMENT_LEFT, DIRECTMANIPULATION-HORIZONTALALIGNMENT_CENTER, DIRECTMANIPULATION_HORIZONTALALIGNMENT_RIGHT. DIRECTMANIPULATION_HORIZONTALALIGNMENT_UNLOCKCENTER can be combined with any option but cannot be configured by itself. ? </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>If you have activated a configuration consisting only of zoom or zoom inertia, specify DIRECTMANIPULATION_HORIZONTALALIGNMENT_UNLOCKCENTER to respect the zoom center point.</p>
        /// </remarks>
        /// <doc-id>hh768909</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationPrimaryContent::SetHorizontalAlignment([In] DIRECTMANIPULATION_HORIZONTALALIGNMENT alignment)</unmanaged>
        /// <unmanaged-short>IDirectManipulationPrimaryContent::SetHorizontalAlignment</unmanaged-short>
        internal unsafe void SetHorizontalAlignment(SharpDX.DirectManipulation.HorizontalAlignment alignment)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)alignment), (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Specifies the vertical alignment of the primary content in the viewport.</p>
        /// </summary>
        /// <param name = "alignment"><dd> <p>One or more values from <strong><see cref = "SharpDX.DirectManipulation.VerticalAlignment"/></strong>.</p> <strong>Note</strong>??You cannot combine <strong>DIRECTMANIPULATION_VERTICALALIGNMENT_TOP</strong>, <strong>DIRECTMANIPULATION_VERTICALALIGNMENT_CENTER</strong>, or <strong>DIRECTMANIPULATION_VERTICALALIGNMENT_BOTTOM</strong>. <strong>DIRECTMANIPULATION_VERTICALALIGNMENT_UNLOCKCENTER</strong> can be combined with any option but cannot be configured by itself. ? </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>If you have activated a configuration consisting only of zoom or zoom inertia, specify <strong>DIRECTMANIPULATION_VERTICALALIGNMENT_UNLOCKCENTER</strong> to respect the zoom center point.</p>
        /// </remarks>
        /// <doc-id>hh768914</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationPrimaryContent::SetVerticalAlignment([In] DIRECTMANIPULATION_VERTICALALIGNMENT alignment)</unmanaged>
        /// <unmanaged-short>IDirectManipulationPrimaryContent::SetVerticalAlignment</unmanaged-short>
        internal unsafe void SetVerticalAlignment(SharpDX.DirectManipulation.VerticalAlignment alignment)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)alignment), (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the final transform, including inertia, of the primary content.</p>
        /// </summary>
        /// <param name = "matrix"><dd> <p>The transformed matrix that represents the inertia ending position.</p> </dd></param>
        /// <param name = "pointCount"><dd> <p>The size of the matrix. </p> <p> This value is always 6, because a 3x2 matrix is used for all direct manipulation transforms.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <strong>Warning</strong>??Calling this method can cause a race condition if inertia has ended or been interrupted. This can also occur during the <strong>OnViewportStatusChanged</strong> callback.?
        /// </remarks>
        /// <doc-id>hh768908</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationPrimaryContent::GetInertiaEndTransform([Out, Buffer] float* matrix,[In] DWORD pointCount)</unmanaged>
        /// <unmanaged-short>IDirectManipulationPrimaryContent::GetInertiaEndTransform</unmanaged-short>
        public unsafe void GetInertiaEndTransform(System.Single[] matrix, System.Int32 pointCount)
        {
            SharpDX.Result __result__;
            fixed (void *matrix_ = matrix)
                __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, matrix_, pointCount, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Retrieves the center point of the manipulation in content coordinates. If there is no manipulation in progress, retrieves the center point of the viewport.</p>
        /// </summary>
        /// <param name = "centerX"><dd> <p>The center on the horizontal axis.</p> </dd></param>
        /// <param name = "centerY"><dd> <p>The center on the vertical axis.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh768907</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationPrimaryContent::GetCenterPoint([Out] float* centerX,[Out] float* centerY)</unmanaged>
        /// <unmanaged-short>IDirectManipulationPrimaryContent::GetCenterPoint</unmanaged-short>
        public unsafe void GetCenterPoint(out System.Single centerX, out System.Single centerY)
        {
            SharpDX.Result __result__;
            fixed (void *centerY_ = &centerY)
                fixed (void *centerX_ = &centerX)
                    __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, centerX_, centerY_, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("790B6337-64F8-4FF5-A269-B32BC2AF27A7")]
    public partial class UpdateHandler : SharpDX.ComObject
    {
        public UpdateHandler(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator UpdateHandler(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new UpdateHandler(nativePtr);
        /// <summary>
        /// <p>Notifies the compositor when to update inertia animation.</p>
        /// </summary>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh447130</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationUpdateHandler::Update()</unmanaged>
        /// <unmanaged-short>IDirectManipulationUpdateHandler::Update</unmanaged-short>
        public unsafe void Update()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("B0AE62FD-BE34-46E7-9CAA-D361FACBB9CC")]
    public partial class UpdateManager : SharpDX.ComObject
    {
        public UpdateManager(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator UpdateManager(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new UpdateManager(nativePtr);
        /// <summary>
        /// <p>Registers a callback that is triggered by a handle.</p>
        /// </summary>
        /// <param name = "handle"><dd> <p>The event handle that triggers the callback.</p> </dd></param>
        /// <param name = "eventHandler"><dd> <p>The event handler to call when the event is fired.</p> </dd></param>
        /// <param name = "cookie"><dd> <p>The unique ID of the event callback instance.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh447134</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationUpdateManager::RegisterWaitHandleCallback([In] void* handle,[In] IDirectManipulationUpdateHandler* eventHandler,[Out] DWORD* cookie)</unmanaged>
        /// <unmanaged-short>IDirectManipulationUpdateManager::RegisterWaitHandleCallback</unmanaged-short>
        public unsafe void RegisterWaitHandleCallback(System.IntPtr handle, SharpDX.DirectManipulation.UpdateHandler eventHandler, out System.Int32 cookie)
        {
            System.IntPtr eventHandler_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            eventHandler_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectManipulation.UpdateHandler>(eventHandler);
            fixed (void *cookie_ = &cookie)
                __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)handle, (void *)eventHandler_, cookie_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Deregisters a callback.</p>
        /// </summary>
        /// <param name = "cookie"><dd> <p>The unique ID of the event callback instance.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh447136</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationUpdateManager::UnregisterWaitHandleCallback([In] DWORD cookie)</unmanaged>
        /// <unmanaged-short>IDirectManipulationUpdateManager::UnregisterWaitHandleCallback</unmanaged-short>
        public unsafe void UnregisterWaitHandleCallback(System.Int32 cookie)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, cookie, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Updates Direct Manipulation at the current time.</p>
        /// </summary>
        /// <param name = "frameInfo">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>If the application provides its own implementation of <strong><see cref = "SharpDX.DirectManipulation.Compositor"/></strong>, this implementation should call <strong>Update</strong> whenever there is a compositor update. Frame timing information can be provided to Direct Manipulation through the <strong><see cref = "SharpDX.DirectManipulation.FrameInfoProvider"/></strong> interface.</p>
        /// </remarks>
        /// <doc-id>hh447142</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationUpdateManager::Update([In, Optional] IDirectManipulationFrameInfoProvider* frameInfo)</unmanaged>
        /// <unmanaged-short>IDirectManipulationUpdateManager::Update</unmanaged-short>
        public unsafe void Update(SharpDX.DirectManipulation.FrameInfoProvider frameInfo)
        {
            System.IntPtr frameInfo_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            frameInfo_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectManipulation.FrameInfoProvider>(frameInfo);
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)frameInfo_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("28b85a3d-60a0-48bd-9ba1-5ce8d9ea3a6d")]
    public partial class Viewport : SharpDX.ComObject
    {
        public Viewport(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Viewport(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Viewport(nativePtr);
        /// <summary>
        /// <p>Specifies an  association between a contact and the viewport.</p>
        /// </summary>
        /// <remarks>
        /// <p>Call this method when a <strong>WM_POINTERDOWN</strong> message is received. Upon receiving a <strong>WM_POINTERDOWN</strong>, the application can use the coordinates of the input to hit-test and determine the viewports to which the contact is associated.
        /// </p><p> <strong>DeferContact</strong> must be called before <strong>SetContact</strong>.</p><p>After initialization, Direct Manipulation is not aware of viewport z-order or parent-child relations between viewports. The order of <strong>SetContact</strong> calls defines the viewport tree. To establish the correct viewport hierarchy, <strong>SetContact</strong> should be called first on the child-most viewport, followed by the parent, grand-parent, and so on. 
        /// </p><p>Use <strong>GET_POINTERID_WPARAM</strong> to get the reference identifier from a reference message. The contact is removed automatically when <strong>WM_POINTERUP</strong> is received.
        /// </p><p>If a contact is associated with one or more viewports using the <strong>SetContact</strong> method, Direct Manipulation will examine further input from that contact and attempt to identify an appropriate manipulation based on the configuration of the associated viewports. If a manipulation is recognized, the application will then receive a <strong>WM_POINTERCAPTURECHANGED</strong> message for this contact. In this context, the <strong>WM_POINTERCAPTURECHANGED</strong> message indicates that Direct Manipulation has captured the contact and the application will not receive input from this contact that is consumed for this manipulation.</p>
        /// </remarks>
        /// <doc-id>hh768921</doc-id>
        /// <unmanaged>SetContact</unmanaged>
        /// <unmanaged-short>SetContact</unmanaged-short>
        public System.Int32 Contact
        {
            set => SetContact(value);
        }

        /// <summary>
        /// <p>Gets the state of the viewport.</p>
        /// </summary>
        /// <remarks>
        /// <p>This method returns the viewport state at the time of the call and not at the time when the return value is read.</p><p>This method will fail if called after <strong>Abandon</strong>.</p>
        /// </remarks>
        /// <doc-id>hh447167</doc-id>
        /// <unmanaged>GetStatus</unmanaged>
        /// <unmanaged-short>GetStatus</unmanaged-short>
        public SharpDX.DirectManipulation.Status Status
        {
            get
            {
                GetStatus(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Retrieves or sets the rectangle for the viewport relative to the origin of the viewport coordinate system specified by <strong>SetViewportRect</strong>.</p>
        /// </summary>
        /// <doc-id>hh768918</doc-id>
        /// <unmanaged>GetViewportRect / SetViewportRect</unmanaged>
        /// <unmanaged-short>GetViewportRect</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawRectangle ViewportRect
        {
            get
            {
                GetViewportRect(out var __output__);
                return __output__;
            }

            set => SetViewportRect(value);
        }

        /// <summary>
        /// <p>Sets how the viewport handles input and output.</p><p>Calling this method overrides all  settings previously specified with <strong>SetUpdateMode</strong> or <strong>SetInputMode</strong>.</p>
        /// </summary>
        /// <remarks>
        /// <p>Calling this method with <strong>DIRECTMANIPULATION_INPUT_MODE_MANUAL</strong> set is similar to calling <strong>SetViewportOptions(DIRECTMANIPULATION_VIEWPORT_OPTIONS_INPUT)</strong>.</p>
        /// </remarks>
        /// <doc-id>jj647932</doc-id>
        /// <unmanaged>SetViewportOptions</unmanaged>
        /// <unmanaged-short>SetViewportOptions</unmanaged-short>
        public SharpDX.DirectManipulation.ViewportOptions ViewportOptions
        {
            set => SetViewportOptions(value);
        }

        /// <summary>
        /// <p>Sets which gestures are ignored by Direct Manipulation. </p>
        /// </summary>
        /// <remarks>
        /// <p>Use this method to specify which gestures the application processes on the UI thread. If a gesture is recognized, it will be passed to the application for processing and ignored by Direct Manipulation.</p>
        /// </remarks>
        /// <doc-id>jj654881</doc-id>
        /// <unmanaged>SetManualGesture</unmanaged>
        /// <unmanaged-short>SetManualGesture</unmanaged-short>
        public SharpDX.DirectManipulation.GestureConfiguration ManualGesture
        {
            set => SetManualGesture(value);
        }

        /// <summary>
        /// <p>Specifies the motion types supported in a viewport that can be chained to a parent viewport.</p>
        /// </summary>
        /// <doc-id>hh447174</doc-id>
        /// <unmanaged>SetChaining</unmanaged>
        /// <unmanaged-short>SetChaining</unmanaged-short>
        public SharpDX.DirectManipulation.MotionTypes Chaining
        {
            set => SetChaining(value);
        }

        /// <summary>
        /// <p>Specifies if input is visible to the UI thread.</p>
        /// </summary>
        /// <remarks>
        /// <p>DIRECTMANIPULATION_INPUT_MODE_AUTOMATIC is the default mode for Direct Manipulation. </p><p> Direct Manipulation consumes all the input that drives the manipulation and the application receives WM_POINTERCAPTURECHANGED messages. 
        /// </p><p>In some situations an application may want to receive input that is driving a manipulation. Set DIRECTMANIPULATION_INPUT_MODE_MANUAL in this case. The application will receive all input messages, even input used by Direct Manipulation to drive a manipulation. </p><strong>Note</strong>??The application will not receive WM_POINTERCAPTURECHANGED messages.?<p>Calling this method with <strong>DIRECTMANIPULATION_INPUT_MODE_MANUAL</strong> set is similar to calling <strong>SetViewportOptions(DIRECTMANIPULATION_VIEWPORT_OPTIONS_INPUT)</strong>. However, calling <strong>SetViewportOptions</strong> also overrides all other settings.</p>
        /// </remarks>
        /// <doc-id>hh447176</doc-id>
        /// <unmanaged>SetInputMode</unmanaged>
        /// <unmanaged-short>SetInputMode</unmanaged-short>
        public SharpDX.DirectManipulation.InputMode InputMode
        {
            set => SetInputMode(value);
        }

        /// <summary>
        /// <p> Specifies whether a viewport updates content manually instead of during an input event.</p>
        /// </summary>
        /// <remarks>
        /// <p>DIRECTMANIPULATION_INPUT_MODE_AUTOMATIC is the default mode for Direct Manipulation. In this mode, visual updates are pushed to compositor driven by input. This is the expected mode of operation if the application is using system-provided implementation of <strong><see cref = "SharpDX.DirectManipulation.Compositor"/></strong>.
        /// </p><p>If the application provides its own implementation of <strong><see cref = "SharpDX.DirectManipulation.Compositor"/></strong>, it should switch viewport update mode to manual by setting DIRECTMANIPULATION_INPUT_MODE_MANUAL. When in manual mode, the compositor pulls visual updates whenever it calls <strong>Update</strong> on Direct Manipulation.
        /// </p><p>Calling this method with <strong>DIRECTMANIPULATION_INPUT_MODE_MANUAL</strong> set is similar to calling <strong>SetViewportOptions(DIRECTMANIPULATION_VIEWPORT_OPTIONS_INPUT)</strong>. However, calling <strong>SetViewportOptions</strong> also overrides all other settings.</p>
        /// </remarks>
        /// <doc-id>hh768922</doc-id>
        /// <unmanaged>SetUpdateMode</unmanaged>
        /// <unmanaged-short>SetUpdateMode</unmanaged-short>
        public SharpDX.DirectManipulation.InputMode UpdateMode
        {
            set => SetUpdateMode(value);
        }

        /// <summary>
        /// <p>Starts or resumes input processing by the viewport.</p>
        /// </summary>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>, or <strong>S_FALSE</strong> if there is no work to do (for example, the viewport is already enabled). Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>This method directs a viewport to attempt to respond to input.</p><p>Call this method if the <strong>AUTODISABLE</strong> option is set. </p>
        /// </remarks>
        /// <doc-id>hh447163</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationViewport::Enable()</unmanaged>
        /// <unmanaged-short>IDirectManipulationViewport::Enable</unmanaged-short>
        public unsafe void Enable()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Stops input processing by the viewport.</p>
        /// </summary>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>When a viewport is disabled, it immediately stops all transforms and moves the content to the final location. </p><p>Call this method when you want to modify multiple attributes atomically. This method can be called at any time. </p><p>The viewport will not resume processing input until <strong>Enable</strong> is called. </p>
        /// </remarks>
        /// <doc-id>hh447162</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationViewport::Disable()</unmanaged>
        /// <unmanaged-short>IDirectManipulationViewport::Disable</unmanaged-short>
        public unsafe void Disable()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Specifies an  association between a contact and the viewport.</p>
        /// </summary>
        /// <param name = "pointerId"><dd> <p>The ID of the reference.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Call this method when a <strong>WM_POINTERDOWN</strong> message is received. Upon receiving a <strong>WM_POINTERDOWN</strong>, the application can use the coordinates of the input to hit-test and determine the viewports to which the contact is associated.
        /// </p><p> <strong>DeferContact</strong> must be called before <strong>SetContact</strong>.</p><p>After initialization, Direct Manipulation is not aware of viewport z-order or parent-child relations between viewports. The order of <strong>SetContact</strong> calls defines the viewport tree. To establish the correct viewport hierarchy, <strong>SetContact</strong> should be called first on the child-most viewport, followed by the parent, grand-parent, and so on. 
        /// </p><p>Use <strong>GET_POINTERID_WPARAM</strong> to get the reference identifier from a reference message. The contact is removed automatically when <strong>WM_POINTERUP</strong> is received.
        /// </p><p>If a contact is associated with one or more viewports using the <strong>SetContact</strong> method, Direct Manipulation will examine further input from that contact and attempt to identify an appropriate manipulation based on the configuration of the associated viewports. If a manipulation is recognized, the application will then receive a <strong>WM_POINTERCAPTURECHANGED</strong> message for this contact. In this context, the <strong>WM_POINTERCAPTURECHANGED</strong> message indicates that Direct Manipulation has captured the contact and the application will not receive input from this contact that is consumed for this manipulation.</p>
        /// </remarks>
        /// <doc-id>hh768921</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationViewport::SetContact([In] unsigned int pointerId)</unmanaged>
        /// <unmanaged-short>IDirectManipulationViewport::SetContact</unmanaged-short>
        internal unsafe void SetContact(System.Int32 pointerId)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, pointerId, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Removes a contact that is associated with a viewport.</p>
        /// </summary>
        /// <param name = "pointerId"><dd> <p>The ID of the reference.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>This method releases a contact from a specific Direct Manipulation viewport (equivalent to the user removing a touch point). </p><p>The viewport state is not affected unless the last remaining contact on the viewport is removed, in which case the viewport will transition to inertia, if supported. </p>
        /// </remarks>
        /// <doc-id>hh768920</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationViewport::ReleaseContact([In] unsigned int pointerId)</unmanaged>
        /// <unmanaged-short>IDirectManipulationViewport::ReleaseContact</unmanaged-short>
        public unsafe void ReleaseContact(System.Int32 pointerId)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, pointerId, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Removes all contacts that are associated with the viewport. Inertia is started if the viewport supports inertia.</p>
        /// </summary>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>This is equivalent to calling <strong>ReleaseContact</strong> on every contact associated with the viewport. The outcome is equivalent to the user removing all touch points from the viewport. </p><p>If supported, inertia will be started after calling this method.</p>
        /// </remarks>
        /// <doc-id>hh768919</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationViewport::ReleaseAllContacts()</unmanaged>
        /// <unmanaged-short>IDirectManipulationViewport::ReleaseAllContacts</unmanaged-short>
        public unsafe void ReleaseAllContacts()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the state of the viewport.</p>
        /// </summary>
        /// <param name = "status"><dd> <p>One of the values from <strong><see cref = "SharpDX.DirectManipulation.Status"/></strong>.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>This method returns the viewport state at the time of the call and not at the time when the return value is read.</p><p>This method will fail if called after <strong>Abandon</strong>.</p>
        /// </remarks>
        /// <doc-id>hh447167</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationViewport::GetStatus([Out] DIRECTMANIPULATION_STATUS* status)</unmanaged>
        /// <unmanaged-short>IDirectManipulationViewport::GetStatus</unmanaged-short>
        internal unsafe void GetStatus(out SharpDX.DirectManipulation.Status status)
        {
            SharpDX.Result __result__;
            fixed (void *status_ = &status)
                __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, status_, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the tag value of a viewport.</p>
        /// </summary>
        /// <param name = "riid"><dd> <p>IID to the interface.</p> </dd></param>
        /// <param name = "@object"><dd> <p>The object portion of the tag.</p> </dd></param>
        /// <param name = "id"><dd> <p>The identifier portion of the tag.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>A tag is a pairing of an integer ID with a Component Object Model (COM) object. It can be used by an app to identify the viewport.</p><p> The out parameters are optional, so the method can return an ID, the viewport object, or both.
        /// </p>
        /// </remarks>
        /// <doc-id>hh447168</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationViewport::GetTag([In] const GUID&amp; riid,[Out, Optional] void** object,[Out, Optional] unsigned int* id)</unmanaged>
        /// <unmanaged-short>IDirectManipulationViewport::GetTag</unmanaged-short>
        public unsafe void GetTag(System.Guid riid, out System.IntPtr @object, out System.Int32 id)
        {
            SharpDX.Result __result__;
            fixed (void *id_ = &id)
                fixed (void *@object_ = &@object)
                    __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, &riid, @object_, id_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets a viewport tag.</p>
        /// </summary>
        /// <param name = "@object"><dd> <p>The object portion of the tag.</p> </dd></param>
        /// <param name = "id"><dd> <p>The ID portion of the tag.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>A tag is a pairing of an integer ID with a Component Object Model (COM) object. It can be used by an app to identify the viewport.</p><p> The object parameter is optional, so that the method can set just an ID.
        /// </p>
        /// </remarks>
        /// <doc-id>hh447180</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationViewport::SetTag([In, Optional] IUnknown* object,[In] unsigned int id)</unmanaged>
        /// <unmanaged-short>IDirectManipulationViewport::SetTag</unmanaged-short>
        public unsafe void SetTag(SharpDX.IUnknown @object, System.Int32 id)
        {
            System.IntPtr @object_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            @object_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(@object);
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)@object_, id, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the rectangle for the viewport relative to the origin of the viewport coordinate system specified by <strong>SetViewportRect</strong>.</p>
        /// </summary>
        /// <param name = "viewport">No documentation.</param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh768918</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationViewport::GetViewportRect([Out] RECT* viewport)</unmanaged>
        /// <unmanaged-short>IDirectManipulationViewport::GetViewportRect</unmanaged-short>
        internal unsafe void GetViewportRect(out SharpDX.Mathematics.Interop.RawRectangle viewport)
        {
            viewport = default (SharpDX.Mathematics.Interop.RawRectangle);
            SharpDX.Result __result__;
            fixed (void *viewport_ = &viewport)
                __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, viewport_, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Sets the bounding rectangle for the viewport, relative to the origin of the viewport coordinate system.</p>
        /// </summary>
        /// <param name = "viewport"><dd> <p>The bounding rectangle.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The viewport rectangle specifies the region of content that is visible to the user. In conjunction with the primary content rectangle, the viewport rectangle is used to determine chaining behaviors.</p>
        /// </remarks>
        /// <doc-id>hh768923</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationViewport::SetViewportRect([In] const RECT* viewport)</unmanaged>
        /// <unmanaged-short>IDirectManipulationViewport::SetViewportRect</unmanaged-short>
        internal unsafe void SetViewportRect(SharpDX.Mathematics.Interop.RawRectangle viewport)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, &viewport, (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Moves the viewport to a specific area of the primary content and specifies whether to animate the transition.</p>
        /// </summary>
        /// <param name = "left"><dd> <p>The leftmost coordinate of the rectangle in the primary content coordinate space.</p> </dd></param>
        /// <param name = "top"><dd> <p>The topmost coordinate of the rectangle in the primary content coordinate space.</p> </dd></param>
        /// <param name = "right"><dd> <p>The rightmost coordinate of the rectangle in the primary content coordinate space.</p> </dd></param>
        /// <param name = "bottom"><dd> <p>The bottommost coordinate of the rectangle in the primary content coordinate space.</p> </dd></param>
        /// <param name = "animate"><dd> <p>Specifies whether to animate the zoom behavior.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh447184</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationViewport::ZoomToRect([In] const float left,[In] const float top,[In] const float right,[In] const float bottom,[In] BOOL animate)</unmanaged>
        /// <unmanaged-short>IDirectManipulationViewport::ZoomToRect</unmanaged-short>
        public unsafe void ZoomToRect(System.Single left, System.Single top, System.Single right, System.Single bottom, SharpDX.Mathematics.Interop.RawBool animate)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint0(this._nativePointer, left, top, right, bottom, animate, (*(void ***)this._nativePointer)[13]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Specifies the transform from the viewport coordinate system to the window client coordinate system. </p>
        /// </summary>
        /// <param name = "matrix"><dd> <p>The transform matrix, in row-wise order: _11, _12, _21, _22, _31, _32.</p> </dd></param>
        /// <param name = "pointCount"><dd> <p>The size of the transform matrix. This value is always 6, because a 3x2 matrix is used for all direct manipulation transforms.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Call this function to specify the viewport position, scaling and orientation on the screen. Viewport position, scaling, orientation and size are uniquely determined by the viewport transform and the viewport rectangle. The application can specify the viewport transform using this method, and the viewport rectangle using <strong>SetViewportRect</strong>. 
        /// </p><p>The viewport rectangle (the rectangular area inside the content that is visible to the user) is specified in viewport coordinates. If the viewport rectangle top-left point is (0,0), the viewport rectangle is positioned exactly at the viewport coordinate system origin. Viewports offset from the viewport coordinate system origin can be specified in two ways:</p><ul> <li>Through the viewport rectangle top-left point</li> <li>Through the viewport transform translation component (_31, _32)</li> </ul><p>The viewport transform converts from the viewport coordinate system to the window client coordinate system. Direct Manipulation ignores the window RTL property, so the client area origin is always the top-left point. 
        /// The transforms are applied in the following order:
        /// </p><ol> <li>Viewport rectangle offset</li> <li>Viewport transform (from viewport to client coordinate system)</li> <li>Client to screen mapping (from client to screen coordinate system)
        /// </li> </ol>
        /// </remarks>
        /// <doc-id>hh768924</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationViewport::SetViewportTransform([In, Buffer] const float* matrix,[In] DWORD pointCount)</unmanaged>
        /// <unmanaged-short>IDirectManipulationViewport::SetViewportTransform</unmanaged-short>
        public unsafe void SetViewportTransform(System.Single[] matrix, System.Int32 pointCount)
        {
            SharpDX.Result __result__;
            fixed (void *matrix_ = matrix)
                __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, matrix_, pointCount, (*(void ***)this._nativePointer)[14]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Specifies a display transform for the viewport, and synchronizes the output transform with the new value of the display transform.</p>
        /// </summary>
        /// <param name = "matrix"><dd> <p>The transform matrix, in row-wise order: _11, _12, _21, _22, _31, _32.</p> </dd></param>
        /// <param name = "pointCount"><dd> <p>The size of the transform matrix. This value is always 6, because a 3x2 matrix is used for all direct manipulation transforms.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>If the application performs special output processing of the content outside of the compositor (content not fully captured in the viewport transform), it should call this method to specify the display transform for the special processing.
        /// </p><p>The display transform affects how manipulation updates are applied to the output transform. For example, if the display transform is set to scale 3x, panning will move the content 3x the original distance. 
        /// </p><p>When a display transform is changed using this method, the output transform will be synchronized to the new value of the display transform.
        /// </p><p>This method cannot be called if the viewport status is <strong>DIRECTMANIPULATION_RUNNING</strong> or <strong>DIRECTMANIPULATION_INERTIA</strong>.
        /// </p>
        /// </remarks>
        /// <doc-id>hh768926</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationViewport::SyncDisplayTransform([In, Buffer] const float* matrix,[In] DWORD pointCount)</unmanaged>
        /// <unmanaged-short>IDirectManipulationViewport::SyncDisplayTransform</unmanaged-short>
        public unsafe void SyncDisplayTransform(System.Single[] matrix, System.Int32 pointCount)
        {
            SharpDX.Result __result__;
            fixed (void *matrix_ = matrix)
                __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, matrix_, pointCount, (*(void ***)this._nativePointer)[15]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the primary content of a viewport that implements <strong><see cref = "SharpDX.DirectManipulation.Content"/></strong> and <strong><see cref = "SharpDX.DirectManipulation.PrimaryContent"/></strong>. </p><p>Primary content is an element that gets transformed (e.g. moved, scaled, rotated) in response to a user interaction. Primary content is created at the same time as the viewport and cannot be added or removed.</p>
        /// </summary>
        /// <param name = "riid">No documentation.</param>
        /// <param name = "@object">No documentation.</param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p> This method gets the content of the viewport that implements <strong><see cref = "SharpDX.DirectManipulation.Content"/></strong> and <strong><see cref = "SharpDX.DirectManipulation.PrimaryContent"/></strong>.
        /// </p>
        /// </remarks>
        /// <doc-id>hh447166</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationViewport::GetPrimaryContent([In] const GUID&amp; riid,[Out] void** object)</unmanaged>
        /// <unmanaged-short>IDirectManipulationViewport::GetPrimaryContent</unmanaged-short>
        public unsafe void GetPrimaryContent(System.Guid riid, out System.IntPtr @object)
        {
            SharpDX.Result __result__;
            fixed (void *@object_ = &@object)
                __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, &riid, @object_, (*(void ***)this._nativePointer)[16]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Adds secondary content, such as a panning indicator, to a viewport.</p>
        /// </summary>
        /// <param name = "content"><dd> <p>The content to add to the viewport.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Secondary content is created by calling <strong>CreateContent</strong>. Once added, the secondary content will move relative to the primary content in response to a manipulation. Its motion is determined by rules associated with each type of secondary content.</p>
        /// </remarks>
        /// <doc-id>hh447158</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationViewport::AddContent([In] IDirectManipulationContent* content)</unmanaged>
        /// <unmanaged-short>IDirectManipulationViewport::AddContent</unmanaged-short>
        public unsafe void AddContent(SharpDX.DirectManipulation.Content content)
        {
            System.IntPtr content_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            content_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectManipulation.Content>(content);
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)content_, (*(void ***)this._nativePointer)[17]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Removes secondary content from a viewport.</p>
        /// </summary>
        /// <param name = "content"><dd> <p>The content object to remove.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Secondary content can be removed from the viewport at any time.</p>
        /// </remarks>
        /// <doc-id>hh447171</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationViewport::RemoveContent([In] IDirectManipulationContent* content)</unmanaged>
        /// <unmanaged-short>IDirectManipulationViewport::RemoveContent</unmanaged-short>
        public unsafe void RemoveContent(SharpDX.DirectManipulation.Content content)
        {
            System.IntPtr content_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            content_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectManipulation.Content>(content);
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)content_, (*(void ***)this._nativePointer)[18]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets how the viewport handles input and output.</p><p>Calling this method overrides all  settings previously specified with <strong>SetUpdateMode</strong> or <strong>SetInputMode</strong>.</p>
        /// </summary>
        /// <param name = "options">No documentation.</param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Calling this method with <strong>DIRECTMANIPULATION_INPUT_MODE_MANUAL</strong> set is similar to calling <strong>SetViewportOptions(DIRECTMANIPULATION_VIEWPORT_OPTIONS_INPUT)</strong>.</p>
        /// </remarks>
        /// <doc-id>jj647932</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationViewport::SetViewportOptions([In] DIRECTMANIPULATION_VIEWPORT_OPTIONS options)</unmanaged>
        /// <unmanaged-short>IDirectManipulationViewport::SetViewportOptions</unmanaged-short>
        internal unsafe void SetViewportOptions(SharpDX.DirectManipulation.ViewportOptions options)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)options), (*(void ***)this._nativePointer)[19]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Adds an interaction configuration for the viewport.</p>
        /// </summary>
        /// <param name = "configuration"><dd> <p>One of the values from <strong><see cref = "SharpDX.DirectManipulation.Configuration"/></strong> that specifies the interaction configuration for the viewport.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>An interaction configuration specifies how the manipulation engine responds to input and which manipulations are supported. Any number of possible configurations can be added to the viewport using <strong>AddConfiguration</strong> before processing input. </p><p>Configurations can be switched by the application at runtime using <strong>ActivateConfiguration</strong>.  </p><p>When a configuration is no longer required (and is not currently active), it can be removed using <strong>RemoveConfiguration</strong>. </p><p>If a configuration has not been added using <strong>AddConfiguration</strong>, it can be automatically added and then activated by calling <strong>ActivateConfiguration</strong>. </p><strong>Note</strong>??If input processing is occurring, this call will fail.?<p>This method fails if a drag and drop behavior has been specified. </p><p>A drag and drop behavior object cannot be attached after successfully calling this method.</p><p>You cannot add another drag and drop behavior after an existing one has already been added.</p><p>This method is designed to allow an application to switch pre-added configurations, as a configuration cannot be changed while a manipulation is occurring. Under most circumstances it is better to update the configuration using <strong>ActivateConfiguration</strong>.</p>
        /// </remarks>
        /// <doc-id>hh447156</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationViewport::AddConfiguration([In] DIRECTMANIPULATION_CONFIGURATION configuration)</unmanaged>
        /// <unmanaged-short>IDirectManipulationViewport::AddConfiguration</unmanaged-short>
        public unsafe void AddConfiguration(SharpDX.DirectManipulation.Configuration configuration)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)configuration), (*(void ***)this._nativePointer)[20]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Removes an interaction configuration for the viewport.</p>
        /// </summary>
        /// <param name = "configuration"><dd> <p>One of the values from <strong><see cref = "SharpDX.DirectManipulation.Configuration"/></strong> that specifies the interaction configuration for the viewport.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>This method removes a possible configuration that was added by using <strong>AddConfiguration</strong>. This method can be called only if the configuration is not active.</p><p>An interaction configuration specifies how the manipulation engine responds to input and which gestures are supported. Any number of configurations can be added to the viewport using <strong>AddConfiguration</strong>. Configurations can be switched by the application at runtime using <strong>ActivateConfiguration</strong>. When a configuration is no longer required (and is not currently active), it can be removed using <strong>RemoveConfiguration</strong>.</p>
        /// </remarks>
        /// <doc-id>hh447170</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationViewport::RemoveConfiguration([In] DIRECTMANIPULATION_CONFIGURATION configuration)</unmanaged>
        /// <unmanaged-short>IDirectManipulationViewport::RemoveConfiguration</unmanaged-short>
        public unsafe void RemoveConfiguration(SharpDX.DirectManipulation.Configuration configuration)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)configuration), (*(void ***)this._nativePointer)[21]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the configuration for input interaction.</p>
        /// </summary>
        /// <param name = "configuration"><dd> <p>One or more values from <strong><see cref = "SharpDX.DirectManipulation.Configuration"/></strong> that specify the interaction configuration for the viewport.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>An interaction configuration specifies how the manipulation engine responds to input and which manipulations are supported. Any number of possible configurations can be added to the viewport using <strong>AddConfiguration</strong> before processing input. </p><p>Configurations can be switched by the application at runtime using <strong>ActivateConfiguration</strong>.  </p><p>When a configuration is no longer required (and is not currently active), it can be removed using <strong>RemoveConfiguration</strong>. </p><p>If a configuration has not been added using <strong>AddConfiguration</strong>, it can be automatically added and then activated by calling <strong>ActivateConfiguration</strong>. </p><strong>Note</strong>??If input processing is occurring, this call will fail.?<p>This method fails if a drag and drop behavior has been specified. </p><p>A drag and drop behavior object cannot be attached after successfully calling this method.</p>
        /// </remarks>
        /// <doc-id>hh447154</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationViewport::ActivateConfiguration([In] DIRECTMANIPULATION_CONFIGURATION configuration)</unmanaged>
        /// <unmanaged-short>IDirectManipulationViewport::ActivateConfiguration</unmanaged-short>
        public unsafe void ActivateConfiguration(SharpDX.DirectManipulation.Configuration configuration)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)configuration), (*(void ***)this._nativePointer)[22]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets which gestures are ignored by Direct Manipulation. </p>
        /// </summary>
        /// <param name = "configuration">No documentation.</param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Use this method to specify which gestures the application processes on the UI thread. If a gesture is recognized, it will be passed to the application for processing and ignored by Direct Manipulation.</p>
        /// </remarks>
        /// <doc-id>jj654881</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationViewport::SetManualGesture([In] DIRECTMANIPULATION_GESTURE_CONFIGURATION configuration)</unmanaged>
        /// <unmanaged-short>IDirectManipulationViewport::SetManualGesture</unmanaged-short>
        internal unsafe void SetManualGesture(SharpDX.DirectManipulation.GestureConfiguration configuration)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)configuration), (*(void ***)this._nativePointer)[23]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Specifies the motion types supported in a viewport that can be chained to a parent viewport.</p>
        /// </summary>
        /// <param name = "enabledTypes"><dd> <p>One of the values from <strong><see cref = "SharpDX.DirectManipulation.MotionTypes"/></strong> that specifies the motion types that are enabled for this viewport.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh447174</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationViewport::SetChaining([In] DIRECTMANIPULATION_MOTION_TYPES enabledTypes)</unmanaged>
        /// <unmanaged-short>IDirectManipulationViewport::SetChaining</unmanaged-short>
        internal unsafe void SetChaining(SharpDX.DirectManipulation.MotionTypes enabledTypes)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)enabledTypes), (*(void ***)this._nativePointer)[24]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Adds a new event handler to listen for viewport events.</p>
        /// </summary>
        /// <param name = "window"><dd> <p>The handle of a window owned by the thread for the event callback.</p> </dd></param>
        /// <param name = "eventHandler"><dd> <p>The handler that is called when viewport status and update events occur. The specified object must implement the <strong><see cref = "SharpDX.DirectManipulation.ViewportEventHandler"/></strong> interface.</p> </dd></param>
        /// <param name = "cookie"><dd> <p>The handle that represents this event handler callback.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The event callback is fired from the thread that owns the specified window. Consecutive events of the same callback method may be coalesced. 
        /// </p><strong>Note</strong>??If the viewport has a drag-drop behavior attached, the event handler should implement <strong><see cref = "SharpDX.DirectManipulation.DragDropEventHandler"/></strong>.?
        /// </remarks>
        /// <doc-id>hh447161</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationViewport::AddEventHandler([In, Optional] HWND window,[In] IDirectManipulationViewportEventHandler* eventHandler,[Out] DWORD* cookie)</unmanaged>
        /// <unmanaged-short>IDirectManipulationViewport::AddEventHandler</unmanaged-short>
        public unsafe void AddEventHandler(System.IntPtr window, SharpDX.DirectManipulation.ViewportEventHandler eventHandler, out System.Int32 cookie)
        {
            System.IntPtr eventHandler_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            eventHandler_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectManipulation.ViewportEventHandler>(eventHandler);
            fixed (void *cookie_ = &cookie)
                __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)window, (void *)eventHandler_, cookie_, (*(void ***)this._nativePointer)[25]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Removes an existing event handler from the viewport.</p>
        /// </summary>
        /// <param name = "cookie"><dd> <p>A value that was returned by a previous call to <strong>AddEventHandler</strong>.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh447173</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationViewport::RemoveEventHandler([In] DWORD cookie)</unmanaged>
        /// <unmanaged-short>IDirectManipulationViewport::RemoveEventHandler</unmanaged-short>
        public unsafe void RemoveEventHandler(System.Int32 cookie)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, cookie, (*(void ***)this._nativePointer)[26]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Specifies if input is visible to the UI thread.</p>
        /// </summary>
        /// <param name = "mode"><dd> <p>One of the values from <strong><see cref = "SharpDX.DirectManipulation.InputMode"/></strong>.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>DIRECTMANIPULATION_INPUT_MODE_AUTOMATIC is the default mode for Direct Manipulation. </p><p> Direct Manipulation consumes all the input that drives the manipulation and the application receives WM_POINTERCAPTURECHANGED messages. 
        /// </p><p>In some situations an application may want to receive input that is driving a manipulation. Set DIRECTMANIPULATION_INPUT_MODE_MANUAL in this case. The application will receive all input messages, even input used by Direct Manipulation to drive a manipulation. </p><strong>Note</strong>??The application will not receive WM_POINTERCAPTURECHANGED messages.?<p>Calling this method with <strong>DIRECTMANIPULATION_INPUT_MODE_MANUAL</strong> set is similar to calling <strong>SetViewportOptions(DIRECTMANIPULATION_VIEWPORT_OPTIONS_INPUT)</strong>. However, calling <strong>SetViewportOptions</strong> also overrides all other settings.</p>
        /// </remarks>
        /// <doc-id>hh447176</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationViewport::SetInputMode([In] DIRECTMANIPULATION_INPUT_MODE mode)</unmanaged>
        /// <unmanaged-short>IDirectManipulationViewport::SetInputMode</unmanaged-short>
        internal unsafe void SetInputMode(SharpDX.DirectManipulation.InputMode mode)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)mode), (*(void ***)this._nativePointer)[27]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Specifies whether a viewport updates content manually instead of during an input event.</p>
        /// </summary>
        /// <param name = "mode"><dd> <p>One of the values from <strong><see cref = "SharpDX.DirectManipulation.InputMode"/></strong>.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>DIRECTMANIPULATION_INPUT_MODE_AUTOMATIC is the default mode for Direct Manipulation. In this mode, visual updates are pushed to compositor driven by input. This is the expected mode of operation if the application is using system-provided implementation of <strong><see cref = "SharpDX.DirectManipulation.Compositor"/></strong>.
        /// </p><p>If the application provides its own implementation of <strong><see cref = "SharpDX.DirectManipulation.Compositor"/></strong>, it should switch viewport update mode to manual by setting DIRECTMANIPULATION_INPUT_MODE_MANUAL. When in manual mode, the compositor pulls visual updates whenever it calls <strong>Update</strong> on Direct Manipulation.
        /// </p><p>Calling this method with <strong>DIRECTMANIPULATION_INPUT_MODE_MANUAL</strong> set is similar to calling <strong>SetViewportOptions(DIRECTMANIPULATION_VIEWPORT_OPTIONS_INPUT)</strong>. However, calling <strong>SetViewportOptions</strong> also overrides all other settings.</p>
        /// </remarks>
        /// <doc-id>hh768922</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationViewport::SetUpdateMode([In] DIRECTMANIPULATION_INPUT_MODE mode)</unmanaged>
        /// <unmanaged-short>IDirectManipulationViewport::SetUpdateMode</unmanaged-short>
        internal unsafe void SetUpdateMode(SharpDX.DirectManipulation.InputMode mode)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)mode), (*(void ***)this._nativePointer)[28]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Stops the manipulation and returns the viewport to a ready state.  
        /// </p>
        /// </summary>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>If a mandatory snap point has been configured, the content may animate to the nearest snap point.</p>
        /// </remarks>
        /// <doc-id>hh768925</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationViewport::Stop()</unmanaged>
        /// <unmanaged-short>IDirectManipulationViewport::Stop</unmanaged-short>
        public unsafe void Stop()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[29]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Releases all resources that are used by the viewport and prepares it for destruction from memory.
        /// </p>
        /// </summary>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Once <strong>Abandon</strong> has been called, do not make subsequent function calls on the viewport. If a function is called after <strong>Abandon</strong>, <strong>E_INVALID_STATE</strong> will be returned.</p>
        /// </remarks>
        /// <doc-id>hh768916</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationViewport::Abandon()</unmanaged>
        /// <unmanaged-short>IDirectManipulationViewport::Abandon</unmanaged-short>
        public unsafe void Abandon()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[30]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("923CCAAC-61E1-4385-B726-017AF189882A")]
    public partial class Viewport2 : SharpDX.DirectManipulation.Viewport
    {
        public Viewport2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Viewport2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Viewport2(nativePtr);
        /// <summary>
        /// <p>Adds a behavior to the viewport and returns a cookie to the caller.</p>
        /// </summary>
        /// <param name = "behavior"><dd> <p>A behavior created using the <strong>CreateBehavior</strong> method.</p> </dd></param>
        /// <param name = "cookie"><dd> <p>A cookie is returned so the caller can remove this behavior later. This allows the caller to release any reference on the behavior and let Direct Manipulation maintain an appropriate lifetime, similar to event handlers. </p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. Attaching a behavior that is already attached to this viewport or another viewport results in a failure.</p></returns>
        /// <remarks>
        /// <p>A behavior takes effect immediately after <strong>AddBehavior</strong> is called. This must be considered when adding a behavior during an active manipulation or inertia phase.</p>
        /// </remarks>
        /// <doc-id>dn280399</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationViewport2::AddBehavior([In] IUnknown* behavior,[Out] DWORD* cookie)</unmanaged>
        /// <unmanaged-short>IDirectManipulationViewport2::AddBehavior</unmanaged-short>
        public unsafe void AddBehavior(SharpDX.IUnknown behavior, out System.Int32 cookie)
        {
            System.IntPtr behavior_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            behavior_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(behavior);
            fixed (void *cookie_ = &cookie)
                __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)behavior_, cookie_, (*(void ***)this._nativePointer)[31]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Removes a behavior from the viewport that matches the given cookie.</p>
        /// </summary>
        /// <param name = "cookie"><dd> <p>A valid cookie returned from the <strong>AddBehavior</strong> call on the same viewport.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. If the behavior has already been removed or if the behavior is not attached to this viewport a failure is returned.</p></returns>
        /// <doc-id>dn280401</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationViewport2::RemoveBehavior([In] DWORD cookie)</unmanaged>
        /// <unmanaged-short>IDirectManipulationViewport2::RemoveBehavior</unmanaged-short>
        public unsafe void RemoveBehavior(System.Int32 cookie)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, cookie, (*(void ***)this._nativePointer)[32]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Removes all behaviors added to the viewport.</p>
        /// </summary>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p><strong>RemoveAllBehaviors</strong> only returns an error if the removal of a behavior from the viewport was unsuccessful. In the event that a specific behavior is not removed successfully, <strong>RemoveAllBehaviors</strong> removes all remaining behaviors.</p>
        /// </remarks>
        /// <doc-id>dn280400</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationViewport2::RemoveAllBehaviors()</unmanaged>
        /// <unmanaged-short>IDirectManipulationViewport2::RemoveAllBehaviors</unmanaged-short>
        public unsafe void RemoveAllBehaviors()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[33]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("952121DA-D69F-45F9-B0F9-F23944321A6D")]
    public partial class ViewportEventHandler : SharpDX.ComObject
    {
        public ViewportEventHandler(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ViewportEventHandler(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ViewportEventHandler(nativePtr);
        /// <summary>
        /// <p>Called when the status of a viewport changes.</p>
        /// </summary>
        /// <param name = "viewport"><dd> <p>The viewport for which status has changed.</p> </dd></param>
        /// <param name = "current"><dd> <p>The new status of the viewport.</p> </dd></param>
        /// <param name = "previous"><dd> <p>The previous status of the viewport.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>If you call <strong>GetStatus</strong> from within this handler, the status returned is not guaranteed to be the same as at the time of the call. This is because of the asynchronous nature of the notification.</p>
        /// </remarks>
        /// <doc-id>hh447150</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationViewportEventHandler::OnViewportStatusChanged([In] IDirectManipulationViewport* viewport,[In] DIRECTMANIPULATION_STATUS current,[In] DIRECTMANIPULATION_STATUS previous)</unmanaged>
        /// <unmanaged-short>IDirectManipulationViewportEventHandler::OnViewportStatusChanged</unmanaged-short>
        public unsafe void OnViewportStatusChanged(SharpDX.DirectManipulation.Viewport viewport, SharpDX.DirectManipulation.Status current, SharpDX.DirectManipulation.Status previous)
        {
            System.IntPtr viewport_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            viewport_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectManipulation.Viewport>(viewport);
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)viewport_, unchecked ((System.Int32)current), unchecked ((System.Int32)previous), (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Called after all content in the viewport has been updated.</p>
        /// </summary>
        /// <param name = "viewport"><dd> <p>The viewport that has been updated.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>If you have actions that need to be executed once for a viewport update, implement <strong>OnViewportUpdated</strong>. <strong>OnContentUpdated</strong> is called once for each  content change in the viewport. This can result in multiple <strong>OnContentUpdated</strong> calls. </p>
        /// </remarks>
        /// <doc-id>hh447152</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationViewportEventHandler::OnViewportUpdated([In] IDirectManipulationViewport* viewport)</unmanaged>
        /// <unmanaged-short>IDirectManipulationViewportEventHandler::OnViewportUpdated</unmanaged-short>
        public unsafe void OnViewportUpdated(SharpDX.DirectManipulation.Viewport viewport)
        {
            System.IntPtr viewport_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            viewport_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectManipulation.Viewport>(viewport);
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)viewport_, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Called when content inside a viewport is updated.
        /// </p>
        /// </summary>
        /// <param name = "viewport"><dd> <p>The viewport that is updated.</p> </dd></param>
        /// <param name = "content"><dd> <p>The content in the viewport that has changed.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>This method is called once for each  content change in the viewport. This can result in multiple <strong>OnContentUpdated</strong> calls. For instance, when the position of the content is changed, you can use <strong>IDirectManipualtionContent::GetContentTransform</strong> to retrieve the new value.</p><p>If you have actions that need to be executed once for a viewport update, implement <strong>OnViewportUpdated</strong>.</p>
        /// </remarks>
        /// <doc-id>hh447148</doc-id>
        /// <unmanaged>HRESULT IDirectManipulationViewportEventHandler::OnContentUpdated([In] IDirectManipulationViewport* viewport,[In] IDirectManipulationContent* content)</unmanaged>
        /// <unmanaged-short>IDirectManipulationViewportEventHandler::OnContentUpdated</unmanaged-short>
        public unsafe void OnContentUpdated(SharpDX.DirectManipulation.Viewport viewport, SharpDX.DirectManipulation.Content content)
        {
            System.IntPtr viewport_ = System.IntPtr.Zero;
            System.IntPtr content_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            viewport_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectManipulation.Viewport>(viewport);
            content_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectManipulation.Content>(content);
            __result__ = SharpDX.DirectManipulation.LocalInterop.CalliStdCallint(this._nativePointer, (void *)viewport_, (void *)content_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }
    }
}